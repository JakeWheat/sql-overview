                                                                    WG3:HBA-003
                                                                     H2-2003-305
                                                                        August, 2003


                                        ISO
                International Organization for Standardization

                                       ANSI
                     American National Standards Institute




                                ANSI TC NCITS H2
                            ISO/IEC JTC 1/SC 32/WG 3
                                      Database



Title: (ISO-ANSI Working Draft) Foundation (SQL/Foundation)
Author: Jim Melton (Editor)
References:
1) WG3:HBA-002 = H2-2003-304 = 5WD-01-Framework-2003-09, WD 9075-1 (SQL/Framework),
   September, 2003

2) WG3:HBA-003 = H2-2003-305 = 5WD-02-Foundation-2003-09, WD 9075-2 (SQL/Foundation),
   September, 2003

3) WG3:HBA-004 = H2-2003-306 = 5WD-03-CLI-2003-09, WD 9075-3 (SQL/CLI), September, 2003

4) WG3:HBA-005 = H2-2003-307 = 5WD-04-PSM-2003-09, WD 9075-4 (SQL/PSM), September,
   2003

5) WG3:HBA-006 = H2-2003-308 = 5WD-09-MED-2003-09, WD 9075-9 (SQL/MED), September,
   2003

6) WG3:HBA-007 = H2-2003-309 = 5WD-10-OLB-2003-09, WD 9075-10 (SQL/OLB), September,
   2003

7) WG3:HBA-008 = H2-2003-310 = 5WD-11-Schemata-2003-09, WD 9075-11 (SQL/Schemata),
   September, 2003

8) WG3:HBA-009 = H2-2003-311 = 5WD-13-JRT-2003-09, WD 9075-13 (SQL/JRT), September,
   2003
9) WG3:HBA-010 = H2-2003-312 = 5WD-14-XML-2003-09, WD 9075-14 (SQL/XML), September,
   2003




2
                                                                            ISO/IEC JTC 1/SC 32
                                                                                       Date: 2003-07-25


                                                                        ISO/IEC 9075-2:2003 (E)

                                                                             ISO/IEC JTC 1/SC 32/WG 3

                                                                         United States of America (ANSI)




Information technology — Database languages — SQL — Part 2: Foundation
(SQL/Foundation)
Technologies de l'information— Langages de base de données — SQL — Partie 2: Fondations (SQL/Fondations)




Document type: International standard
Document subtype:
Document stage: (4) Approval
Document language: English
                                              Copyright notice
This ISO document is a Draft International Standard and is copyright-protected by ISO. Except as permitted under
the applicable laws of the user’s country, neither this ISO draft nor any extract from it may be reproduced, stored
in a retrieval system, or transmitted in any form or by any means, electronic, photocopying, recording, or otherwise,
without prior written permission being secured.

Requests for permission to reproduce should be addressed to ISO at the address below or ISO’s member body
in the country of the requester.

     Copyright Manager
     ISO Central Secretariat
     1 rue de Varembé
     1211 Geneva 20 Switzerland
     tel. +41 22 749 0111
     fax +41 22 734 1079
     internet: iso@iso.ch

Reproduction may be subject to royalty payments or a licensing agreement.

Violaters may be prosecuted.
Contents                                                                                                                                                                       Page

Foreword. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xix
Introduction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xx
1        Scope. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
2        Normative references. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
2.1            JTC1 standards. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
2.2            Other international standards. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
3        Definitions, notations, and conventions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
3.1            Definitions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
3.1.1          Definitions taken from ISO/IEC 10646. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
3.1.2          Definitions taken from ISO/IEC 14651. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
3.1.3          Definitions taken from Unicode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
3.1.4          Definitions taken from ISO 8601. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
3.1.5          Definitions taken from Part 1. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
3.1.6          Definitions provided in Part 2. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
3.2            Notation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
3.3            Conventions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
3.3.1          Use of terms. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
3.3.1.1         Other terms. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
4        Concepts. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
4.1            Data types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
4.1.1          General introduction to data types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
4.1.2          Naming of predefined types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
4.1.3          Non-predefined and non-SQL types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
4.1.4          Comparison and ordering. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
4.2            Character strings. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
4.2.1          Introduction to character strings. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
4.2.2          Comparison of character strings. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
4.2.3          Operations involving character strings. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
4.2.3.1          Operators that operate on character strings and return character strings. . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
4.2.3.2          Other operators involving character strings. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
4.2.3.3          Operations involving large object character strings. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
4.2.4          Character repertoires. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
4.2.5          Character encoding forms. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
4.2.6          Collations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
4.2.7          Character sets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
4.2.8          Universal character sets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25



©ISO/IEC 2003 – All rights reserved                                                                                                                               Contents iii
ISO/IEC 9075-2:2003 (E)




4.3        Binary strings. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
4.3.1      Introduction to binary strings. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
4.3.2      Binary string comparison. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
4.3.3      Operations involving binary strings. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
4.3.3.1      Operators that operate on binary strings and return binary strings. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
4.3.3.2      Other operators involving binary strings. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
4.4        Numbers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
4.4.1      Introduction to numbers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
4.4.2      Characteristics of numbers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
4.4.3      Operations involving numbers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.5        Boolean types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4.5.1      Introduction to Boolean types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4.5.2      Comparison and assignment of booleans. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4.5.3      Operations involving booleans. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4.5.3.1      Operations on booleans that return booleans. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4.5.3.2      Other operators involving booleans. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4.6        Datetimes and intervals. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
4.6.1      Introduction to datetimes and intervals. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
4.6.2      Datetimes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
4.6.3      Intervals. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
4.6.4      Operations involving datetimes and intervals. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
4.7        User-defined types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
4.7.1      Introduction to user-defined types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
4.7.2      User-defined type descriptor. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
4.7.3      Observers and mutators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
4.7.4      Constructors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
4.7.5      Subtypes and supertypes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
4.7.6      User-defined type comparison and assignment. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
4.7.7      Transforms for user-defined types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
4.8        Row types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
4.9        Reference types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
4.9.1      Introduction to reference types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
4.9.2      Operations involving references. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
4.10       Collection types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
4.10.1     Introduction to collection types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
4.10.2     Arrays. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
4.10.3     Multisets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
4.10.4     Collection comparison and assignment. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
4.10.5     Operations involving arrays. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
4.10.5.1     Operators that operate on array values and return array elements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
4.10.5.2     Operators that operate on array values and return array values. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
4.10.6     Operations involving multisets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47



iv Foundation (SQL/Foundation)                                                                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                                                                         ISO/IEC 9075-2:2003 (E)




4.10.6.1     Operators that operate on multisets and return multiset elements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
4.10.6.2     Operators that operate on multisets and return multisets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
4.11       Data conversions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
4.12       Domains. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
4.13       Columns, fields, and attributes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
4.14       Tables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
4.14.1     Introduction to tables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
4.14.2     Types of tables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
4.14.3     Table descriptors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
4.14.4     Relationships between tables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
4.14.5     Referenceable tables, subtables, and supertables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
4.14.6     Operations involving tables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
4.14.7     Identity columns. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
4.14.8     Base columns and generated columns. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
4.14.9     Windowed tables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
4.15       Data analysis operations (involving tables). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
4.15.1     Introduction to data analysis operations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
4.15.2     Group functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
4.15.3     Window functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
4.15.4     Aggregate functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
4.16       Determinism. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
4.17       Integrity constraints. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
4.17.1     Overview of integrity constraints. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
4.17.2     Checking of constraints. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
4.17.3     Table constraints. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
4.17.4     Domain constraints. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
4.17.5     Assertions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
4.18       Functional dependencies. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
4.18.1     Overview of functional dependency rules and notations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
4.18.2     General rules and definitions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
4.18.3     Known functional dependencies in a base table. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
4.18.4     Known functional dependencies in a transition table. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
4.18.5     Known functional dependencies in <table value constructor>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
4.18.6     Known functional dependencies in a <joined table>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
4.18.7     Known functional dependencies in a <table primary>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
4.18.8     Known functional dependencies in a <table factor>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
4.18.9     Known functional dependencies in a <table reference>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
4.18.10    Known functional dependencies in the result of a <from clause>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
4.18.11    Known functional dependencies in the result of a <where clause>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
4.18.12    Known functional dependencies in the result of a <group by clause>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
4.18.13    Known functional dependencies in the result of a <having clause>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
4.18.14    Known functional dependencies in a <query specification>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74



©ISO/IEC 2003 – All rights reserved                                                                                                                            Contents v
ISO/IEC 9075-2:2003 (E)




4.18.15    Known functional dependencies in a <query expression>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
4.19       Candidate keys. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
4.20       SQL-schemas. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
4.21       Sequence generators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
4.21.1     General description of sequence generators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
4.21.2     Operations involving sequence generators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
4.22       SQL-client modules. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
4.23       Embedded syntax. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
4.24       Dynamic SQL concepts. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
4.24.1     Overview of dynamic SQL. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
4.24.2     Dynamic SQL statements and descriptor areas. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
4.25       Direct invocation of SQL. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
4.26       Externally-invoked procedures. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
4.27       SQL-invoked routines. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
4.27.1     Overview of SQL-invoked routines. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
4.27.2     Characteristics of SQL-invoked routines. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
4.27.3     Execution of SQL-invoked routines. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
4.27.4     Routine descriptors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
4.28       SQL-paths. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
4.29       Host parameters. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
4.29.1     Overview of host parameters. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
4.29.2     Status parameters. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
4.29.3     Data parameters. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
4.29.4     Indicator parameters. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
4.29.5     Locators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
4.30       Diagnostics area. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
4.31       Standard programming languages. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
4.32       Cursors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
4.32.1     General description of cursors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
4.32.2     Operations on and using cursors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
4.33       SQL-statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
4.33.1     Classes of SQL-statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
4.33.2     SQL-statements classified by function. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
4.33.2.1     SQL-schema statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
4.33.2.2     SQL-data statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
4.33.2.3     SQL-data change statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
4.33.2.4     SQL-transaction statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
4.33.2.5     SQL-connection statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
4.33.2.6     SQL-control statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
4.33.2.7     SQL-session statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
4.33.2.8     SQL-diagnostics statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
4.33.2.9     SQL-dynamic statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102



vi Foundation (SQL/Foundation)                                                                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                                                                          ISO/IEC 9075-2:2003 (E)




4.33.2.10     SQL embedded exception declaration. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
4.33.3      SQL-statements and SQL-data access indication. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
4.33.4      SQL-statements and transaction states. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
4.33.5      SQL-statement atomicity and statement execution contexts. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
4.33.6      Embeddable SQL-statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
4.33.7      Preparable and immediately executable SQL-statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
4.33.8      Directly executable SQL-statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
4.34        Basic security model. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
4.34.1      Authorization identifiers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
4.34.1.1      SQL-session authorization identifiers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
4.34.1.2      SQL-client module authorization identifiers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
4.34.1.3      SQL-schema authorization identifiers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
4.34.2      Privileges. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
4.34.3      Roles. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
4.34.4      Security model definitions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
4.35        SQL-transactions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
4.35.1      General description of SQL-transactions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
4.35.2      Savepoints. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
4.35.3      Properties of SQL-transactions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
4.35.4      Isolation levels of SQL-transactions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
4.35.5      Implicit rollbacks. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
4.35.6      Effects of SQL-statements in an SQL-transaction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
4.35.7      Encompassing transactions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
4.36        SQL-connections. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
4.37        SQL-sessions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
4.37.1      General description of SQL-sessions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
4.37.2      SQL-session identification. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
4.37.3      SQL-session properties. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122
4.37.4      Execution contexts. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
4.37.5      Routine execution context. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
4.38        Triggers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
4.38.1      General description of triggers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
4.38.2      Trigger execution. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
4.39        Client-server operation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
5     Lexical elements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
5.1         <SQL terminal character>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
5.2         <token> and <separator>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
5.3         <literal>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143
5.4         Names and identifiers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
6     Scalar expressions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
6.1         <data type>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
6.2         <field definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173


©ISO/IEC 2003 – All rights reserved                                                                                                                           Contents vii
ISO/IEC 9075-2:2003 (E)




6.3          <value expression primary>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
6.4          <value specification> and <target specification>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
6.5          <contextually typed value specification>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181
6.6          <identifier chain>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
6.7          <column reference>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
6.8          <SQL parameter reference>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190
6.9          <set function specification>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
6.10         <window function>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193
6.11         <case expression>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197
6.12         <cast specification>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201
6.13         <next value expression>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
6.14         <field reference>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219
6.15         <subtype treatment>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220
6.16         <method invocation>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 222
6.17         <static method invocation>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224
6.18         <new specification>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 226
6.19         <attribute or method reference>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 228
6.20         <dereference operation>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230
6.21         <method reference>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231
6.22         <reference resolution>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233
6.23         <array element reference>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 235
6.24         <multiset element reference>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 236
6.25         <value expression>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237
6.26         <numeric value expression>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 241
6.27         <numeric value function>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 243
6.28         <string value expression>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252
6.29         <string value function>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 256
6.30         <datetime value expression>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267
6.31         <datetime value function>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
6.32         <interval value expression>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272
6.33         <interval value function>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 277
6.34         <boolean value expression>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 278
6.35         <array value expression>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283
6.36         <array value constructor>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 285
6.37         <multiset value expression>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 287
6.38         <multiset value function>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290
6.39         <multiset value constructor>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291
7      Query expressions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293
7.1          <row value constructor>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293
7.2          <row value expression>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 296
7.3          <table value constructor>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 298
7.4          <table expression>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 300



viii Foundation (SQL/Foundation)                                                                                               ©ISO/IEC 2003 – All rights reserved
                                                                                                                                        ISO/IEC 9075-2:2003 (E)




7.5          <from clause>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301
7.6          <table reference>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 303
7.7          <joined table>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 312
7.8          <where clause>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 319
7.9          <group by clause>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 320
7.10         <having clause>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 329
7.11         <window clause>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 331
7.12         <query specification>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 341
7.13         <query expression>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 351
7.14         <search or cycle clause>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 365
7.15         <subquery>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 370
8      Predicates. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 373
8.1          <predicate>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 373
8.2          <comparison predicate>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 375
8.3          <between predicate>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 382
8.4          <in predicate>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 383
8.5          <like predicate>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 385
8.6          <similar predicate>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 391
8.7          <null predicate>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 397
8.8          <quantified comparison predicate>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399
8.9          <exists predicate>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 401
8.10         <unique predicate>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 402
8.11         <normalized predicate>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 403
8.12         <match predicate>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 404
8.13         <overlaps predicate>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 407
8.14         <distinct predicate>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409
8.15         <member predicate>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 411
8.16         <submultiset predicate>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 413
8.17         <set predicate>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 415
8.18         <type predicate>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 416
8.19         <search condition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 418
9      Additional common rules. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 419
9.1          Retrieval assignment. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 419
9.2          Store assignment. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 424
9.3          Data types of results of aggregations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429
9.4          Subject routine determination. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 432
9.5          Type precedence list determination. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 433
9.6          Host parameter mode determination. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 436
9.7          Type name determination. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 438
9.8          Determination of identical values. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 440
9.9          Equality operations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 442
9.10         Grouping operations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 445


©ISO/IEC 2003 – All rights reserved                                                                                                                          Contents ix
ISO/IEC 9075-2:2003 (E)




9.11         Multiset element grouping operations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 447
9.12         Ordering operations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 449
9.13         Collation determination. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 451
9.14         Execution of array-returning functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 452
9.15         Execution of multiset-returning functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 455
9.16         Data type identity. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 456
9.17         Determination of a from-sql function. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 458
9.18         Determination of a from-sql function for an overriding method. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 459
9.19         Determination of a to-sql function. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 460
9.20         Determination of a to-sql function for an overriding method. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 461
9.21         Generation of the next value of a sequence generator. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 462
9.22         Creation of a sequence generator. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 463
9.23         Altering a sequence generator. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 465
10      Additional common elements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 467
10.1         <interval qualifier>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 467
10.2         <language clause>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 471
10.3         <path specification>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 473
10.4         <routine invocation>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 474
10.5         <character set specification>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 497
10.6         <specific routine designator>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 499
10.7         <collate clause>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 502
10.8         <constraint name definition> and <constraint characteristics>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 503
10.9         <aggregate function>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 505
10.10        <sort specification list>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 517
11      Schema definition and manipulation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 519
11.1         <schema definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 519
11.2         <drop schema statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 522
11.3         <table definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 525
11.4         <column definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 536
11.5         <default clause>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 541
11.6         <table constraint definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 545
11.7         <unique constraint definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 547
11.8         <referential constraint definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 549
11.9         <check constraint definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 569
11.10        <alter table statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 571
11.11        <add column definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 572
11.12        <alter column definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 574
11.13        <set column default clause>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 575
11.14        <drop column default clause>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 576
11.15        <add column scope clause>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 577
11.16        <drop column scope clause>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 578
11.17        <alter identity column specification>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 580


x Foundation (SQL/Foundation)                                                                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                                                                    ISO/IEC 9075-2:2003 (E)




11.18      <drop column definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 581
11.19      <add table constraint definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 583
11.20      <drop table constraint definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 584
11.21      <drop table statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 587
11.22      <view definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 590
11.23      <drop view statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 600
11.24      <domain definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 603
11.25      <alter domain statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 605
11.26      <set domain default clause>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 606
11.27      <drop domain default clause>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 607
11.28      <add domain constraint definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 608
11.29      <drop domain constraint definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 609
11.30      <drop domain statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 610
11.31      <character set definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 612
11.32      <drop character set statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 614
11.33      <collation definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 616
11.34      <drop collation statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 618
11.35      <transliteration definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 620
11.36      <drop transliteration statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 623
11.37      <assertion definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 625
11.38      <drop assertion statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 627
11.39      <trigger definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 629
11.40      <drop trigger statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 633
11.41      <user-defined type definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 634
11.42      <attribute definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 650
11.43      <alter type statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 652
11.44      <add attribute definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 653
11.45      <drop attribute definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 655
11.46      <add original method specification>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 657
11.47      <add overriding method specification>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 663
11.48      <drop method specification>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 668
11.49      <drop data type statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 672
11.50      <SQL-invoked routine>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 675
11.51      <alter routine statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 700
11.52      <drop routine statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 703
11.53      <user-defined cast definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 705
11.54      <drop user-defined cast statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 707
11.55      <user-defined ordering definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 709
11.56      <drop user-defined ordering statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 712
11.57      <transform definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 714
11.58      <alter transform statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 717
11.59      <add transform element list>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 719



©ISO/IEC 2003 – All rights reserved                                                                                                                     Contents xi
ISO/IEC 9075-2:2003 (E)




11.60         <drop transform element list>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 721
11.61         <drop transform statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 723
11.62         <sequence generator definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 726
11.63         <alter sequence generator statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 728
11.64         <drop sequence generator statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 729
12      Access control. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 731
12.1          <grant statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 731
12.2          <grant privilege statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 736
12.3          <privileges>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 739
12.4          <role definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 743
12.5          <grant role statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 744
12.6          <drop role statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 746
12.7          <revoke statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 747
13      SQL-client modules. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 765
13.1          <SQL-client module definition>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 765
13.2          <module name clause>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 770
13.3          <externally-invoked procedure>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 771
13.4          Calls to an <externally-invoked procedure>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 774
13.5          <SQL procedure statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 790
13.6          Data type correspondences. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 798
14      Data manipulation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 809
14.1          <declare cursor>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 809
14.2          <open statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 815
14.3          <fetch statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 817
14.4          <close statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 822
14.5          <select statement: single row>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 824
14.6          <delete statement: positioned>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 828
14.7          <delete statement: searched>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 831
14.8          <insert statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 834
14.9          <merge statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 839
14.10         <update statement: positioned>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 846
14.11         <update statement: searched>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 849
14.12         <set clause list>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 853
14.13         <temporary table declaration>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 858
14.14         <free locator statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 860
14.15         <hold locator statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 861
14.16         Effect of deleting rows from base tables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 862
14.17         Effect of deleting some rows from a derived table. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 864
14.18         Effect of deleting some rows from a viewed table. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 866
14.19         Effect of inserting tables into base tables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 867
14.20         Effect of inserting a table into a derived table. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 869
14.21         Effect of inserting a table into a viewed table. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 871


xii Foundation (SQL/Foundation)                                                                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                                                                       ISO/IEC 9075-2:2003 (E)




14.22         Effect of replacing rows in base tables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 873
14.23         Effect of replacing some rows in a derived table. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 876
14.24         Effect of replacing some rows in a viewed table. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 879
14.25         Execution of BEFORE triggers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 881
14.26         Execution of AFTER triggers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 882
14.27         Execution of triggers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 883
15      Control statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 885
15.1          <call statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 885
15.2          <return statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 886
16      Transaction management. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 887
16.1          <start transaction statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 887
16.2          <set transaction statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 890
16.3          <set constraints mode statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 892
16.4          <savepoint statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 894
16.5          <release savepoint statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 895
16.6          <commit statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 896
16.7          <rollback statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 898
17      Connection management. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 901
17.1          <connect statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 901
17.2          <set connection statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 904
17.3          <disconnect statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 906
18      Session management. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 909
18.1          <set session characteristics statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 909
18.2          <set session user identifier statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 910
18.3          <set role statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 911
18.4          <set local time zone statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 913
18.5          <set catalog statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 914
18.6          <set schema statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 915
18.7          <set names statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 917
18.8          <set path statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 918
18.9          <set transform group statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 919
18.10         <set session collation statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 920
19      Dynamic SQL. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 923
19.1          Description of SQL descriptor areas. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 923
19.2          <allocate descriptor statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 933
19.3          <deallocate descriptor statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 935
19.4          <get descriptor statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 936
19.5          <set descriptor statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 939
19.6          <prepare statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 943
19.7          <cursor attributes>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 955
19.8          <deallocate prepared statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 956



©ISO/IEC 2003 – All rights reserved                                                                                                                      Contents xiii
ISO/IEC 9075-2:2003 (E)




19.9          <describe statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 957
19.10         <input using clause>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 963
19.11         <output using clause>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 967
19.12         <execute statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 972
19.13         <execute immediate statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 974
19.14         <dynamic declare cursor>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 975
19.15         <allocate cursor statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 976
19.16         <dynamic open statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 978
19.17         <dynamic fetch statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 979
19.18         <dynamic single row select statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 980
19.19         <dynamic close statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 981
19.20         <dynamic delete statement: positioned>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 982
19.21         <dynamic update statement: positioned>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 984
19.22         <preparable dynamic delete statement: positioned>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 986
19.23         <preparable dynamic update statement: positioned>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 988
20      Embedded SQL. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 991
20.1          <embedded SQL host program>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 991
20.2          <embedded exception declaration>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1003
20.3          <embedded SQL Ada program>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1007
20.4          <embedded SQL C program>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1013
20.5          <embedded SQL COBOL program>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1021
20.6          <embedded SQL Fortran program>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1027
20.7          <embedded SQL MUMPS program>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1032
20.8          <embedded SQL Pascal program>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1037
20.9          <embedded SQL PL/I program>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1042
21      Direct invocation of SQL. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1049
21.1          <direct SQL statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1049
21.2          <direct select statement: multiple rows>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1053
22      Diagnostics management. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1055
22.1          <get diagnostics statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1055
22.2          Pushing and popping the diagnostics area stack. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1070
23      Status codes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1071
23.1          SQLSTATE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1071
23.2          Remote Database Access SQLSTATE Subclasses. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1080
24      Conformance. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1081
24.1          Claims of conformance to SQL/Foundation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1081
24.2          Additional conformance requirements for SQL/Foundation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1082
24.3          Implied feature relationships of SQL/Foundation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1082
Annex A              SQL Conformance Summary. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1085
Annex B              Implementation-defined elements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1145



xiv Foundation (SQL/Foundation)                                                                                                ©ISO/IEC 2003 – All rights reserved
                                                                                                                                            ISO/IEC 9075-2:2003 (E)




Annex C               Implementation-dependent elements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1163
Annex D               Deprecated features. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1171
Annex E               Incompatibilities with ISO/IEC 9075:1999. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1173
Annex F               SQL feature taxonomy. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1177
Annex G               Defect Reports not addressed in this edition of ISO/IEC 9075. . . . . . . . . . . . . . . . . . . . . . 1207
Index. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1211




©ISO/IEC 2003 – All rights reserved                                                                                                                             Contents xv
                                                                                                                                    ISO/IEC 9075-2:2003 (E)




                                                                            Tables
Table                                                                                                                                                              Page

1     Overview of character sets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
2     Fields in datetime values. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
3     Datetime data type conversions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
4     Fields in year-month INTERVAL values. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
5     Fields in day-time INTERVAL values. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
6     Valid values for fields in INTERVAL values. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
7     Valid operators involving datetimes and intervals. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
8     SQL-transaction isolation levels and the three phenomena. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
9     Valid values for datetime fields. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
10    Valid absolute values for interval fields. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168
11    Truth table for the AND boolean operator. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281
12    Truth table for the OR boolean operator. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281
13    Truth table for the IS boolean operator. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281
14    <null predicate> semantics. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 398
15    Standard programming languages. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 471
16    Data type correspondences for Ada. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 798
17    Data type correspondences for C. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 799
18    Data type correspondences for COBOL. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 800
19    Data type correspondences for Fortran. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 802
20    Data type correspondences for M. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 803
21    Data type correspondences for Pascal. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 804
22    Data type correspondences for PL/I. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 805
23    Data types of <key word>s used in the header of SQL descriptor areas. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 927
24    Data types of <key word>s used in SQL item descriptor areas. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 927
25    Codes used for SQL data types in Dynamic SQL. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 929
26    Codes associated with datetime data types in Dynamic SQL. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 931
27    Codes used for <interval qualifier>s in Dynamic SQL. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 931
28    Codes used for input/output SQL parameter modes in Dynamic SQL. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 932
29    Codes associated with user-defined types in Dynamic SQL. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 932
30    <identifier>s for use with <get diagnostics statement>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1056
31    SQL-statement codes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1059
32    SQLSTATE class and subclass values. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1072
33    SQLSTATE class codes for RDA. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1080
34    Implied feature relationships of SQL/Foundation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1082
35    Feature taxonomy and definition for mandatory features. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1177
36    Feature taxonomy for optional features. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1194




©ISO/IEC 2003 – All rights reserved                                                                                                                  Contents xvi
                                                                                                                     ISO/IEC 9075-2:2003 (E)




                                                                  Figures
Figure                                                                                                                                           Page

1     Operation of <regular expression substring function>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2     Illustration of WIDTH_BUCKET Semantics. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29




©ISO/IEC 2003 – All rights reserved                                                                                                 Contents xvii
ISO/IEC 9075-2:2003 (E)




                                    This page intentionally left blank.




xviii Foundation (SQL/Foundation)                                         ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)




Foreword

ISO (the International Organization for Standardization) and IEC (the International Electrotechnical Commission)
form the specialized system for worldwide standardization. National bodies that are members of ISO or IEC
participate in the development of International Standards through technical committees established by the
respective organization to deal with particular fields of mutual interest. Other international organizations,
governmental and non-governmental, in liaison with ISO and IEC, also take part in the work.
International Standards are drafted in accordance with the rules given in the ISO/IEC Directives, Part 2.
In the field of information technology, ISO and IEC have established a joint technical committee, ISO/IEC
JTC 1. Draft International Standards adopted by the joint technical committee are circulated to national bodies
for voting. Publication as an International Standard requires approval by at leat 75% of the national bodies
casting a vote.
Attention is drawn to the possibility that some of the elements of this International Standard may be the subject
of patent rights. ISO and IEC shall not be held responsible for identifying any or all such patent rights.
International Standard ISO/IEC 9075-2 was prepared by Joint Technical Committee ISO/IEC JTC 1, Information
technology, Subcommittee SC 32, Data management and interchange.
This fifth edition cancels and replaces the fourth edition (ISO/IEC 9075:1999).
ISO/IEC 9075 consists of the following parts, under the general title Information technology — Database lan-
guages — SQL:
— Part 1: Framework (SQL/Framework)
— Part 2: Foundation (SQL/Foundation)
— Part 3: Call-Level Interface (SQL/CLI)
— Part 4: Persistent Stored Modules (SQL/PSM)
— Part 9: Management of External Data (SQL/MED)
— Part 10: Object Language Bindings (SQL/OLB)
— Part 11: Information and Definition Schema (SQL/Schemata)
— Part 13: Routines and Types Using the Java™ Programming Language (SQL/JRT)
— Part 14: XML-Related Specifications (SQL/XML)
Annexes A, B, C, D, E, F, and G of this part of ISO/IEC 9075 are for information only.




©ISO/IEC 2003 – All rights reserved                                                               Foreword xix
ISO/IEC 9075-2:2003 (E)




Introduction

The organization of this part of ISO/IEC 9075 is as follows:
1) Clause 1, “Scope”, specifies the scope of this part of ISO/IEC 9075.
2) Clause 2, “Normative references”, identifies additional standards that, through reference in this part of
   ISO/IEC 9075, constitute provisions of this part of ISO/IEC 9075.
3) Clause 3, “Definitions, notations, and conventions”, defines the notations and conventions used in this part
   of ISO/IEC 9075.
4) Clause 4, “Concepts”, presents concepts used in the definition of SQL.
5) Clause 5, “Lexical elements”, defines the lexical elements of the language.
6) Clause 6, “Scalar expressions”, defines the elements of the language that produce scalar values.
7) Clause 7, “Query expressions”, defines the elements of the language that produce rows and tables of data.
8) Clause 8, “Predicates”, defines the predicates of the language.
9) Clause 9, “Additional common rules”, specifies the rules for assignments that retrieve data from or store
   data into SQL-data, and formation rules for set operations.
10) Clause 10, “Additional common elements”, defines additional language elements that are used in various
    parts of the language.
11) Clause 11, “Schema definition and manipulation”, defines facilities for creating and managing a schema.
12) Clause 12, “Access control”, defines facilities for controlling access to SQL-data.
13) Clause 13, “SQL-client modules”, defines SQL-client modules and externally-invoked procedures.
14) Clause 14, “Data manipulation”, defines the data manipulation statements.
15) Clause 15, “Control statements”, defines the SQL-control statements.
16) Clause 16, “Transaction management”, defines the SQL-transaction management statements.
17) Clause 17, “Connection management” defines the SQL-connection management statements.
18) Clause 18, “Session management”, defines the SQL-session management statements.
19) Clause 19, “Dynamic SQL”, defines the SQL dynamic statements.
20) Clause 20, “Embedded SQL”, defines the host language embeddings.
21) Clause 21, “Direct invocation of SQL”, defines direct invocation of SQL language.
22) Clause 22, “Diagnostics management”, defines the diagnostics management facilities.
23) Clause 23, “Status codes”, defines values that identify the status of the execution of SQL-statements and
    the mechanisms by which those values are returned.
24) Clause 24, “Conformance”, defines the criteria for conformance to this part of ISO/IEC 9075.


xx Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)




25) Annex A, “SQL Conformance Summary”, is an informative Annex. It summarizes the conformance
    requirements of the SQL language.
26) Annex B, “Implementation-defined elements”, is an informative Annex. It lists those features for which
    the body of this part of ISO/IEC 9075 states that the syntax, the meaning, the returned results, the effect
    on SQL-data and/or schemas, or any other behavior is partly or wholly implementation-defined.
27) Annex C, “Implementation-dependent elements”, is an informative Annex. It lists those features for which
    the body of this part of ISO/IEC 9075 states that the syntax, the meaning, the returned results, the effect
    on SQL-data and/or schemas, or any other behavior is partly or wholly implementation-dependent.
28) Annex D, “Deprecated features”, is an informative Annex. It lists features that the responsible Technical
    Committee intend will not appear in a future revised version of this part of ISO/IEC 9075.
29) Annex E, “Incompatibilities with ISO/IEC 9075:1999”, is an informative Annex. It lists incompatibilities
    with the previous version of this part of ISO/IEC 9075.
30) Annex F, “SQL feature taxonomy”, is an informative Annex. It identifies features of the SQL language
    specified in this part of ISO/IEC 9075 by an identifier and a short descriptive name. This taxonomy is used
    to specify conformance and may be used to develop other profiles involving the SQL language.
31) Annex G, “Defect Reports not addressed in this edition of ISO/IEC 9075”, is an informative Annex. It
    describes the Defect Reports that were known at the time of publication of this part of this International
    Standard. Each of these problems is a problem carried forward from the previous edition of ISO/IEC 9075-
    2. No new problems have been created in the drafting of this edition of this International Standard.
In the text of this part of ISO/IEC 9075, Clauses begin a new odd-numbered page, and in Clause 5, “Lexical
elements”, through Clause 23, “Status codes”, Subclauses begin a new page. Any resulting blank space is not
significant.




©ISO/IEC 2003 – All rights reserved                                                            Introduction xxi
ISO/IEC 9075-2:2003 (E)




                                   This page intentionally left blank.




xxii Foundation (SQL/Foundation)                                         ©ISO/IEC 2003 – All rights reserved
INTERNATIONAL STANDARD                                                            ISO/IEC 9075-2:2003 (E)




Information technology— Database languages —SQL —
Part 2: Foundation (SQL/Foundation)

1 Scope

This part of ISO/IEC 9075 defines the data structures and basic operations on SQL-data. It provides functional
capabilities for creating, accessing, maintaining, controlling, and protecting SQL-data.
This part of ISO/IEC 9075 specifies the syntax and semantics of a database language:
— For specifying and modifying the structure and the integrity constraints of SQL-data.
— For declaring and invoking operations on SQL-data and cursors.
— For declaring database language procedures.
— For embedding SQL-statements in a compilation unit that otherwise conforms to the standard for a partic-
  ular programming language (host language).
— For deriving an equivalent compilation unit that conforms to the particular programming language standard.
  In that equivalent compilation unit, each embedded SQL-statement has been replaced by one or more
  statements in the host language, some of which invoke an SQL externally-invoked procedure that, when
  executed, has an effect equivalent to executing the SQL-statement.
— For direct invocation of SQL-statements.
— To support dynamic preparation and execution of SQL-statements.
This part of ISO/IEC 9075 provides a vehicle for portability of data definitions and compilation units between
SQL-implementations.
This part of ISO/IEC 9075 provides a vehicle for interconnection of SQL-implementations.
Implementations of this part of ISO/IEC 9075 may exist in environments that also support application program-
ming languages, end-user query languages, report generator systems, data dictionary systems, program library
systems, and distributed communication systems, as well as various tools for database design, data administration,
and performance optimization.




©ISO/IEC 2003 – All rights reserved                                                                      Scope 1
ISO/IEC 9075-2:2003 (E)




                                This page intentionally left blank.




2 Foundation (SQL/Foundation)                                         ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                          2.1 JTC1 standards




2 Normative references

The following referenced documents are indispensable for the application of this document. For dated references,
only the edition cited applies. For undated references, the latest edition of the referenced document (including
any amendments) applies.



2.1      JTC1 standards

   [ISO646] ISO/IEC 646:1991, Information technology — ISO 7-bit coded character set for information
   interchange.
   [ISO1539] ISO/IEC 1539-1:1997, Information technology — Programming languages — Fortran — Part 1:
   Base language.
   ISO/IEC 1539-1:1997/Cor.1:2001.
   ISO/IEC 1539-1:1997/Cor.2:2002.
   [ISO1989] ISO 1989:1985, Programming languages — COBOL. (Endorsement of ANSI X3.23-1985).
   ISO/IEC 1989:1985/Amd.1:1992, Intrinsic function module
   ISO/IEC 1989:1985/Amd.2:1994, Correction and clarification amendment for COBOL
   ISO 6160:1979, Programming languages — PL/I (Endorsement of ANSI X3.53-1976).
   [ISO6429] ISO/IEC 6429:1992, Information technology — Control functions for coded character sets
   [ISO7185] ISO/IEC 7185:1990, Information technology — Programming languages — Pascal.
   [ISO8601] ISO 8601:2000, Data elements and interchange formats — Information interchange — Represen-
   tation of dates and times.
   [ISO8649] ISO/IEC 8649:1996, Information technology — Open Systems Interconnection — Service Definition
   for the Association Control Service Element.
   [ISO8652] ISO/IEC 8652:1995, Information technology — Programming languages — Ada.
   ISO/IEC 8652:1995/Cor.1:2001.
   [Latin1] ISO/IEC 8859-1:1998, Information technology — 8-bit single-byte coded graphic character sets
   — Part 1: Latin alphabet No. 1
   [Framework] ISO/IEC FCD 9075-1:2003, Information technology — Database languages — SQL — Part 1:
   Framework (SQL/Framework).
   [Schemata] ISO/IEC FCD 9075-11:2003, Information technology — Database languages — SQL — Part 11:
   Information and Definition Schemas (SQL/Schemata).



©ISO/IEC 2003 – All rights reserved                                                    Normative references 3
ISO/IEC 9075-2:2003 (E)
2.1 JTC1 standards



  [ISO9579] ISO/IEC 9579:2000, Information technology — Remote database access for SQL with security
  enhancement.
  [ISO9899] ISO/IEC 9899:1999, Programming languages — C.
  ISO/IEC 9899:1999/Cor 1:2001, Technical Corrigendum to ISO/IEC 9899:1999.
  [ISO10026] ISO/IEC 10026-2:1998, Information technology — Open Systems Interconnection — Distributed
  Transaction Processing — Part 2: OSI TP Service.
  [ISO10206] ISO/IEC 10206:1991, Information technology — Programming languages — Extended Pascal.
  [UCS] ISO/IEC 10646-1:2000, Information technology — Universal Multi-Octet Coded Character Set (UCS)
  — Part 1: Architecture and Basic Multilingual Plane.
  [UCSsupp] ISO/IEC FDIS 10646-2:2001, Information technology — Universal Multi-Octet Coded Character
  Set (UCS) — Part 2: Supplementary Planes.
  [ISO11756] ISO/IEC 11756:1999, Information technology — Programming languages — M.
  [ISO14651] ISO/IEC 14651:2001, Information technology — International string ordering and comparison
  — Method for comparing character strings and description of the common template tailorable ordering.



2.2    Other international standards

  [Unicode 3.0] The Unicode Consortium, The Unicode Standard, Version 3.0, Reading, MA, Addison-Wesley
  Developers Press, 2000. ISBN 0-201-61633-5.
  [Unicode 3.1] The Unicode Consortium, The Unicode Standard, Version 3.1.0, Unicode Standard Annex
  #27: Unicode 3.1 (which amends The Unicode Standard, Version 3.0). 2001-03-23.
  http://www.unicode.org/unicode/reports/tr27/
  [Unicode10] Davis, Mark and Whistler, Ken. Unicode Technical Standard #10, Unicode Collation Algorithm,
  Version 8.0, 2001-03-23. The Unicode Consortium.
  http://www.unicode.org/unicode/reports/tr10/tr10-8.html
  [Unicode15] Davis, Mark and Dürst, Martin. Unicode Standard Annex #15, Unicode Normalization Forms,
  Version 21.0, 2001-03-23. The Unicode Consortium.
  http://www.unicode.org/unicode/reports/tr15/tr15-21.html
  [Unicode19] Davis, Mark. Unicode Standard Annex #19, UTF-32, Version 8.0, 2001-03-23. The Unicode
  Consortium.
  http://www.unicode.org/unicode/reports/tr19/tr19-8.html
  [IANA] The Internet Assigned Numbers Authority, Character sets
  http://www.iana.org/assignments/character-sets




4 Foundation (SQL/Foundation)                                               ©ISO/IEC 2003 – All rights reserved
                                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                                              3.1 Definitions




3 Definitions, notations, and conventions


3.1      Definitions


3.1.1 Definitions taken from ISO/IEC 10646

For the purposes of this part of ISO/IEC 9075, the definitions of the following terms given in ISO/IEC 10646
apply:
3.1.1.1 character
NOTE 1 — This is identical to the Unicode definition of abstract character. In ISO/IEC 9075, when the relevant character repertoire
is UCS, a character can be thought of as that which is represented by one code point.

3.1.1.2 repertoire



3.1.2 Definitions taken from ISO/IEC 14651

For the purposes of this part of ISO/IEC 9075, the definitions of the following terms given in ISO/IEC 14651
apply:
3.1.2.1 collation



3.1.3 Definitions taken from Unicode

For the purposes of this part of ISO/IEC 9075, the definitions of the following terms given in The Unicode
Standard apply:
3.1.3.1 character encoding form
3.1.3.2 code point
3.1.3.3 code unit
3.1.3.4 control character
3.1.3.5 noncharacter
3.1.3.6 normalization
3.1.3.7 transcoding



©ISO/IEC 2003 – All rights reserved                                                Definitions, notations, and conventions 5
ISO/IEC 9075-2:2003 (E)
3.1 Definitions



3.1.4 Definitions taken from ISO 8601

For the purposes of this part of ISO/IEC 9075, the definitions of the following terms given in ISO 8601 apply:
3.1.4.1 Coordinated Universal Time (UTC)
3.1.4.2 date (date, calendar in ISO 8601)



3.1.5 Definitions taken from Part 1

For the purposes of this part of ISO/IEC 9075, the definitions given in ISO/IEC 9075-1 apply.



3.1.6 Definitions provided in Part 2

For the purposes of this part of ISO/IEC 9075, in addition to those definitions taken from other sources, the
following definitions apply:
3.1.6.1 assignable (of types, taken pairwise): The characteristic of a data type T1 that permits a value of T1
        to be assigned to a site of a specified data type T2 (where T1 and T2 may be the same data type.
3.1.6.2 assignment: The operation that causes the value at a site T (known as the target) to be a given value
        S (known as the source). Assignment is frequently indicated by the use of the phrase “T is set to S” or
        “the value of T is set to S”.
3.1.6.3 attribute: A component of a structured type. Each value V in structured type T has exactly one attribute
        value for each attribute A of T. The characteristics of an attribute are specified by an attribute descriptor.
        The value of an attribute may be retrieved as the result of the invocation A(V) of the observer function
        for that attribute.
3.1.6.4 cardinality (of a collection): The number of elements in that collection. Those elements need not
        necessarily have distinct values. The objects to which this concept applies includes tables and the values
        of collection types.
3.1.6.5 comparable (of a pair of values): Capable of being compared, according to the rules of Subclause 8.2,
        “<comparison predicate>”. In most, but not all, cases, the values of a data type can be compared one
        with another. For the specification of comparability of individual data types, see Subclause 4.2,
        “Character strings”, through Subclause 4.10, “Collection types”.
3.1.6.6 constructor function: A niladic SQL-invoked function of which exactly one is implicitly specified
        for every structured type. An invocation of the constructor function for data type T returns a value V
        of the most specific type T such that V is not null and, for every observer function O defined for T, the
        invocation O(V) returns the default value of the attribute corresponding to O.
3.1.6.7 declared type (of an expression denoting a value or anything that can be referenced to denote a
        value, such as, for example, a parameter, column, or variable): The unique data type that is common
        to every value that might result from evaluation of that expression.



6 Foundation (SQL/Foundation)                                                         ©ISO/IEC 2003 – All rights reserved
                                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                                                3.1 Definitions



3.1.6.8 distinct (of a pair of comparable values): Capable of being distinguished within a given context.
        Informally, not equal, not both null. A null value and a non-null value are distinct.
For two non-null values, the following rules apply:
— Two values of predefined type or reference type are distinct if and only if they are not equal.
— If two values V1 and V2 are of a user-defined type whose comparison form is RELATIVE or MAP and the
  result of comparing them for equality according to Subclause 8.2, “<comparison predicate>”, is Unknown,
  then it is implementation-dependent whether they are distinct or not; otherwise, they are distinct if and only
  if they are not equal.
— If two values V1 and V2 are of a user-defined type whose comparison form is STATE, then they are distinct
  if their most specific types are different, or if there is an attribute A of their common most specific type
  such that the value of A in V1 and the value of A in V2 are distinct.
— Two rows are distinct if and only if at least one of their pairs of respective fields is distinct.
— Two arrays that do not have the same cardinality are distinct.
— Two arrays that have the same cardinality and in which there exists at least one ordinal position P such that
  the array element at position P in one array is distinct from the array element at position P in the other array
  are distinct.
— Two multisets A and B are distinct if there exists a value V in the element type of A or B, including the null
  value, such that the number of elements in A that are not distinct from V does not equal the number of ele-
  ments in B that are not distinct from V.
NOTE 2 — The result of evaluating whether or not two comparable values are distinct is never Unknown. The result of evaluating
whether or not two values that are not comparable (for example, values of a user-defined type that has no comparison type) are distinct
is not defined.

3.1.6.9 duplicates: Two or more members of a multiset that are not distinct.
3.1.6.10 dyadic (of operators, functions, and procedures): Having exactly two operands or parameters.
NOTE 3 — An example of a dyadic operator in this part of ISO/IEC 9075 is “–”, specifying the subtraction of the right operand from
the left operand. An example of a dyadic function is POSITION.

3.1.6.11 element type (of a collection type and every value in that collection type): The declared type spec-
         ified in the definition of a collection type CT that is common to every element of every value of type
         CT.
3.1.6.12 equal (of a pair of comparable values): Yielding True if passed as arguments in a <comparison
         predicate> in which the <comp op> is <equals operator>. (see Subclause 8.2, “<comparison predicate>”).
3.1.6.13 external routine: An SQL-invoked routine whose routine body is an external body reference that
         identifies a program written in a standard programming language other than SQL.
3.1.6.14 fixed-length: A characteristic of character strings that restricts a string to contain exactly one number
         of characters, known as the length in characters of the string.
3.1.6.15 identical (of a pair of comparable values): Indistinguishable, in the sense that it is impossible, by
         any means specified in ISO/IEC 9075, to detect any difference between them. For the full definition,
         see Subclause 9.8, “Determination of identical values”.




©ISO/IEC 2003 – All rights reserved                                                  Definitions, notations, and conventions 7
ISO/IEC 9075-2:2003 (E)
3.1 Definitions



3.1.6.16 interface (of a structured type): The set comprising every function such that the declared type of at
         least one of its parameters or result is that structured type.
3.1.6.17 monadic (of operators, functions, and procedures): Having exactly one operand or parameter.
NOTE 4 — An example of a monadic arithmetic operator in this part of ISO/IEC 9075 is “–”, specifying the negation of the operand.
An example of a monadic function is CHARACTER_LENGTH, specifying the length in characters of the argument.

3.1.6.18 most specific type (of a value): The unique data type of which every data type of that value is a
         supertype.
3.1.6.19 mutator function: A dyadic, type-preserving function M whose definition is implied by the definition
         of some attribute A (of declared type AT) of some user-defined type T. The first parameter of M is a
         result SQL parameter of declared type T, which is also the result type of M. The second parameter of
         M is of declared type AT. If V is some value in T and AV is some value in AT, then the invocation M(V,
         AV) returns the value V1 such that V1 differs from V only in its value for attribute A, if at all. The most
         specific type of V1 is the most specific type of V.
3.1.6.20 n-adic operator: An operator having a variable number of operands (informally: n operands).
NOTE 5 — An example of an n-adic operator in this part of ISO/IEC 9075 is COALESCE.

3.1.6.21 niladic (of functions and procedures): Having no parameters.
3.1.6.22 observer function: An SQL-invoked function M implicitly defined by the definition of attribute A of
         a structured type T. If V is some value in T and the declared type of A is AT, then the invocation of
         M(V) returns some value AV in AT. AV is then said to be the value of attribute A in V.
3.1.6.23 redundant duplicates: All except one of any collection of duplicate values or rows.
3.1.6.24 REF value: A value that references some site.
3.1.6.25 reference type: A data type all of whose values are potential references to sites of one specified data
         type.
3.1.6.26 referenced type: The declared type of the values at sites referenced by values of a particular reference
         type.
3.1.6.27 referenced value: The value at the site referenced by a REF value.
3.1.6.28 result SQL parameter: An SQL parameter that specifies RESULT.
3.1.6.29 result data type: The declared type of the result of an SQL-invoked function.
3.1.6.30 signature (of an SQL-invoked routine): The name of an SQL-invoked routine, the position and
         declared type of each of its SQL parameters, and an indication of whether it is an SQL-invoked function
         or an SQL-invoked procedure.
3.1.6.31 SQL argument: An expression denoting a value to be substituted for an SQL parameter in an invocation
         of an SQL-invoked routine.
3.1.6.32 SQL-invoked routine: A routine that is allowed to be invoked only from within SQL.
3.1.6.33 SQL parameter: A parameter declared as part of the signature of an SQL-invoked routine.
3.1.6.34 SQL routine: An SQL-invoked routine whose routine body is written in SQL.




8 Foundation (SQL/Foundation)                                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                                                                 3.1 Definitions



3.1.6.35 subfield (of a row type): A field that is a field of a row type RT or a field of a row type RT2 that is
         the declared type of a field that is a subfield of RT.
3.1.6.36 subtype (of a data type): A data type T2 such that every value of T2 is also a value of data type T1.
         If T1 and T2 are not compatible, then T2 is a proper subtype of T1. “Compatible” is defined in
         Subclause 4.1, “Data types”. See also supertype.
3.1.6.37 supertype (of a data type): A data type T1 such that every value of T2 is also a value of data type T1.
         If T1 and T2 are not compatible, then T1 is a proper supertype of T2. “Compatible” is defined in
         Subclause 4.1, “Data types”. See also subtype.
3.1.6.38 transliteration: A method of translating characters in one character set into characters of the same or
         a different character set.
3.1.6.39 type-preserving function: An SQL-invoked function, one of whose parameters is a result SQL
         parameter. The most specific type of the value returned by an invocation of a type-preserving function
         is identical to the most specific type of the SQL argument value substituted for the result SQL param-
         eter.
3.1.6.40 user-defined type: A type whose characteristics are specified by a user-defined type descriptor.
3.1.6.41 variable-length: A characteristic of character strings and binary strings that allows a string to contain
         any number of characters or octets, respectively, between 0 (zero) and some maximum number, known
         as the maximum length in characters or octets, respectively, of the string.
3.1.6.42 white space: Characters used to separate tokens in SQL text; white space may be required (for example,
         to separate <nondelimiter token>s from one another) and may be used between any two tokens for
         which there are no rules prohibiting such use.
White space is any character in the Unicode General Category classes “Zs”, “Zl”, and “Zp”, or any of the fol-
lowing characters:
— U+0009, Horizontal Tabulation
— U+000A, Line Feed
— U+000B, Vertical Tabulation
— U+000C, Form Feed
— U+000D, Carriage Return
— U+0085, Next Line
NOTE 6 — The normative provisions of this International Standard impose no requirement that any character set have equivalents for
any of these characters except U+0020 (<space>); however, by reference to this definition of white space, they do impose the requirement
that every equivalent for one of these shall be recognized as a white space character.
NOTE 7 — The Unicode General Category classes “Zs”, “Zl”, and “Zp” are assigned to Unicode characters that are, respectively, space
separators, line separators, and paragraph separators.
The only character that is a member of the Unicode General Category class “Zl” is U+2028, Line Separator. The only character that is
a member of the Unicode General Category class “Zp” is U+2029, Paragraph Separator. The characters that are members of the Unicode
General Category class “Zs” are: U+0020, Space, U+00A0, No-Break Space, U+1680, Ogham Space Mark, U+2000, En Quad, U+2001,
Em Quad, U+2002, En Space, U+2003, Em Space, U+2004, Three-Per-Em Space, U+2005, Four-Per-Em Space, U+2006, Six-Per-Em
Space, U+2007, Figure Space, U+2008, Punctuation Space, U+2009, Thin Space, U+200A, Hair Space, U+202F, Narrow No-Break
Space, and U+3000, Ideographic Space.




©ISO/IEC 2003 – All rights reserved                                                  Definitions, notations, and conventions 9
ISO/IEC 9075-2:2003 (E)
3.2 Notation



3.2     Notation

The notation used in this part of ISO/IEC 9075 is defined in ISO/IEC 9075-1.



3.3     Conventions

The conventions used in this part of ISO/IEC 9075 are defined in ISO/IEC 9075-1, with the following additions.



3.3.1 Use of terms


3.3.1.1 Other terms

An SQL-statement S1 is said to be executed as a direct result of executing an SQL-statement if S1 is the SQL-
statement contained in an <externally-invoked procedure> or <SQL-invoked routine> that has been executed.
An SQL-statement S1 is said to be executed as a direct result of executing an SQL-statement if S1 is the value
of an <SQL statement variable> referenced by an <execute immediate statement> contained in an <externally-
invoked procedure> that has been executed, or if S1 was the value of the <SQL statement variable> that was
associated with an <SQL statement name> by a <prepare statement> and that same <SQL statement name> is
referenced by an <execute statement> contained in an <externally-invoked procedure> that has been executed.




10 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                                                 4.1 Data types




4 Concepts


4.1      Data types


4.1.1 General introduction to data types

A data type is a set of representable values. Every representable value belongs to at least one data type and
some belong to several data types.
Exactly one of the data types of a value V, namely the most specific type of V, is a subtype of every data type
of V. A <value expression> E has exactly one declared type, common to every possible result of evaluating E.
Items that can be referenced by name, such as SQL parameters, columns, fields, attributes, and variables, also
have declared types.
SQL supports three sorts of data types: predefined data types, constructed types, and user-defined types. Prede-
fined data types are sometimes called “built-in data types”, though not in this International Standard. User-
defined types can be defined by a standard, by an implementation, or by an application.
A constructed type is specified using one of SQL's data type constructors, ARRAY, MULTISET, REF, and
ROW. A constructed type is either an array type, a multiset type, a reference type, or a row type, according to
whether it is specified with ARRAY, MULTISET, REF, or ROW, respectively. Array types and multiset types
are known generically as collection types.
Every predefined data type is a subtype of itself and of no other data types. It follows that every predefined
data type is a supertype of itself and of no other data types. The predefined data types are individually described
in each of Subclause 4.2, “Character strings”, through Subclause 4.6, “Datetimes and intervals”.
Row types, reference types and collection types are described in Subclause 4.8, “Row types”, Subclause 4.9,
“Reference types”, Subclause 4.10, “Collection types”, respectively.



4.1.2 Naming of predefined types

SQL defines predefined data types named by the following <key word>s: CHARACTER, CHARACTER
VARYING, CHARACTER LARGE OBJECT, BINARY LARGE OBJECT, NUMERIC, DECIMAL,
SMALLINT, INTEGER, BIGINT, FLOAT, REAL, DOUBLE PRECISION, BOOLEAN, DATE, TIME,
TIMESTAMP, and INTERVAL. These names are used in the type designators that constitute the type precedence
lists specified in Subclause 9.5, “Type precedence list determination”.
For reference purposes:
— The data types CHARACTER, CHARACTER VARYING, and CHARACTER LARGE OBJECT are
  collectively referred to as character string types.



©ISO/IEC 2003 – All rights reserved                                                                  Concepts 11
ISO/IEC 9075-2:2003 (E)
4.1 Data types



— The data type BINARY LARGE OBJECT is referred to as the binary string type and the values of binary
  string types are referred to as binary strings.
— The data types CHARACTER LARGE OBJECT and BINARY LARGE OBJECT are collectively referred
  to as large object string types and the values of large object string types are referred to as large object
  strings.
— Character string types and binary string types are collectively referred to as string types and values of string
  types are referred to as strings.
— The data types NUMERIC, DECIMAL, SMALLINT, INTEGER, and BIGINT are collectively referred to
  as exact numeric types.
— The data types FLOAT, REAL, and DOUBLE PRECISION are collectively referred to as approximate
  numeric types.
— Exact numeric types and approximate numeric types are collectively referred to as numeric types. Values
  of numeric types are referred to as numbers.
— The data types TIME WITHOUT TIME ZONE and TIME WITH TIME ZONE are collectively referred
  to as time types (or, for emphasis, as time with or without time zone).
— The data types TIMESTAMP WITHOUT TIME ZONE and TIMESTAMP WITH TIME ZONE are collec-
  tively referred to as timestamp types (or, for emphasis, as timestamp with or without time zone).
— The data types DATE, TIME, and TIMESTAMP are collectively referred to as datetime types.
— Values of datetime types are referred to as datetimes.
— The data type INTERVAL is referred to as an interval type. Values of interval types are called intervals.
Each data type has an associated data type descriptor; the contents of a data type descriptor are determined by
the specific data type that it describes. A data type descriptor includes an identification of the data type and all
information needed to characterize a value of that data type.
Subclause 6.1, “<data type>”, describes the semantic properties of each data type.



4.1.3 Non-predefined and non-SQL types

A structured type ST is directly based on a data type DT if any of the following are true:
— DT is the declared type of some attribute of ST.
— DT is a direct supertype of ST.
— DT is a direct subtype of ST.
— DT is compatible with ST.
A collection type CT is directly based on a data type DT if DT is the element type of CT.
A row type RT is directly based on a data type DT if DT is the declared type of some field (or the data type of
the domain of some field) whose descriptor is included in the descriptor of RT.



12 Foundation (SQL/Foundation)                                                       ©ISO/IEC 2003 – All rights reserved
                                                                                            ISO/IEC 9075-2:2003 (E)
                                                                                                    4.1 Data types



A data type DT1 is based on a data type DT2 if DT1 is compatible with DT2, DT1 is directly based on DT2, or
DT1 is directly based on some data type that is based on DT2.
A type TY is usage-dependent on a user-defined type UDT if one of the following conditions is true:
— TY is UDT.
— TY is a reference type whose referenced type is UDT.
— TY is a row type, and the declared type of a field of TY is usage-dependent on UDT.
— TY is a collection type, and the declared element type of TY is usage-dependent on UDT.
Each host language has its own data types, which are separate and distinct from SQL data types, even though
similar names may be used to describe the data types. Mappings of SQL data types to data types in host languages
are described in Subclause 11.50, “<SQL-invoked routine>”, and Subclause 20.1, “<embedded SQL host pro-
gram>”. Not every SQL data type has a corresponding data type in every host language.



4.1.4 Comparison and ordering

Ordering and comparison of values of the predefined data types requires knowledge only about those predefined
data types. However, to be able to compare and order values of constructed types or of user-defined types,
additional information is required. We say that some type T is S-ordered, for some set of types S, if, in order
to compare and order values of type T, information about ordering at least one of the types in S is first required.
A definition of S-ordered is required for several S (that is, for several sets of types), but not for all possible such
sets.
The general definition of S-ordered is this:
Let T be a type and let S be a set of types. T is S-ordered if one of the following is true:
— T is a member of S.
— T is a row type and the declared type of some field of T is S-ordered.
— T is a collection type and the element type of T is S-ordered.
— T is a structured type whose comparison form is STATE and the declared type of some attribute of T is
  S-ordered.
— T is a user-defined type whose comparison form is MAP and the return type of the SQL-invoked function
  that is identified by the <map function specification> is S-ordered.
— T is a reference type with a derived representation and the declared type of some attribute enumerated by
  the <derived representation> is S-ordered.
The notion of S-ordered is applied in the following definitions:
— A type T is LOB-ordered if T is L-ordered, where L is the set of large object types.
— A type T is array-ordered if T is ARR-ordered, where ARR is the set of array types.
— A type T is multiset-ordered if T is MUL-ordered, where MUL is the set of multiset types.



©ISO/IEC 2003 – All rights reserved                                                                     Concepts 13
ISO/IEC 9075-2:2003 (E)
4.1 Data types



— A type T is reference-ordered if T is REF-ordered, where REF is the set of reference types.
— A type T is DT-EC-ordered if T is DTE-ordered, where DTE is the set of distinct types with EQUALS
  ONLY comparison form (DT-EC stands for “distinct type-equality comparison”).
— A type T is DT-FC-ordered if T is DTF-ordered, where DTF is the set of distinct types with FULL compar-
  ison form.
— A type T is DT-NC-ordered if T is DTN-ordered, where DTN is the set of distinct types with no comparison
  form.
— A type T is ST-EC-ordered if T is STE-ordered, where STE is the set of structured types with EQUALS
  ONLY comparison form.
— A type T is ST-FC-ordered if T is STF-ordered, where STF is the set of structured types with FULL com-
  parison form.
— A type T is ST-NC-ordered if T is STN-ordered, where STN is the set of structured types with no comparison
  form.
— A type T is ST-ordered if T is ST-EC-ordered, ST-FC-ordered, or ST-NC-ordered.
— A type T is UDT-EC-ordered if T is either DT-EC-ordered or ST-EC-ordered (UDT stands for “user-defined
  type”).
— A type T is UDT-FC-ordered if T is either DT-FC-ordered or ST-FC-ordered
— A type T is UDT-NC-ordered if T is either DT-NC-ordered or ST-NC-ordered.
The notion of a constituent of a declared type DT is defined recursively as follows:
— DT is a constituent of DT.
— If DT is a row type, then the declared type of each field of DT is a constituent of DT.
— If DT is a collection type, then the element type of DT is a constituent of DT.
— Every constituent of a constituent of DT is a constituent of DT.
Two data types, T1 and T2, are said to be compatible if T1 is assignable to T2, T2 is assignable to T1, and their
descriptors include the same data type name. If they are row types, it shall further be the case that the declared
types of their corresponding fields are pairwise compatible. If they are collection types, it shall further be the
case that their element types are compatible. If they are reference types, it shall further be the case that their
referenced types are compatible.
NOTE 8 — The data types “CHARACTER(n) CHARACTER SET CS1” and “CHARACTER(m) CHARACTER SET CS2”, where
CS1 ≠ CS2, have descriptors that include the same data type name (CHARACTER), but are not mutually assignable; therefore, they
are not compatible.




14 Foundation (SQL/Foundation)                                                               ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                            4.2 Character strings



4.2      Character strings


4.2.1 Introduction to character strings

A character string is a sequence of characters. All the characters in a character string are taken from a single
character set. A character string has a length, which is the number of characters in the sequence. The length is
0 (zero) or a positive integer.
A character string type is described by a character string type descriptor. A character string type descriptor
contains:
— The name of the specific character string type (CHARACTER, CHARACTER VARYING, and CHARAC-
  TER LARGE OBJECT; NATIONAL CHARACTER, NATIONAL CHARACTER VARYING, and
  NATIONAL CHARACTER LARGE OBJECT are represented as CHARACTER, CHARACTER
  VARYING, and CHARACTER LARGE OBJECT, respectively).
— The length or maximum length in characters of the character string type.
— The catalog name, schema name, and character set name of the character set of the character string type.
— The catalog name, schema name, and collation name of the collation of the character string type.
A character large object type is a character string type where the name of the specific character string type is
CHARACTER LARGE OBJECT. A value of a character large object type is a large object character string.
The character set of a character string type may be specified explicitly or implicitly.
The <key word>s NATIONAL CHARACTER are used to specify an implementation-defined character set.
Special syntax (N'string') is provided for representing literals in that character set.
With two exceptions, a character string expression is assignable only to sites of a character string type whose
character set is the same. The exceptions are as specified in Subclause 4.2.8, “Universal character sets”, and
such other cases as may be implementation-defined. If a store assignment would result in the loss of non-<space>
characters due to truncation, then an exception condition is raised. If a retrieval assignment or evaluation of a
<cast specification> would result in the loss of characters due to truncation, then a warning condition is raised.
Character sets fall into three categories: those defined by national or international standards, those defined by
SQL-implementations, and those defined by applications. The character sets defined by ISO/IEC 10646 and
The Unicode Standard are known as Universal Character Sets (UCS) and their treatment is described in
Subclause 4.2.8, “Universal character sets”. Every character set contains the <space> character (equivalent to
U+0020). An application defines a character set by assigning a new name to a character set from one of the
first two categories. They can be defined to “reside” in any schema chosen by the application. Character sets
defined by standards or by SQL-implementations reside in the Information Schema (named INFORMA-
TION_SCHEMA) in each catalog, as do collations defined by standards and collations, transliterations, and
transcodings defined by SQL-implementations.
NOTE 9 — The Information Schema is defined in ISO/IEC 9075-11.




©ISO/IEC 2003 – All rights reserved                                                                 Concepts 15
ISO/IEC 9075-2:2003 (E)
4.2 Character strings



4.2.2 Comparison of character strings

Two character strings are comparable if and only if either they have the same character set or there exists at
least one collation that is applicable to both their respective character sets.
A collation is defined by ISO/IEC 14651 as “a process by which two strings are determined to be in exactly
one of the relationships of less than, greater than, or equal to one another”. Each collation known in an SQL-
environment is applicable to one or more character sets, and for each character set, one or more collations are
applicable to it, one of which is associated with it as its character set collation.
Anything that has a declared type can, if that type is a character string type, be associated with a collation
applicable to its character set; this is known as a declared type collation. Every declared type that is a character
string type has a collation derivation, this being either none, implicit, or explicit. The collation derivation of a
declared type with a declared type collation that is explicitly or implicitly specified by a <data type> is implicit.
If the collation derivation of a declared type that has a declared type collation is not implicit, then it is explicit.
The collation derivation of an expression of character string type that has no declared type collation is none.
An operation that explicitly or implicitly involves character string comparison is a character comparison
operation. At least one of the operands of a character comparison operation shall have a declared type collation.
There may be an SQL-session collation for some or all of the character sets known to the SQL-implementation
(see Subclause 4.37, “SQL-sessions”).
The collation used for a particular character comparison is specified by Subclause 9.13, “Collation determination”.
The comparison of two character string expressions depends on the collation used for the comparison (see
Subclause 9.13, “Collation determination”). When values of unequal length are compared, if the collation for
the comparison has the NO PAD characteristic and the shorter value is equal to some prefix of the longer value,
then the shorter value is considered less than the longer value. If the collation for the comparison has the PAD
SPACE characteristic, for the purposes of the comparison, the shorter value is effectively extended to the length
of the longer by concatenation of <space>s on the right.
For every character set, there is at least one collation.



4.2.3 Operations involving character strings


4.2.3.1 Operators that operate on character strings and return character strings

<concatenation operator> is an operator, ||, that returns the character string made by joining its character
string operands in the order given.
<character substring function> is a triadic function, SUBSTRING, that returns a string extracted from a given
string according to a given numeric starting position and a given numeric length.
<regular expression substring function> is a triadic function, SUBSTRING, distinguished by the keywords
SIMILAR and UESCAPE. It has three parameters: a source character string, a pattern string, and an escape
character. It returns a result string extracted from the source character string by pattern matching.



16 Foundation (SQL/Foundation)                                                         ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                                           4.2 Character strings



— Step 1: The escape character is exactly one character in length. As indicated in Figure 1, “Operation of
  <regular expression substring function>”, the escape character precedes two instances of <double quote>
  that are used to partition the pattern string into three subpatterns (identified as R1, R2, and R3).
— Step 2: If the source string S does not satisfy the predicate

    'S' SIMILAR TO 'R1' || 'R2' || 'R3'

    then the result is the null value.
— Step 3: Otherwise, S is partitioned into two substrings S1 and S23 such that S1 is the shortest initial substring
  of S such that the following condition is satisfied:

    'S1' SIMILAR TO 'R1' AND
      'S23' SIMILAR TO '(' || 'R2' || 'R3' || ')'

— Step 4: Next, S23 is partitioned into two substrings S2 and S3 such that S3 is the shortest final substring
  such that the following condition is satisfied:

    'S2' SIMILAR TO 'R2' AND 'S3' SIMILAR TO 'R3'

The result of the <regular expression substring function> is S2.




©ISO/IEC 2003 – All rights reserved                                                                  Concepts 17
ISO/IEC 9075-2:2003 (E)
4.2 Character strings




                     Figure 1 — Operation of <regular expression substring function>




<character overlay function> is a function, OVERLAY, that modifies a string argument by replacing a given
substring of the string, which is specified by a given numeric starting position and a given numeric length, with
another string (called the replacement string). When the length of the substring is zero, nothing is removed
from the original string and the string returned by the function is the result of inserting the replacement string
into the original string at the starting position.
<fold> is a pair of functions for converting all the lower case and title case characters in a given string to upper
case (UPPER) or all the upper case and title case characters to lower case (LOWER). A lower case character
is a character in the Unicode General Category class “Ll” (lower-case letters). An upper case character is a



18 Foundation (SQL/Foundation)                                                       ©ISO/IEC 2003 – All rights reserved
                                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                                        4.2 Character strings



character in the Unicode General Category class “Lu” (upper-case letters). A title case character is a character
in the Unicode General Category class “Lt” (title-case letters).
NOTE 10 — Case correspondences are not always one-to-one: the result of case folding may be of a different length in characters than
the source string. For example, U+00DF, “ß”, Latin Small Letter Sharp S, becomes “SS” when folded to upper case.

<transcoding> is a function that invokes an installation-supplied transcoding to return a character string S2
derived from a given character string S1. It is intended, though not enforced by this part of ISO/IEC 9075, that
S2 be exactly the same sequence of characters as S1, but encoded according to some different character
encoding form. A typical use might be to convert a character string from two-octet UCS to one-octet Latin1 or
vice versa.
<trim function> is a function that returns its first string argument with leading and/or trailing pad characters
removed. The second argument indicates whether leading, or trailing, or both leading and trailing pad characters
should be removed. The third argument specifies the pad character that is to be removed.
<character transliteration> is a function for changing each character of a given string according to some many-
to-one or one-to-one mapping between two not necessarily distinct character sets. The mapping, rather than
being specified as part of the function, is some external function identified by a <transliteration name>.
For any pair of character sets, there are zero or more transliterations that may be invoked by a <character
transliteration>. A transliteration is described by a transliteration descriptor. A transliteration descriptor includes:
— The name of the transliteration.
— The name of the character set from which it translates.
— The name of the character set to which it translates.
— The specific name of the SQL-invoked routine that performs the transliteration.



4.2.3.2 Other operators involving character strings

<length expression> returns the length of a given character string, as an exact numeric value, in characters or
octets according to the choice of function.
<position expression> determines the first position, if any, at which one string, S1, occurs within another, S2.
If S1 is of length zero, then it occurs at position 1 (one) for any value of S2. If S1 does not occur in S2, then
zero is returned. The declared type of a <position expression> is exact numeric.
<like predicate> uses the triadic operator LIKE (or the inverse, NOT LIKE), operating on three character strings
and returning a Boolean. LIKE determines whether or not a character string “matches” a given “pattern” (also
a character string). The characters <percent> and <underscore> have special meaning when they occur in the
pattern. The optional third argument is a character string containing exactly one character, known as the “escape
character”, for use when a <percent>, <underscore>, or the “escape character” itself is required in the pattern
without its special meaning.
<similar predicate> uses the triadic operator SIMILAR (or the inverse, NOT SIMILAR), operating on three
character strings and returning a Boolean. SIMILAR determines whether or not a character string “matches”
a given “pattern” (also a character string). The pattern is in the form of a “regular expression”. In this regular
expression, certain characters (<left bracket>, <right bracket>, <left paren>, <right paren>, <vertical bar>,
<circumflex>, <minus sign>, <plus sign>, <asterisk>, <underscore>, <percent>, <question mark>, <left brace>)


©ISO/IEC 2003 – All rights reserved                                                                                 Concepts 19
ISO/IEC 9075-2:2003 (E)
4.2 Character strings



have a special meaning. The optional third argument specifies the “escape character”, for use when one of the
special characters or the “escape character” itself is required in the pattern without its special meaning.



4.2.3.3 Operations involving large object character strings

Large object character strings cannot be operated on by all string operations. Large object character strings can,
however, be operated on by the following operations:
— <null predicate>.
— <like predicate>.
— <similar predicate>.
— <position expression>.
— <comparison predicate> with an <equals operator> or <not equals operator>.
— <quantified comparison predicate> with the <equals operator> or <not equals operator>.
As a result of these restrictions, large object character strings cannot be used in (among other places):
— predicates other than those listed above and the <exists predicate>
— <general set function>.
— <group by clause>.
— <order by clause>.
— <unique constraint definition>.
— <referential constraint definition>.
— <select list> of a <query specification> that has a <set quantifier> of DISTINCT.
— UNION, INTERSECT, and EXCEPT.
— columns used for matching when forming a <joined table>.
All the operations described within Subclause 4.2.3.1, “Operators that operate on character strings and return
character strings”, and Subclause 4.2.3.2, “Other operators involving character strings”, are supported for large
object character strings.



4.2.4 Character repertoires

An SQL-implementation supports one or more character repertoires. These character repertoires may be defined
by a standard or be implementation-defined.
A character repertoire is described by a character repertoire descriptor. A character repertoire descriptor includes:



20 Foundation (SQL/Foundation)                                                       ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                        4.2 Character strings



— The name of the character repertoire.
— The name of the default collation for the character repertoire.
The following character repertoire names are specified as part of ISO/IEC 9075:
— SQL_CHARACTER is a character repertoire that consists of the 88 <SQL language character>s as specified
  in Subclause 5.1, “<SQL terminal character>”. The name of the default collation is SQL_CHARACTER.
— GRAPHIC_IRV is the character repertoire that consists of the 95-character graphic subset of the International
  Reference Version (IRV) as specified in ISO 646:1991. Its repertoire is a proper superset of that of
  SQL_CHARACTER. The name of the default collation is GRAPHIC_IRV.
— LATIN1 is the character repertoire defined in ISO 8859-1. The name of the default collation is LATIN1.
— ISO8BIT is the character repertoires formed by combining the character repertoire specified by ISO 8859-
  1 and the “control characters” specified by ISO 6429. The repertoire consists of all 255 characters, each
  consisting of exactly 8 bits, as, including all control characters and all graphic characters except the char-
  acter corresponding to the numeric value 0 (zero). The name of the default collation is ISO8BIT.
— UCS is the Universal Character Set repertoire specified by The Unicode Standard Version 3.1 and by
  ISO/IEC 10646. It is implementation-defined whether the name of the default collation is UCS_BASIC or
  UNICODE.
— SQL_TEXT is a character repertoire that is an implementation-defined subset of the repertoire of the Uni-
  versal Character Set that includes every <SQL language character> and every character in every character
  set supported by the SQL-implementation. The name of the default collation is SQL_TEXT.
— SQL_IDENTIFIER is a character repertoire consisting of the <SQL language character>s and all other
  characters that the SQL-implementation supports for use in <regular identifier>s. The name of the default
  collation is SQL_IDENTIFIER.



4.2.5 Character encoding forms

An SQL-implementation supports one or more character encoding forms for each character repertoire that it
supports. These character encoding forms may be defined by a standard or be implementation-defined.
A character encoding form is described by a character encoding form descriptor. A character encoding form
descriptor includes:
— The name of the character encoding form.
— The name of the character repertoire to which it is applicable.
The following character encoding form names are specified as part of ISO/IEC 9075:
— SQL_CHARACTER is an implementation-defined character encoding form. It is applicable to the
  SQL_CHARACTER character repertoire.
— GRAPHIC_IRV is the character encoding form in which the coded representation of each character is
  specified in ISO 646:1991. It is applicable to the GRAPHIC_IRV character repertoire.




©ISO/IEC 2003 – All rights reserved                                                               Concepts 21
ISO/IEC 9075-2:2003 (E)
4.2 Character strings



— LATIN1 is the character encoding form specified in ISO 8859-1. It is applicable to the LATIN1 character
  repertoire.
— ISO8BIT is the character encoding form specified in ISO 8859-1, augmented by ISO 6429. When restricted
  to the LATIN1 characters, it is the same character encoding form as LATIN1. It is applicable to the ISO8BIT
  character repertoire.
— UTF32 is the character encoding form specified in the Unicode Standard Annex #19, “UTF-32”, in which
  each character is encoded as four octets. It is applicable to the UCS character repertoire.
— UTF16 is the character encoding form specified in ISO/IEC 10646-1, Annex C (normative), “Transformation
  format for 16 planes of Group 00 (UTF-16)”, in which each character is encoded as two or four octets. It
  is applicable to the UCS character repertoire.
— UTF8 is the character encoding form specified in ISO/IEC 10646-1, Annex D (normative), “UCS Transfor-
  mation Format 8 (UTF-8)”, in which each character is encoded as from one to four octets. It is applicable
  to the UCS character repertoire.
— SQL_TEXT is an implementation-defined character encoding form. It is applicable to the SQL_TEXT
  character repertoire.
— SQL_IDENTIFIER is an implementation-defined character encoding form. It is applicable to the
  SQL_IDENTIFIER character repertoire.
If an SQL-implementation supplies more than one character encoding form for a particular character repertoire,
then it shall specify a precedence ordering of the character encoding forms of that character repertoire. The
precedence of character encoding forms applicable to the UCS character repertoire and defined in this part of
ISO/IEC 9075 is:
  UTF8 ≺ UTF16 ≺ UTF32



4.2.6 Collations

An SQL-implementation supports one or more collations for each character repertoire that it supports, and one
or more collations for each character set that it supports. A collation is described by a collation descriptor. A
collation descriptor includes:
— The name of the collation.
— The name of the character repertoire to which it is applicable.
— A list of the names of the character sets to which the collation can be applied.
— Whether the collation has the NO PAD or the PAD SPACE characteristic.
The supported collation names are specified as part of ISO/IEC 9075:
— SQL_CHARACTER is an implementation-defined collation. It is applicable to the SQL_CHARACTER
  character repertoire.
— GRAPHIC_IRV is a collation in which the ordering is determined by treating the code points defined by
  ISO 646:1991 as unsigned integers. It is applicable to the GRAPHIC_IRV character repertoire.



22 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                                                       4.2 Character strings



— LATIN1 is a collation in which the ordering is determined by treating the code points defined by ISO 8859-
  1 as unsigned integers. It is applicable to the LATIN1 character repertoire.
— ISO8BIT is a collation in which the ordering is determined by treating the code points defined by ISO
  8859-1 as unsigned integers. When restricted to the LATIN1 characters, it produces the same collation as
  LATIN1. It is applicable to the ISO8BIT character repertoire.
— UCS_BASIC is a collation in which the ordering is determined entirely by the Unicode scalar values of
  the characters in the strings being sorted. It is applicable to the UCS character repertoire. Since every
  character repertoire is a subset of the UCS repertoire, the UCS_BASIC collation is potentially applicable
  to every character set.
    NOTE 11 — The Unicode scalar value of a character is its code point treated as an unsigned integer.

— UNICODE is the collation in which the ordering is determined by applying the Unicode Collation Algorithm
  with the Default Unicode Collation Element Table, as specified in [Unicode10]. It is applicable to the UCS
  character repertoire. Since every character repertoire is a subset of the UCS repertoire, the UNICODE
  collation is potentially applicable to every character set.
— SQL_TEXT is an implementation-defined collation. It is applicable to the SQL_TEXT character repertoire.
— SQL_IDENTIFIER is an implementation-defined collation. It is applicable to the SQL_IDENTIFIER
  character repertoire.



4.2.7 Character sets

An SQL <character set specification> allows a reference to a character set name defined by a standard, an SQL-
implementation, or a user.
A character set is described by a character set descriptor. A character set descriptor includes:
— The name of the character set.
— The name of the character repertoire for the character set.
— The name of the character encoding form for the character set.
— The name of the default collation for the character set.
The following SQL supported character set names are specified as part of ISO/IEC 9075:
— SQL_CHARACTER is a character set whose repertoire is SQL_CHARACTER and whose character
  encoding form is SQL_CHARACTER. The name of its default collation is SQL_CHARACTER.
— GRAPHIC_IRV is a character set whose repertoire is GRAPHIC_IRV and whose character encoding form
  is GRAPHIC_IRV. The name of its default collation is GRAPHIC_IRV.
— ASCII_GRAPHIC is a synonym for GRAPHIC_IRV.
— LATIN1 is a character set whose repertoire is LATIN1 and whose character encoding form is LATIN1.
  The name of its default collation is LATIN1.




©ISO/IEC 2003 – All rights reserved                                                                            Concepts 23
ISO/IEC 9075-2:2003 (E)
4.2 Character strings



— ISO8BIT is a character set whose repertoire is ISO8BIT and whose character encoding form is ISO8BIT.
  The name of its default collation is ISO8BIT.
— ASCII_FULL is a synonym for ISO8BIT.
— UTF32 is a character set whose repertoire is UCS and whose character encoding form is UTF32. It is
  implementation-defined whether the name of its default collation is UCS_BASIC or UNICODE.
— UTF16 is a character set whose repertoire is UCS and whose character encoding form is UTF16. It is
  implementation-defined whether the name of its default collation is UCS_BASIC or UNICODE.
— UTF8 is the name of a character set whose repertoire is UCS and whose character encoding form is UTF8.
  It is implementation-defined whether the name of its default collation is UCS_BASIC or UNICODE.
— SQL_TEXT is a character set whose repertoire is SQL_TEXT and whose character encoding form is
  SQL_TEXT. The name of its default collation is SQL_TEXT.
— SQL_IDENTIFIER is a character set whose repertoire is SQL_IDENTIFIER and whose character encoding
  form is SQL_IDENTIFIER. The name of its default collation is SQL_IDENTIFIER.
   The result of evaluating a character string expression whose most specific type has character set CS is
   constrained to consist of characters drawn from the character repertoire of CS.

                                 Table 1 — Overview of character sets


 Character Set     Character           Character           Collation           Synonym
                   Repertoire          Encoding Form

 GRAPHIC_IRV       GRAPHIC_IRV         GRAPHIC_IRV         GRAPHIC_IRV         ASCII_GRAPHIC

 ISO8BIT           ISO8BIT             ISO8BIT             ISO8BIT             ASCII_FULL

 LATIN1            LATIN1              LATIN1              LATIN1

 SQL_CHARAC- SQL_CHARAC- SQL_CHARAC- SQL_CHARAC-
 TER         TER         TER         TER

 SQL_TEXT          SQL_TEXT            SQL_TEXT            SQL_TEXT

 SQL-IDENTI-       SQL-IDENTI-         SQL-IDENTI-         SQL-IDENTI-
 FIER              FIER                FIER                FIER

 UTF16             UCS                 UTF16               UCS_BASIC or
                                                           UNICODE

 UTF32             UCS                 UTF32               UCS_BASIC or
                                                           UNICODE

 UTF8              UCS                 UTF8                UCS_BASIC or
                                                           UNICODE




24 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                                 ISO/IEC 9075-2:2003 (E)
                                                                                                   4.2 Character strings



NOTE 12 — An SQL-implementation may supply additional character sets and/or additional character encoding forms and collations
for character sets defined in this Part of ISO/IEC 9075.



4.2.8 Universal character sets

A UCS string is a character string whose character repertoire is UCS and whose character encoding form is
one of UTF8, UTF16, or UTF32. Any two UCS strings are comparable.
An SQL-implementation may assume that all UCS strings are normalized in Normalization Form C (NFC), as
specified by [Unicode15]. With the exception of <normalize function> and <normalized predicate>, the result
of any operation on an unnormalized UCS string is implementation-defined.
Conversion of UCS strings from one character set to another is automatic.
Detection of a noncharacter in a UCS-string causes an exception condition to be raised. The detection of an
unassigned code point does not.



4.3      Binary strings


4.3.1 Introduction to binary strings

A binary string is a sequence of octets that does not have either a character set or collation associated with it.
A binary string data type is described by a binary string data type descriptor. A binary string data type
descriptor contains:
— The name of the data type (BINARY LARGE OBJECT).
— The maximum length of the binary string data type (in octets).
A binary string is assignable only to sites of data type BINARY LARGE OBJECT. If a store assignment would
result in the loss of non-zero octets due to truncation, then an exception condition is raised. If a retrieval
assignment would result in the loss of octets due to truncation, then a warning condition is raised.



4.3.2 Binary string comparison

All binary string values are comparable. When binary string values are compared, they shall have exactly the
same length (in octets) to be considered equal. Binary string values can be compared only for equality.




©ISO/IEC 2003 – All rights reserved                                                                            Concepts 25
ISO/IEC 9075-2:2003 (E)
4.3 Binary strings



4.3.3 Operations involving binary strings


4.3.3.1 Operators that operate on binary strings and return binary strings

<blob concatenation> is an operator, ||, that returns a binary string by joining its binary string operands in the
order given.
<blob substring function> is a triadic function identical in syntax and semantics to <character substring function>
except that the returned value is a binary string.
<blob overlay function> is a function identical in syntax and semantics to <character overlay function> except
that the first argument, second argument, and returned value are all binary strings.
<trim function> when applied to binary strings is identical in syntax (apart from the default <trim character>)
and semantics to the corresponding operation on character strings except that the returned value is a binary
string.



4.3.3.2 Other operators involving binary strings

<length expression> returns the length of a given binary string, as an exact numeric value, in characters or
octets according to the choice of function.
<position expression> when applied to binary strings is identical in syntax and semantics to the corresponding
operation on character strings except that the operands are binary strings.
<like predicate> when applied to binary strings is identical in syntax and semantics to the corresponding oper-
ation on character strings except that the operands are binary strings.
Binary strings cannot be used in:
— Predicates other than <comparison predicate> with an <equals operator> or a <not equals operator>,
  <quantified comparison predicate> with an <equals operator> or a <not equals operator>, and <exists
  predicate>.
— <general set function>.
— <group by clause>.
— <order by clause>.
— <unique constraint definition>.
— <select list> of a <query specification> that has a <set quantifier> of DISTINCT.
— UNION, INTERSECT, and EXCEPT.
— Columns used for matching when forming a <joined table>.




26 Foundation (SQL/Foundation)                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                                    4.4 Numbers



4.4      Numbers


4.4.1 Introduction to numbers

A number is either an exact numeric value or an approximate numeric value. Any two numbers are comparable.
A numeric type is described by a numeric type descriptor. A numeric type descriptor contains:
— The name of the specific numeric type (NUMERIC, DECIMAL, SMALLINT, INTEGER, BIGINT, FLOAT,
  REAL, or DOUBLE PRECISION).
— The precision of the numeric type.
— The scale of the numeric type, if it is an exact numeric type.
— An indication of whether the precision (and scale) are expressed in decimal or binary terms.
An SQL-implementation is permitted to regard certain <exact numeric type>s as equivalent, if they have the
same precision, scale, and radix, as permitted by the Syntax Rules of Subclause 6.1, “<data type>”. When two
or more <exact numeric type>s are equivalent, the SQL-implementation chooses one of these equivalent <exact
numeric type>s as the normal form representing that equivalence class of <exact numeric type>s. The normal
form determines the name of the exact numeric type in the numeric type descriptor.
Similarly, an SQL-implementation is permitted to regard certain <approximate numeric type>s as equivalent,
as permitted the Syntax Rules of Subclause 6.1, “<data type>”, in which case the SQL-implementation chooses
a normal form to represent each equivalence class of <approximate numeric type> and the normal form deter-
mines the name of the approximate numeric type.
For every numeric type, the least value is less than zero and the greatest value is greater than zero.



4.4.2 Characteristics of numbers

An exact numeric type has a precision P and a scale S. P is a positive integer that determines the number of
significant digits in a particular radix R, where R is either 2 or 10. S is a non-negative integer. Every value of
an exact numeric type of scale S is of the form n × 10–S, where n is an integer such that –RP ≤ n < RP.
NOTE 13 — Not every value in that range is necessarily a value of the type in question.

An approximate numeric value consists of a mantissa and an exponent. The mantissa is a signed numeric value,
and the exponent is a signed integer that specifies the magnitude of the mantissa. An approximate numeric
value has a precision. The precision is a positive integer that specifies the number of significant binary digits
in the mantissa. The value of an approximate numeric value is the mantissa multiplied by a factor determined
by the exponent.
An <approximate numeric literal> ANL consists of an <exact numeric literal> (called the <mantissa>), the letter
'E' or 'e', and a <signed integer> (called the <exponent>). If M is the value of the <mantissa> and E is the value
of the <exponent>, then M * 10E is the apparent value of ANL. The actual value of ANL is approximately the
apparent value of ANL, according to implementation-defined rules.


©ISO/IEC 2003 – All rights reserved                                                                  Concepts 27
ISO/IEC 9075-2:2003 (E)
4.4 Numbers



A number is assignable only to sites of numeric type. If an assignment of some number would result in a loss
of its most significant digit, an exception condition is raised. If least significant digits are lost, implementation-
defined rounding or truncating occurs, with no exception condition being raised. The rules for arithmetic are
specified in Subclause 6.26, “<numeric value expression>”.
Whenever an exact or approximate numeric value is assigned to an exact numeric value site, an approximation
of its value that preserves leading significant digits after rounding or truncating is represented in the declared
type of the target. The value is converted to have the precision and scale of the target. The choice of whether
to truncate or round is implementation-defined.
An approximation obtained by truncation of a numeric value N for an <exact numeric type> T is a value V in
T such that N is not closer to zero than is V and there is no value in T between V and N.
An approximation obtained by rounding of a numeric value N for an <exact numeric type> T is a value V in T
such that the absolute value of the difference between N and the numeric value of V is not greater than half the
absolute value of the difference between two successive numeric values in T. If there is more than one such
value V, then it is implementation-defined which one is taken.
All numeric values between the smallest and the largest value, inclusive, in a given exact numeric type have
an approximation obtained by rounding or truncation for that type; it is implementation-defined which other
numeric values have such approximations.
An approximation obtained by truncation or rounding of a numeric value N for an <approximate numeric type>
T is a value V in T such that there is no numeric value in T and distinct from that of V that lies between the
numeric value of V and N, inclusive.
If there is more than one such value V then it is implementation-defined which one is taken. It is implementation-
defined which numeric values have approximations obtained by rounding or truncation for a given approximate
numeric type.
Whenever an exact or approximate numeric value is assigned to an approximate numeric value site, an
approximation of its value is represented in the declared type of the target. The value is converted to have the
precision of the target.
Operations on numbers are performed according to the normal rules of arithmetic, within implementation-
defined limits, except as provided for in Subclause 6.26, “<numeric value expression>”.



4.4.3 Operations involving numbers

As well as the usual arithmetic operators, plus, minus, times, divide, unary plus, and unary minus, there are the
following functions that return numbers:
— <position expression> (see Subclause 4.2.3, “Operations involving character strings”, and Subclause 4.3.3,
  “Operations involving binary strings”) takes two strings as arguments and returns an integer.
— <length expression> (see Subclause 4.2.3, “Operations involving character strings”, and Subclause 4.3.3,
  “Operations involving binary strings”) operates on a string argument and returns an integer.
— <extract expression> (see Subclause 4.6.4, “Operations involving datetimes and intervals”) operates on a
  datetime or interval argument and returns an exact numeric.



28 Foundation (SQL/Foundation)                                                        ©ISO/IEC 2003 – All rights reserved
                                                                                                ISO/IEC 9075-2:2003 (E)
                                                                                                          4.4 Numbers



— <cardinality expression> (see Subclause 4.10.5, “Operations involving arrays”, and Subclause 4.10.6,
  “Operations involving multisets”) operates on a collection argument and returns an integer.
— <absolute value expression> operates on a numeric argument and returns its absolute value in the same
  most specific type.
— <modulus expression> operates on two exact numeric arguments with scale 0 (zero) and returns the modulus
  (remainder) of the first argument divided by the second argument as an exact numeric with scale 0 (zero).
— <natural logarithm> computes the natural logarithm of its argument.
— <exponential function> computes the exponential function, that is, e, (the base of natural logarithms) raised
  to the power equal to its argument.
— <power function> raises its first argument to the power of its second argument.
— <square root> computes the square root of its argument.
— <floor function> computes the greatest integer less than or equal to its argument.
— <ceiling function> computes the least integer greater than or equal to its argument.
— <width bucket function> is a function of four arguments, returning an integer between 0 (zero) and the
  value of the final argument plus 1 (one), by assigning the first argument to an equi-width partitioning of
  the range of numbers between the second and third arguments. Values outside the range between the second
  and third arguments are assigned to either 0 (zero) or the value of the final argument plus 1 (one).
    NOTE 14 — The semantics of <width bucket function> are illustrated in Figure 2, “Illustration of WIDTH_BUCKET Semantics”.

                                Figure 2 — Illustration of WIDTH_BUCKET Semantics




©ISO/IEC 2003 – All rights reserved                                                                           Concepts 29
ISO/IEC 9075-2:2003 (E)
4.5 Boolean types



4.5     Boolean types


4.5.1 Introduction to Boolean types

The data type boolean comprises the distinct truth values True and False. Unless prohibited by a NOT NULL
constraint, the boolean data type also supports the truth value Unknown as the null value. This specification
does not make a distinction between the null value of the boolean data type and the truth value Unknown that
is the result of an SQL <predicate>, <search condition>, or <boolean value expression>; they may be used
interchangeably to mean exactly the same thing.
The boolean data type is described by the boolean data type descriptor. The boolean data type descriptor contains:
— The name of the boolean data type (BOOLEAN).



4.5.2 Comparison and assignment of booleans

All boolean values and SQL truth values are comparable and all are assignable to a site of type boolean. The
value True is greater than the value False, and any comparison involving the null value or an Unknown truth
value will return an Unknown result. The values True and False may be assigned to any site having a boolean
data type; assignment of Unknown, or the null value, is subject to the nullability characteristic of the target.



4.5.3 Operations involving booleans


4.5.3.1 Operations on booleans that return booleans

The monadic boolean operator NOT and the dyadic boolean operators AND and OR take boolean operands
and produce a boolean result (see Table 11, “Truth table for the AND boolean operator”, and Table 12, “Truth
table for the OR boolean operator”).



4.5.3.2 Other operators involving booleans

Every SQL <predicate>, <search condition>, and <boolean value expression> may be considered as an operator
that returns a boolean result.




30 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                     4.6 Datetimes and intervals



4.6      Datetimes and intervals


4.6.1 Introduction to datetimes and intervals

A datetime data type is described by a datetime data type descriptor. An interval data type is described by an
interval data type descriptor.
A datetime data type descriptor contains:
— The name of the specific datetime data type (DATE, TIME WITHOUT TIME ZONE, TIMESTAMP
  WITHOUT TIME ZONE, TIME WITH TIME ZONE, or TIMESTAMP WITH TIME ZONE).
— The value of the <time fractional seconds precision>, if it is a TIME WITHOUT TIME ZONE, TIMESTAMP
  WITHOUT TIME ZONE, TIME WITH TIME ZONE, or TIMESTAMP WITH TIME ZONE type.
An interval data type descriptor contains:
— The name of the interval data type (INTERVAL).
— An indication of whether the interval data type is a year-month interval or a day-time interval.
— The <interval qualifier> that describes the precision of the interval data type.
A value described by an interval data type descriptor is always signed.
Every datetime or interval data type has an implied length in positions. Let D denote a value in some datetime
or interval data type DT. The length in positions of DT is constant for all D. The length in positions is the
number of characters from the character set SQL_TEXT that it would take to represent any value in a given
datetime or interval data type.
An approximation obtained by rounding of a datetime or interval value D for a <datetime type> or <interval
type> T is a value V in T such that the absolute value of the difference between D and the numeric value of V
is not greater than half the absolute value of the difference between two successive datetime or interval values
in T. If there is more than one such value V, then it is implementation-defined which one is taken.



4.6.2 Datetimes

Table 2, “Fields in datetime values”, specifies the fields that can make up a datetime value; a datetime value
is made up of a subset of those fields. Not all of the fields shown are required to be in the subset, but every
field that appears in the table between the first included primary field and the last included primary field shall
also be included. If either time zone field is in the subset, then both of them shall be included.




©ISO/IEC 2003 – All rights reserved                                                                 Concepts 31
ISO/IEC 9075-2:2003 (E)
4.6 Datetimes and intervals




                                    Table 2 — Fields in datetime values


 Keyword                    Meaning

 YEAR                       Year

 MONTH                      Month within year

 DAY                        Day within month

 HOUR                       Hour within day

 MINUTE                     Minute within hour

 SECOND                     Second and possibly fraction of a second within minute

 TIMEZONE_HOUR              Hour value of time zone displacement

 TIMEZONE_MINUTE Minute value of time zone displacement

There is an ordering of the significance of <primary datetime field>s. This is, from most significant to least
significant: YEAR, MONTH, DAY, HOUR, MINUTE, and SECOND.
The <primary datetime field>s other than SECOND contain non-negative integer values, constrained by the
natural rules for dates using the Gregorian calendar. SECOND, however, can be defined to have a <time fractional
seconds precision> that indicates the number of decimal digits maintained following the decimal point in the
seconds value, a non-negative exact numeric value.
There are three classes of datetime data types defined within this part of ISO/IEC 9075:
— DATE — contains the <primary datetime field>s YEAR, MONTH, and DAY.
— TIME — contains the <primary datetime field>s HOUR, MINUTE, and SECOND.
— TIMESTAMP — contains the <primary datetime field>s YEAR, MONTH, DAY, HOUR, MINUTE, and
  SECOND.
Items of type datetime are comparable only if they have the same <primary datetime field>s.
A datetime data type that specifies WITH TIME ZONE is a data type that is datetime with time zone, while a
datetime data type that specifies WITHOUT TIME ZONE is a data type that is datetime without time zone.
The surface of the earth is divided into zones, called time zones, in which every correct clock tells the same
time, known as local time. Local time is equal to UTC (Coordinated Universal Time) plus the time zone dis-
placement, which is an interval value that ranges between INTERVAL '–12:59' HOUR TO MINUTE and
INTERVAL '+14:00' HOUR TO MINUTE. The time zone displacement is constant throughout a time zone,
changing at the beginning and end of Daylight Time, where applicable.
A datetime value, of data type TIME WITHOUT TIME ZONE or TIMESTAMP WITHOUT TIME ZONE,
may represent a local time, whereas a datetime value of data type TIME WITH TIME ZONE or TIMESTAMP
WITH TIME ZONE represents UTC.


32 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                   4.6 Datetimes and intervals



On occasion, UTC is adjusted by the omission of a second or the insertion of a “leap second” in order to
maintain synchronization with sidereal time. This implies that sometimes, but very rarely, a particular minute
will contain exactly 59, 61, or 62 seconds. Whether an SQL-implementation supports leap seconds, and the
consequences of such support for date and interval arithmetic, is implementation-defined.
For the convenience of users, whenever a datetime value with time zone is to be implicitly derived from one
without (for example, in a simple assignment operation), SQL assumes the value without time zone to be local,
subtracts the current default time zone displacement of the SQL-session from it to give UTC, and associates
that time zone displacement with the result.
Conversely, whenever a datetime value without time zone is to be implicitly derived from one with, SQL
assumes the value with time zone to be UTC, adds the time zone displacement to it to give local time, and the
result, without any time zone displacement, is local.
The preceding principles, as implemented by <cast specification>, result in data type conversions between the
various datetime data types, as summarized in Table 3, “Datetime data type conversions”.

                                      Table 3 — Datetime data type conversions


                     to DATE             to TIME         to TIME         to                to
                                         WITHOUT         WITH TIME       TIMESTAMP         TIMESTAMP
                                         TIME ZONE       ZONE            WITHOUT           WITH TIME
                                                                         TIME ZONE         ZONE

 from DATE           trivial             not supported   not supported   Copy year,      SV ⇒ TSw/oTZ
                                                                         month, and day;
                                                                         set hour,       ⇒ TSw/TZ
                                                                         minute, and
                                                                         second to 0
                                                                         (zero)

 from TIME not supported                 trivial         TV.UTC = SV –   Copy date         SV ⇒ TSw/oTZ
 WITHOUT                                                 STZD (modulo    fields from
 TIME ZONE                                               24); TV.TZ =    CUR-              ⇒ TSw/TZ
                                                         STZD            RENT_DATE
                                                                         and time fields
                                                                         from SV

 from TIME not supported                 SV.UTC +        trivial         SV ⇒ TSw/TZ       Copy date
 WITH TIME                               SV.TZ (modulo                                     fields from
 ZONE                                    24)                             ⇒ TSwo/TZ         CUR-
                                                                                           RENT_DATE
                                                                                           and time and
                                                                                           time zone fields
                                                                                           from SV




©ISO/IEC 2003 – All rights reserved                                                               Concepts 33
ISO/IEC 9075-2:2003 (E)
4.6 Datetimes and intervals



                    to DATE               to TIME              to TIME               to                    to
                                          WITHOUT              WITH TIME             TIMESTAMP             TIMESTAMP
                                          TIME ZONE            ZONE                  WITHOUT               WITH TIME
                                                                                     TIME ZONE             ZONE

 from      Copy date                      Copy time            SV ⇒ TSw/TZ           trivial               TV.UTC = SV –
 TIMES-    fields from SV                 fields from SV                                                   STZD; TV.TZ =
 TAMP                                                          ⇒ TIMEw/TZ                                  STZD
 WITHOUT
 TIME ZONE

 from      SV ⇒ TSw/oTZ SV ⇒ TSw/oTZ Copy time and SV.UTC +                                                trivial
 TIMES-                              time zone fields SV.TZ
 TAMP      ⇒ DATE       ⇒ TIMEw/oTZ from SV
 WITH TIME
 ZONE
 †
   Where SV is the source value, TV is the target value, .UTC is the UTC component of SV or TV (if and only if the source or
 target has time zone), STZD is the SQL-session default time zone displacement, ⇒ means to cast from the type preceding the
 arrow to the type following the arrow, “TIMEw/TZ” is “TIME WITH TIME ZONE”, “TIMEw/oTZ” is “TIME WITHOUT
 TIME ZONE”, “TSw/TZ” is “TIMESTAMP WITH TIME ZONE”, and “TSw/oTZ” is “TIMESTAMP WITHOUT TIME
 ZONE”.


A datetime is assignable to a site only if the source and target of the assignment are both of type DATE, or both
of type TIME (regardless whether WITH TIME ZONE or WITHOUT TIME ZONE is specified or implicit),
or both of type TIMESTAMP (regardless whether WITH TIME ZONE or WITHOUT TIME ZONE is specified
or implicit).



4.6.3 Intervals

There are two classes of intervals. One class, called year-month intervals, has an express or implied datetime
precision that includes no fields other than YEAR and MONTH, though not both are required. The other class,
called day-time intervals, has an express or implied interval precision that can include any fields other than
YEAR or MONTH.
Table 4, “Fields in year-month INTERVAL values”, specifies the fields that make up a year-month interval.
A year-month interval is made up of a contiguous subset of those fields.

                                Table 4 — Fields in year-month INTERVAL values


 Keyword            Meaning

 YEAR               Years

 MONTH              Months




34 Foundation (SQL/Foundation)                                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                     4.6 Datetimes and intervals



Table 5, “Fields in day-time INTERVAL values”, specifies the fields that make up a day-time interval. A day-
time interval is made up of a contiguous subset of those fields.

                                  Table 5 — Fields in day-time INTERVAL values


 Keyword             Meaning

 DAY                 Days

 HOUR                Hours

 MINUTE              Minutes

 SECOND              Seconds and possibly fractions of a second

The actual subset of fields that comprise a value of either type of interval is defined by an <interval qualifier>
and this subset is known as the precision of the value.
Within a value of type interval, the first field is constrained only by the <interval leading field precision> of
the associated <interval qualifier>. Table 6, “Valid values for fields in INTERVAL values”, specifies the con-
straints on subsequent field values.

                              Table 6 — Valid values for fields in INTERVAL values


 Keyword             Valid values of INTERVAL fields

 YEAR                Unconstrained except by <interval leading field precision>

 MONTH               Months (within years) (0-11)


 DAY                 Unconstrained except by <interval leading field precision>

 HOUR                Hours (within days) (0-23)

 MINUTE              Minutes (within hours) (0-59)

 SECOND              Seconds (within minutes) (0-59.999...)

Values in interval fields other than SECOND are integers and have precision 2 when not the first field. SECOND,
however, can be defined to have an <interval fractional seconds precision> that indicates the number of decimal
digits maintained following the decimal point in the seconds value. When not the first field, SECOND has a
precision of 2 places before the decimal point.
Fields comprising an item of type interval are also constrained by the definition of the Gregorian calendar.
Year-month intervals are comparable only with other year-month intervals. If two year-month intervals have
different interval precisions, they are, for the purpose of any operations between them, effectively converted


©ISO/IEC 2003 – All rights reserved                                                                 Concepts 35
ISO/IEC 9075-2:2003 (E)
4.6 Datetimes and intervals



to the same precision by appending new <primary datetime field>s to either the most significant end of one
interval, the least significant end of one interval, or both. New least significant <primary datetime field>s are
assigned a value of 0 (zero). When it is necessary to add new most significant datetime fields, the associated
value is effectively converted to the new precision in a manner obeying the natural rules for dates and times
associated with the Gregorian calendar.
Day-time intervals are comparable only with other day-time intervals. If two day-time intervals have different
interval precisions, they are, for the purpose of any operations between them, effectively converted to the same
precision by appending new <primary datetime field>s to either the most significant end of one interval or the
least significant end of one interval, or both. New least significant <primary datetime field>s are assigned a
value of 0 (zero). When it is necessary to add new most significant datetime fields, the associated value is
effectively converted to the new precision in a manner obeying the natural rules for dates and times associated
with the Gregorian calendar.



4.6.4 Operations involving datetimes and intervals

Table 7, “Valid operators involving datetimes and intervals”, specifies the declared types of arithmetic
expressions involving datetime and interval operands.

                       Table 7 — Valid operators involving datetimes and intervals


 Operand 1        Operator         Operand 2         Result Type

 Datetime         –                Datetime          Interval

 Datetime         + or –           Interval          Datetime

 Interval         +                Datetime          Datetime

 Interval         + or –           Interval          Interval

 Interval         * or /           Numeric           Interval

 Numeric          *                Interval          Interval

Arithmetic operations involving values of type datetime or interval obey the natural rules associated with dates
and times and yield valid datetime or interval results according to the Gregorian calendar.
Operations involving values of type datetime require that the datetime values be comparable. Operations
involving values of type interval require that the interval values be comparable.
Operations involving a datetime and an interval preserve the time zone of the datetime operand. If the datetime
operand does not include a time zone displacement, then the result has no time zone displacement.
<overlaps predicate> uses the operator OVERLAPS to determine whether or not two chronological periods
overlap in time. A chronological period is specified either as a pair of datetimes (starting and ending) or as a
starting datetime and an interval. If the length of the period is greater than 0 (zero), then the period consists of



36 Foundation (SQL/Foundation)                                                       ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)
                                                                                        4.6 Datetimes and intervals



all points of time greater than or equal to the lower endpoint, and less than the upper endpoint. If the length of
the period is equal to 0 (zero), then the period consists of a single point in time, the lower endpoint. Two periods
overlap if they have at least one point in common.
<extract expression> operates on a datetime or interval and returns an exact numeric value representing the
value of one component of the datetime or interval.
<interval absolute value function> operates on an interval argument and returns its absolute value in the same
most specific type.



4.7      User-defined types


4.7.1 Introduction to user-defined types

A user-defined type is a schema object, identified by a <user-defined type name>. The definition of a user-
defined type specifies a representation for values of that type. In some cases, known as distinct types, the rep-
resentation is a single predefined type, known as the source type; in others, structured types, it consists of a list
of attribute definitions. Although the attribute definitions are said to define the representation of the user-defined
type, in fact they implicitly define certain functions (observers and mutators) that are part of the interface of
the user-defined type; physical representations of user-defined type values are implementation-dependent.
The definition of a user-defined type may include a <method specification list> consisting of one or more
<method specification>s. A <method specification> is either an <original method specification> or an <over-
riding method specification> (in which case the type being defined must be a structured type). Each <original
method specification> specifies:
— The <method name>.
— The <specific method name>.
— The <SQL parameter declaration list>.
— The <returns data type>.
— The <result cast from type> (if any).
— Whether the method is type-preserving.
— The <language clause>.
— If the language is not SQL, then the <parameter style>.
— Whether STATIC or CONSTRUCTOR is specified.
— Whether the method is deterministic.
— Whether the method possibly modifies SQL-data, possibly reads SQL-data, possibly contains SQL, or does
  not possibly contain SQL.




©ISO/IEC 2003 – All rights reserved                                                                     Concepts 37
ISO/IEC 9075-2:2003 (E)
4.7 User-defined types



— Whether the method should be evaluated as the null value whenever any argument is the null value, without
  actually invoking the method.
Each <overriding method specification> specifies the <method name>, the <specific method name>, the <SQL
parameter declaration list> and the <returns data type>. For each <overriding method specification>, there shall
be an <original method specification> with the same <method name> and <SQL parameter declaration list>
in some proper supertype of the user-defined type. Every SQL-invoked method in a schema shall correspond
to exactly one <original method specification> or <overriding method specification> associated with some
user-defined type existing in that schema.
A method M that corresponds to an <original method specification> in the definition of a structured type T1 is
an original method of T1. A method M that corresponds to an <overriding method specification> in the definition
of T1 is an overriding method of T1.
A method M is a method of type T1 if one of the following holds:
— M is an original method of T1.
— M is an overriding method of T1.
— There is a proper supertype T2 of T1 such that M is an original or overriding method of T2 and such that
  there is no method M3 such that M3 has the same <method name> and <SQL parameter declaration list>
  as M and M3 is an original method or overriding method of a type T3 such that T2 is a proper supertype of
  T3 and T3 is a supertype of T1.
If T1 is a subtype of T2 and M1 is a method of T1 such that there exists a method M2 of T2 such that M1 and
M2 have the same <method name> and the same unaugmented <SQL parameter declaration list>, then M1 is
an inherited method of T1 from T2.



4.7.2 User-defined type descriptor

A user-defined type is described by a user-defined type descriptor. A user-defined type descriptor contains:
— The name of the user-defined type (<user-defined type name>). This is the type designator of that type,
  used in type precedence lists (see Subclause 9.5, “Type precedence list determination”).
— An indication of whether the user-defined type is a structured type or a distinct type.
— The ordering form for the user-defined type (EQUALS, FULL, or NONE).
— The ordering category for the user-defined type (RELATIVE, MAP, or STATE).
— A <specific routine designator> identifying the ordering function, depending on the ordering category.
— If the user-defined type is a direct subtype of another user-defined type, then the name of that user-defined
  type.
— If the representation is a predefined data type, then the descriptor of that type; otherwise the attribute
  descriptor of every originally-defined attribute and every inherited attribute of the user-defined type.
— An indication of whether the user-defined type is instantiable or not instantiable.
— An indication of whether the user-defined type is final or not final.


38 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                                        4.7 User-defined types



— The transform descriptor of the user-defined type.
— If the user-defined type is a structured type, then:
    •    Whether the referencing type of the structured type has a user-defined representation, a derived repre-
         sentation, or a system-defined representation.
    •    If user-defined representation is specified, then the type descriptor of the representation type of the
         referencing type of the structured type; otherwise, if derived representation is specified, then the list
         of attributes.
    NOTE 15 — “user-defined representation”, “derived representation”, and “system-defined representation” of a reference type are
    defined in Subclause 4.9, “Reference types”.

— If the <method specification list> is specified, then for each <method specification> contained in <method
  specification list>, a method specification descriptor that includes:
    •    The <method name>.
    •    The <specific method name>.
    •    The <SQL parameter declaration list> augmented to include the implicit first parameter with parameter
         name SELF.
    •    The <language name>.
    •    If the <language name> is not SQL, then the <parameter style>.
    •    The <returns data type>.
    •    The <result cast from type>, if any.
    •    An indication as to whether the <method specification> is an <original method specification> or an
         <overriding method specification>.
    •    If the <method specification> is an <original method specification>, then an indication of whether
         STATIC or CONSTRUCTOR is specified.
    •    An indication whether the method is deterministic.
    •    An indication whether the method possibly modifies SQL-data, possibly reads SQL-data, possibly
         contains SQL, or does not possibly contain SQL.
    •    An indication whether the method should not be invoked if any argument is the null value, in which
         case the value of the method is the null value.
    NOTE 16 — The characteristics of an <overriding method specification> other than the <method name>, <SQL parameter decla-
    ration list>, and <returns data type> are the same as the characteristics for the corresponding <original method specification>.



4.7.3 Observers and mutators

Corresponding to every attribute of every structured type is exactly one implicitly-defined observer function
and exactly one implicitly-defined mutator function. These are both SQL-invoked functions. Further, the
mutator function is a type-preserving function.



©ISO/IEC 2003 – All rights reserved                                                                                 Concepts 39
ISO/IEC 9075-2:2003 (E)
4.7 User-defined types



Let A be the name of an attribute of structured type T and let AT be the data type of A. The signature of the
observer function for this attribute is FUNCTION A(T) and its result data type is AT. The signature of the
mutator function for this attribute is FUNCTION A(T RESULT, AT) and its result data type is T.
Let V be a value in data type T and let AV be a value in data type AT. The invocation A(V,AV) returns MV such
that “A(MV) is identical to AV” and for every attribute A' (A' ≠ A) of T, “A'(MV) is identical to A'(V)”. The most
specific type of MV is the most specific type of V.



4.7.4 Constructors

Associated with each structured type ST is one implicitly defined constructor function, if and only if ST is
instantiable.
Let TN be the name of a structured type T. The signature of the constructor function for T is TN() and its result
data type is T. The invocation TN() returns a value V such that V is not null and, for every attribute A of T, A(V)
returns the default value of A. The most specific type of V is T.
For every structured type ST that is instantiable, zero or more SQL-invoked constructor methods can be specified.
The names of those methods shall be equivalent to the name of the type for which they are specified.
NOTE 17 — SQL-invoked constructor methods are original methods that cannot be overloaded. An SQL-invoked constructor method
and a regular SQL-invoked function may exist such that they have equivalent routine names, the types of the first parameter of the
method's augmented parameter list and the function's parameter list are the same, and the types of the corresponding remaining
parameters (if any) are identical according to the Syntax Rules of Subclause 9.16, “Data type identity”.



4.7.5 Subtypes and supertypes

As a consequence of the <subtype clause> of <user-defined type definition>, two structured types Ta and Tb
that are not compatible can be such that Ta is a subtype of Tb. See Subclause 11.41, “<user-defined type defini-
tion>”.
A type Ta is a direct subtype of a type Tb if Ta is a proper subtype of Tb and there does not exist a type Tc such
that Tc is a proper subtype of Tb and a proper supertype of Ta.

A type Ta is a subtype of type Tb if one of the following pertains:

— Ta and Tb are compatible;

— Ta is a direct subtype of Tb; or

— Ta is a subtype of some type Tc and Tc is a direct subtype of Tb.

By the same token, Tb is a supertype of Ta and is a direct supertype of Ta in the particular case where Ta is a
direct subtype of Tb.

If Ta is a subtype of Tb and Ta and Tbare not compatible, then Ta is proper subtype of Tb and Tb is a proper
supertype of Ta. A type cannot be a proper supertype of itself.


40 Foundation (SQL/Foundation)                                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                                                     4.7 User-defined types



A type with no proper supertypes is a maximal supertype. A type with no proper subtypes is a leaf type.
Let Ta be a maximal supertype and let T be a subtype of Ta. The set of all subtypes of Ta (which includes Ta
itself) is called a subtype family of T or (equivalently) of Ta. A subtype family is not permitted to have more
than one maximal supertype.
Every value in a type T is a value in every supertype of T. A value V in type T has exactly one most specific
type MST such that MST is a subtype of T and V is not a value in any proper subtype of MST. The most specific
type of value need not be a leaf type. For example, a type structure might consist of a type PERSON that has
STUDENT and EMPLOYEE as its two subtypes, while STUDENT has two direct subtypes UG_STUDENT
and PG_STUDENT. The invocation STUDENT() of the constructor function for STUDENT returns a value
whose most specific type is STUDENT, which is not a leaf type.
If Ta is a subtype of Tb, then a value in Ta can be used wherever a value in Tb is expected. In particular, a value
in Ta can be stored in a column of type Tb, can be substituted as an argument for an input SQL parameter of
data type Tb, and can be the value of an invocation of an SQL-invoked function whose result data type is Tb.

A type T is said to be the minimal common supertype of a set of types S if T is a supertype of every type in S
and a subtype of every type that is a supertype of every type in S.
NOTE 18 — Because a subtype family has exactly one maximal supertype, if two types have a common subtype, they shall also have
a minimal common supertype. Thus, for every set of types drawn from the same subtype family, there is some member of that family
that is the minimal common supertype of all of the types in that set.

If a structured type ST is defined to be not instantiable, then the most specific type of every value in ST is nec-
essarily of some proper subtype of ST.
If a user-defined type UDT is defined to be final, then UDT has no proper subtypes. As a consequence, the
most specific type of every value in UDT is necessarily UDT.
Users shall have the UNDER privilege on a type before they can define any direct subtypes of it. A type can
have more than one direct subtype. A user-defined type or a reference type can have at most one direct supertype.
A row type can have more than one direct supertype.
A <user-defined type definition> for type T can include references to components of every direct supertype of
T. Effectively, components of all direct supertype representations are copied to the subtype's representation.



4.7.6 User-defined type comparison and assignment

Let comparison type of a user-defined type Ta be the user-defined type Tb that satisfies all the following condi-
tions:
1) The type designator of Tb is in the type precedence list of Ta.

2) The user-defined type descriptor of Tb includes an ordering form that is EQUALS or FULL.

3) The descriptor of no type Tc whose type designator precedes that of Tb in the type precedence list of Ta
   includes an ordering form that includes EQUALS or FULL.
If there is no such type Tb, then Ta has no comparison type.



©ISO/IEC 2003 – All rights reserved                                                                             Concepts 41
ISO/IEC 9075-2:2003 (E)
4.7 User-defined types



Let comparison form of a user-defined type Ta be the ordering form included in the user-defined type descriptor
of the comparison type of Ta.

Let comparison category of a user-defined type Ta be the ordering category included in the user-defined type
descriptor of the comparison type of Ta.

Let comparison function of a user-defined type Ta be the ordering function included in the user-defined type
descriptor of the comparison type of Ta.

Two values V1 and V2 whose most specific types are user-defined types T1 and T2 are comparable if and only
if T1 and T2 are in the same subtype family and each have some comparison type CT1 and CT2, respectively.
CT1 and CT2 constrain the comparison forms and comparison categories of T1 and T2 to be the same and to
be the same as those of all their supertypes. If the comparison category is either STATE or RELATIVE, then
T1 and T2 are constrained to have the same comparison function; if the comparison category is MAP, they are
not constrained to have the same comparison function.
NOTE 19 — Explicit cast functions or attribute comparisons can be used to make both values of the same subtype family or to perform
the comparisons on attributes of the user-defined types.
NOTE 20 — “Subtype” and “subtype family” are defined in Subclause 4.7.5, “Subtypes and supertypes”.

If there is no appropriate user-defined cast function, then an expression E whose declared type is some user-
defined type UDT1 is assignable to a site S whose declared type is some user-defined type UDT2 if and only
if UDT1 is a subtype of UDT2. The effect of the assignment of E to S is that the value of S is V, obtained by
the evaluation of E. The most specific type of V is some subtype of UDT1, possibly UDT1 itself, while the
declared type of S remains UDT2.
An expression whose declared type is some distinct type whose source type is SDT is assignable to any site
whose declared type is SDT becaues of the implicit cast functions created by the General Rules of
Subclause 11.41, “<user-defined type definition>”. Similarly, an expression whose declared type is some pre-
defined data type SDT is assignable to any site whose declared type is some distinct type whose source type is
SDT.



4.7.7 Transforms for user-defined types

Transforms are SQL-invoked functions that are automatically invoked when values of user-defined types are
transferred from SQL-environment to host languages or vice-versa.
A transform is associated with a user-defined type. A transform identifies a list of transform groups of up to
two SQL-invoked functions, called the transform functions, each identified by a group name. The group name
of a transform group is an <identifier> such that no two transform groups for a transform have the same group
name. The two transform functions are:
— from-sql function — This SQL-invoked function maps the user-defined type value into a value of an SQL
  pre-defined type, and gets invoked whenever a user-defined type value is passed to a host language program
  or an external routine.
— to-sql function — This SQL-invoked function maps a value of an SQL predefined type to a value of a
  user-defined type and gets invoked whenever a user-defined type value is supplied by a host language
  program or an external routine.



42 Foundation (SQL/Foundation)                                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                                           4.7 User-defined types



A transform is defined by a <transform definition>. A transform is described by a transform descriptor. A
transform descriptor includes a possibly empty list of transform group descriptors, where each transform group
descriptor includes:
— The group name of the transform group.
— The specific name of the from-sql function, if any, associated with the transform group.
— The specific name of the to-sql function, if any, associated with the transform group.



4.8      Row types

A row type is a sequence of (<field name> <data type>) pairs, called fields. It is described by a row type
descriptor. A row type descriptor consists of the field descriptor of every field of the row type.
The most specific type of a row of a table is a row type. In this case, each column of the row corresponds to
the field of the row type that has the same ordinal position as the column.
Row type RT2 is a subtype of data type RT1 if and only if RT1 and RT2 are row types of the same degree and,
in every n-th pair of corresponding field definitions, FD1n in RT1 and FD2n in RT2, the <field name>s are
equivalent and the <data type> of FD2n is a subtype of the <data type> of FD1n.

A value of row type RT1 is assignable to a site of row type RT2 if and only if the degree of RT1 is the same as
the degree of RT2 and every field in RT1 is assignable to the field in the same ordinal position in RT2.
A value of row type RT1 is comparable with a value of row type RT2 if and only if the degree of RT1 is the
same as the degree of RT2 and every field in RT1 is comparable with the field in the same ordinal position in
RT2.



4.9      Reference types


4.9.1 Introduction to reference types

A REF value is a value that references a row in a referenceable table (see Subclause 4.14.5, “Referenceable
tables, subtables, and supertables”). A referenceable table is necessarily also a typed table (that is, it has an
associated structured type from which its row type is derived).
Given a structured type T, the REF values that can reference rows in typed tables defined on T collectively
form a certain data type RT known as a reference type. RT is the referencing type of T and T is the referenced
type of RT.
Let TN be name of T. The type designator of RT is REF(TN).
Values of two reference types are comparable if the referenced types of their declared types have some common
supertype.



©ISO/IEC 2003 – All rights reserved                                                                  Concepts 43
ISO/IEC 9075-2:2003 (E)
4.9 Reference types



An expression E whose declared type is some reference type RT1 is assignable to a site S whose declared type
is some reference type RT2 if and only if the referenced type of RT1 is a subtype of the referenced type of RT2.
The effect of the assignment of E to S is that the value of S is V, obtained by the evaluation of E. The most
specific type of V is some subtype of RT1, possibly RT1 itself, while the declared type of S remains RT2.
A site RS that is occupied by a REF value might have a scope, which determines the effect of an invocation of
<reference resolution> RR on the value at RS. A scope is specified as a table name STN and consists at any
time of every row in the table ST identified by STN. ST is the scoped table of RR. The scope of RS is specified
in the declared type of RS. If no scope is specified in the declard type of RS, then <reference resolution> is not
available.
A reference type is described by a reference type descriptor. The reference type descriptor for RT includes:
— The type designator of RT.
— The name of the referenceable table, if any, that is the scope of RT.
In a host variable, a REF value is materialized as an N-octet value, where N is implementation-defined.
Reference type RT2 is a subtype of data type RT1 (equivalently, RT1 is a supertype of RT2) if and only if RT1
is a reference type and the referenced type of RT2 is a subtype of the referenced type of RT1.
Every value in a reference type RT is a value in every supertype of RT. A value V in type RT has exactly one
most specific type MST such that MST is a subtype of RT and V is not a value in any proper subtype of MST.
A reference type has a user-defined representation if its referenced type is defined by a <user-defined type
definition> that specifies <user-defined representation>. A reference type has a derived representation if its
referenced type is defined by a <user-defined type definition> that specifies <derived representation>. A reference
type has a system-defined representation if it does not have a user-defined representation or a derived represen-
tation.



4.9.2 Operations involving references

An operation is provided that takes a REF value and returns the value that is held in a column of the site iden-
tified by the REF value (see Subclause 6.20, “<dereference operation>”). If the REF value identifies no site,
perhaps because a site it once identified has been destroyed, then the null value is returned.
An operation is provided that takes a REF value and returns a value of the referenced type; that value is con-
structed from the values of the columns of the site identified by that REF value (see Subclause 6.22, “<reference
resolution>”). An operation is also provided that takes a REF value and returns a value acquired from invoking
an SQL-invoked method on a value of the referenced type; that value is constructed from the values of the
columns of the site identified by that REF value (see Subclause 6.21, “<method reference>”).




44 Foundation (SQL/Foundation)                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                           4.10 Collection types



4.10 Collection types


4.10.1 Introduction to collection types

A collection is a composite value comprising zero or more elements, each a value of some data type DT. If the
elements of some collection C are values of DT, then C is said to be a collection of DT. The number of elements
in C is the cardinality of C. The term “element” is not further defined in this part of ISO/IEC 9075. The term
“collection” is generic, encompassing various kinds of collection in connection with each of which, individually,
this part of ISO/IEC 9075 defines primitive type constructors and operators. This part of ISO/IEC 9075 supports
two kinds of collection types, arrays and multisets.
A specific <collection type> CT is a <data type> specified by pairing a keyword KC (either ARRAY or
MULTISET) with a specific data type EDT. In addition, a maximum cardinality may optionally be specified
for arrays. Every element of every possible value of CT is a value of EDT and is permitted to be, more specifi-
cally, of some subtype of EDT. EDT is termed the element type of CT. KC specifies the kind of collection, such
as ARRAY or MULTISET, that every value of CT is, and thus determines the operators that are available for
operating on or returning values of CT.
Let EDTN be the type designator of EDT. The type designator of CT is EDTN KC.
A collection type descriptor describes a collection type. The collection type descriptor for CT includes:
— The type designator of CT.
— The descriptor of the element type of CT.
— An indication of the kind of the collection of CT: ARRAY or MULTISET.
— If CT is an array type, the maximum number of elements of CT.
Collection type CT2 is a subtype of data type CT1 (equivalently, CT1 is a supertype of CT2) if and only if CT1
is the same kind of collection as CT2 and the element type of CT2 is a subtype of the element type of CT1.



4.10.2 Arrays

An array is a collection A in which each element is associated with exactly one ordinal position in A. If n is
the cardinality of A, then the ordinal position p of an element is an integer in the range 1 (one) ≤ p ≤ n. If EDT
is the element type of A, then A can thus be considered as a function of the integers in the range 1 (one) to n
into EDT.
An array site AS has a maximum cardinality m. The cardinality n of an array occupying AS is constrained not
to exceed m.
An array type is a <collection type>. If AT is some array type with element type EDT, then every value of AT
is an array of EDT.




©ISO/IEC 2003 – All rights reserved                                                                 Concepts 45
ISO/IEC 9075-2:2003 (E)
4.10 Collection types



Let A1 and A2 be arrays of EDT. A1 and A2 are identical if and only if A1 and A2 have the same cardinality n
and if, for all i in the range 1 (one) ≤ i ≤ n, the element at ordinal position i in A1 is identical to the element at
ordinal position i in A2.
Let n1 be the cardinality of A1 and let n2 be the cardinality of A2. A1 is a subarray of A2 if and only if there
exists some j in the range 0 (zero) ≤ j < n2 such that, for every i in the range 1 (one) ≤ i ≤ n1, the element at
ordinal position i in A1 is the same as the element at ordinal position i+j in A2.



4.10.3 Multisets

A multiset is an unordered collection. Since a multiset is unordered, there is no ordinal position to reference
individual elements of a multiset.
A multiset type is a <collection type>. If MT is some multiset type with element type EDT, then every value
of MT is a multiset of EDT.
Let M1 and M2 be multisets of EDT. M1 and M2 are identical if and only if M1 and M2 have the same cardi-
nality n, and for each element x in M1, the number of elements of M1 that are identical to x, including x itself,
equals the number of elements of M2 that are identical to x.
Let n1 be the cardinality of M1 and let n2 be the cardinality of M2. M1 is a submultiset of M2 if, for each element
x of M1, the number of elements of M1 that are not distinct from x, including x itself, is less than or equal to
the number of elements of M2 that are not distinct from x.



4.10.4 Collection comparison and assignment

Two collections are comparable if and only if they are of the same kind of collection (ARRAY or MULTISET)
and their element types are comparable.
A value of collection type CT1 is assignable to a site of collection type CT2 if and only if CT1 is the same kind
of collection (ARRAY or MULTISET) as CT2 and the element type of CT1 is assignable to the element type
of CT2.
The array types have a defined element order. Comparisons are defined in terms of the element order of the
arrays. The element order defines the pairs of corresponding elements from the arrays being compared. The
element order of an array is implicitly defined by the ordinal position of its elements.
In the case of comparison of two arrays C and D, the elements are compared pairwise in element order. C = D
is True if and only if C and D have the same cardinality and every pair of elements are equal.
Two multisets C and D of comparable element types are equal if they have the same cardinality N and there
exist an enumeration CEj , 1 (one) ≤ j ≤ N of the elements of C and an enumeration DEj , 1 (one) ≤ j ≤ N of the
elements of D such that for all j, CEj = DEj.




46 Foundation (SQL/Foundation)                                                        ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                           4.10 Collection types



4.10.5 Operations involving arrays


4.10.5.1 Operators that operate on array values and return array elements

<array element reference> is an operation that returns the array element in the specified position within the
array.



4.10.5.2 Operators that operate on array values and return array values

<array concatenation> is an operation that returns the array value made by joining its array value operands in
the order given.



4.10.6 Operations involving multisets


4.10.6.1 Operators that operate on multisets and return multiset elements

<multiset element reference> is an operation that returns the value of the element of a multiset, if the multiset
has only one element.



4.10.6.2 Operators that operate on multisets and return multisets

<multiset set function> is an operation that returns the multiset obtained by removing duplicates from a multiset.
MULTISET UNION is an operator that computes the union of two multisets. There are two variants, specified
using ALL or DISTINCT, to either retain duplicates or remove duplicates.
MULTISET INTERSECT is an operator that computes the intersection of two multisets. There are two variants,
ALL and DISTINCT. The variant specified by ALL places in the result as many instances of each value as the
minimum number of instances of that value in either operand. The variant specified by DISTINCT removes
duplicates from the result.
MULTISET EXCEPT is an operator that computes the multiset difference of two multisets. There are two
variants, ALL and DISTINCT. The variant specified by ALL places in the result a number of instances of a
value, equal to the number of instances of the value in the first operand minus the number of instances of the
value in the second operand. The variant specified by DISTINCT removes duplicates from the result.




©ISO/IEC 2003 – All rights reserved                                                                 Concepts 47
ISO/IEC 9075-2:2003 (E)
4.11 Data conversions



4.11 Data conversions

Implicit type conversion can occur in expressions, fetch operations, single row select operations, inserts, deletes,
and updates. Explicit type conversions can be specified by the use of the CAST operator.
Explicit data conversions can be specified by a CAST operator. A CAST operator defines how values of a
source data type are converted into a value of a target data type according to the Syntax Rules and General
Rules of Subclause 6.12, “<cast specification>”. Data conversions between predefined data types and between
constructed types are defined by the rules of this part of ISO/IEC 9075. Data conversions between a user-defined
type and another data type are defined by a user-defined cast.
A user-defined cast identifies an SQL-invoked function, called the cast function, that has one SQL parameter
whose declared type is the same as the source data type and a result data type that is the target data type. A cast
function may optionally be specified to be implicitly invoked whenever values are assigned to targets of its
result data type. Such a cast function is called an implicitly invocable cast function.
A user-defined cast is defined by a <user-defined cast definition>. A user-defined cast has a user-defined cast
descriptor that includes:
— The name of the source data type.
— The name of the target data type.
— The specific name of the SQL-invoked function that is the cast function.
— An indication as to whether the cast function is implicitly invocable.
When a value V of declared type TV is assigned to a target T of declared type TT, a user-defined cast function
UDCF is said to be an appropriate user-defined cast function if and only if all of the following are true:
— The descriptor of UDCF indicates that UDCF is implicitly invocable.
— The type designator of the declared type DTP of the only SQL parameter P of UDCF is in the type precedence
  list of TV.
— The result data type of UDCF is TT.
— No other user-defined cast function UDCQ with an SQL parameter Q with declared type TQ that precedes
  DTP in the type precedence list of TV is an appropriate user-defined cast function to assign V to T.
An SQL procedure statement S is said to be dependent on an appropriate user-defined cast function UDCF if
and only if all of the following are true:
— S is a <select statement: single row>, <insert statement>, <update statement: positioned>, <update statement:
  searched>, or <merge statement>.
— UDCF is invoked during a store or retrieval assignment operation that is executed during the execution of
  S and UDCF is not executed during the invocation of an SQL-invoked function that is invoked during the
  execution of S.




48 Foundation (SQL/Foundation)                                                       ©ISO/IEC 2003 – All rights reserved
                                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                                                             4.12 Domains



4.12 Domains

A domain is a set of permissible values. A domain is defined in a schema and is identified by a <domain name>.
The purpose of a domain is to constrain the set of valid values that can be stored in a column of a base table
by various operations.
A domain definition specifies a data type. It may also specify a <domain constraint> that further restricts the
valid values of the domain and a <default clause> that specifies the value to be used in the absence of an
explicitly specified value or column default.
A domain is described by a domain descriptor. A domain descriptor includes:
— The name of the domain.
— The data type descriptor of the data type of the domain.
— The value of <default option>, if any, of the domain.
— The domain constraint descriptors of the domain constraints, if any, of the domain.



4.13 Columns, fields, and attributes

The terms column, field, and attribute refer to structural components of tables, row types, and structured types,
respectively, in analogous fashion. As the structure of a table consists of one or more columns, so does the
structure of a row type consist of one or more fields and that of a structured type one or more attributes. Every
structural element, whether a column, a field, or an attribute, is primarily a name paired with a declared type.
The elements of a structure are ordered. Elements in different positions in the same structure can have the same
declared type but not the same name. Although the elements of a structure are distinguished from each other
by name, in some circumstances the compatibility of two structures (for the purpose at hand) is determined
solely by considering the declared types of each pair of elements at the same ordinal position.
A table (see Subclause 4.14, “Tables”) is defined on one or more columns and consists of zero or more rows.
A column has a name and a declared type. Each row in a table has exactly one value for each column. Each
value in a row is a value in the declared type of the column.
NOTE 21 — The declared type includes the null value and values in proper subtypes of the declared type.

Every column has a nullability characteristic that indicates whether the value from that column can be the null
value. A nullability characteristic is either known not nullable or possibly nullable.
Let C be a column of a base table T. C is known not nullable if and only if at least one of the following is true:
— There exists at least one constraint NNC that is not deferrable and that simply contains a <search condition>
  that is a <boolean value expression> that is a known-not-null condition for C.
— C is based on a domain that has a domain constraint that is not deferrable and that simply contains a <search
  condition> that is a <boolean value expression> that is a known-not-null condition for VALUE.
— C is a unique column of a nondeferrable unique constraint that is a PRIMARY KEY.




©ISO/IEC 2003 – All rights reserved                                                                           Concepts 49
ISO/IEC 9075-2:2003 (E)
4.13 Columns, fields, and attributes



— The SQL-implementation is able to deduce that the <search condition> “C IS NULL” can never be true
  when applied to a row in T through some additional implementation-defined rule or rules.
The nullability characteristic of a column of a derived table is defined by the the Syntax Rules of Subclause 7.7,
“<joined table>”, Subclause 7.12, “<query specification>”, and Subclause 7.13, “<query expression>”.
A column C is described by a column descriptor. A column descriptor includes:
— The name of the column.
— Whether the name of the column is an implementation-dependent name.
— If the column is based on a domain, then the name of that domain; otherwise, the data type descriptor of
  the declared type of C.
— The value of <default option>, if any, of C.
— The nullability characteristic of C.
— The ordinal position of C within the table that contains it.
— An indication of whether C is updatable or not.
— An indication of whether C is a self-referencing column of a base table or not.
— An indication of whether C is an identity column or not.
— If C is an identity column, then an indication of whether values are always generated or generated by default.
— If C is an identity column, then the start value of C.
— If C is an identity column, then the descriptor of the internal sequence generator for C.
    NOTE 22 — Identity columns and the meaning of “start value” are described in Subclause 4.14.7, “Identity columns”.

— If C is a generated column, then the generation expression of C.
    NOTE 23 — Generated columns and the meaning of “generation expression” are described in Subclause 4.14.8, “Base columns
    and generated columns”.

An attribute A is described by an attribute descriptor. An attribute descriptor includes:
— The name of the attribute.
— The data type descriptor of the declared type of A.
— The ordinal position of A within the structured type that contains it.
— The value of the implicit or explicit <attribute default> of A.
— The name of the structured type defined by the <user-defined type definition> that defines A.
A field F is described by a field descriptor. A field descriptor includes:
— The name of the field.
— The data type descriptor of the declared type of F.
— The ordinal position of F within the row type that simply contains it.



50 Foundation (SQL/Foundation)                                                               ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)
                                                                                                      4.14 Tables



4.14 Tables


4.14.1 Introduction to tables

A table is a collection of rows having one or more columns. A row is a value of a row type. Every row of the
same table has the same row type. The value of the i-th field of every row in a table is the value of the i-th
column of that row in the table. The row is the smallest unit of data that can be inserted into a table and deleted
from a table.
A table T2 is part of a column C of a table T1 if setting the value of T1.C to a null value (ignoring any constraints
or triggers defined on T1 or T1.C) would cause T2 to disappear.
The most specific type of a row is a row type. All rows of a table are of the same row type and this is called
the row type of that table.
The degree of a table, and the degree of each of its rows, is the number of columns of that table. The number
of rows in a table is its cardinality. A table whose cardinality is 0 (zero) is said to be empty.



4.14.2 Types of tables

A table is either a base table, a derived table, or a transient table. A base table is either a persistent base table,
a global temporary table, a created local temporary table, or a declared local temporary table.
A persistent base table is a named table defined by a <table definition> that does not specify TEMPORARY.
A derived table is a table derived directly or indirectly from one or more other tables by the evaluation of a
<query expression> whose result has an element type that is a row type. The values of a derived table are
derived from the values of the underlying tables when the <query expression> is evaluated.
A viewed table is a named derived table defined by a <view definition>. A viewed table is sometimes called a
view.
A transient table is a named table that may come into existence implicitly during the evaluation of a <query
expression> or the execution of a trigger. A transient table is identified by a <query name> if it arises during
the evaluation of a <query expression>, or by a <transition table name> if it arises during the execution of a
trigger. Such tables exist only for the duration of the executing SQL-statement containing the <query expression>
or for the duration of the executing trigger.
A table is either updatable or not updatable. An updatable table has at least one updatable column. If every
column of table T is updatable, then T is fully updatable. An updatable table that is not fully updatable is partially
updatable. All base tables are fully updatable. Derived tables and transient tables are either updatable or not
updatable. The operations of update and delete are permitted for updatable tables, subject to constraining Access
Rules and Conformance Rules. Some updatable tables, including all base tables whose row type is not derived
from a user-defined type that is not instantiable, are also insertable-into, in which case the operation of insert
is also permitted, again subject to Access Rules and Conformance Rules.
A grouped table is a set of groups derived during the evaluation of a <group by clause>. A group G is a collection
of rows in which, for every grouping column GC, if the value of GC in some row is not distinct from GV, then


©ISO/IEC 2003 – All rights reserved                                                                     Concepts 51
ISO/IEC 9075-2:2003 (E)
4.14 Tables



the value of GC in every row is GV; moreover, if R1 is a row in group G1 of grouped table GT and R2 is a row
in GT such that for every grouping column GC the value of GC in R1 is not distinct from the value of GC in
R2, then R2 is in G1. Every row in GT is in exactly one group. A group may be considered as a table. Set
functions operate on groups.
A global temporary table is a named table defined by a <table definition> that specifies GLOBAL TEMPORARY.
A created local temporary table is a named table defined by a <table definition> that specifies LOCAL TEM-
PORARY. Global and created local temporary tables are effectively materialized only when referenced in an
SQL-session. Every SQL-client module in every SQL-session that references a created local temporary table
causes a distinct instance of that created local temporary table to be materialized. That is, the contents of a
global temporary table or a created local temporary table cannot be shared between SQL-sessions.
In addition, the contents of a created local temporary table cannot be shared between SQL-client modules of a
single SQL-session. The definition of a global temporary table or a created local temporary table appears in a
schema. In SQL language, the name and the scope of the name of a global temporary table or a created local
temporary table are indistinguishable from those of a persistent base table. However, because global temporary
table contents are distinct within SQL-sessions, and created local temporary tables are distinct within SQL-
client modules within SQL-sessions, the effective <schema name> of the schema in which the global temporary
table or the created local temporary table is instantiated is an implementation-dependent <schema name> that
may be thought of as having been effectively derived from the <schema name> of the schema in which the
global temporary table or created local temporary table is defined and the implementation-dependent SQL-
session identifier associated with the SQL-session.
In addition, the effective <schema name> of the schema in which the created local temporary table is instantiated
may be thought of as being further qualified by a unique implementation-dependent name associated with the
SQL-client module in which the created local temporary table is referenced.
A module local temporary table is a named table defined by a <temporary table declaration> in an SQL-client
module. A module local temporary table is effectively materialized the first time it is referenced in an SQL-
session, and it persists for that SQL-session.
A declared local temporary table may be declared in an SQL-client module.
A declared local temporary table is a module local temporary table. A declared local temporary table is acces-
sible only by externally-invoked procedures in the SQL-client module that contains the <temporary table dec-
laration> that declares the declared local temporary table. The effective <schema name> of the <schema qual-
ified name> of the declared local temporary table may be thought of as the implementation-dependent SQL-
session identifier associated with the SQL-session and a unique implementation-dependent name associated
with the <SQL-client module definition> that contains the <temporary table declaration>.
All references to a declared local temporary table are prefixed by “MODULE.”.
The materialization of a temporary table does not persist beyond the end of the SQL-session in which the table
was materialized. Temporary tables are effectively empty at the start of an SQL-session.



4.14.3 Table descriptors

A table is described by a table descriptor. A table descriptor is either a base table descriptor, a view descriptor,
or a derived table descriptor (for a derived table that is not a view).



52 Foundation (SQL/Foundation)                                                       ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                                   4.14 Tables



Every table descriptor includes:
— The column descriptor of each column in the table.
— The name, if any, of the structured type, if any, associated with the table.
— An indication of whether the table is insertable-into or not.
— An indication of whether the table is a referenceable table or not, and an indication of whether the self-
  referencing column is a system-generated, a user-generated, or a derived self-referencing column.
— A list, possibly empty, of the names of its direct supertables.
— A list, possibly empty, of the names of its direct subtables.
A transient table descriptor describes a transient table. In addition to the components of every table descriptor,
a transient table descriptor includes:
— If the transient table is defined by a <with list element> contained in a <query expression>, then the <query
  name>. If the transient table is defined by a <trigger definition> then the <transition table name>.
A base table descriptor describes a base table. In addition to the components of every table descriptor, a base
table descriptor includes:
— The name of the base table.
— An indication of whether the table is a persistent base table, a global temporary table, a created local tem-
  porary table, or a declared local temporary table.
— If the base table is a global temporary table, a created local temporary table, or a declared local temporary
  table, then an indication of whether ON COMMIT PRESERVE ROWS was specified or ON COMMIT
  DELETE ROWS was specified or implied.
— The descriptor of each table constraint specified for the table.
— A non-empty set of functional dependencies, according to the rules given in Subclause 4.18, “Functional
  dependencies”.
— A non-empty set of candidate keys, according to the rules of Subclause 4.19, “Candidate keys”.
— A preferred candidate key, which may or may not be additionally designated the primary key, according
  to the Rules in Subclause 4.18, “Functional dependencies”.
A derived table descriptor describes a derived table. In addition to the components of every table descriptor, a
derived table descriptor includes:
— The <query expression> that defines how the table is to be derived.
— An indication of whether the derived table is updatable or not.
— An indication of whether the derived table is simply updatable or not.
A view descriptor describes a view. In addition to the components of a derived table descriptor, a view
descriptor includes:
— The name of the view.



©ISO/IEC 2003 – All rights reserved                                                                 Concepts 53
ISO/IEC 9075-2:2003 (E)
4.14 Tables



— An indication of whether the view has the CHECK OPTION; if so, whether it is to be applied as CASCADED
  or LOCAL.
— The original <query expression> of the view.



4.14.4 Relationships between tables

The terms simply underlying table, underlying table, leaf underlying table, generally underlying table, and leaf
generally underlying table define a relationship between a derived table or cursor and other tables.
The simply underlying tables of derived tables and cursors are defined in Subclause 7.12, “<query specification>”,
Subclause 7.13, “<query expression>”, and Subclause 14.1, “<declare cursor>”. A <table or query name> has
no simply underlying tables.
The underlying tables of a derived table or cursor are the simply underlying tables of the derived table or cursor
and the underlying tables of the simply underlying tables of the derived table or cursor.
The leaf underlying tables of a derived table or cursor are the underlying tables of the derived table or cursor
that do not themselves have any underlying tables.
The generally underlying tables of a derived table or cursor are the underlying tables of the derived table or
cursor and, for each underlying table of the derived table or cursor that is a <table or query name> TORQN,
the generally underlying tables of TORQN, which are defined as follows:
— If TORQN identifies a base table or if TORQN is a <transition table name>, then TORQN has no generally
  underlying tables.
— If TORQN is a <query name>, then the generally underlying tables of TORQN are the <query expression
  body> QEB of the <with list element> identified by TORQN and the generally underlying tables of QEB.
— If TORQN identifies a view V, then the generally underlying tables of TORQN are the <query expression>
  QEV included in the view descriptor of V and the generally underlying tables of QEV.
The leaf generally underlying tables of a derived table or cursor are the generally underlying tables of the
derived table or cursor that do not themselves have any generally underlying tables.



4.14.5 Referenceable tables, subtables, and supertables

A table RT whose row type is derived from a structured type ST is called a typed table. Only a base table or a
view can be a typed table. A typed table has columns corresponding, in name and declared type, to every
attribute of ST and one other column REFC that is the self-referencing column of RT; let REFCN be the <column
name> of REFC. The declared type of REFC is necessarily REF(ST) and the nullability characteristic of REFC
is known not nullable. If RT is a base table, then the table constraint “UNIQUE(REFCN)” is implicit in the
definition of RT. A typed table is called a referenceable table. A self-referencing column cannot be updated.
Its value is determined during the insertion of a row into the referenceable table. The value of a system-generated
self-referencing column and a derived self-referencing column is automatically generated when the row is
inserted into the referenceable table. The value of a user-generated self-referencing column is supplied as part
of the candidate row to be inserted into the referenceable table.


54 Foundation (SQL/Foundation)                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)
                                                                                                      4.14 Tables



A table Ta is a direct subtable of another table Tb if and only if the <table name> of Tb is contained in the
<subtable clause> contained in the <table definition> or <view definition> of Ta. Both Ta and Tb shall be created
on a structured type and the structured type of Ta shall be a direct subtype of the structured type of Tb.

A table Ta is a subtable of a table Tb if and only if any of the following are true:

1) Ta and Tb are the same named table.

2) Ta is a direct subtable of Tb.

3) There is a table Tc such that Ta is a direct subtable of Tc and Tc is a subtable of Tb.

A table T is considered to be one of its own subtables. Subtables of T other than T itself are called its proper
subtables. A table shall not have itself as a proper subtable.
A table Tb is called a supertable of a table Ta if Ta is a subtable of Tb. If Ta is a direct subtable of Tb, then Tb
is called a direct supertable of Ta. A table that is not a subtable of any other table is called a maximal supertable.

Let Ta be a maximal supertable and T be a subtable of Ta. The set of all subtables of Ta (which includes Ta
itself) is called the subtable family of T or (equivalently) of Ta. Every subtable family has exactly one maximal
supertable.
A leaf table is a table that does not have any proper subtables.
Those columns of a subtable Ta of a structured type STa that correspond to the inherited attributes of STa are
called inherited columns. Those columns of Ta that correspond to the originally-defined attributes of STa are
called originally-defined columns.
Let TB be a subtable of TA. Let SLA be the <value expression> sequence implied by the <select list> “*” in the
<query specification> “SELECT * FROM TA”. For every row RB in the value of TB there exists exactly one
row RA in the value of TA such that RA is the result of the <row subquery> “SELECT SLA FROM VALUES
RRB”, where RRB is some <row value constructor> whose value is RB. RA is said to be the superrow in TA of
RB and RB is said to be the subrow in TB of RA. If TA is a base table, then the one-to-one correspondence
between superrows and subrows is guaranteed by the requirement for a unique constraint to be specified for
some supertable of TA. If TA is a view, then such one-to-one correspondence is guaranteed by the requirement
for a unique constraint to be specified on the leaf generally underlying table of TA.
Users shall have the UNDER privilege on a table before they can use the table in a subtable definition. A table
can have more than one proper subtable. Similarly, a table can have more than one proper supertable.



4.14.6 Operations involving tables

Table values are operated on and returned by <query expression>s. The syntax of <query expression> includes
various internal operators that operate on table values and return table values. In particular, every <query
expression> effectively includes at least one <from clause>, which operates on one or more table values and
returns a single table value. A table value operated on by a <from clause> is specified by a <table reference>.




©ISO/IEC 2003 – All rights reserved                                                                     Concepts 55
ISO/IEC 9075-2:2003 (E)
4.14 Tables



An operation involving a table T may define a range variable RV that ranges over rows of T, referencing each
row in turn in an implementation-dependent order. Thus, each reference to RV references exactly one row of
T. T is said to be the table associated with RV.
In a <table reference>, ONLY can be specified to exclude from the result rows that have subrows in proper
subtables of the referenced table.
In a <table reference>, <sample clause> can be specified to return a subset of result rows depending on the
<sample method> and <sample percentage>. If the <sample clause> contains <repeatable clause>, then repeated
executions of that <table reference> return a result table with identical rows for a given <repeat argument>,
provided certain implementation-defined conditions are satisfied.
A <table reference> that satisfies certain properties specified in this international standard can be used to des-
ignate an updatable table. Certain table updating operations, specified by SQL-data change statements, are
available in connection with updatable tables, subject to applicable Access Rules and Conformance Rules. The
value of an updatable table T is determined by the result of the mostly recently executed SQL-data change
statement (see Subclause 4.33.2, “SQL-statements classified by function”) operating on T. An SQL-data change
statement on table T has a primary effect (on T itself) and zero or more secondary effects (not necessarily on
T).
The primary effect of a <delete statement: positioned> on a table T is to delete exactly one specified row from
T. The primary effect of a <delete statement: searched> on a table T is to delete zero or more rows from T.
The primary effect of an <update statement: positioned> on a table T is to replace exactly one specified row in
T with some specified row. The primary effect of an <update statement: searched> on a table T is to replace
zero or more rows in T.
If a table T, as well as being updatable, is insertable-into, then rows can be inserted into it (subject to applicable
Access Rules and Conformance Rules). The primary effect of an <insert statement> on T is to insert into T
each of the zero or more rows contained in a specified table. The primary effect of a <merge statement> on T
is to replace zero or more rows in T with specified rows and/or to insert into T zero or more specified rows,
depending on the result of a <search condition> and on whether one or both of <merge when matched clause>
and <merge when not matched clause> are specified.
Each of the table updating operations, when applied to a table T, can have various secondary effects. Such
secondary effects can include alteration or reversal of the primary effect. Secondary effects might arise from
the existence of:
— Underlying tables of T, other than T itself, whose values might be subject to secondary effects.
— Updatable views whose <view definition>s do not specify WITH CASCADED CHECK OPTION.
— Cascaded operations specified in connection with integrity constraints involving underlying tables of T,
  which might result in secondary effects on tables referenced by such constraints.
— Proper subtables and proper supertables of T, whose values might be affected by updating operations on
  T.
— Triggers specified for underlying tables of T, which might specify table updating operations on updatable
  tables other than T.




56 Foundation (SQL/Foundation)                                                        ©ISO/IEC 2003 – All rights reserved
                                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                                                   4.14 Tables



4.14.7 Identity columns

The columns of a base table BT can optionally include not more than one identity column. The declared type
of an identity column is either an exact numeric type with scale 0 (zero), INTEGER for example, or a distinct
type whose source type is an exact numeric type with scale 0 (zero). An identity column has a start value, an
increment, a maximum value, a minimum value, and a cycle option. An identity column is associated with an
internal sequence generator SG. Let IC be the identity column of BT. When a row R is presented for insertion
into BT, if R does not contain a column corresponding to IC, then the value V for IC in the row inserted into
BT is obtained by applying the General Rules of Subclause 9.21, “Generation of the next value of a sequence
generator”, to SG. The definition of an identity column may specify GENERATED ALWAYS or GENERATED
BY DEFAULT.
NOTE 24 — “Start value”, “increment”, “maximum value”, “minimum value”, and “cycle option” are defined in Subclause 4.21,
“Sequence generators”.
NOTE 25 — The notion of an internal sequence generator being associated with an identity column is used only for definitional purposes
in this International Standard.



4.14.8 Base columns and generated columns

A column of a base table is either a base column or a generated column. A base column is one that is not a
generated column. A generated column is one whose values are determined by evaluation of a generation
expression, a <value expression> whose declared type is by implication that of the column. A generation
expression can reference base columns of the base table to which it belongs but cannot otherwise access SQL-
data. Thus, the value of the field corresponding to a generated column in row R is determined by the values of
zero or more other fields of R.
A generated column GC depends on each column that is referenced by a <column reference> in its generation
expression, and each such referenced column is a parametric column of GC.



4.14.9 Windowed tables

A windowed table is a table together with one or more windows. A window is a transient data structure associated
with a <table expression>. A window is defined explicitly by a <window definition> or implicitly by an <in-
line window specification>. Implicitly defined windows have an implementation-dependent window name. A
window is used to specify window partitions and window frames, which are collections of rows used in the
definition of <window function>s.
Every window defines a window partitioning of the rows of the <table expression>. The window partitioning
is specified by a list of columns. Window partitioning is similar to forming groups of a grouped table. However,
unlike grouped tables, each row is retained in the result of the <table expression>. The window partition of a
row R is the collection of rows R2 that are not distinct from R, for all columns enumerated in the window par-
titioning clause. The window partitioning clause is optional; if omitted, there is a single window partition con-
sisting of all the rows in the result.




©ISO/IEC 2003 – All rights reserved                                                                                   Concepts 57
ISO/IEC 9075-2:2003 (E)
4.14 Tables



If a <table expression> is grouped and also has a window, then there is a syntactic transformation that segregates
the grouping into a <derived table>, so that the window partitions consist of rows of the <derived table> rather
than groups of rows.
A window may define a window ordering of rows within each window partition defined by the window. The
window ordering of rows within window partitions is specified by a list of <value expression>s, followed by
ASC (for ascending order) or DESC (for descending order). In addition, NULLS FIRST or NULLS LAST may
be specified, to indicate whether a null value should appear before or after all non-null values in the ordered
sequence of each <value expression>.
Optionally, a window may define a window frame for each row R. A window frame is always defined relative
to the current row. A window frame is specified by up to four syntactic elements:
— The choice of RANGE, to indicate a logical definition of the window frame by offsetting forward or
  backward from the current row by an increment or decrement to the sort key; or ROWS, to indicate a
  physical definition of the window frame, by counting rows forward or backward from the current row.
— A starting row, which may be the first row of the window partition of R, the current row, or some row
  determined by a logical or physical offset from the current row.
— An ending row, which may be the last row of the window partition of R, the current row, or some row
  determined by a logical or physical offset from the current row.
— A <window frame exclusion>, indicating whether to exclude the current row and/or its peers (if not already
  excluded by being prior to the starting row or after the ending row).
A window is described by a window structure descriptor, including:
— The window name.
— Optionally, the ordering window name—that is, the name of another window, called the ordering window,
  that is used to define the partitioning and ordering of the present window.
— The window partitioning clause—that is, a <window partition clause> if any is specified in either the present
  <window specification> or in the window descriptor of the ordering window.
— The window ordering clause—that is, a <window order clause> if any is specified in either the present
  <window specification> or in the window descriptor of the ordering window.
— The window framing clause—that is, a <window frame clause>, if any.
In general, two <window function>s are computed independently, each one performing its own sort of its data,
even if they use the same data and the same <sort specification list>. Since sorts may specify partial orderings,
the computation of <window function>s is inevitably non-deterministic to the extent that the ordering is not
total. Nevertheless, the user may desire that two <window function>s be computed using the same ordering,
so that, for example, two moving aggregates move through the rows of a partition in precisely the same order.
Two <window function>s are computed using the same (possibly non-deterministic) window ordering of the
rows if any of the following are true:
— The <window function>s identify the same window structure descriptor.
— The <window function>s' window structure descriptors have window partitioning clauses that enumerate
  the same number of column references, and those column references are pairwise equivalent in their order
  of occurrence; and their window structure descriptors have window ordering clauses with the same number
  of <sort key>s, and those <sort key>s are all column references, and those column references are pairwise


58 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                                                    4.14 Tables



    equivalent in their order of occurrence, and the <sort specification>s pairwise specify or imply <collate
    clause>s that specify equivalent <collation name>s, the same <ordering specification> (ASC or DESC),
    and the same <null ordering> (NULLS FIRST or NULLS LAST).
— The window structure descriptor of one <window function> is the ordering window of the other <window
  function>, or both window structure descriptors identify the same ordering window.



4.15 Data analysis operations (involving tables)


4.15.1 Introduction to data analysis operations

A data analysis function is a function that returns a value derived from a number of rows in the result of a <table
expression>. A data analysis function may only be invoked as part of a <query specification> or <select statement:
single row>, and then only in certain contexts, identified below. A data analysis function is one of:
— A group function, which is invoked on a grouped table and computes a grouping operation or an aggregate
  function from a group of the grouped table.
— A window function, which is invoked on a windowed table and computes a rank, row number or window
  aggregate function.



4.15.2 Group functions

A group function may only appear in the <select list>, <having clause> or <window clause> of a <query
specification> or <select statement: single row>, or in the <order by clause> of a cursor that is a simple table
query.
A group function is one of:
— The grouping operation.
— A group aggregate function.
The grouping operation is of the form GROUPING(<column reference>). The result of such an invocation
is 1 (one) in the case of a row whose values are the results of aggregation over that <column reference> during
the execution of a grouped query containing CUBE, ROLLUP, or GROUPING SET, and 0 (zero) otherwise.



4.15.3 Window functions

A window function is a function whose result for a given row is derived from the window frame of that row
as defined by a window structure descriptor of a windowed table. Window functions may only appear in the
<select list> of a <query specification> or <select statement: single row>, or the <order by clause> of a simple
table query.


©ISO/IEC 2003 – All rights reserved                                                                  Concepts 59
ISO/IEC 9075-2:2003 (E)
4.15 Data analysis operations (involving tables)



A window function is one of:
— A rank function.
— A distribution function.
— The row number function.
— A window aggregate function.
The rank functions compute the ordinal rank of a row R within the window partition of R as defined by a window
structure descriptor, according to the window ordering of those rows, also specified by the same window
structure descriptor. Rows that are not distinct with respect to the window ordering within their window partition
are assigned the same rank. There are two variants, indicated by the keywords RANK and DENSE_RANK.
— If RANK is specified, then the rank of row R is defined as 1 (one) plus the number of rows that precede R
  and are not peers of R.
    NOTE 26 — This implies that if two or more rows are not distinct with respect to the window ordering, then there will be one or
    more gaps in the sequential rank numbering.

— If DENSE_RANK is specified, then the rank of row R is defined as the number of rows preceding and
  including R that are distinct with respect to the window ordering.
    NOTE 27 — This implies that there are no gaps in the sequential rank numbering of rows in each window partition.

The distribution functions compute a relative rank of a row R within the window partition of R defined by a
window structure descriptor, expressed as an approximate numeric ratio between 0.0 and 1.0. There are two
variants, indicated by the keywords PERCENT_RANK and CUME_DIST.
— If PERCENT_RANK is specified, then the relative rank of a row R is defined as (RK–1)/(NR–1), where
  RK is defined to be the RANK of R and NR is defined to be the number of rows in the window partition of
  R.
— If CUME_DIST is specified, then the relative rank of a row R is defined as NP/NR, where NP is defined
  to be the number of rows preceding or peer with R in the window ordering of the window partition of R
  and NR is defined to be the number of rows in the window partition of R.
The ROW_NUMBER function computes the sequential row number, starting with 1 (one) for the first row, of
the row within its window partition according to the window ordering of the window.
The window aggregate functions compute an aggregate value (COUNT, SUM, AVG, etc.), the same as a group
aggregate function, except that the computation aggregates over the window frame of a row rather than over a
group of a grouped table. The hypothetical set functions are not permitted as window aggregate functions.



4.15.4 Aggregate functions

An aggregate function is a function whose result is derived from an aggregation of rows defined by one of:
— The grouping of a grouped table, in which case the aggregate function is a group aggregate function, or set
  function, and for each group there is one aggregation, which includes every row in the group.




60 Foundation (SQL/Foundation)                                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                  4.15 Data analysis operations (involving tables)



— The window frame of a row R of a windowed table relative to a particular window structure descriptor, in
  which case the aggregate function is a window aggregate function, and the aggregation consists of every
  row in the window frame of R, as defined by the window structure descriptor.
Optionally, the collection of rows in an aggregation may be filtered, retaining only those rows that satisfy a
<search condition> that is specified by a <filter clause>.
The result of the aggregate function COUNT (*) is the number of rows in the aggregation.
Every other aggregate function may be classified as a unary group aggregate function, a binary group aggregate
functions, an inverse distribution, or a hypothetical set function.
Every unary aggregate function takes an arbitrary <value expression> as the argument; most unary aggregate
functions can optionally be qualified with either DISTINCT or ALL. Of the rows in the aggregation, the fol-
lowing do not qualify:
— If DISTINCT is specified, then redundant duplicates.
— Every row in which the <value expression> evaluates to the null value.
If no row qualifies, then the result of COUNT is 0 (zero), and the result of any other aggregate function is the
null value.
Otherwise (i.e., at least one row qualifies), the result of the aggregate function is:
— If COUNT <value expression> is specified, then the number of rows that qualify.
— If SUM is specified, then the sum of <value expression> evaluated for each row that qualifies.
— If AVG is specified, then the average of <value expression> evaluated for each row that qualifies.
— If MAX is specified, then the maximum value of <value expression> evaluated for each row that qualifies.
— If MIN is specified, then the minimum value of <value expression> evaluated for each row that qualifies.
— If EVERY is specified, then True if the <value expression> evaluates to True for every row that qualifies;
  otherwise, False.
— If ANY or SOME is specified, then True if the <value expression> evaluates to True for at least one row
  remaining in the group; otherwise, False.
— If VAR_POP is specified, then the population variance of <value expression> evaluated for each row
  remaining in the group, defined as the sum of squares of the difference of <value expression> from the
  mean of <value expression>, divided by the number of rows remaining.
— If VAR_SAMP is specified, then the sample variance of <value expression> evaluated for each row
  remaining in the group, defined as the sum of squares of the difference of <value expression> from the
  mean of <value expression>, divided by the number of rows remaining minus 1 (one).
— If STDDEV_POP is specified, then the population standard deviation of <value expression> evaluated for
  each row remaining in the group, defined as the square root of the population variance.
— If STDDEV_SAMP is specified, then the sample standard deviation of <value expression> evaluated for
  each row remaining in the group, defined as the square root of the sample variance.




©ISO/IEC 2003 – All rights reserved                                                                 Concepts 61
ISO/IEC 9075-2:2003 (E)
4.15 Data analysis operations (involving tables)



Neither DISTINCT nor ALL are allowed to be specified for VAR_POP, VAR_SAMP, STDDEV_POP, or
STDDEV_SAMP; redundant duplicates are not removed when computing these functions.
The binary aggregate functions take a pair of arguments, the <dependent variable expression> and the <inde-
pendent variable expression>, which are both <numeric value expression>s. Any row in which either argument
evaluates to the null value is removed from the group. If there are no rows remaining in the group, then the
result of REGR_COUNT is 0 (zero), and the other binary aggregate functions result in the null value. Otherwise,
the computation concludes and the result is:
— If REGR_COUNT is specified, then the number of rows remaining in the group.
— If COVAR_POP is specified, then the population covariance, defined as the sum of products of the difference
  of <independent variable expression> from its mean times the difference of <dependent variable expression>
  from its mean, divided by the number of rows remaining.
— If COVAR_SAMP is specified, then the sample covariance, defined as the sum of products of the difference
  of <independent variable expression> from its mean times the difference of <dependent variable expression>
  from its mean, divided by the number of rows remaining minus 1 (one).
— If CORR is specified, then the correlation coefficient, defined as the ratio of the population covariance
  divided by the product of the population standard deviation of <independent variable expression> and the
  population standard deviation of <dependent variable expression>.
— If REGR_R2 is specified, then the square of the correlation coefficient.
— If REGR_SLOPE is specified, then the slope of the least-squares-fit linear equation determined by the
  (<independent variable expression>, <dependent variable expression>) pairs.
— If REGR_INTERCEPT is specified, then the y-intercept of the least-squares-fit linear equation determined
  by the (<independent variable expression>, <dependent variable expression>) pairs.
— If REGR_SXX is specified, then the sum of squares of <independent variable expression>.
— If REGR_SYY is specified, then the sum of squares of <dependent variable expression>.
— If REGR_SXY is specified, then the sum of products of <independent variable expression> times
  <dependent variable expression>.
— If REGR_AVGX is specified, then the average of <independent variable expression>.
— If REGR_AVGY is specified, then the average of <dependent variable expression>.
There are two inverse distribution functions, PERCENTILE_CONT and PERCENTILE_DISC. Both inverse
distribution functions specify an argument and an ordering of a value expression. The value of the argument
should be between 0 (zero) and 1 (one) inclusive. The value expression is evaluated for each row of the group,
nulls are discarded, and the remaining rows are ordered. The computation concludes:
— If PERCENTILE_CONT is specified, by considering the pair of consecutive rows that are indicated by the
  argument, treated as a fraction of the total number of rows in the group, and interpolating the value of the
  value expression evaluated for these rows.
— If PERCENTILE_DISC is specified, by treating the group as a window partition of the CUME_DIST
  window function, using the specified ordering of the value expression as the window ordering, and
  returning the first value expression whose cumulative distribution value is greater than or equal to the
  argument.


62 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                                  ISO/IEC 9075-2:2003 (E)
                                                                            4.15 Data analysis operations (involving tables)



The hypothetical set functions are related to the window functions RANK, DENSE_RANK, PERCENT_RANK,
and CUME_DIST, and use the same names, though with a different syntax. These functions take an argument
A and an ordering of a value expression VE. VE is evaluated for all rows of the group. This collection of values
is augmented with A; the resulting collection is treated as a window partition of the corresponding window
function whose window ordering is the ordering of the value expression. The result of the hypothetical set
function is the value of the eponymous window function for the hypothetical “row” that contributes A to the
collection.



4.16 Determinism

In general, an operation is deterministic if that operation assuredly computes identical results when repeated
with identical input values. For an SQL-invoked routine, the values in the argument list are regarded as the
input; otherwise, the SQL-data and the set of privileges by which they are accessed is regarded as the input.
Differences in the ordering of rows, as permitted by General Rules that specify implementation-dependent
behavior, are not regarded as significant to the question of determinism.
NOTE 28 — Transaction isolation levels have a significant impact on determinism, particularly isolation levels other than SERIALIZ-
ABLE. However, this International Standard does not address that impact, particularly because of the difficulty in clearly specifying
that impact without appearing to mandate implementation techniques (such as row or page locking) and because different SQL-imple-
mentations almost certainly resolve the issue in significantly different ways.

Recognizing that an operation is deterministic is a difficult task, it is in general not mandated by this International
Standard. SQL-invoked routines are regarded as deterministic if the routine is declared to be DETERMINISTIC;
that is, the SQL-implementation trusts the definer of the SQL-invoked routine to correctly declare that the
routine is deterministic. For other operations, this International Standard does not label an operation as deter-
ministic; instead it identifies certain operations as “possibly non-deterministic”. Specific definitions can be
found in other subclauses relative to <value expression>, <table reference>, <table primary>, <query specifica-
tion>, <query expression>, and <SQL procedure statement>.
Certain <boolean value expression>s are identified as “retrospectively deterministic”. A retrospectively deter-
ministic <boolean value expression> has the property that if it is True at one point time, then it is True for all
later points in time if re-evaluated for the identical SQL-data by an arbitrary user with the identical set of
privileges. The precise definition is found in Subclause 6.34, “<boolean value expression>”.



4.17 Integrity constraints


4.17.1 Overview of integrity constraints

Integrity constraints, generally referred to simply as constraints, define the valid states of SQL-data by constrain-
ing the values in the base tables. A constraint is described by a constraint descriptor. A constraint is either a
table constraint, a domain constraint, or an assertion and is described by, respectively, a table constraint
descriptor, a domain constraint descriptor, or an assertion descriptor. Every constraint descriptor includes:
— The name of the constraint.



©ISO/IEC 2003 – All rights reserved                                                                                  Concepts 63
ISO/IEC 9075-2:2003 (E)
4.17 Integrity constraints



— An indication of whether or not the constraint is deferrable.
— An indication of whether the initial constraint mode is deferred or immediate.
No integrity constraint shall be defined using a <search condition> that is not retrospectively deterministic.



4.17.2 Checking of constraints

Every constraint is either deferrable or non-deferrable. Within an SQL-transaction, every constraint has a
constraint mode; if a constraint is non-deferrable, then its constraint mode is always immediate, otherwise it
is either immediate or deferred. Every constraint has an initial constraint mode that specifies the constraint
mode for that constraint at the start of each SQL-transaction and immediately after definition of that constraint.
If a constraint is deferrable, then its constraint mode may be changed (from immediate to deferred, or from
deferred to immediate) by execution of a <set constraints mode statement>.
The checking of a constraint depends on its constraint mode within the current SQL-transaction. If the constraint
mode is immediate, then the constraint is effectively checked at the end of each SQL-statement.
NOTE 29 — This includes SQL-statements that are executed as a direct result or an indirect result of executing a different SQL-statement.

If the constraint mode is deferred, then the constraint is effectively checked when the constraint mode is changed
to immediate either explicitly by execution of a <set constraints mode statement>, or implicitly at the end of
the current SQL-transaction.
When a constraint is checked other than at the end of an SQL-transaction, if it is not satisfied, then an exception
condition is raised and the SQL-statement that caused the constraint to be checked has no effect other than
entering the exception information into the first diagnostics area. When a <commit statement> is executed, all
constraints are effectively checked and, if any constraint is not satisfied, then an exception condition is raised
and the SQL-transaction is terminated by an implicit <rollback statement>.



4.17.3 Table constraints

A table constraint is either a unique constraint, a referential constraint or a table check constraint. A table con-
straint is described by a table constraint descriptor which is either a unique constraint descriptor, a referential
constraint descriptor or a table check constraint descriptor.
Every table constraint specified for base table T is implicitly a constraint on every subtable of T, by virtue of
the fact that every row in a subtable is considered to have a corresponding superrow in every one of its
supertables.
A unique constraint is satisfied if and only if no two rows in a table have the same non-null values in the unique
columns. In addition, if the unique constraint was defined with PRIMARY KEY, then it requires that none of
the values in the specified column or columns be a null value.
A unique constraint is described by a unique constraint descriptor. In addition to the components of every table
constraint descriptor, a unique constraint descriptor includes:
— An indication of whether it was defined with PRIMARY KEY or UNIQUE.



64 Foundation (SQL/Foundation)                                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                                         4.17 Integrity constraints



— The names and positions of the unique columns specified in the <unique column list>.
If the table descriptor for base table T includes a unique constraint descriptor indicating that the unique constraint
was defined with PRIMARY KEY, then the columns of that unique constraint constitute the primary key of T.
A table that has a primary key cannot have a proper supertable.
A referential constraint is described by a referential constraint descriptor. In addition to the components of
every table constraint descriptor, a referential constraint descriptor includes:
— A list of the names of the referencing columns specified in the <referencing columns>.
— The referenced table specified in the <referenced table and columns>.
— A list of the names of the referenced columns specified in the <referenced table and columns>.
— The value of the <match type>, if specified, and the <referential triggered action>s, if specified.
NOTE 30 — If MATCH FULL or MATCH PARTIAL is specified for a referential constraint and if the referencing table has only one
column specified in <referential constraint definition> for that referential constraint, or if the referencing table has more than one
specified column for that <referential constraint definition>, but none of those columns is nullable, then the effect is the same as if no
<match type> were specified.

The ordering of the lists of referencing column names and referenced column names is implementation-defined,
but shall be such that corresponding column names occupy corresponding positions in each list.
In the case that a table constraint is a referential constraint, the table is referred to as the referencing table. The
referenced columns of a referential constraint shall be the unique columns of some unique constraint of the
referenced table.
A referential constraint is satisfied if one of the following conditions is true, depending on the <match type>
specified in the <referential constraint definition>:
— If no <match type> was specified then, for each row R1 of the referencing table, either at least one of the
  values of the referencing columns in R1 shall be a null value, or the value of each referencing column in
  R1 shall be equal to the value of the corresponding referenced column in some row of the referenced table.
— If MATCH FULL was specified then, for each row R1 of the referencing table, either the value of every
  referencing column in R1 shall be a null value, or the value of every referencing column in R1 shall not be
  null and there shall be some row R2 of the referenced table such that the value of each referencing column
  in R1 is equal to the value of the corresponding referenced column in R2.
— If MATCH PARTIAL was specified then, for each row R1 of the referencing table, there shall be some
  row R2 of the referenced table such that the value of each referencing column in R1 is either null or is equal
  to the value of the corresponding referenced column in R2.
The referencing table may be the same table as the referenced table.
A table check constraint is described by a table check constraint descriptor. In addition to the components of
every table constraint descriptor, a table check constraint descriptor includes:
— The <search condition>.
A table check constraint is satisfied if and only if the specified <search condition> is not False for any row of
a table.




©ISO/IEC 2003 – All rights reserved                                                                                      Concepts 65
ISO/IEC 9075-2:2003 (E)
4.17 Integrity constraints



4.17.4 Domain constraints

A domain constraint is a constraint that is specified for a domain. It is applied to all columns that are based on
that domain, and to all values cast to that domain.
A domain constraint is described by a domain constraint descriptor. In addition to the components of every
constraint descriptor a domain constraint descriptor includes:
— The <search condition>.
A domain constraint is satisfied by SQL-data if and only if, for any table T that has a column named C based
on that domain, the specified <search condition>, with each occurrence of VALUE replaced by C, is not False
for any row of T.
A domain constraint is satisfied by the result of a <cast specification> if and only if the specified <search con-
dition>, with each occurrence of VALUE replaced by that result, is not False.



4.17.5 Assertions

An assertion is a named constraint that may relate to the content of individual rows of a table, to the entire
contents of a table, or to a state required to exist among a number of tables.
An assertion is described by an assertion descriptor. In addition to the components of every constraint
descriptor an assertion descriptor includes:
— The <search condition>.
An assertion is satisfied if and only if the specified <search condition> is not False.



4.18 Functional dependencies


4.18.1 Overview of functional dependency rules and notations

This Subclause defines functional dependency and specifies a minimal set of rules that a conforming implemen-
tation shall follow to determine functional dependencies and candidate keys in base tables and <query expres-
sion>s.
The rules in this Subclause may be freely augmented by implementation-defined rules, where indicated in this
Subclause.
Let T be any table. Let CT be the set comprising all the columns of T, and let A and B be arbitrary subsets of
CT, not necessarily disjoint and possibly empty.
Let “T: A ↦ B” (read “in T, A determines B” or “B is functionally dependent on A in T”) denote the functional
dependency of B on A in T, which is true if, for any possible value of T, any two rows that are not distinct for



66 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                                               4.18 Functional dependencies



every column in A also are not distinct for every column in B. When the table T is understood from context,
the abbreviation “A ↦ B” may also be used.
If X ↦ Y is some functional dependency in some table T, then X is a determinant of Y in T.
Let A ↦ B and C ↦ D be any two functional dependencies in T. The following are also functional dependencies
in T:
— A UNION ( C DIFFERENCE B ) ↦ B UNION D
— C UNION ( A DIFFERENCE D ) ↦ B UNION D
NOTE 31 — Here, “UNION” denotes set union and “DIFFERENCE” denotes set difference.

These two rules are called the rules of deduction for functional dependencies.
Every table has an associated non-empty set of functional dependencies.
The set of functional dependencies is non-empty because X ↦ X for any X. A functional dependency of this
form is an axiomatic functional dependency, as is X ↦ Y where Y is a subset of X. X ↦ Y is a non-axiomatic
functional dependency if Y is not a subset of X.



4.18.2 General rules and definitions

In the following Subclauses, let a column C1 be a counterpart of a column C2 under qualifying table QT if C1
is specified by a column reference (or by a <value expression> that is a column reference) that references C2
and QT is the qualifying table of C2. If C1 is a counterpart of C2 under qualifying table QT1 and C2 is a
counterpart of C3 under qualifying table QT2, then C1 is a counterpart of C3 under QT2.
The notion of counterparts naturally generalizes to sets of columns, as follows: If S1 and S2 are sets of columns,
and there is a one-to-one correspondence between S1 and S2 such that each element of S1 is a counterpart of
the corresponding element of S2, then S1 is a counterpart of S2.
The next Subclauses recursively define the notion of known functional dependency. This is a ternary relationship
between a table and two sets of columns of that table. This relationship expresses that a functional dependency
in the table is known to the SQL-implementation. All axiomatic functional dependencies are known functional
dependencies. In addition, any functional dependency that can be deduced from known functional dependencies
using the rules of deduction for functional dependency is a known functional dependency.
The next Subclauses also recursively define the notion of a “BUC-set”, which is a set of columns of a table (as
in “S is BUC-set”, where S is a set of columns).
NOTE 32 — “BUC” is an acronym for “base table unique constraint”, since the starting point of the recursion is a set of known not
null columns comprising a nondeferrable unique constraint of a base table.

The notion of BUC-set is closed under the following deduction rule for BUC-sets: If S1 and S2 are sets of
columns, S1 is a subset of S2, S1 ↦ S2, and S2 is a BUC-set, then S1 is also a BUC-set.
NOTE 33 — A BUC-set may be empty, in which case there is at most one row in the table. This case shall be distinguished from a
table with no BUC-set.

An SQL-implementation may define additional rules for determining BUC-sets, provided that every BUC-set
S of columns of a table T shall have an associated base table BT such that every column of S has a counterpart



©ISO/IEC 2003 – All rights reserved                                                                                Concepts 67
ISO/IEC 9075-2:2003 (E)
4.18 Functional dependencies



in BT, and for any possible value of the columns of S, there is at most one row in BT having those values in
those columns.
The next Subclauses also recursively define the notion of a “BPK-set”, which is a set of columns of a table (as
in “S is a BPK-set”, where S is a set of columns). Every BPK-set is a BUC-set.
NOTE 34 — “BPK” is an acronym for “base table primary key”, since the starting point of the recursion is a set of known not null
columns comprising a nondeferrable primary key constraint of a base table.

The notion of BPK-set is closed under the following deduction rule for BPK-sets: If S1 and S2 are sets of
columns, S1 is a subset of S2, S1 ↦ S2, and S2 is a BPK-set, then S1 is also a BPK-set.
NOTE 35 — Like BUC-sets, a BPK-set may be empty.

An SQL-implementation may define additional rules for determining BPK-sets, provided that every BPK-set
S is a BUC-set, and every member of S has a counterpart to a column in a primary key in the associated base
table BT.
All applicable syntactic transformations (for example, to remove *, CUBE, or ROLLUP) shall be applied before
using the rules to determine known functional dependencies, BUC-sets, and BPK-sets.
The following Subclauses use the notion of AND-component of a <search condition> SC. which is defined
recursively as follows:
— If SC is a <boolean test> BT, then the only AND-component of SC is BT.
— If SC is a <boolean factor> BF, then the only AND-component of SC is BF.
— If SC is a <boolean term> of the form “P AND Q”, then the AND-components of SC are the AND-compo-
  nents of P and the AND-components of Q.
— If SC is a <boolean value expression> BVE that specifies OR, then the only AND-component of SC is BVE.
Let AC be an AND-component of SC such that AC is a <comparison predicate> whose <comp op> is <equals
operator>. Let RVE1 and RVE2 be the two <row value predicand>s that are the operands of AC. Suppose that
both RVE1 and RVE2 are <row value constructor predicand>s. Let n be the degree of RVE1. Let RVEC1i and
RVEC2i, 1 (one) ≤ i ≤ n, be the i-th <common value expression>, <boolean predicand>, or <row value constructor
element> of RVE1 and RVE2, respectively. The <comparison predicate> “RVEC1i = RVEC2i” is called an
equality AND-component of SC.



4.18.3 Known functional dependencies in a base table

Let T be a base table and let CT be the set comprising all the columns of T.
A set of columns S1 of T is a BPK-set if it is the set of columns enumerated in some unique constraint UC of
T, UC specifies PRIMARY KEY, and UC is nondeferrable.
A set of columns S1 of T is a BUC-set if it is the set of columns enumerated in some unique constraint UC of
T, UC is nondeferrable, and every member of S1 is known not null.
If UCL is a set of columns of T such that UCL is a BUC-set, then UCL ↦ CT is a known functional dependency
in T.



68 Foundation (SQL/Foundation)                                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                                   4.18 Functional dependencies



If GC is a generated column of T, then D ↦ GC, where D is the set of parameteric columns of GC, is a known
functional dependency in T.
Implementation-defined rules may determine other known functional dependencies in T.



4.18.4 Known functional dependencies in a transition table

Let TT be the transition table defined in a trigger TR and let T be the subject table of TR. If TT is an old transition
table or if TR is an AFTER trigger and TT is a new transition table, then the BPK-sets, BUC-sets, and known
functional dependencies of TT are the same as the BPK-sets, BUC-sets, and known functional dependencies
of T. If TR is a BEFORE trigger and TT is a new transition table, then no set of columns of TT is a BPK-set or
a BUC-set and the known functional dependencies of TT are the axiomatic functional dependencies.



4.18.5 Known functional dependencies in <table value constructor>

Let R be the result of a <table value constructor>, and let CR be the set comprising all the columns of R.
No set of columns of R is a BPK-set or a BUC-set, except as determined by implementation-defined rules.
All axiomatic functional dependencies are known functional dependencies of a <table value constructor>. In
addition, there may be implementation-defined known functional dependencies (for example, by examining
the actual value of the <table value constructor>).



4.18.6 Known functional dependencies in a <joined table>

Let T1 and T2 denote the tables identified by the first and second <table reference>s of some <joined table>
JT. Let R denote the table that is the result of JT. Let CT be the set of columns of the result of JT.
Every column of R has some counterpart in either T1 or T2. If NATURAL is specified or the <join specification>
is a <named columns join>, then some columns of R may have counterparts in both T1 and T2.
A set of columns S of R is a BPK-set if S has some counterpart in T1 or T2 that is a BPK-set, every member of
S is known not null, and S ↦ CT is a known functional dependency of R.
A set of columns S of R is a BUC-set if S has some counterpart in T1 or T2 that is a BUC-set, every member
of S is known not null, and S ↦ CT is a known functional dependency of R.
NOTE 36 — The following rules for known functional dependencies in a <joined table> are not mutually exclusive. The set of known
functional dependencies is the union of those dependencies generated by all applicable rules, including the rules of deduction presented
earlier.

If A ↦ B is a known functional dependency in T1, CA is the counterpart of A in R, and CB is the counterpart of
B in R, then CA ↦ CB is a known functional dependency in R if either:
— CROSS, INNER, or LEFT is specified.



©ISO/IEC 2003 – All rights reserved                                                                                    Concepts 69
ISO/IEC 9075-2:2003 (E)
4.18 Functional dependencies



— RIGHT or FULL is specified and at least one column in A is known not nullable.
If A ↦ B is a known functional dependency in T2, CA is the counterpart of A in R, and CB is the counterpart of
B in R, then CA ↦ CB is a known functional dependency in R if either:
— CROSS, INNER, or RIGHT is specified.
— LEFT or FULL is specified and at least one column in A is known not nullable.
If <join condition> is specified, AP is an equality AND-component of the <search condition>, one comparand
of AP is a column reference CR, and the other comparand of AP is a <literal>, then let CRC be the counterparts
of CR in R. Let {} denote the empty set. {} ↦ {CRC} is a known functional dependency in R if any of the fol-
lowing conditions is true:
— INNER is specified.
— If LEFT is specified and CR is a column reference to a column in T1.
— If RIGHT is specified and CR is a column reference to a column in T2.
NOTE 37 — An SQL-implementation may also choose to recognize {} -> {CRC} as a known functional dependency if the other
comparand is a deterministic expression containing no column references.

If <join condition> is specified, AP is an equality AND-component of the <search condition>, one comparand
of AP is a column reference CRA, and the other comparand of AP is a column references CRB, then let CRAC
and CRBC be the counterparts of CRA and CRB in R. {CRAC} ↦ {CRBC} is a known functional dependency
in R if any of the following conditions is true:
— INNER is specified.
— If LEFT is specified and CRA is a column reference to a column in T1.
— If RIGHT is specified and CRA is a column reference to a column in T2.
NOTE 38 — An SQL-implementation may also choose to recognize the following as known functional dependencies: {CRAC} ↦
{CRBC} if CRA is known not nullable, CRA is a column of T1, and RIGHT or FULL is specified; or if CRA is known not nullable,
CRA is a column of T2, and LEFT or FULL is specified.
NOTE 39 — An SQL-implementation may also choose to recognize similar known functional dependencies of the form { CRA1 , ...,
CRAN } ↦ {CRBC} in case one comparand is a deterministic expression of column references CRA1 , ..., CRAN under similar conditions.

If NATURAL is specified, or if a <join specification> immediately containing a <named columns join> is
specified, then let C1 , ..., CN be the column names of the corresponding join columns, for i between 1 (one)
and N. Let SC be the <search condition>:
    ( TN1.C1 = TN2.C1 )
   AND
   ...
   AND
   ( TN1.CN = TN2.CN )

Let SLCC and SL be the <select list>s defined in the Syntax Rules of Subclause 7.7, “<joined table>”. Let JT
be the <join type>. Let TN1 and TN2 be the exposed <table or query name> or <correlation name> of tables
T1 and T2, respectively. Let IR be the result of the <query expression>:




70 Foundation (SQL/Foundation)                                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                               4.18 Functional dependencies



   SELECT SLCC, TN1.*, TN2.*
   FROM TN1 JT JOIN TN2
        ON SC

The following are recognized as additional known functional dependencies of IR:
— If INNER or LEFT is specified, then { COALESCE ( TN1.Ci, TN2.Ci ) } ↦ { TN1.Ci }, for all i between
  1 (one) and N.
— If INNER or RIGHT is specified, then { COALESCE ( TN1.Ci, TN2.Ci ) } ↦ { TN2.Ci }, for all i between
  1 (one) and N.
The known functional dependencies of R are the known functional dependencies of:
   SELECT SL FROM IR




4.18.7 Known functional dependencies in a <table primary>

Let R be the result of some <table primary> TP. The BPK-sets, BUC-sets, and functional dependencies of R
are determined as follows:
Case:
— If TP immediately contains a <table or query name> TQN (with or without ONLY), then the counterparts
  of the BPK-sets and BUC-sets of TQN are the BPK-sets and BUC-sets, respectively, of R. If A ↦ B is a
  functional dependency in the result of TQN, and AC and BC are the counterparts of A and B, respectively,
  then AC ↦ BC is a known functional dependency in R.
— If TP immediately contains a <derived table> DT, then the counterparts of the BPK-sets and BUC-sets of
  DT are the BPK-sets and BUC-sets, respectively, of R. If A ↦ B is a functional dependency in the result of
  DT, and AC and BC are the counterparts of A and B, respectively, then AC ↦ BC is a known functional
  dependency in R.
— If TP immediately contains a <lateral derived table> LDT, then the counterparts of the BPK-sets and BUC-
  sets of LDT are the BPK-sets and BUC-sets, respectively, of R. If A ↦ B is a functional dependency in the
  result of LDT, and AC and BC are the counterparts of A and B, respectively, then AC ↦ BC is a known
  functional dependency in R.
— If TP immediately contains a <collection derived table> CDT, and WITH ORDINALITY is specified, then
  let C1 and C2 be the two columns names of CDT. {C2} is a BPK-set and a BUC-set, and {C2} ↦ {C2,
  C1} is a known functional dependency . If WITH ORDINALITY is not specified, then these rules do not
  identify any BPK-set, BUC-set, or non-axiomatic known functional dependency.



4.18.8 Known functional dependencies in a <table factor>

Let R be the result of <table factor> TF. Let S be the result of <table primary> immediately contained in TF.
The counterparts of the BPK-sets and BUC-sets of S are the BPK-sets and BUCsets, respectively, of R. If A ↦



©ISO/IEC 2003 – All rights reserved                                                             Concepts 71
ISO/IEC 9075-2:2003 (E)
4.18 Functional dependencies



B is a functional dependency in S, and AC and BC are the counterparts of A and B, respectively, then AC ↦ BC
is a known functional dependency in R.



4.18.9 Known functional dependencies in a <table reference>

Let R be the result of some <table reference> TR. The BPK-sets, BUC-sets, and functional dependencies of R
are determined as follows:
Case:
— If TR immediately contains a <table factor> TF, then the counterparts of the BPK-sets and BUC-sets of TF
  are the BPK-sets and BUC-sets, respectively, of R. If A ↦ B is a functional dependency in the result of TF,
  and AC and BC are the counterparts of A and B, respectively, then AC ↦ BC is a known functional dependency
  in R.
— If TR immediately contains a <joined table> JT, then the counterparts of the BPK-sets and BUC-sets of JT
  are the BPK-sets and BUC-sets, respectively, of R. If A ↦ B is a functional dependency in the result of JT,
  and AC and BC are the counterparts of A and B, respectively, then AC ↦ BC is a known functional dependency
  in R.



4.18.10Known functional dependencies in the result of a <from clause>

Let R be the result of some <from clause> FC.
If there is only one <table reference> TR in FC, then the counterparts of the BPK-sets of TR and the counterparts
of the BUC-sets of TR are the BPK-sets and BUC-sets of TR, respectively. Otherwise, these rules do not identify
any BPK-sets or BUC-sets in the result of FC.
If T is a <table reference> immediately contained in the <table reference list> of FC, then all known functional
dependencies in T are known functional dependencies in R.



4.18.11Known functional dependencies in the result of a <where clause>

Let T be the table that is the operand of the <where clause>. Let R be the result of the <where clause>. A set
of columns S in R is a BUC-set if there is a <table reference> TR such that every member of S has a counterpart
in TR, the counterpart of S in TR is a BUC-set, and S ↦ CR, where CR is the set of all columns of R. If, in
addition, the counterpart of S is a BPK-set, then S is a BPK-set.
If A ↦ B is a known functional dependency in T, then let AC be the set of columns of R whose counterparts are
in A, and let BC be the set of columns of R whose counterparts are in B. AC ↦ BC is a known functional
dependency in R.
If AP is an equality AND-component of the <search condition> simply contained in the <where clause> and
one comparand of AP is a column reference CR, and the other comparand of AP is a <literal>, then let CRC be



72 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                                                4.18 Functional dependencies



the counterpart of CR in R. {} ↦ {CRC} is a known functional dependency in R, where {} denotes the empty
set.
NOTE 40 — An SQL-implementation may also choose to recognize {} ↦ {CRC} as a known functional dependency if the other comparand
is a deterministic expression containing no column references.

If AP is an equality AND-component of the <search condition> simply contained in the <where clause> and
one comparand of AP is a column reference CRA, and the other comparand of AP is a column references CRB,
then let CRAC and CRBC be the counterparts of CRA and CRB in R. {CRBC} ↦ {CRAC} and {CRAC} ↦
{CRBC} are known functional dependencies in R.
NOTE 41 — An SQL-implementation may also choose to recognize known functional dependencies of the form {CRAC1, ..., CRACN
} ↦ {CRBC} if one comparand is a deterministic expressions that contains column references CRA1, ..., CRAN and the other comparand
is a column reference CRB.



4.18.12Known functional dependencies in the result of a <group by clause>

Let T1 be the table that is the operand of the <group by clause>, and let R be the result of the <group by clause>.
Let G be the set of columns specified by the <grouping column reference list> of the <group by clause>, after
applying all syntactic transformations to eliminate ROLLUP, CUBE, and GROUPING SETS.
The columns of R are the columns of G, with an additional column CI, whose value in any particular row of R
somehow denotes the subset of rows of T1 that is associated with the combined value of the columns of G in
that row.
If every element of G is a column reference to a known not null column, then G is a BUC-set of R. If G is a
subset of a BPK-set of columns of T1, then G is a BPK-set of R.
G ↦ CI is a known functional dependency in R.
NOTE 42 — Any <set function specification> that is specified in conjunction with R is necessarily a function of CI. If SFVC denotes
the column containing the results of such a <set function specification>, then CI ↦ SFVC holds true, and it follows that G ↦ SFVC is
a known functional dependency in the table containing SFVC.



4.18.13Known functional dependencies in the result of a <having clause>

Let T1 be the table that is the operand of the <having clause>, let SC be the <search condition> simply contained
in the <having clause>, and let R be the result of the <having clause>.
If S is a set of columns of R and the counterpart of S in T1 is a BPK-set, then S is a BPK-set. If the counterpart
of S in T1 is a BUC-set, then S is a BUC-set.
Any known functional dependency in the <query expression>
   SELECT * FROM T1 WHERE SC
is a known functional dependency in R.




©ISO/IEC 2003 – All rights reserved                                                                                 Concepts 73
ISO/IEC 9075-2:2003 (E)
4.18 Functional dependencies



4.18.14Known functional dependencies in a <query specification>

Let T be the <table expression> simply contained in the <query specification> QS and let R be the result of the
<query specification>.
Let SL be the <select list> of the <query specification>.
Let T1 be T extended to the right with columns arising from <value expression>s contained in the <select list>,
as follows: A <value expression> VE that is not a column reference specifies a computed column CC in T1.
For every row in T1, the value in CC is the result of VE.
Let S be a set of columns of R such that every element of S arises from the use of <asterisk> in SL or by the
specification of a column reference as a <value expression> simply contained in SL. S has counterparts in T
and T1. If the counterpart of S in T is a BPK-set, then S is a BPK-set. If the counterpart of S in T is a BUC-set
or a BPK-set, then S is a BUC-set.
If A ↦ B is some known functional dependency in T, then A ↦ B is a known functional dependency in T1.
Let CC be the column specified by some <value expression> VE that is not possibly non-deterministic in the
<select list>.
Let OP1, OP2, ... be the operands of VE that are column references whose qualifying query is QS and that are
not contained in an aggregated argument of a <set function specification>.
If VE does not contain a <set function specification> whose aggregation query is QS, then {OP1, OP2, ...} ↦
CC is a known functional dependency in T1.
If VE contains a <set function specification> whose aggregation query is QS, then let {G1, ...} be the set of
grouping columns of T. {G1, ..., OP1, OP2, ...} ↦ CC is a known functional dependency in T1.
Let C ↦ D be some known functional dependency in T1. If all the columns of C have counterparts in R, then
let DR be the set comprising those columns of D that have counterparts in R. C ↦ DR is a known functional
dependency in R.



4.18.15Known functional dependencies in a <query expression>

If a <with clause> is specified, and RECURSIVE is not specified, then the BPK-sets, BUC-sets, and known
functional dependencies of the table identified by a <query name> in the <with list> are the same as the BPK-
sets, BUC-sets, and known functional dependencies of the corresponding <query expression>, respectively. If
RECURSIVE is specified, then the BPK-sets, BUC-sets, and non-axiomatic known functional dependencies
are implementation-defined.
A <query expression> that is a <query term> that is a <query primary> that is a <simple table> or a <joined
table> is covered by previous Subclauses of this Clause.
If the <query expression> specifies UNION, EXCEPT or INTERSECT, then let T1 and T2 be the left and right
operand tables and let R be the result. Let CR be the set comprising all the columns of R.
Each column of R has a counterpart in T1 and a counterpart in T2.
Case:


74 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                                               4.18 Functional dependencies



— If EXCEPT is specified, then a set S of columns of R is a BPK-set if its counterpart in T1 is a BPK-set. S
  is a BUC-set if its counterpart in T1 is a BUC-set.
— If UNION is specified, then there are no BPK-sets and no BUC-sets.
— If INTERSECT is specified, then a set S of columns of R is a BPK-set if either of its counterparts in T1 and
  T2 is a BPK-set. S is a BUC-set if either of its counterparts in T1 and T2 is a BUC-set.
Case:
— If UNION is specified, then no non-axiomatic functional dependency in T1 or T2 is a known functional
  dependency in R, apart from any functional dependencies determined by implementation-defined rules.
— If EXCEPT is specified, then all known functional dependencies in T1 are known functional dependencies
  in R.
— If INTERSECT is specified, then all known functional dependencies in T1 and all known functional
  dependencies in T2 are known functional dependencies in R.
NOTE 43 — Other known functional dependencies may be determined according to implementation-defined rules.




4.19 Candidate keys

If the functional dependency CK ↦ CT holds true in some table T, where CT consists of all columns of T, and
there is no proper subset CK1 of CK such that CK1 ↦ CT holds true in T, then CK is a candidate key of T. The
set of candidate keys SCK is nonempty because, if no proper subset of CT is a candidate key, then CT is a
candidate key.
NOTE 44 — Because a candidate key is a set (of columns), SCK is therefore a set of sets (of columns).

A candidate key CK is a strong candidate key if CK is a BUC-set, or if T is a grouped table and CK is a subset
of the set of grouping columns of T. Let SSCK be the set of strong candidate keys.
Let PCK be the set of P such that P is a member of SCK and P is a BPK-set.
Case:
— If PCK is nonempty, then the primary key is chosen from PCK as follows: If PCK has exactly one element,
  then that element is the primary key; otherwise, the left-most element of PCK is chosen according to the
  “left-most rule” below. The primary key is also the preferred candidate key.
— Otherwise, there is no primary key and the preferred candidate key is chosen as follows:
    Case:
    •    If SSCK has exactly one element, then it is the preferred candidate key; otherwise, if SSCK has more
         than one element, then the left-most element of SSCK is chosen, according to the “left-most” rule below.
    •    Otherwise, if SCK has exactly one element, then it is the preferred candidate key; otherwise, the left-
         most element of SCK is chosen, according to the “left-most” rule below.
— The “left-most” rule:




©ISO/IEC 2003 – All rights reserved                                                                           Concepts 75
ISO/IEC 9075-2:2003 (E)
4.19 Candidate keys



    •   This rule uses the ordering of the columns of a table, as specified elsewhere in this part of ISO/IEC
        9075.
        To determine the left-most of two sets of columns of T, first list each set in the order of the column-
        numbers of its members, extending the shorter list with zeros to the length of the longer list. Then,
        starting at the left of each ordered list, step forward until a pair of unequal column numbers, one from
        the same position in each list, is found. The list containing the number that is the smaller member of
        this pair identifies the left-most of the two sets of columns of T.
        To determine the left-most of more than two sets of columns of T, take the left-most of any two sets,
        then pair that with one of the remaining sets and take the left-most, and so on until there are no
        remaining sets.



4.20 SQL-schemas

An SQL-schema is a persistent descriptor that includes:
— The name of the SQL-schema.
— The <authorization identifier> of the owner of the SQL-schema.
— The name of the default character set for the SQL-schema.
— The <schema path specification> defining the SQL-path for SQL-invoked routines for the SQL-schema.
— The descriptor of every component of the SQL-schema.
In this part of ISO/IEC 9075, the term “schema” is used only in the sense of SQL-schema. The persistent objects
described by the descriptors are said to be owned by or to have been created by the <authorization identifier>
of the schema. Each component descriptor is one of:
— A domain descriptor.
— A base table descriptor.
— A view descriptor.
— A constraint descriptor.
— A privilege descriptor.
— A character set descriptor.
— A collation descriptor.
— A transliteration descriptor.
— A user-defined type descriptor.
— A routine descriptor.
— A sequence generator descriptor.




76 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                                              4.20 SQL-schemas



A schema is created initially using a <schema definition> and may be subsequently modified incrementally
over time by the execution of <SQL schema statement>s. <schema name>s are unique within a catalog.
A <schema name> is explicitly or implicitly qualified by a <catalog name> that identifies a catalog.
Base tables and views are identified by <table name>s. A <table name> consists of a <schema name> and an
<identifier>. The <schema name> identifies the schema in which a persistent base table or view identified by
the <table name> is defined. Base tables and views defined in different schemas can have <identifier>s that
are equal according to the General Rules of Subclause 8.2, “<comparison predicate>”.
If a reference to a <table name> does not explicitly contain a <schema name>, then a specific <schema name>
is implied. The particular <schema name> associated with such a <table name> depends on the context in which
the <table name> appears and is governed by the rules for <schema qualified name>.
If a reference to an SQL-invoked routine that is contained in a <routine invocation> does not explicitly contain
a <schema name>, then the SQL-invoked routine is selected from the SQL-path of the schema.
The containing schema of an <SQL schema statement> is defined as the schema identified by the <schema
name> implicitly or explicitly contained in the name of the object that is created or manipulated by that SQL-
statement.



4.21 Sequence generators


4.21.1 General description of sequence generators

A sequence generator is a mechanism for generating successive exact numeric values, one at a time. A sequence
generator is either an external sequence generator or an internal sequence generator. An external sequence
generator is a named schema object while an internal sequence generator is a component of another schema
object. A sequence generator has a data type, which shall be an exact numeric type with scale 0 (zero), a minimum
value, a maximum value, a start value, an increment, and a cycle option.
Specification of a sequence generator can optionally include the specification of a data type, a minimum value,
a maximum value, a start value, an increment, and a cycle option.
If a sequence generator is associated with a negative increment, then it is a descending sequence generator;
otherwise, it is an ascending sequence generator.
A sequence generator has a time-varying current base value, which is a value of its data type. A sequence
generator has a cycle which consists of all the possible values between the minimum value and the maximum
value which are expressible as (current base value + N * increment), where N is a non-negative number.
When a sequence generator is created, its current base value is initialized to the start value. Subsequently, the
current base value is set to the value of the lowest non-issued value in the cycle for an ascending sequence
generator, or the highest non-issued value in the cycle for a descending sequence generator.
Any time after a sequence generator is created, its current base value can be set to an arbitrary value of its data
type by an <alter sequence generator statement>.




©ISO/IEC 2003 – All rights reserved                                                                  Concepts 77
ISO/IEC 9075-2:2003 (E)
4.21 Sequence generators



Changes to the current base value of a sequence generator are not controlled by SQL-transactions; therefore,
commits and rollbacks of SQL-transactions have no effect on the current base value of a sequence generator.
A sequence generator is described by a sequence generator descriptor. A sequence generator descriptor includes:
— The sequence generator name that is a schema-qualified sequence generator name for an external sequence
  generator and a zero-length character string for an internal sequence generator.
— The data type descriptor of the data type associated with the sequence generator.
— The increment of the sequence generator.
— The maximum value of the sequence generator.
— The minimum value of the sequence generator.
— The cycle option of the sequence generator.
— The current base value of the sequence generator.



4.21.2 Operations involving sequence generators

When a <next value expression> is applied to a sequence generator SG, SG issues a value V taken from SG's
current cycle such that V is expressible as the current base value of SG plus N multiplied by the increment of
SG, where N is a non-negative number.
Thus a sequence generator will normally issue all of the values in its cycle and these will normally be in
increasing or decreasing order (depending on the sign of the increment) but within that general ordering separate
subgroups of ordered values may occur.
If the sequence generator's cycle is exhausted (i.e., it cannot issue a value that meets the criteria), then a new
cycle is created with the current base value set to the minimum value of SG (if SG is an ascending sequence
generator) or the maximum value of SG (if SG is a descending sequence generator).
If a new cycle is created and the descriptor of SG includes NO CYCLE, then an exception condition is raised.
If there are multiple instances of <next value expression>s specifying the same sequence generator within a
single SQL-statement, all those instances return the same value for a given row processed by that SQL-statement.



4.22 SQL-client modules

An SQL-client module is an SQL-environment object that can include externally-invoked procedures and certain
descriptors. An SQL-client module is created and destroyed by implementation-defined mechanisms (which
can include the granting and revoking of privileges required for the use of the SQL-client module). An SQL-
client module exists in the SQL-environment containing an SQL-client.
If an SQL-client module S is defined by an <SQL-client module definition> that contains a <module authorization
identifier> MAI, then the owner of S is MAI; otherwise, S has no owner.



78 Foundation (SQL/Foundation)                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                                                     4.22 SQL-client modules



An SQL-client module can be specified by a <SQL-client module definition> (see Subclause 13.1, “<SQL-
client module definition>”).
An SQL-client module includes:
— The name, if any of the SQL-client module.
— The name of the standard programming language from a compilation unit of which an externally-invoked
  procedure included in the module can be invoked.
— The <module authorization identifier>, if any.
— An indication of whether or not the <module authorization identifier> is to apply to execution of prepared
  statements resulting from invocation of externally-invoked procedures in the SQL-client module that contain
  <prepare statement>s or <execute immediate statement>s.
— SQL-client module defaults, for use in the application of Syntax Rules to <externally-invoked procedure>s,
  <temporary table declaration>s, and <declare cursor>s.
    •    The name of the schema for use as the default <schema name> when deriving externally-invoked pro-
         cedures from <externally-invoked procedure>s, specified either by the <schema name> or, failing that,
         by the <module authorization identifier>.
    •    The SQL-path, if any, used to qualify:
         — Unqualified <routine name>s that are immediately contained in <routine invocation>s that are
           contained in the SQL-client module.
         — Unqualified <user-defined type name>s that are immediately contained in <path-resolved user-
           defined type name>s that are contained in the SQL-client module.
    •    The names of zero or more SQL-client module collations, each specifying a collation for one or more
         character sets for the SQL-client module.
— The name, if specified, of the character set used to express the <SQL-client module definition>.
    NOTE 45 — The <module character set specification> has no effect on the SQL language contained in the SQL-client module
    and exists only for compatibility with ISO/IEC 9075:1992. It may be used to document the character set of the SQL-client module.

— Module contents:
    •    Zero or more temporary table descriptors.
    •    Zero or more cursors.
    •    One or more externally-invoked procedures.
A compilation unit is a segment of executable code, possibly consisting of one or more subprograms. An SQL-
client module is associated with a compilation unit during its execution. A single SQL-client module may be
associated with multiple compilation units and multiple SQL-client modules may be associated with a single
compilation unit. The manner in which this association is specified, including the possible requirement for
execution of some implementation-defined statement, is implementation-defined. Whether a compilation unit
may invoke or transfer control to other compilation units, written in the same or a different programming lan-
guage, is implementation-defined.




©ISO/IEC 2003 – All rights reserved                                                                                 Concepts 79
ISO/IEC 9075-2:2003 (E)
4.23 Embedded syntax



4.23 Embedded syntax

An <embedded SQL host program> (<embedded SQL Ada program>, <embedded SQL C program>,
<embedded SQL COBOL program>, <embedded SQL Fortran program>, <embedded SQL MUMPS program>,
<embedded SQL Pascal program>, or <embedded SQL PL/I program>) is a compilation unit that consists of
programming language text and SQL text. The programming language text shall conform to the requirements
of a specific standard programming language. The SQL text shall consist of one or more <embedded SQL
statement>s and, optionally, one or more <embedded SQL declare section>s, as defined in this International
Standard. This allows database applications to be expressed in a hybrid form in which SQL-statements are
embedded directly in a compilation unit. Such a hybrid compilation unit is defined to be equivalent to:
— An SQL-client module, containing externally-invoked procedures and declarations.
— A standard compilation unit in which each SQL-statement has been replaced by an invocation of an exter-
  nally-invoked procedure in the SQL-client module, and the declarations contained in such SQL-statements
  have been suitably transformed into declarations in the host language.
    If an <embedded SQL host program> contains an <embedded authorization declaration>, then it shall be
    the first statement or declaration in the <embedded SQL host program>. The <embedded authorization
    declaration> is not replaced by a procedure or subroutine call of an <externally-invoked procedure>, but
    is removed and replaced by syntax associated with the <SQL-client module definition>'s <module autho-
    rization clause>.
    An implementation may reserve a portion of the name space in the <embedded SQL host program> for the
    names of procedures or subroutines that are generated to replace SQL-statements and for program variables
    and branch labels that may be generated as required to support the calling of these procedures or subroutines;
    whether this reservation is made is implementation-defined. They may similarly reserve name space for
    the <SQL-client module name> and <procedure name>s of the generated <SQL-client module definition>
    that may be associated with the resulting standard compilation unit. The portion of the name space to be
    so reserved, if any, is implementation-defined.



4.24 Dynamic SQL concepts


4.24.1 Overview of dynamic SQL

In many cases, the SQL-statement to be executed can be coded into an <SQL-client module definition> or into
a compilation unit using the embedded syntax. In other cases, the SQL-statement is not known when the program
is written and will be generated during program execution.
Dynamic execution of SQL-statements can generally be accomplished in two different ways. Statements can
be prepared for execution and then later executed one or more times; when the statement is no longer needed
for execution, it can be released by the use of a <deallocate prepared statement>. Alternatively, a statement
that is needed only once can be executed without the preparation step—it can be executed immediately (not all
SQL-statements can be executed immediately).




80 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                                                 4.24 Dynamic SQL concepts



When a prepared statement is executed, if it has an owner, then it is executed under definer's rights; otherwise,
it is executed under invoker's rights.
Many SQL-statements can be written to use “parameters” (which are manifested in static execution of SQL-
statements as host parameters in <SQL procedure statement>s contained in <externally-invoked procedure>s
in <SQL-client module definition>s or as host variables in <embedded SQL statement>s contained in
<embedded SQL host program>s). In SQL-statements that are executed dynamically, the parameters are called
dynamic parameters (<dynamic parameter specification>s) and are represented in SQL language by a <question
mark> (?).
In many situations, an application that generates an SQL-statement for dynamic execution knows in detail the
required characteristics (e.g., <data type>, <length>, <precision>, <scale>, etc.) of each of the dynamic
parameters used in the statement; similarly, the application may also know in detail the characteristics of the
values that will be returned by execution of the statement. However, in other cases, the application may not
know this information to the required level of detail; it is possible in some cases for the application to ascertain
the information from the Information Schema, but in other cases (e.g., when a returned value is derived from
a computation instead of simply from a column in a table, or when dynamic parameters are supplied) this
information is not generally available except in the context of preparing the statement for execution.
NOTE 46 — The Information Schema is defined in ISO/IEC 9075-11.

To provide the necessary information to applications, SQL permits an application to request the SQL-server
to describe a prepared statement. The description of a statement identifies the number of input dynamic
parameters (describe input) and their data type information or it identifies the number of output dynamic
parameters or values to be returned (describe output) and their data type information. The description of a
statement is placed into the SQL descriptor areas already mentioned.
Many, but not all, SQL-statements can be prepared and executed dynamically.
NOTE 47 — The complete list of statements that may be dynamically prepared and executed is defined in Subclause 4.33.7, “Preparable
and immediately executable SQL-statements”.

Certain “set statements” (<set catalog statement>, <set schema statement>, <set names statement>, and <set
path statement>) have no effect other than to set up default information (catalog name, schema name, character
set, and SQL path, respectively) to be applied to other SQL-statements that are prepared or executed immediately
or that are invoked directly.
Syntax errors and Access Rule violations caused by the preparation or immediate execution of <preparable
statement>s are identified when the statement is prepared (by <prepare statement>) or when it is executed (by
<execute statement> or <execute immediate statement>); such violations are indicated by the raising of an
exception condition.



4.24.2 Dynamic SQL statements and descriptor areas

An <execute immediate statement> can be used for a one-time preparation and execution of an SQL-statement.
A <prepare statement> is used to prepare the generated SQL-statement for subsequent execution. A <deallocate
prepared statement> is used to deallocate SQL-statements that have been prepared with a <prepare statement>.
A description of the input dynamic parameters for a prepared statement can be obtained by execution of a
<describe input statement>. A description of the resultant columns of a <dynamic select statement> or <dynamic
single row select statement> can be obtained by execution of a <describe output statement>. A description of



©ISO/IEC 2003 – All rights reserved                                                                                Concepts 81
ISO/IEC 9075-2:2003 (E)
4.24 Dynamic SQL concepts



the output dynamic parameters of a statement that is neither a <dynamic select statement> nor a <dynamic
single row select statement> can be obtained by execution of a <describe output statement>.
For a statement other than a <dynamic select statement>, an <execute statement> is used to associate parameters
with the prepared statement and execute it as though it had been coded when the program was written. For a
<dynamic select statement>, the prepared <cursor specification> is associated with a cursor via a <dynamic
declare cursor> or <allocate cursor statement>. The cursor can be opened and dynamic parameters can be
associated with the cursor with a <dynamic open statement>. A <dynamic fetch statement> positions an open
cursor on a specified row and retrieves the values of the columns of that row. A <dynamic close statement>
closes a cursor that was opened with a <dynamic open statement>. A <dynamic delete statement: positioned>
is used to delete rows through a dynamic cursor. A <dynamic update statement: positioned> is used to update
rows through a dynamic cursor. A <preparable dynamic delete statement: positioned> is used to delete rows
through a dynamic cursor when the precise format of the statement isn't known until runtime. A <preparable
dynamic update statement: positioned> is used to update rows through a dynamic cursor when the precise format
of the statement isn't known until runtime.
The interface for input dynamic parameters and output dynamic parameters for a prepared statement and for
the resulting values from a <dynamic fetch statement> or the execution of a prepared <dynamic single row
select statement> can be either a list of dynamic parameters or embedded variables or an SQL descriptor area.
An SQL descriptor area consists of one or more item descriptor areas, together with a header that includes a
count of the number of those item descriptor areas. The header of an SQL descriptor area consists of the fields
in Table 23, “Data types of <key word>s used in the header of SQL descriptor areas”, in Subclause 19.1,
“Description of SQL descriptor areas”. Each item descriptor area consists of the fields specified in Table 24,
“Data types of <key word>s used in SQL item descriptor areas”, in Subclause 19.1, “Description of SQL
descriptor areas”. The SQL descriptor area is allocated and maintained by the system with the following state-
ments: <allocate descriptor statement>, <deallocate descriptor statement>, <set descriptor statement>, and <get
descriptor statement>.
Two kinds of identifier are used for referencing dynamic SQL objects, extended names and non-extended names.
An extended name is an <identifier> assigned to a parameter or variable and the object it identifies is referenced
indirectly, by referencing that parameter or variable. A non-extended name is just an <identifier> and the object
it identifies is referenced by using that <identifier> directly in an SQL-statement.
SQL descriptor areas are always identified by extended names. Dynamic statements and cursors can be identified
either by non-extended names or by extended names.
Two extended names are equivalent if their values, with leading and trailing <space>s removed, are equivalent
according to the rules for <identifier> comparison in Subclause 5.2, “<token> and <separator>”.
The scope of an extended name is either global or local and is determined by the run-time context in which the
object it identifies is brought into existence.
The scope of a global extended name GEN is the SQL-session, meaning that, during the existence of the object
O it identifies, GEN can be used to reference O by any SQL-statement executed in that SQL-session.
The scope of a local extended name LEN is the SQL-client module M containing the externally-invoked procedure
that is being executed when the object O identified by LEN is brought into existence. This means that, during
the existence of O, LEN can be used to reference O by any SQL-statement executed in the same SQL-session
by an externallyinvoked procedure in M.
The scope of a non-extended name is the <SQL-client module definition> containing the SQL-statement that
defines it.



82 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                              ISO/IEC 9075-2:2003 (E)
                                                                                          4.24 Dynamic SQL concepts



NOTE 48 — The namespace of non-extended names is different from the namespace of extended names.

Let PRP be the prepared statement resulting from execution of a <prepare statement> in an externally-invoked
procedure, SQL-invoked routine, or triggered action E. In the following cases, PRP has no owner:
— E is an SQL-invoked routine whose security characteristic is INVOKED.
— E is an externally-invoked procedure contained in an SQL-client module that either has no owner or for
  which FOR STATIC ONLY was specified.
Otherwise, the owner of PRP is the owner of E.



4.25 Direct invocation of SQL

Direct invocation of SQL is a mechanism for executing direct SQL-statements, known as <direct SQL state-
ment>s. In direct invocation of SQL, the method of invoking <direct SQL statement>s, the method of raising
conditions that result from the execution of <direct SQL statement>s, the method of accessing the diagnostics
information that results from the execution of <direct SQL statement>s, and the method of returning the results
are implementation-defined.



4.26 Externally-invoked procedures

An externally-invoked procedure consists of an SQL-statement and can be invoked from a compilation unit of
a host language. The host language is specified by the <language clause> of the SQL-client module that contains
the externally-invoked procedure.



4.27 SQL-invoked routines


4.27.1 Overview of SQL-invoked routines

An SQL-invoked routine is an SQL-invoked procedure or an SQL-invoked function. An SQL-invoked routine
comprises at least a <schema qualified routine name>, a sequence of <SQL parameter declaration>s, and a
<routine body>.
An SQL-invoked routine is an element of an SQL-schema and is called a schema-level routine.
An SQL-invoked routine SR is said to be dependent on a user-defined type UDT if SR is created during the
execution of the <user-defined type definition> that created UDT or if SR is created during the execution of an
<alter type statement> that specifies an <add attribute definition>. An SQL-invoked routine that is dependent
on a user-defined type cannot be modified by an <alter routine statement> or be destroyed by a <drop routine
statement>. It is destroyed implicitly by a <drop data type statement>.




©ISO/IEC 2003 – All rights reserved                                                                     Concepts 83
ISO/IEC 9075-2:2003 (E)
4.27 SQL-invoked routines



An SQL-invoked procedure is an SQL-invoked routine that is invoked from an SQL <call statement>. An SQL-
invoked procedure may have input SQL parameters, output SQL parameters, and SQL parameters that are both
input SQL parameters and output SQL parameters. The format of an SQL-invoked procedure is specified by
<SQL-invoked procedure> (see Subclause 11.50, “<SQL-invoked routine>”).
An SQL-invoked procedure may optionally be specified to require a new savepoint level to be established when
it is invoked and destroyed on return from the executed routine body. The alternative of not taking a savepoint
can also be directly specified with OLD SAVEPOINT LEVEL. When an SQL-invoked function is invoked a
new savepoint level is always established. Savepoint levels are described in Subclause 4.35.2, “Savepoints”.
An SQL-invoked function is an SQL-invoked routine whose invocation returns a value. Every parameter of an
SQL-invoked function is an input SQL parameter, one of which may be designated as the result SQL parameter.
The format of an SQL-invoked function is specified by <SQL-invoked function> (see Subclause 11.50, “<SQL-
invoked routine>”). An SQL-invoked function can be a type-preserving function; a type-preserving function
is an SQL-invoked function that has a result SQL parameter. The most specific type of a non-null result of
invoking a type-preserving function shall be compatible with the most specific type of the value of the argument
substituted for its result SQL parameter.
An SQL-invoked method is an SQL-invoked function that is specified by <method specification designator>
(see Subclause 11.50, “<SQL-invoked routine>”). There are three kinds of SQL-invoked methods: SQL-invoked
constructor methods, instance SQL-invoked methods and static SQL-invoked methods. All SQL-invoked
methods are associated with a user-defined type, also known as the type of the method. The <method character-
istic>s of an SQL-invoked method are specified by a <method specification> contained in the <user-defined
type definition> of the type of the method. Both an instance SQL-invoked method and an SQL-invoked con-
structor method satisfy the following conditions:
— Its first parameter, called the subject parameter, has a declared type that is a user-defined type. The type
  of the subject parameter is the type of the method. A parameter other than the subject parameter is called
  an additional parameter.
— Its descriptor is in the same schema as the descriptor of the data type of its subject parameter.
An SQL-invoked constructor method satisfies the following additional conditions:
— Its <method name> is equivalent to the <qualified identifier> simply contained in the <user-defined type
  name> included in the user-defined type descriptor of the type of the method.
A static SQL-invoked method satisfies the following conditions:
— It has no subject parameter. Its first parameter, if any, is treated no differently than any other parameter.
— Its descriptor is in the same schema as the descriptor of the structured type of the method. The name of this
  type (or of some subtype of it) is always specified together with the name of the method when the method
  is to be invoked.
An SQL-invoked function that is not an SQL-invoked method is an SQL-invoked regular function. An SQL-
invoked regular function is specified by <function specification> (see Subclause 11.50, “<SQL-invoked rou-
tine>”).
A null-call function is an SQL-invoked function that is defined to return the null value if any of its input argu-
ments is the null value. A null-call function is an SQL-invoked function whose <null-call clause> specifies
“RETURNS NULL ON NULL INPUT”.




84 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                                    4.27 SQL-invoked routines



4.27.2 Characteristics of SQL-invoked routines

An SQL-invoked routine can be an SQL routine or an external routine. An SQL routine is an SQL-invoked
routine whose <language clause> specifies SQL. The <routine body> of an SQL routine is an <SQL procedure
statement>; the <SQL procedure statement> forming the <routine body> can be any SQL-statement, including
an <SQL control statement>, but excluding an <SQL connection statement> and an <SQL transaction statement>
other than a <savepoint statement>, a <release savepoint statement>, or a <rollback statement> that specifies
a <savepoint clause>.
An external routine is one whose <language clause> does not specify SQL. The <routine body> of an external
routine is an <external body reference> whose <external routine name> identifies a program written in some
standard programming language other than SQL. The program identified by <external routine name> shall not
execute either an <SQL connection statement> or an <SQL transaction statement> other than a <savepoint
statement>, a <release savepoint statement>, or a <rollback statement> that specifies a <savepoint clause>
An SQL-invoked routine is uniquely identified by a <specific name>, called the specific name of the SQL-
invoked routine.
SQL-invoked routines are invoked differently depending on their form. SQL-invoked procedures are invoked
by <call statement>s. SQL-invoked regular functions are invoked by <routine invocation>s. Instance SQL-
invoked methods are invoked by <method invocation>s, while SQL-invoked constructor methods are invoked
by <new specification>s and static SQL-invoked methods are invoked by <static method invocation>s. An
invocation of an SQL-invoked routine specifies the <routine name> of the SQL-invoked routine and supplies
a sequence of argument values corresponding to the <SQL parameter declaration>s of the SQL-invoked routine.
A subject routine of an invocation is an SQL-invoked routine that may be invoked by a <routine invocation>.
After the selection of the subject routine of a <routine invocation>, the SQL arguments are evaluated and the
SQL-invoked routine that will be executed is selected. If the subject routine is an instance SQL-invoked method,
then the SQL-invoked routine that is executed is selected from the set of overriding methods of the subject
routine. (The term “set of overriding methods” is defined in the General Rules of Subclause 10.4, “<routine
invocation>”.) The overriding method that is selected is the overriding method with a subject parameter the
type designator of whose declared type precedes that of the declared type of the subject parameter of every
other overriding method in the type precedence list of the most specific type of the value of the SQL argument
that corresponds to the subject parameter. See the General Rules of Subclause 10.4, “<routine invocation>”.
If the subject routine is not an SQL-invoked method, then the SQL-invoked routine executed is that subject
routine. After the selection of the SQL-invoked routine for execution, the values of the SQL arguments are
assigned to the corresponding SQL parameters of the SQL-invoked routine and its <routine body> is executed.
If the SQL-invoked routine is an SQL routine, then the <routine body> is an <SQL procedure statement> that
is executed according to the General Rules of <SQL procedure statement>. If the SQL-invoked routine is an
external routine, then the <routine body> identifies a program written in some standard programming language
other than SQL that is executed according to the rules of that standard programming language.
The <routine body> of an SQL-invoked routine is always executed under the same SQL-session from which
the SQL-invoked routine was invoked. Before the execution of the <routine body>, a new context for the current
SQL-session is created and the values of the current context preserved. When the execution of the <routine
body> completes the original context of the current SQL-session is restored.
If the SQL-invoked routine is an external routine, then an effective SQL parameter list is constructed before
the execution of the <routine body>. The effective SQL parameter list has different entries depending on the
parameter passing style of the SQL-invoked routine. The value of each entry in the effective SQL parameter
list is set according to the General Rules of Subclause 10.4, “<routine invocation>”, and passed to the program
identified by the <routine body> according to the rules of Subclause 13.6, “Data type correspondences”. After


©ISO/IEC 2003 – All rights reserved                                                               Concepts 85
ISO/IEC 9075-2:2003 (E)
4.27 SQL-invoked routines



the execution of that program, if the parameter passing style of the SQL-invoked routine is SQL, then the SQL-
implementation obtains the values for output parameters (if any), the value (if any) returned from the program,
the value of the SQLSTATE, and the value of the message text (if any) from the values assigned by the program
to the effective SQL parameter list. If the parameter passing style of the SQL-invoked routine is GENERAL,
then such values are obtained in an implementation-defined manner.
Different SQL-invoked routines can have equivalent <routine name>s. No two SQL-invoked functions in the
same schema are allowed to have the same signature. No two SQL-invoked procedures in the same schema are
allowed to have the same name and the same number of parameters. Subject routine determination is the process
for choosing the subject routine for a given <routine invocation> given a <routine name> and an <SQL argument
list>. Subject routine determination for SQL-invoked functions considers the most specific types of all of the
arguments (that is, all of the arguments that are not <dynamic parameter specification>s whose types are not
known at the time of subject routine determination) to the invocation of the SQL-invoked function in order
from left to right. Where there is not an exact match between the most specific types of the arguments and the
declared types of the parameters, type precedence lists are used to determine the closest match. See Subclause 9.4,
“Subject routine determination”.
If a <routine invocation> is contained in a <query expression> of a view, a check constraint, or an assertion,
the <triggered action> of a trigger, or in an <SQL-invoked routine>, then the subject routine for that invocation
is determined at the time the view is created, the check constraint is defined, the assertion is created, the trigger
is created, or the SQL-invoked routine is created. If the subject routine is an SQL-invoked procedure, an SQL-
invoked regular function, or a static SQL-invoked method, then the same SQL-invoked routine is executed
whenever the view is used, the check constraint or assertion is evaluated, the trigger is executed, or the SQL-
invoked routine is invoked. If the subject routine is an instance SQL-invoked method, then the SQL-invoked
routine that is executed is determined whenever the view is used, the check constraint or assertion is evaluated,
the trigger is executed, or the SQL-invoked routine is invoked, based on the most specific type of the value
resulting from the evaluation of the SQL argument that correspond to the subject parameter. See the General
Rules of Subclause 10.4, “<routine invocation>”.
All <identifier chain>s in the <routine body> of an SQL routine are resolved to identify the basis and basis
referent at the time that the SQL routine is created. Thus, the same columns and SQL parameters are referenced
whenever the SQL routine is invoked.
An SQL-invoked routine is either deterministic or possibly non-deterministic. An SQL-invoked function that
is deterministic always returns the identical return value for a given list of SQL argument values. An SQL-
invoked procedure that is deterministic always returns the identical values in its output and inout SQL parameters
for a given list of SQL argument values. An SQL-invoked routine is possibly non-deterministic if it might
produce nonidentical results when invoked with the identical list of SQL argument values.
An external routine does not possibly contain SQL, possibly contains SQL, possibly reads SQL-data, or possibly
modifies SQL-data. Only an external routine that possibly contains SQL, possibly reads SQL-data, or possibly
modifies SQL-data is permitted to execute SQL-statements during its invocation. Only an SQL-invoked routine
that possibly reads SQL-data or possibly modifies SQL-data may read SQL-data during its invocation. Only
an SQL-invoked routine that possibly modifies SQL-data may modify SQL-data during its invocation.
An SQL-invoked routine has a routine authorization identifier, which is (directly or indirectly) the authorization
identifier of the owner of the schema that contains the SQL-invoked routine at the time that the SQL-invoked
routine is created.




86 Foundation (SQL/Foundation)                                                       ©ISO/IEC 2003 – All rights reserved
                                                                                             ISO/IEC 9075-2:2003 (E)
                                                                                          4.27 SQL-invoked routines



4.27.3 Execution of SQL-invoked routines

When the <routine body> of an SQL-invoked routine is executed and the new SQL-session context for the
SQL-session is created, the SQL-session user identifier in the new SQL-session context is set to the current
user identifier in the SQL-session context that was active when the SQL-session caused the execution of the
<routine body>. The authorization stack of this new SQL-session context is initially set to empty and a new
pair of identifiers is immediately appended to the authorization stack such that:
— The user identifier is the newly initialized SQL-session user identifier.
— The role name is the current role name of the SQL-session context that was active when the SQL-session
  caused the execution of the <routine body>.
The identifiers in this new entry of the authorization stack are then modified depending on whether the SQL-
invoked routine is an SQL routine or an external routine.
If the SQL-invoked routine is an SQL routine, then the identifiers are determined according to the SQL security
characteristic of the SQL-invoked routine:
— If the SQL security characteristic is DEFINER, then:
    •    If the routine authorization identifier is a user identifier, the user identifier is set to the routine autho-
         rization identifier and the role name is set to null.
    •    Otherwise, the role name is set to the routine authorization identifier and the user identifier is set to
         null.
— If the SQL security characteristic is INVOKER, then the identifiers remain unchanged.
If the SQL-invoked routine is an external routine, then the identifiers are determined according to the external
security characteristic of the SQL-invoked routine:
— If the external security characteristic is DEFINER, then:
    •    If the routine authorization identifier is a user identifier, then the user identifier is set to the routine
         authorization identifier and the role name is set to the null value.
    •    Otherwise, the role name is set to the routine authorization identifier and the user identifier is set to the
         null value.
— If the external security characteristic is INVOKER, then the identifiers remain unchanged.
— If the external security characteristic is IMPLEMENTATION DEFINED, then the identifiers are set to
  implementation-defined values.
An SQL-invoked routine that is an external routine also has an external routine authorization identifier, which
is the <module authorization identifier>, if any, of the <SQL-client module definition> contained in the external
program identified by the <routine body> of the external routine. If that <SQL-client module definition> does
not specify a <module authorization identifier>, then the external routine authorization identifier is an imple-
mentation-defined authorization identifier.
The final value of the user identifier and role name in the authorization stack are used for privilege determination
for access to the SQL objects, if any, referenced in the <SQL procedure statement>s that are executed during
the execution of the <routine body>.



©ISO/IEC 2003 – All rights reserved                                                                      Concepts 87
ISO/IEC 9075-2:2003 (E)
4.27 SQL-invoked routines



An SQL-invoked routine has a routine SQL-path, which is inherited from its containing SQL-schema, the current
SQL-session, or the containing SQL-client module.
An SQL-invoked routine that is an external routine also has an external routine SQL-path, which is derived
from the <module path specification>, if any, of the <SQL-client module definition> contained in the external
program identified by the routine body of the external routine. If that <SQL-client module definition> does not
specify a <module path specification>, then the external routine SQL-path is an implementation-defined SQL-
path. For both SQL and external routines, the SQL-path of the current SQL-session is used to determine the
search order for the subject routine of a <routine invocation> whose <routine name> does not contain a <schema
name> if the <routine invocation> is contained in a <preparable statement> that is prepared in the current SQL-
session or in a <direct SQL statement>. SQL routines use the routine SQL-path to determine the search order
for the subject routines of a <routine invocation> whose <routine name> does not contain a <schema name>
if the <routine invocation> is not contained in a <preparable statement> that is prepared in the current SQL-
session or in a <direct SQL statement>. External routines use the external routine SQL-path to determine the
search order for the subject routine of a <routine invocation> whose <routine name> does not contain a <schema
name> if the <routine invocation> is not contained in a <preparable statement> that is prepared in the current
SQL-session or in a <direct SQL statement>.



4.27.4 Routine descriptors

An SQL-invoked routine is described by a routine descriptor. A routine descriptor includes:
— The routine name of the SQL-invoked routine.
— The specific name of the SQL-invoked routine.
— The routine authorization identifier of the SQL-invoked routine.
— The routine SQL-path of the SQL-invoked routine.
— The name of the language in which the body of the SQL-invoked routine is written.
— For each of the SQL-invoked routine's SQL parameters, the <SQL parameter name>, if it is specified, the
  <data type>, the ordinal position, and an indication of whether the SQL parameter is an input SQL param-
  eter, an output SQL parameter, or both an input SQL parameter and an output SQL parameter.
— An indication of whether the SQL-invoked routine is an SQL-invoked function or an SQL-invoked procedure.
— If the SQL-invoked routine is an SQL-invoked procedure, then the maximum number of dynamic result
  sets.
— An indication of whether the SQL-invoked routine is deterministic or possibly non-deterministic.
— Indications of whether the SQL-invoked routine possibly modifies SQL-data, possibly reads SQL-data,
  possibly contains SQL, or does not possibly contain SQL.
— If the SQL-invoked routine is an SQL-invoked function, then:
    •   The <returns data type> of the SQL-invoked function.
    •   If the <returns data type> simply contains <locator indication>, then an indication that the return value
        is a locator.


88 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                       4.27 SQL-invoked routines



    •    An indication of whether the SQL-invoked function is a type-preserving function or not.
    •    An indication of whether the SQL-invoked function is a mutator function or not.
    •    If the SQL-invoked function is a type-preserving function, then an indication of which parameter is
         the result parameter.
    •    An indication of whether the SQL-invoked function is a null-call function.
    •    An indication of whether the SQL-invoked function is an SQL-invoked method.
— The creation timestamp.
— The last-altered timestamp.
— If the SQL-invoked routine is an SQL routine, then:
    •    The SQL routine body of the SQL-invoked routine.
    •    The SQL security characteristic of the SQL routine.
— If the SQL-invoked routine is an external routine, then:
    •    The external routine name of the external routine.
    •    The <parameter style> of the external routine.
    •    If the external routine specifies a <result cast>, then an indication that it specifies a <result cast> and
         the <data type> specified in the <result cast>. If <result cast> contains <locator indication>, then an
         indication that the <data type> specified in the <result cast> has a locator indication.
    •    The external security characteristic of the external routine.
    •    The external routine authorization identifier of the external routine.
    •    The external routine SQL-path of the external routine.
    •    The effective SQL parameter list of the external routine.
    •    For every SQL parameter that has an associated from-sql function FSF, the specific name of FSF.
    •    For every SQL parameter that has an associated to-sql function TSF, the specific name of TSF.
    •    If the SQL-invoked routine is an external function and if it has a to-sql function TRF associated with
         the result, then the specific name of TRF.
    •    For every SQL parameter whose <SQL parameter declaration> contains <locator indication>, an indi-
         cation that the SQL parameter is a locator parameter.
— The schema name of the schema that includes the SQL-invoked routine.
— If the SQL-invoked routine is an SQL-invoked method, then:
    •    An indication of the user-defined type whose descriptor contains the corresponding method specification
         descriptor.
    •    An indication of whether STATIC was specified.



©ISO/IEC 2003 – All rights reserved                                                                   Concepts 89
ISO/IEC 9075-2:2003 (E)
4.27 SQL-invoked routines



— An indication of whether the SQL-invoked routine is dependent on a user-defined type.
— An indication as to whether or not the SQL-invoked routine requires a new savepoint level to be established
  when it is invoked.



4.28 SQL-paths

An SQL-path is a list of one or more <schema name>s that determines the search order for one of the following:
— The subject routine of a <routine invocation> whose <routine name> does not contain a <schema name>.
— The user-defined type when the <path-resolved user-defined type name> does not contain a <schema
  name>.
The value specified by CURRENT_PATH is the value of the SQL-path of the current SQL-session. This SQL-
path is used to search for the subject routine of a <routine invocation> whose <routine name> does not contain
a <schema name> when the <routine invocation> is contained in <preparable statement>s that are prepared in
the current SQL-session by either an <execute immediate statement> or a <prepare statement>, or contained
in <direct SQL statement>s that are invoked directly. The definition of SQL-schemas specifies an SQL-path
that is used to search for the subject routine of a <routine invocation> whose <routine name>s do not contain
a <schema name> when the <routine invocation> is contained in the <schema definition>.



4.29 Host parameters


4.29.1 Overview of host parameters

A host parameter is declared in an <externally-invoked procedure> by a <host parameter declaration>. A host
parameter either assumes or supplies the value of the corresponding argument in the invocation of the <externally-
invoked procedure>.
A <host parameter declaration> specifies the <data type> of its value, which maps to the host language type
of its corresponding argument. Host parameters cannot be null, except through the use of indicator parameters.



4.29.2 Status parameters

The SQLSTATE host parameter is a status parameter. It is set to status codes that indicate either that a call of
the <externally-invoked procedure> completed successfully or that an exception condition was raised during
execution of the <externally-invoked procedure>.
An <externally-invoked procedure> shall specify the SQLSTATE host parameter. The SQLSTATE host
parameter is a character string host parameter for which exception values are defined in Clause 23, “Status
codes”.



90 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                              ISO/IEC 9075-2:2003 (E)
                                                                                                4.29 Host parameters



If a condition is raised that causes a statement to have no effect other than that associated with raising the
condition (that is, not a completion condition), then the condition is said to be an exception condition or
exception. If a condition is raised that permits a statement to have an effect other than that associated with
raising the condition (corresponding to an SQLSTATE class value of successful completion, warning, or no
data), then the condition is said to be a completion condition.
Exception conditions or completion conditions may be raised during the execution of an <SQL procedure
statement>. One of the conditions becomes the active condition when the <SQL procedure statement> terminates.
If the active condition is an exception condition, then it will be called the active exception condition. If the
active condition is a completion condition, then it will be called the active completion condition.
The completion condition warning is broadly defined as completion in which the effects are correct, but there
is reason to caution the user about those effects. It is raised for implementation-defined conditions as well as
conditions specified in this part of ISO/IEC 9075. The completion condition no data has special significance
and is used to indicate an empty result. The completion condition successful completion is defined to indicate
a completion condition that does not correspond to warning or no data. This includes conditions in which the
SQLSTATE subclass provides implementation-defined information of a non-cautionary nature.
For the purpose of choosing status parameter values to be returned, exception conditions for transaction rollback
have precedence over exception conditions for statement failure. Similarly, the completion condition no data
has precedence over the completion condition warning, which has precedence over the completion condition
successful completion. All exception conditions have precedence over all completion conditions. The values
assigned to SQLSTATE shall obey these precedence requirements.



4.29.3 Data parameters

A data parameter is a host parameter that is used to either assume or supply the value of data exchanged between
a host program and an SQL-implementation.



4.29.4 Indicator parameters

An indicator parameter is an integer host parameter that is specified immediately following another host
parameter. Its primary use is to indicate whether the value that the other host parameter assumes or supplies is
a null value. An indicator host parameter cannot immediately follow another indicator host parameter.
The other use for indicator parameters is to indicate whether string data truncation occurred during a transfer
between a host program and an SQL-implementation in host parameters or host variables. If a non-null string
value is transferred and the length of the target is sufficient to accept the entire source value, then the indicator
parameter or variable is set to 0 (zero) to indicate that truncation did not occur. However, if the length of the
target is insufficient, the indicator parameter or variable is set to the length (in characters or octets, as appropriate)
of the source value to indicate that truncation occurred and to indicate original length in characters or octets,
as appropriate, of the source.




©ISO/IEC 2003 – All rights reserved                                                                        Concepts 91
ISO/IEC 9075-2:2003 (E)
4.29 Host parameters



4.29.5 Locators

A host parameter, a host variable, an SQL parameter of an external routine, or the value returned by an external
function may be specified to be a locator by specifying AS LOCATOR. A locator is an SQL-session object,
rather than SQL-data, that can be used to reference an SQL-data instance. A locator is either a large object
locator, a user-defined type locator, an array locator, or a multiset locator.
A large object locator is one of the following:
— Binary large object locator, a value of which identifies a binary large object.
— Character large object locator, a value of which identifies a large object character string.
— National character large object locator, a value of which identifies a national large object character string.
A user-defined type locator identifies a value of the user-defined type specified by the locator specification.
An array locator identifies a value of the array type specified by the locator specification. A multiset locator
identifies a value of the multiset type specified by the locator specification.
When the value at a site of binary large object type, character large object type, user-defined type, array type,
or multiset type is to be assigned to locator of the corresponding type, an implementation-dependent four-octet
non-zero integer value is generated and assigned to the target. A locator value uniquely identifies a value of
the corresponding type.
A locator may be either valid or invalid. A host parameter or host variable specified as a locator may be further
specified to be a holdable locator. When a locator is initially created, it is marked valid and, if applicable, not
holdable. A <hold locator statement> identifying the locator shall be specifically executed before the end of
the SQL-transaction in which it was created in order to make that locator holdable.
A non-holdable locator remains valid until the end of the SQL-transaction in which it was generated, unless it
is explicitly made invalid by the execution of a <free locator statement> or a <rollback statement> that specifies
a <savepoint clause> is executed before the end of that SQL-transaction if the locator was generated subsequent
to the establishment of the savepoint identified by the <savepoint clause>.
A holdable locator may remain valid beyond the end of the SQL-transaction in which it is generated. A holdable
locator becomes invalid whenever a <free locator statement> identifying that locator is executed or the SQL-
transaction in which it is generated or any subsequent SQL-transaction is rolled back. All locators remaining
valid at the end of an SQL-session are marked invalid when that SQL-session terminates.



4.30 Diagnostics area

A diagnostics area is a place where completion and exception condition information is stored when an SQL-
statement is executed. The diagnostics areas associated with an SQL-session form the diagnostics area stack
of that SQL-session. For definitional purposes, the diagnostics areas in this stack are considered to be numbered
sequentially beginning with 1 (one). An additional diagnostics area is maintained by the SQL-client, as described
in ISO/IEC 9075-1, Subclause 4.2.3.1, “SQL-clients”.
Two operations on diagnostics area stacks are specified in this International Standard for definitional purposes
only. Pushing a diagnostics area stack effectively creates a new first diagnostics area, incrementing the ordinal
position of every existing diagnostics area in the stack by 1 (one). The content of the new first diagnostics area


92 Foundation (SQL/Foundation)                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                             ISO/IEC 9075-2:2003 (E)
                                                                                               4.30 Diagnostics area



is initially a copy of the content of the old (now second) one. Popping a diagnostics area stack effectively
destroys the first diagnostics area in the stack and decrements the ordinal position of every remaining diagnostics
area by 1 (one). The maximum number of diagnostics areas in a diagnostics area stack is implementation-
dependent.
Each diagnostics area consists of a statement area and a sequence of one or more condition areas, each of
which is at any particular time either occupied or vacant. A diagnostics area is empty when each of its condition
areas is vacant; emptying a diagnostics area brings about this state. A statement area consists of a collection of
named statement information items. A condition area consists of a collection of named condition information
items.
A statement information item gives information about the innermost SQL-statement that is being executed
when a condition is raised. A condition information item gives information about the condition itself. The
names and data types of statement and condition information items are given in Table 30, “<identifier>s for
use with <get diagnostics statement>”. Their meanings are given by the General Rules of Subclause 22.1, “<get
diagnostics statement>”.
At the beginning of the execution of any <SQL procedure statement> that is not an <SQL diagnostics statement>,
the first diagnostics area is emptied. An implementation places information about a completion condition or
an exception condition reported by SQLSTATE into a vacant condition area in this diagnostics area. If other
conditions are raised, the extent to which these cause further condition areas to become occupied is implemen-
tation-defined.
An <externally-invoked procedure> containing an <SQL diagnostics statement> returns a code indicating a
completion or an exception condition for that statement via SQLSTATE, but does not necessarily cause any
vacant condition areas to become occupied.
The number of condition areas per diagnostics area is referred to as the condition area limit. An SQL-agent
may set the condition area limit with the <set transaction statement>; if the SQL-agent does not specify the
condition area limit, then the condition area limit is implementation-dependent, but shall be at least one condition
area. An SQL-implementation may place information into this area about fewer conditions than there are con-
dition areas. The ordering of the information about conditions placed into a diagnostics area is implementation-
dependent, except that the first condition area in a diagnostics area always corresponds to the condition specified
by the SQLSTATE value.
The <get diagnostics statement> is used to obtain information from an occupied condition area, referenced by
its ordinal position within the first diagnostics area.



4.31 Standard programming languages

This part of ISO/IEC 9075 specifies the actions of <externally-invoked procedure>s in SQL-client modules
when those <externally-invoked procedure>s are called by programs that conform to certain specified program-
ming language standards. The term “standard PLN program”, where PLN is the name of a programming language,
refers to a program that conforms to the standard for that programming language as specified in Clause 2,
“Normative references”.
This part of ISO/IEC 9075 specifies a mechanism whereby SQL language may be embedded in programs that
otherwise conform to any of the same specified programming language standards.
NOTE 49 — Interfaces between SQL and the Java programming language are defined in ISO/IEC 9075-10 and ISO/IEC 9075-13.



©ISO/IEC 2003 – All rights reserved                                                                       Concepts 93
ISO/IEC 9075-2:2003 (E)
4.31 Standard programming languages



Although there are obviouis mappings between many SQL data types and the data types of most standard pro-
gramming languages, this is not the case for all SQL data types or for all standard programming languages.
For the purposes of interfacing with programming languages, the data types DATE, TIME, TIMESTAMP, and
INTERVAL shall be converted to or from character strings in those programming languages by means of a
<cast specification>. It is anticipated that future evolution of programming language standards will support
data types corresponding to these four SQL data types; this standard will then be amended to reflect the avail-
ability of those corresponding data types.
The data types CHARACTER, CHARACTER VARYING, and CHARACTER LARGE OBJECT are also
mapped to character strings in the programming languages. However, because the facilities available in the
programming languages do not provide the same capabilities as those available in SQL, there shall be agreement
between the host program and SQL regarding the specific format of the character data being exchanged. Specific
syntax for this agreement is provided in this part of ISO/IEC 9075.
For standard programming languages C and COBOL, BOOLEAN values are mapped to integer variables in
the host language. For standard programming languages Ada, Fortran, Pascal, and PL/I, BOOLEAN variables
are directly supported.
For the purposes of interfacing with programming languages, the data type ARRAY shall be converted to a
locator (see Subclause 4.29.5, “Locators”).
For the purposes of interfacing with programming languages, the data type MULTISET shall be converted to
a locator (see Subclause 4.29.5, “Locators”).
For the purposes of interfacing with programming languages, user-defined types shall be handled with a locator
(see Subclause 4.29.5, “Locators”) or transformed to another SQL data type that has a defined mapping to the
host language (see Subclause 4.7.7, “Transforms for user-defined types”).



4.32 Cursors


4.32.1 General description of cursors

A cursor is a mechanism by which the rows of a table may be acted on (e.g., returned to a host programming
language) one at a time.
A cursor is specified by a <declare cursor>, a <dynamic declare cursor>, or an <allocate cursor statement>. A
cursor specified by a <dynamic declare cursor> is a declared dynamic cursor. A cursor specified by an <allocate
cursor statement> is an extended dynamic cursor. A dynamic cursor is either a declared dynamic cursor or an
extended dynamic cursor.
For every <declare cursor> in an SQL-client module, a cursor is effectively created when an SQL-transaction
(see Subclause 4.35, “SQL-transactions”) referencing the SQL-client module is initiated.
For every <dynamic declare cursor> in an <SQL-client module definition>, a cursor is effectively created when
an SQL-transaction (see Subclause 4.35, “SQL-transactions”) referencing the <SQL-client module definition>
is initiated. An extended dynamic cursor is also effectively created when an <allocate cursor statement> is
executed within an SQL-session and destroyed when that SQL-session is terminated.



94 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                                    4.32 Cursors



A dynamic cursor is destroyed when a <deallocate prepared statement> is executed that deallocates the prepared
statement on which the dynamic cursor is based.
One of the properties that may be specified for a cursor determines whether or not it is a holdable cursor:
— A cursor that is not a holdable cursor is closed when the SQL-transaction in which it was created is termi-
  nated.
— A holdable cursor is not closed if that cursor is in the open state at the time that the SQL-transaction is
  terminated with a commit operation. A holdable cursor that is in the closed state at the time that the SQL-
  transaction is terminated remains closed. A holdable cursor is closed no matter what its state if the SQL-
  transaction is terminated with a rollback operation.
— A holdable cursor is closed and destroyed when the SQL-session in which it was created is terminated.
NOTE 50 — A holdable cursor may be said to be “holdable” or “held”.

A cursor is in either the open state or the closed state. The initial state of a cursor is the closed state. A cursor
is placed in the open state by an <open statement> and returned to the closed state by a <close statement> or
a <rollback statement>. A dynamic cursor is placed in the open state by a <dynamic open statement> and
returned to the closed state by a <dynamic close statement>. An open cursor that was not defined as a holdable
cursor is also closed by a <commit statement>.
A cursor in the open state identifies a table, an ordering of the rows of that table, and a position relative to that
ordering. If the <declare cursor> does not contain an <order by clause>, or contains an <order by clause> that
does not specify the order of the rows completely, then the rows of the table have an order that is defined only
to the extent that the <order by clause> specifies an order and is otherwise implementation-dependent.
When the ordering of a cursor is not defined by an <order by clause>, the relative position of two rows is
implementation-dependent. When the ordering of a cursor is partially determined by an <order by clause>, then
the relative positions of two rows are determined only by the <order by clause>; if the two rows have equal
values for the purpose of evaluating the <order by clause>, then their relative positions are implementation-
dependent.
A cursor is either updatable or not updatable. If FOR UPDATE OF is specified for the cursor, or if the table
identified by the cursor is simply updatable and FOR READ ONLY, SCROLL, and ORDER BY are not spec-
ified for the cursor, then the cursor is updatable; otherwise, the cursor is not updatable. The operations of update
and delete are permitted for updatable cursors, subject to constraining Access Rules.
The position of a cursor in the open state is either before a certain row, on a certain row, or after the last row.
If a cursor is on a row, then that row is the current row of the cursor. A cursor may be before the first row or
after the last row of a table even though the table is empty. When a cursor is initially opened, the position of
the cursor is before the first row.
A holdable cursor that has been held open retains its position when the new SQL-transaction is initiated.
However, before either an <update statement: positioned> or a <delete statement: positioned> is permitted to
reference that cursor in the new SQL-transaction, a <fetch statement> shall be issued against the cursor.




©ISO/IEC 2003 – All rights reserved                                                                    Concepts 95
ISO/IEC 9075-2:2003 (E)
4.32 Cursors



4.32.2 Operations on and using cursors

A <fetch statement> positions an open cursor on a specified row of the cursor's ordering and retrieves the values
of the columns of that row. An <update statement: positioned> updates the current row of the cursor. A <delete
statement: positioned> deletes the current row of the cursor.
A <dynamic fetch statement> positions an open dynamic cursor on a specified row of the cursor's ordering and
retrieves the values of the columns of that row. A <dynamic update statement: positioned> updates the current
row of the cursor. A <dynamic delete statement: positioned> deletes the current row of the cursor.
If an error occurs during the execution of an SQL-statement that identifies a cursor, then, except where otherwise
explicitly defined, the effect, if any, on the position or state of that cursor is implementation-dependent.
If a completion condition is raised during the execution of an SQL-statement that identifies a cursor, then the
particular SQL-statement identifying that open cursor on which the completion condition is returned is imple-
mentation-dependent.
Another property of a cursor is its sensitivity, which may be sensitive, insensitive, or asensitive, depending on
whether SENSITIVE, INSENSITIVE, or ASENSITIVE is specified or implied. The following paragraphs
define several terms used to discuss issues relating to cursor sensitivity:
A change to SQL-data is said to be independent of a cursor CR if and only if it is not made by an <update
statement: positioned> or a <delete statement: positioned> that is positioned on CR.
A change to SQL-data is said to be significant to CR if and only if it is independent of CR, and, had it been
committed before CR was opened, would have caused the table associated with the cursor to be different in
any respect.
A change to SQL-data is said to be visible to CR if and only if it has an effect on CR by inserting a row in CR,
deleting a row from CR, changing the value of a column of a row of CR, or reordering the rows of CR.
If a cursor is open, and the SQL-transaction in which the cursor was opened makes a significant change to
SQL-data, then whether that change is visible through that cursor before it is closed is determined as follows:
— If the cursor is insensitive, then significant changes are not visible.
— If the cursor is sensitive, then significant changes are visible.
— If the cursor is asensitive, then the visibility of significant changes is implementation-dependent.
If a holdable cursor is open during an SQL-transaction T and it is held open for a subsequent SQL-transaction,
then whether any significant changes made to SQL-data (by T or any subsequent SQL-transaction in which the
cursor is held open) are visible through that cursor in the subsequent SQL-transaction before that cursor is
closed is determined as follows:
— If the cursor is insensitive, then significant changes are not visible.
— If the cursor is sensitive, then the visibility of significant changes is implementation-defined.
— If the cursor is asensitive, then the visibility of significant changes is implementation-dependent.
A <declare cursor> DC that specifies WITH RETURN is called a result set cursor. The <cursor specification>
CR contained in DC defines a table T; the term result set is used to refer to T. A result set cursor, if declared




96 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                                               4.32 Cursors



in an SQL-invoked procedure and not closed when the procedure returns to its invoker, returns a result set to
the invoker.



4.33 SQL-statements


4.33.1 Classes of SQL-statements

An SQL-statement is a string of characters that conforms to the Format and Syntax Rules specified in the parts
of ISO/IEC 9075. Most SQL-statements can be prepared for execution and executed in an SQL-client module,
in which case they are prepared when the SQL-client module is created and executed when the containing
externally-invoked procedure is called (see Subclause 4.22, “SQL-client modules”).
Most SQL-statements can be prepared for execution and executed in additional ways. These are:
— In an embedded SQL host program, in which case they are prepared when the embedded SQL host program
  is preprocessed (see Subclause 4.23, “Embedded syntax”).
— Being prepared and executed by the use of SQL-dynamic statements (which are themselves executed in an
  SQL-client module or an embedded SQL host program—see Subclause 4.24, “Dynamic SQL concepts”).
— Direct invocation, in which case they are effectively prepared immediately prior to execution (see
  Subclause 4.25, “Direct invocation of SQL”).
In this part of ISO/IEC 9075, there are at least six ways of classifying SQL-statements:
— According to their effect on SQL objects, whether persistent objects, i.e., SQL-data, SQL-client modules,
  and schemas, or transient objects, such as SQL-sessions and other SQL-statements.
— According to whether or not they start an SQL-transaction, or can, or shall, be executed when no SQL-
  transaction is active.
— According to whether they possibly read SQL-data or possibly modify SQL-data.
— According to whether or not they may be embedded.
— According to whether they may be dynamically prepared and executed.
— According to whether or not they may be directly executed.
This part of ISO/IEC 9075 permits SQL-implementations to provide additional, implementation-defined,
statements that may fall into any of these categories. This Subclause will not mention those statements again,
as their classification is implementation-defined.
The main classes of SQL-statements are:
— SQL-schema statements; these may have a persistent effect on the set of schemas.
— SQL-data statements; some of these, the SQL-data change statements, may have a persistent effect on SQL-
  data.




©ISO/IEC 2003 – All rights reserved                                                              Concepts 97
ISO/IEC 9075-2:2003 (E)
4.33 SQL-statements



— SQL-transaction statements; except for the <commit statement>, these, and the following classes, have no
  effects that persist when an SQL-session is terminated.
— SQL-control statements.
— SQL-connection statements.
— SQL-session statements.
— SQL-diagnostics statements.
— SQL-dynamic statements.
— SQL embedded exception declaration.



4.33.2 SQL-statements classified by function


4.33.2.1 SQL-schema statements

The following are the SQL-schema statements:
— <schema definition>.
— <drop schema statement>.
— <domain definition>.
— <drop domain statement>.
— <table definition>.
— <drop table statement>.
— <view definition>.
— <drop view statement>.
— <assertion definition>.
— <drop assertion statement>.
— <alter table statement>.
— <alter domain statement>.
— <grant privilege statement>.
— <revoke statement>.
— <character set definition>.
— <drop character set statement>.



98 Foundation (SQL/Foundation)                                               ©ISO/IEC 2003 – All rights reserved
                                             ISO/IEC 9075-2:2003 (E)
                                                4.33 SQL-statements



— <collation definition>.
— <drop collation statement>.
— <transliteration definition>.
— <drop transliteration statement>.
— <trigger definition>.
— <drop trigger statement>.
— <user-defined type definition>.
— <alter type statement>.
— <drop data type statement>.
— <user-defined ordering definition>.
— <drop user-defined ordering statement>.
— <user-defined cast definition>.
— <drop user-defined cast statement>.
— <transform definition>.
— <alter transform statement>.
— <drop transform statement>.
— <schema routine>.
— <alter routine statement>.
— <drop routine statement>.
— <sequence generator definition>.
— <alter sequence generator statement>.
— <drop sequence generator statement>.
— <role definition>.
— <grant role statement>.
— <drop role statement>.



4.33.2.2 SQL-data statements

The following are the SQL-data statements:
— <temporary table declaration>.



©ISO/IEC 2003 – All rights reserved                    Concepts 99
ISO/IEC 9075-2:2003 (E)
4.33 SQL-statements



— <declare cursor>.
— <open statement>.
— <close statement>.
— <fetch statement>.
— <select statement: single row>.
— <free locator statement>.
— <hold locator statement>.
— <dynamic declare cursor>.
— <allocate cursor statement>.
— <dynamic select statement>.
— <dynamic open statement>.
— <dynamic close statement>.
— <dynamic fetch statement>.
— <direct select statement: multiple rows>.
— <dynamic single row select statement>.
— All SQL-data change statements.



4.33.2.3 SQL-data change statements

The following are the SQL-data change statements:
— <insert statement>.
— <delete statement: searched>.
— <delete statement: positioned>.
— <update statement: searched>.
— <update statement: positioned>.
— <merge statement>.
— <dynamic delete statement: positioned>.
— <preparable dynamic delete statement: positioned>.
— <dynamic update statement: positioned>.
— <preparable dynamic update statement: positioned>.



100 Foundation (SQL/Foundation)                        ©ISO/IEC 2003 – All rights reserved
                                                    ISO/IEC 9075-2:2003 (E)
                                                       4.33 SQL-statements



4.33.2.4 SQL-transaction statements

The following are the SQL-transaction statements:
— <start transaction statement>.
— <set transaction statement>.
— <set constraints mode statement>.
— <commit statement>.
— <rollback statement>.
— <savepoint statement>.
— <release savepoint statement>.



4.33.2.5 SQL-connection statements

The following are the SQL-connection statements:
— <connect statement>.
— <set connection statement>.
— <disconnect statement>.



4.33.2.6 SQL-control statements

The following are the SQL-control statements:
— <call statement>.
— <return statement>.



4.33.2.7 SQL-session statements

The following are the SQL-session statements:
— <set session characteristics statement>.
— <set session user identifier statement>.
— <set role statement>.
— <set local time zone statement>.


©ISO/IEC 2003 – All rights reserved                          Concepts 101
ISO/IEC 9075-2:2003 (E)
4.33 SQL-statements



— <set catalog statement>.
— <set schema statement>.
— <set names statement>.
— <set path statement>.
— <set transform group statement>.
— <set session collation statement>.



4.33.2.8 SQL-diagnostics statements

The following are the SQL-diagnostics statements:
— <get diagnostics statement>.



4.33.2.9 SQL-dynamic statements

The following are the SQL-dynamic statements:
— <execute immediate statement>.
— <allocate descriptor statement>.
— <deallocate descriptor statement>.
— <get descriptor statement>.
— <set descriptor statement>.
— <prepare statement>.
— <deallocate prepared statement>.
— <describe input statement>.
— <describe output statement>.
— <execute statement>.



4.33.2.10SQL embedded exception declaration

The following is the SQL embedded exception declaration:
— <embedded exception declaration>.




102 Foundation (SQL/Foundation)                            ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                                        4.33 SQL-statements



4.33.3 SQL-statements and SQL-data access indication

Some SQL-statements may be classified either as SQL-statements that possibly read SQL-data or that possibly
modify SQL-data. A given SQL-statement belongs to at most one such class.
The following SQL-statements possibly read SQL-data:
— SQL-data statements other than SQL-data change statements, <free locator statement>, and <hold locator
  statement>.
— SQL-statements that simply contain a <subquery> and that are not SQL-statements that possibly modify
  SQL-data.
The following SQL-statements possibly modify SQL-data:
— SQL-schema statements.
— SQL-data change statements.



4.33.4 SQL-statements and transaction states

The following SQL-statements are transaction-initiating SQL-statements, i.e., if there is no current SQL-
transaction, and a statement of this class is executed, an SQL-transaction is initiated:
— All SQL-schema statements
— The SQL-transaction statements <commit statement> and <rollback statement>, if they specify AND
  CHAIN.
— The following SQL-data statements:
    •    <open statement>.
    •    <close statement>.
    •    <fetch statement>.
    •    <select statement: single row>.
    •    <insert statement>.
    •    <delete statement: searched>.
    •    <delete statement: positioned>.
    •    <update statement: searched>.
    •    <update statement: positioned>.
    •    <merge statement>.
    •    <allocate cursor statement>.
    •    <dynamic open statement>.


©ISO/IEC 2003 – All rights reserved                                                            Concepts 103
ISO/IEC 9075-2:2003 (E)
4.33 SQL-statements



    •   <dynamic close statement>.
    •   <dynamic fetch statement>.
    •   <direct select statement: multiple rows>.
    •   <dynamic single row select statement>.
    •   <dynamic delete statement: positioned>.
    •   <preparable dynamic delete statement: positioned>.
    •   <dynamic update statement: positioned>.
    •   <preparable dynamic update statement: positioned>.
    •   <free locator statement>.
    •   <hold locator statement>.
— <start transaction statement>.
— The following SQL-dynamic statements:
    •   <describe input statement>.
    •   <describe output statement>.
    •   <allocate descriptor statement>.
    •   <deallocate descriptor statement>.
    •   <get descriptor statement>.
    •   <set descriptor statement>.
    •   <prepare statement>.
    •   <deallocate prepared statement>.
Whether or not an <execute immediate statement> starts a transaction depends on the content of the <SQL
statement variable> referenced by the <execute immediate statement> at the time it is executed. Whether or
not an <execute statement> starts a transaction depends on the content of the <SQL statement variable> referenced
by the <prepare statement> at the time the prepared statement referenced by the <execute statement> was pre-
pared. In both cases, if the content of the <SQL statement variable> was a transaction-initiating SQL-statement,
then the <execute immediate statement> or <execute statement> is treated as a transaction-initiating statement;
otherwise it is not treated as a transaction-initiating statement.
The following SQL-statements are not transaction-initiating SQL-statements, i.e., if there is no current SQL-
transaction, and a statement of this class is executed, no SQL-transaction is initiated.
— All SQL-transaction statements except <start transaction statement>s and <commit statement>s and
  <rollback statement>s that specify AND CHAIN.
— All SQL-connection statements.
— All SQL-session statements.



104 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                                       4.33 SQL-statements



— All SQL-diagnostics statements.
— SQL embedded exception declarations.
— The following SQL-data statements:
    •    <temporary table declaration>.
    •    <declare cursor>.
    •    <dynamic declare cursor>.
    •    <dynamic select statement>.
The following SQL-statements are possibly transaction-initiating SQL-statements:
— <return statement>.
— <call statement>.
If the initiation of an SQL-transaction occurs in an atomic execution context, and an SQL-transaction has
already completed in this context, then an exception condition is raised: invalid transaction initiation.
If an <SQL control statement> causes the evaluation of a <subquery> and there is no current SQL-transaction,
then an SQL-transaction is initiated before evaluation of the <subquery>.



4.33.5 SQL-statement atomicity and statement execution contexts

The execution of all SQL-statements other than certain SQL-control statements and certain SQL-transaction
statements is atomic with respect to recovery. Such an SQL-statement is called an atomic SQL-statement. An
SQL-statement that is not an atomic SQL-statement is called a non-atomic SQL statement.
The following are non-atomic SQL-statements:
— <call statement>
— <execute statement>
— <execute immediate statement>
— <commit statement>
— <return statement>
— <rollback statement>
— <savepoint statement>
All other SQL-statements are atomic SQL-statements.
A statement execution context is either atomic or non-atomic.
The statement execution context brought into existence by the execution of a non-atomic SQL-statement is a
non-atomic execution context.



©ISO/IEC 2003 – All rights reserved                                                            Concepts 105
ISO/IEC 9075-2:2003 (E)
4.33 SQL-statements



The statement execution context brought into existence by the execution of an atomic SQL-statement or the
evaluation of a <subquery> is an atomic execution context.
Within one execution context, another execution context may become active. This latter execution context is
said to be a more recent execution context than the former. If there is no execution context that is more recent
than execution context EC, then EC is said to be the most recent execution context.
If there is no atomic execution context that is more recent than atomic execution context AEC, then AEC is the
most recent atomic execution context.
An SQL-transaction cannot be explicitly terminated within an atomic execution context. If the execution of an
atomic SQL-statement is unsuccessful, then the changes to SQL-data or schemas made by the SQL-statement
are canceled.



4.33.6 Embeddable SQL-statements

The following SQL-statements are embeddable in an embedded SQL host program, and may be the <SQL
procedure statement> in an <externally-invoked procedure> in an <SQL-client module definition>:
— All SQL-schema statements.
— All SQL-transaction statements.
— All SQL-connection statements.
— All SQL-session statements.
— All SQL-dynamic statements.
— All SQL-diagnostics statements.
— The following SQL-data statements:
    •   <allocate cursor statement>.
    •   <open statement>.
    •   <dynamic open statement>.
    •   <close statement>.
    •   <dynamic close statement>.
    •   <fetch statement>.
    •   <dynamic fetch statement>.
    •   <select statement: single row>.
    •   <insert statement>.
    •   <delete statement: searched>.
    •   <delete statement: positioned>.



106 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                                      4.33 SQL-statements



    •    <dynamic delete statement: positioned>.
    •    <update statement: searched>.
    •    <update statement: positioned>.
    •    <merge statement>.
    •    <dynamic update statement: positioned>.
    •    <hold locator statement>.
    •    <free locator statement>.
— The following SQL-control statements:
    •    <call statement>.
    •    <return statement>.
The following SQL-statements are embeddable in an embedded SQL host program, and may occur in an <SQL-
client module definition>, though not in an <externally-invoked procedure>:
— <temporary table declaration>.
— <declare cursor>.
— <dynamic declare cursor>.
The following SQL-statements are embeddable in an embedded SQL host program, but may not occur in an
<SQL-client module definition>:
— SQL embedded exception declarations.
Consequently, the following SQL-data statements are not embeddable in an embedded SQL host program, nor
may they occur in an <SQL-client module definition>, nor be the <SQL procedure statement> in an <externally-
invoked procedure> in an <SQL-client module definition>:
— <dynamic select statement>.
— <dynamic single row select statement>.
— <direct select statement: multiple rows>.
— <preparable dynamic delete statement: positioned>.
— <preparable dynamic update statement: positioned>.



4.33.7 Preparable and immediately executable SQL-statements

The following SQL-statements are preparable:
— All SQL-schema statements.
— All SQL-transaction statements.


©ISO/IEC 2003 – All rights reserved                                                           Concepts 107
ISO/IEC 9075-2:2003 (E)
4.33 SQL-statements



— All SQL-session statements.
— The following SQL-data statements:
   •   <delete statement: searched>.
   •   <dynamic select statement>.
   •   <dynamic single row select statement>.
   •   <insert statement>.
   •   <update statement: searched>.
   •   <merge statement>.
   •   <preparable dynamic delete statement: positioned>.
   •   <preparable dynamic update statement: positioned>.
   •   <preparable implementation-defined statement>.
   •   <hold locator statement>.
   •   <free locator statement>.
— The following SQL-control statements:
   •   <call statement>.
Consequently, the following SQL-statements are not preparable:
— All SQL-connection statements.
— All SQL-dynamic statements.
— All SQL-diagnostics statements.
— SQL embedded exception declarations.
— The following SQL-data statements:
   •   <allocate cursor statement>.
   •   <open statement>.
   •   <dynamic open statement>.
   •   <close statement>.
   •   <dynamic close statement>.
   •   <fetch statement>.
   •   <dynamic fetch statement>.
   •   <select statement: single row>.
   •   <delete statement: positioned>.



108 Foundation (SQL/Foundation)                                  ©ISO/IEC 2003 – All rights reserved
                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                                      4.33 SQL-statements



    •    <dynamic delete statement: positioned>.
    •    <update statement: positioned>.
    •    <dynamic update statement: positioned>.
    •    <direct select statement: multiple rows>.
    •    <temporary table declaration>.
    •    <declare cursor>.
    •    <dynamic declare cursor>.
— The following SQL-control statements:
    •    <return statement>.
Any preparable SQL-statement can be executed immediately, with the exception of:
— <dynamic select statement>.
— <dynamic single row select statement>.



4.33.8 Directly executable SQL-statements

The following SQL-statements may be executed directly:
— All SQL-schema statements.
— All SQL-transaction statements.
— All SQL-connection statements.
— All SQL-session statements.
— The following SQL-data statements:
    •    <temporary table declaration>.
    •    <direct select statement: multiple rows>.
    •    <insert statement>.
    •    <delete statement: searched>.
    •    <update statement: searched>.
    •    <merge statement>.
— The following SQL-control statements:
    •    <call statement>.
    •    <return statement>.



©ISO/IEC 2003 – All rights reserved                                                         Concepts 109
ISO/IEC 9075-2:2003 (E)
4.33 SQL-statements



Consequently, the following SQL-statements may not be executed directly:
— All SQL-dynamic statements.
— All SQL-diagnostics statements.
— SQL embedded exception declarations.
— The following SQL-data statements:
   •   <declare cursor>.
   •   <dynamic declare cursor>.
   •   <allocate cursor statement>.
   •   <open statement>.
   •   <dynamic open statement>.
   •   <close statement>.
   •   <dynamic close statement>.
   •   <fetch statement>.
   •   <dynamic fetch statement>.
   •   <select statement: single row>.
   •   <dynamic select statement>.
   •   <dynamic single row select statement>.
   •   <delete statement: positioned>.
   •   <dynamic delete statement: positioned>.
   •   <preparable dynamic delete statement: positioned>.
   •   <update statement: positioned>.
   •   <dynamic update statement: positioned>.
   •   <preparable dynamic update statement: positioned>.
— <free locator statement>.
— <hold locator statement>.




110 Foundation (SQL/Foundation)                                            ©ISO/IEC 2003 – All rights reserved
                                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                                                  4.34 Basic security model



4.34 Basic security model


4.34.1 Authorization identifiers

An <authorization identifier> identifies a set of privileges. An <authorization identifier> is either a user identifier
or a role name. A user identifier represents a user of the database system. The mapping of user identifiers to
operating system users is implementation-dependent. A role name represents a role.



4.34.1.1 SQL-session authorization identifiers

An SQL-session has a <user identifier> called the SQL-session user identifier. When an SQL-session is initiated,
the SQL-session user identifier is determined in an implementation-defined manner, unless the session is initiated
using a <connect statement>. The value of the SQL-session user identifier can never be the null value. The
SQL-session user identifier can be determined by using SESSION_USER.
An SQL-session context contains a time-varying sequence of cells, known as the authorization stack, each cell
of which contains either a user identifier, a role name, or both. This stack is maintained using a “last-in, first-
out” discipline, and effectively only the top cell is visible. When an SQL-session is started, by explicit or implicit
execution of a <connect statement>, the authorization stack is initialized with one cell, which contains only the
user identifier known as the SQL-session user identifier; a role name, known as the SQL-session role name
may be added subsequently.
Let E be an externally-invoked procedure, SQL-invoked routine, triggered action, prepared statement, or directly
executed statement. When E is invoked, a copy of the top cell is pushed onto the authorization stack. If the
invocation of E is to be under definer's rights, then the contents of the top cell are replaced with the authorization
identifier of the owner of E. On completion of the execution of E, the top cell is removed.
The contents of the top cell in the authorization stack of the current SQL-session context determine the privileges
for the execution of each SQL-statement. The user identifier, if any, in this cell is known as the current user
identifier; the role name, if any, is known as the current role name. They may be determined using CUR-
RENT_USER and CURRENT_ROLE, respectively.
At a given time, there may be no current user identifier or no current role name, but at least one or the other is
always present.
NOTE 51 — The privileges granted to PUBLIC are available to all of the <authorization identifier>s in the SQL-environment.

The <set session user identifier statement> changes the value of the current user identifier and of the SQL-
session user identifier. The <set role statement> changes the value of the current role name.
The term current authorization identifier denotes an authorization identifier in the top cell of the authorization
stack.




©ISO/IEC 2003 – All rights reserved                                                                             Concepts 111
ISO/IEC 9075-2:2003 (E)
4.34 Basic security model



4.34.1.2 SQL-client module authorization identifiers

If an <SQL-client module definition> contains a <module authorization identifier> MAI, then MAI is the owner
of the corresponding SQL-client module M and is used as the current authorization identifier for the execution
of each externally-invoked procedure in M. If M has no owner, then the current user identifier and the current
role name of the SQL-session are used as the current user identifier and current role name, respectively, for the
execution of each externally-invoked procedure in M.



4.34.1.3 SQL-schema authorization identifiers

Every schema has an owner, determined at the time of its creation from a <schema definition> SD. That owner
is
Case:
— If SD simply contains a <schema authorization identifier> SAI, then SAI.
— If SD is simply contained in an <SQL-client module definition> that contains a <module authorization
  identifier> MAI, then MAI.
— Otherwise, the SQL-session user identifier.



4.34.2 Privileges

A privilege authorizes a given category of <action> to be performed on a specified base table, view, column,
domain, character set, collation, transliteration, user-defined type, trigger, SQL-invoked routine, or sequence
generator by a specified <authorization identifier>.
Each privilege is represented by a privilege descriptor. A privilege descriptor contains:
— The identification of the base table, view, column, domain, character set, collation, transliteration, user-
  defined type, table/method pair, trigger, SQL-invoked routine, or sequence generator that the descriptor
  describes.
— The <authorization identifier> of the grantor of the privilege.
— The <authorization identifier> of the grantee of the privilege.
— Identification of the <action> that the privilege allows.
— An indication of whether or not the privilege is grantable.
— An indication of whether or not the privilege has the WITH HIERARCHY OPTION specified.
The <action>s that can be specified are:
— INSERT
— INSERT (<column name list>)


112 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                                        4.34 Basic security model



— UPDATE
— UPDATE (<column name list>)
— DELETE
— SELECT
— SELECT (<column name list>)
— SELECT (<privilege method list>)
— REFERENCES
— REFERENCES (<column name list>)
— USAGE
— UNDER
— TRIGGER
— EXECUTE
A privilege descriptor with an <action> of INSERT, UPDATE, DELETE, SELECT, TRIGGER, or REFER-
ENCES is called a table privilege descriptor and identifies the existence of a privilege on the table identified
by the privilege descriptor.
A privilege descriptor with an <action> of SELECT (<column name list>), INSERT (<column name list>),
UPDATE (<column name list>), or REFERENCES (<column name list>) is called a column privilege
descriptor and identifies the existence of a privilege on the columns in the table identified by the privilege
descriptor.
A privilege descriptor with an <action> of SELECT (<privilege method list>) is called a table/method privilege
descriptor and identifies the existence of a privilege on the methods of the structured type of the table identified
by the privilege descriptor.
A table privilege descriptor specifies that the privilege identified by the <action> (unless the <action> is
DELETE) is to be automatically granted by the grantor to the grantee on all columns subsequently added to
the table.
A privilege descriptor with an <action> of USAGE is called a usage privilege descriptor and identifies the
existence of a privilege on the domain, user-defined type, character set, collation, transliteration, or sequence
generator identified by the privilege descriptor.
A privilege descriptor with an <action> of UNDER is called an under privilege descriptor and identifies the
existence of the privilege on the structured type identified by the privilege descriptor.
A privilege descriptor with an <action> of EXECUTE is called an execute privilege descriptor and identifies
the existence of a privilege on the SQL-invoked routine identified by the privilege descriptor.
A grantable privilege is a privilege associated with a schema that may be granted by a <grant statement>. The
WITH GRANT OPTION clause of a <grant statement> specifies whether the <authorization identifier> recip-
ient of a privilege (acting as a grantor) may grant it to others.




©ISO/IEC 2003 – All rights reserved                                                                  Concepts 113
ISO/IEC 9075-2:2003 (E)
4.34 Basic security model



Privilege descriptors that represent privileges for the owner of an object have a special grantor value, “_SYS-
TEM”. This value is reflected in the Information Schema for all privileges that apply to the owner of the object.
NOTE 52 — The Information Schema is defined in ISO/IEC 9075-11.

A schema that is owned by a given schema <user identifier> or schema <role name> may contain privilege
descriptors that describe privileges granted to other <authorization identifier>s (grantees). The granted privileges
apply to objects defined in the current schema.
Direct SQL statements are always executed under invoker's rights.



4.34.3 Roles

A role, identified by a <role name>, is a set of privileges defined by the union of the privileges defined by the
privilege descriptors whose grantee is that <role name> and the sets of privileges for the <role name>s defined
by the role authorization descriptors whose grantee is the first <role name>. A role may be granted to <autho-
rization identifier>s with a <grant role statement>. No cycles of role grants are allowed.
The WITH ADMIN OPTION clause of the <grant role statement> specifies whether the recipient of a role may
grant it to others.
Each grant is represented and identified by a role authorization descriptor. A role authorization descriptor
includes:
— The role name of the role.
— The <authorization identifier> of the grantor.
— The <authorization identifier> of the grantee.
— An indication of whether or not the role was granted with the WITH ADMIN OPTION and hence is
  grantable.
Because roles may be granted to other roles, a role is said to “contain” other roles. The set of roles X contained
in any role A is defined as the set of roles identified by role authorization descriptors whose grantee is A, together
with all other roles contained by roles in X.



4.34.4 Security model definitions

The term enabled authorization identifiers denotes the set of authorization identifiers whose members are the
current user identifier, the current role name, and every role name that is contained in the current role name.
The term applicable privileges for an authorization identifier A denotes the union of the set of privileges whose
grantee is PUBLIC with the set of privileges whose grantees are A and, if A is a role name, every role name
contained in A.
The term current privileges denotes the union of the applicable privileges for the current user identifier with
the applicable privileges for the current role name.




114 Foundation (SQL/Foundation)                                                       ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                                           4.35 SQL-transactions



4.35 SQL-transactions


4.35.1 General description of SQL-transactions

An SQL-transaction (transaction) is a sequence of executions of SQL-statements that is atomic with respect to
recovery. These operations are performed by one or more compilation units and SQL-client modules. The
operations comprising an SQL-transaction may also be performed by the direct invocation of SQL.
It is implementation-defined whether or not the execution of an SQL-data statement is permitted to occur within
the same SQL-transaction as the execution of an SQL-schema statement. If it does occur, then the effect on
any open cursor or deferred constraint is implementation-defined. There may be additional implementation-
defined restrictions, requirements, and conditions. If any such restrictions, requirements, or conditions are
violated, then an implementation-defined exception condition or a completion condition warning with an
implementation-defined subclass code is raised.
It is implementation-defined whether or not the dynamic execution of an <SQL dynamic data statement> is
permitted to occur within the same SQL-transaction as the dynamic execution of an SQL-schema statement.
If it does occur, then the effect on any open cursor, prepared dynamic statement, or deferred constraint is
implementation-defined. There may be additional implementation-defined restrictions, requirements, and con-
ditions. If any such restrictions, requirements, or conditions are violated, then an implementation-defined
exception condition or a completion condition warning with an implementation-defined subclass code is raised.
Each SQL-client module that executes an SQL-statement of an SQL-transaction is associated with that SQL-
transaction. Each direct invocation of SQL that executes an SQL-statement of an SQL-transaction is associated
with that SQL-transaction. An SQL-transaction is initiated when no SQL-transaction is currently active by
direct invocation of SQL that results in the execution of a transaction-initiating <direct SQL statement>. An
SQL-transaction is initiated when no SQL-transaction is currently active and an <externally-invoked procedure>
is called that results in the execution of a transaction-initiating SQL-statement. An SQL-transaction is terminated
by a <commit statement> or a <rollback statement>. If an SQL-transaction is terminated by successful execution
of a <commit statement>, then all changes made to SQL-data or schemas by that SQL-transaction are made
persistent and accessible to all concurrent and subsequent SQL-transactions. If an SQL-transaction is terminated
by a <rollback statement> or unsuccessful execution of a <commit statement>, then all changes made to SQL-
data or schemas by that SQL-transaction are canceled. Committed changes cannot be canceled. If execution of
a <commit statement> is attempted, but certain exception conditions are raised, it is unknown whether or not
the changes made to SQL-data or schemas by that SQL-transaction are canceled or made persistent.



4.35.2 Savepoints

An SQL-transaction may be partially rolled back by using a savepoint. The savepoint and its <savepoint name>
are established within an SQL-transaction when a <savepoint statement> is executed.
An SQL-transaction has one or more savepoint levels, exactly one of which is the current savepoint level. The
savepoint levels of an SQL-transaction are nested, such that when a new savepoint level NSL is established,
the current savepoint level CSL ceases to be current and NSL becomes current. When NSL is destroyed, CSL
becomes current again.



©ISO/IEC 2003 – All rights reserved                                                                 Concepts 115
ISO/IEC 9075-2:2003 (E)
4.35 SQL-transactions



A savepoint level exists in an SQL-session SS even when no SQL-transaction is active, this savepoint level
remaining the current one when an SQL-transaction is initiated in SS.
A savepoint SP exists at exactly one savepoint level, namely, the savepoint level that is current when SP is
established.
If a <rollback statement> references a savepoint SS, then all changes made to SQL-data or schema subsequent
to the establishment of the savepoint are canceled, all savepoints established since SS was established are
destroyed, and the SQL-transaction is restored to its state as it was immediately following the execution of the
<savepoint statement>. Savepoints existing at savepoint level SPL are destroyed when SPL is destroyed.
Savepoint SS in the current savepoint level and all savepoints established since SS was established are destroyed
when a <release savepoint statement> specifying the savepoint name of SS is executed. A savepoint may be
replaced by another with the same name within a savepoint level by executing a <savepoint statement> that
specifies that name.
It is implementation-defined whether or not, or how, a <rollback statement> that references a <savepoint
specifier> affects diagnostics area contents, the contents of SQL descriptor areas, and the status of prepared
statements.



4.35.3 Properties of SQL-transactions

An SQL-transaction has a constraint mode for each integrity constraint. The constraint mode for an integrity
constraint in an SQL-transaction is described in Subclause 4.17, “Integrity constraints”.
An SQL-transaction has an access mode that is either read-only or read-write. The access mode may be
explicitly set by a <set transaction statement> before the start of an SQL-transaction or by the use of a <start
transaction statement> to start an SQL-transaction; otherwise, it is implicitly set to the default access mode for
the SQL-session before each SQL-transaction begins. If no <set session characteristics statement> has set the
default access mode for the SQL-session, then the default access mode for the SQL-session is read-write. The
term read-only applies only to viewed tables and persistent base tables.
An SQL-transaction has a condition area limit, which is a positive integer that specifies the maximum number
of conditions that can be placed in any diagnostics area during execution of an SQL-statement in this SQL-
transaction.
SQL-transactions initiated by different SQL-agents that access the same SQL-data or schemas and overlap in
time are concurrent SQL-transactions.



4.35.4 Isolation levels of SQL-transactions

An SQL-transaction has an isolation level that is READ UNCOMMITTED, READ COMMITTED,
REPEATABLE READ, or SERIALIZABLE. The isolation level of an SQL-transaction defines the degree to
which the operations on SQL-data or schemas in that SQL-transaction are affected by the effects of and can
affect operations on SQL-data or schemas in concurrent SQL-transactions. The isolation level of an SQL-
transaction when any cursor is held open from the previous SQL-transaction within an SQL-session is the iso-
lation level of the previous SQL-transaction by default. If no cursor is held open, or this is the first SQL-trans-
action within an SQL-session, then the isolation level is SERIALIZABLE by default. The level can be explicitly


116 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)
                                                                                             4.35 SQL-transactions



set by the <set transaction statement> before the start of an SQL-transaction or by the use of a <start transaction
statement> to start an SQL-transaction. If it is not explicitly set, then the isolation level is implicitly set to the
default isolation level for the SQL-session before each SQL-transaction begins. If no <set session characteristics
statement> has set the default isolation level for the SQL-session, then the default isolation level for the SQL-
session is SERIALIZABLE.
Execution of a <set transaction statement> is prohibited after the start of an SQL-transaction and before its
termination. Execution of a <set transaction statement> before the start of an SQL-transaction sets the access
mode, isolation level, and condition area limit for the single SQL-transaction that is started after the execution
of that <set transaction statement>. If multiple <set transaction statement>s are executed before the start of an
SQL-transaction, the last such statement is the one whose settings are effective for that SQL-transaction; their
actions are not cumulative.
The execution of concurrent SQL-transactions at isolation level SERIALIZABLE is guaranteed to be serializable.
A serializable execution is defined to be an execution of the operations of concurrently executing SQL-transac-
tions that produces the same effect as some serial execution of those same SQL-transactions. A serial execution
is one in which each SQL-transaction executes to completion before the next SQL-transaction begins.
The isolation level specifies the kind of phenomena that can occur during the execution of concurrent SQL-
transactions. The following phenomena are possible:
1) P1 (“Dirty read”): SQL-transaction T1 modifies a row. SQL-transaction T2 then reads that row before T1
   performs a COMMIT. If T1 then performs a ROLLBACK, T2 will have read a row that was never committed
   and that may thus be considered to have never existed.
2) P2 (“Non-repeatable read”): SQL-transaction T1 reads a row. SQL-transaction T2 then modifies or deletes
   that row and performs a COMMIT. If T1 then attempts to reread the row, it may receive the modified value
   or discover that the row has been deleted.
3) P3 (“Phantom”): SQL-transaction T1 reads the set of rows N that satisfy some <search condition>. SQL-
   transaction T2 then executes SQL-statements that generate one or more rows that satisfy the <search con-
   dition> used by SQL-transaction T1. If SQL-transaction T1 then repeats the initial read with the same
   <search condition>, it obtains a different collection of rows.
The four isolation levels guarantee that each SQL-transaction will be executed completely or not at all, and
that no updates will be lost. The isolation levels are different with respect to phenomena P1, P2, and P3. Table 8,
“SQL-transaction isolation levels and the three phenomena” specifies the phenomena that are possible and not
possible for a given isolation level.

                     Table 8 — SQL-transaction isolation levels and the three phenomena


 Level                                P1              P2                   P3

 READ UNCOMMITTED                     Possible        Possible             Possible

 READ COMMITTED                       Not Possible    Possible             Possible

 REPEATABLE READ                      Not Possible    Not Possible         Possible

 SERIALIZABLE                         Not Possible    Not Possible         Not Possible




©ISO/IEC 2003 – All rights reserved                                                                   Concepts 117
ISO/IEC 9075-2:2003 (E)
4.35 SQL-transactions



NOTE 53 — The exclusion of these phenomena for SQL-transactions executing at isolation level SERIALIZABLE is a consequence
of the requirement that such transactions be serializable.

Changes made to SQL-data or schemas by an SQL-transaction in an SQL-session may be perceived by that
SQL-transaction in that same SQL-session, and by other SQL-transactions, or by that same SQL-transaction
in other SQL-sessions, at isolation level READ UNCOMMITTED, but cannot be perceived by other SQL-
transactions at isolation level READ COMMITTED, REPEATABLE READ, or SERIALIZABLE until the
former SQL-transaction terminates with a <commit statement>.
Regardless of the isolation level of the SQL-transaction, phenomena P1, P2, and P3 shall not occur during the
implied reading of schema definitions performed on behalf of executing an SQL-statement, the checking of
integrity constraints, and the execution of referential actions associated with referential constraints. The schema
definitions that are implicitly read are implementation-dependent. This does not affect the explicit reading of
rows from tables in the Information Schema, which is done at the isolation level of the SQL-transaction.
NOTE 54 — The Information Schema is defined in ISO/IEC 9075-11.



4.35.5 Implicit rollbacks

The execution of a <rollback statement> may be initiated implicitly by an SQL-implementation when it detects
the inability to guarantee the serializability of two or more concurrent SQL-transactions. When this error occurs,
an exception condition is raised: transaction rollback — serialization failure.
The execution of a <rollback statement> may be initiated implicitly by an SQL-implementation when it detects
unrecoverable errors. When such an error occurs, an exception condition is raised: transaction rollback with
an implementation-defined subclass code.



4.35.6 Effects of SQL-statements in an SQL-transaction

The execution of an SQL-statement within an SQL-transaction has no effect on SQL-data or schemas other
than the effect stated in the General Rules for that SQL-statement, in the General Rules for Subclause 11.8,
“<referential constraint definition>”, in the General Rules for Subclause 11.39, “<trigger definition>”, and in
the General Rules for Subclause 11.50, “<SQL-invoked routine>”. Together with serializable execution, this
implies that all read operations are repeatable within an SQL-transaction at isolation level SERIALIZABLE,
except for:
1) The effects of changes to SQL-data or schemas and its contents made explicitly by the SQL-transaction
   itself.
2) The effects of differences in SQL parameter values supplied to externally-invoked procedures.
3) The effects of references to time-varying system variables such as CURRENT_DATE and CUR-
   RENT_USER.




118 Foundation (SQL/Foundation)                                                           ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                                         4.35 SQL-transactions



4.35.7 Encompassing transactions

In some environments (e.g., remote database access), an SQL-transaction can be part of an encompassing
transaction that is controlled by an agent other than the SQL-agent. The encompassing transaction may involve
different resource managers, the SQL-implementation being just one instance of such a manager. In such
environments, an encompassing transaction shall be terminated via that other agent, which in turn interacts
with the SQL-implementation via an interface that may be different from SQL (COMMIT or ROLLBACK),
in order to coordinate the orderly termination of the encompassing transaction. When an SQL-transaction is
part of an encompassing transaction that is controlled by an agent other than an SQL-agent and a <rollback
statement> is initiated implicitly by an SQL-implementation, then the SQL-implementation will interact with
that other agent to terminate that encompassing transaction. The specification of the interface between such
agents and the SQL-implementation is beyond the scope of this part of ISO/IEC 9075. However, it is important
to note that the semantics of an SQL-transaction remain as defined in the following sense:
— When an agent that is different from the SQL-agent requests the SQL-implementation to rollback an SQL-
  transaction, the General Rules of Subclause 16.7, “<rollback statement>”, are performed.
— When such an agent requests the SQL-implementation to commit an SQL-transaction, the General Rules
  of Subclause 16.6, “<commit statement>”, are performed. To guarantee orderly termination of the encom-
  passing transaction, this commit operation may be processed in several phases not visible to the application;
  not all the General Rules of Subclause 16.6, “<commit statement>”, need to be executed in a single phase.
However, even in such environments, the SQL-agent interacts directly with the SQL-server to set characteristics
(such as read-only or read-write, isolation level, and constraints mode) that are specific to the SQL-transaction
model.
It is implementation-defined whether SQL-transactions that affect more than one SQL-server are supported. If
such SQL-transactions are supported, then the part of each SQL-transaction that affects a single SQL-server is
called a branch transaction or a branch of the SQL-transaction. If such SQL-transactions are supported, then
they generally have all the same characteristics (access mode, condition area limit, and isolation level, as well
as constraint mode). However, it is possible to alter some characteristics of such an SQL-transaction at one
SQL-server by the use of the SET LOCAL TRANSACTION statement; if a SET LOCAL TRANSACTION
statement is executed at an SQL-server before any transaction-initiating SQL-statement, then it may set the
characteristics of that branch of the SQL-transaction at that SQL-server.
The characteristics of a branch of an SQL-transaction are limited by the characteristics of the SQL-transaction
as a whole:
— If the SQL-transaction is read-write, then the branch of the SQL-transaction may be read-write or read-
  only; if the SQL-transaction is read-only, then the branch of the SQL-transaction shall be read-only.
— If the SQL-transaction has an isolation level of READ UNCOMMITTED, then the branch of the SQL-
  transaction may have an isolation level of READ UNCOMMITTED, READ COMMITTED, REPEATABLE
  READ, or SERIALIZABLE.
    If the SQL-transaction has an isolation level of READ COMMITTED, then the branch of the SQL-transaction
    shall have an isolation level of READ COMMITTED, REPEATABLE READ, or SERIALIZABLE.
    If the SQL-transaction has an isolation level of REPEATABLE READ, then the branch of the SQL-trans-
    action shall have an isolation level of REPEATABLE READ or SERIALIZABLE.




©ISO/IEC 2003 – All rights reserved                                                               Concepts 119
ISO/IEC 9075-2:2003 (E)
4.35 SQL-transactions



    If the SQL-transaction has an isolation level of SERIALIZABLE, then the branch of the SQL-transaction
    shall have an isolation level of SERIALIZABLE.
— The diagnostics area limit of a branch of an SQL-transaction is always the same as the condition area limit
  of the SQL-transaction; SET LOCAL TRANSACTION shall not specify a condition area limit.
SQL-transactions that are not part of an encompassing transaction are terminated by the execution of <commit
statement>s and <rollback statement>s. If those statements specify AND CHAIN, then they also initiate a new
SQL-transaction with the same characteristics as the SQL-transaction that was just terminated, except that the
constraint mode of each integrity constraint reverts to its default mode (deferred or immediate).



4.36 SQL-connections

An SQL-connection is an association between an SQL-client and an SQL-server. An SQL-connection may be
established and named by a <connect statement>, which identifies the desired SQL-server by means of an
<SQL-server name>. A <connection name> is specified as a <simple value specification> whose value is an
<identifier>. Two <connection name>s identify the same SQL-connection if their values, with leading and
trailing <space>s removed, are equivalent according to the rules for <identifier> comparison in Subclause 5.2,
“<token> and <separator>”. It is implementation-defined how an SQL-implementation uses <SQL-server
name> to determine the location, identity, and communication protocol required to access the SQL-server and
create an SQL-session.
An SQL-connection is an active SQL-connection if any SQL-statement that initiates or requires an SQL-trans-
action has been executed at its SQL-server via that SQL-connection during the current SQL-transaction.
An SQL-connection is either current or dormant. If the SQL-connection established by the most recently executed
implicit or explicit <connect statement> or <set connection statement> has not been terminated, then that SQL-
connection is the current SQL-connection; otherwise, there is no current SQL-connection. An existing SQL-
connection that is not the current SQL-connection is a dormant SQL-connection.
An SQL implementation may detect the loss of the current SQL-connection during execution of any SQL-
statement. When such a connection failure is detected, an exception condition is raised: transaction rollback
— statement completion unknown. This exception condition indicates that the results of the actions performed
in the SQL-server on behalf of the statement are unknown to the SQL-agent.
Similarly, an SQL-implementation may detect the loss of the current SQL-connection during the execution of
a <commit statement>. When such a connection failure is detected, an exception condition is raised: connection
exception — transaction resolution unknown. This exception condition indicates that the SQL-implementation
cannot verify whether the SQL-transaction was committed successfully, rolled back, or left active.
A user may initiate an SQL-connection between the SQL-client associated with the SQL-agent and a specific
SQL-server by executing a <connect statement>. Otherwise, an SQL-connection between the SQL-client and
an implementation-defined default SQL-server is initiated when an externally-invoked procedure is called and
no SQL-connection is current. The SQL-connection associated with an implementation-defined default SQL-
server is called the default SQL-connection. An SQL-connection is terminated either by executing a <disconnect
statement>, or following the last call to an externally-invoked procedure within the last active SQL-client
module, or by the last execution of a <direct SQL statement> through the direct invocation of SQL. The
mechanism and rules by which an SQL-implementation determines whether a call to an externally-invoked
procedure is the last call within the last active SQL-client module and the mechanism and rules by which an



120 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)
                                                                                             4.36 SQL-connections



SQL-implementation determines whether a direct invocation of SQL is the last execution of a <direct SQL
statement> are implementation-defined.
An SQL-implementation shall support at least one SQL-connection and may require that the SQL-server be
identified at the binding time chosen by the SQL-implementation. If an SQL-implementation permits more
than one concurrent SQL-connection, then the SQL-agent may connect to more than one SQL-server and select
the SQL-server by executing a <set connection statement>.



4.37 SQL-sessions


4.37.1 General description of SQL-sessions

An SQL-session spans the execution of a sequence of consecutive SQL-statements invoked either by a single
user from a single SQL-agent or by the direct invocation of SQL. At any one time during an SQL-session,
exactly one of the SQL-statements in this sequence is being executed and is said to be an executing statement.
In some cases, an executing statement ES causes a nested sequence of consecutive SQL-statements to be executed
as a direct result of ES; during that time, exactly one of these is also an executing statement and it in turn might
similarly involve execution of a further nested sequence, and so on, indefinitely. An executing statement ES
such that no statement is executing as a direct result of ES is called the innermost executing statement of the
SQL-session.
An SQL-session is associated with an SQL-connection. The SQL-session associated with the default SQL-
connection is called the default SQL-session. An SQL-session is either current or dormant. The current SQL-
session is the SQL-session associated with the current SQL-connection. A dormant SQL-session is an SQL-
session that is associated with a dormant SQL-connection.
Within an SQL-session, module local temporary tables are effectively created by <temporary table declaration>s.
Module local temporary tables are accessible only to invocations of <externally-invoked procedure>s in the
SQL-client module in which they are created. The definitions of module local temporary tables persist until
the end of the SQL-session.
Within an SQL-session, locators are effectively created when a host parameter, a host variable, or an SQL
parameter of an external routine that is specified as a binary large object locator, a character large object locator,
a user-defined type locator, an array locator, or a multiset locator is assigned a value of binary large object type,
character large object type, user-defined type, array type, or multiset type, respectively. These locators are part
of the SQL-session context. A locator may be either valid or invalid. All locators remaining valid at the end of
an SQL-session are marked invalid on termination of that SQL-session. A host variable that is a locator may
be holdable or nonholdable.



4.37.2 SQL-session identification

An SQL-session has a unique implementation-dependent SQL-session identifier. This SQL-session identifier
is different from the SQL-session identifier of any other concurrent SQL-session. The SQL-session identifier




©ISO/IEC 2003 – All rights reserved                                                                   Concepts 121
ISO/IEC 9075-2:2003 (E)
4.37 SQL-sessions



is used to effectively define implementation-defined schemas that contain the instances of any global temporary
tables, created local temporary tables, or declared local temporary tables within the SQL-session.
An SQL-session is started as a result of successful execution of a <connect statement>, which sets the initial
SQL-session user identifier to the value of the implicit or explicit <connection user name> contained in the
<connect statement>.
An SQL-session initially has no SQL-session role name.
An SQL-session has an original time zone displacement and a current default time zone displacement, which
are values of data type INTERVAL HOUR TO MINUTE. Both the original time zone displacement and the
current default time zone displacement are initially set to the same implementation-defined value. The current
default time zone displacement can subsequently be changed by successful execution of a <set local time zone
statement>. The original time zone displacement cannot be changed. It is also possible to set the current default
time zone displacement to equal the value of the original time zone displacement.
An SQL-session has a default catalog name that is used to effectively qualify unqualified <schema name>s
that are contained in <preparable statement>s when those statements are prepared in the current SQL-session
by either an <execute immediate statement> or a <prepare statement> or are contained in <direct SQL statement>s
when those statements are invoked directly. The default catalog name is initially set to an implementation-
defined value but can subsequently be changed by the successful execution of a <set catalog statement> or <set
schema statement>.
An SQL-session has a default unqualified schema name that is used to effectively qualify unqualified <schema
qualified name>s that are contained in <preparable statement>s when those statements are prepared in the
current SQL-session by either an <execute immediate statement> or a <prepare statement> or are contained in
<direct SQL statement>s when those statements are invoked directly. The default unqualified schema name is
initially set to an implementation-defined value but can subsequently be changed by the successful execution
of a <set schema statement>.



4.37.3 SQL-session properties

An SQL-session has an SQL-path that is used to effectively qualify unqualified <routine name>s that are
immediately contained in <routine invocation>s that are contained in <preparable statement>s when those
statements are prepared in the current SQL-session by either an <execute immediate statement> or a <prepare
statement> or are contained in <direct SQL statement>s when those statements are invoked directly. The SQL-
path is initially set to an implementation-defined value, but can subsequently be changed by the successful
execution of a <set path statement>.
The text defining the SQL-path can be referenced by using the <general value specification> CURRENT_PATH.
An SQL-session has a default transform group name and one or more user-defined type name—transform group
name pairs that are used to identify the group of transform functions for every user-defined type that is referenced
in <preparable statement>s when those statements are prepared in the current SQL-session by either an <execute
immediate statement> or a <prepare statement> or are contained in <direct SQL statement>s when those
statements are invoked directly. The transform group name for a given user-defined type name is initially set
to an implementation-defined value but can subsequently be changed by the successful execution of a <set
transform group statement>.




122 Foundation (SQL/Foundation)                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                             4.37 SQL-sessions



The text defining the transform group names associated with the SQL-session can be referenced using two
mechanisms: the <general value specification> “CURRENT_TRANSFORM_GROUP_FOR_TYPE <path-
resolved user-defined type name>”, which evaluates to the name of the transform group associated with the
specified data type, and the <general value specification> “CURRENT_DEFAULT_TRANSFORM_GROUP”,
which evaluates to the name of the transform group associated with all types that have no type-specific transform
group specified for them.
An SQL-session has a default character set name that is used to identify the character set in which <preparable
statement>s are represented when those statements are prepared in the current SQL-session by either an <execute
immediate statement> or a <prepare statement>. The default character set name is initially set to an implemen-
tation-defined value but can subsequently be changed by the successful execution of a <set names statement>.
For each character set known to the SQL-implementation, an SQL-session has at most one SQL-session collation
for that character set, to be used when the rules of Subclause 9.13, “Collation determination”, are applied. There
are no SQL-session collations at the start of an SQL-session. The SQL-session collation for a character set can
be set or changed by the successful execution of a <set session collation statement>.
An SQL-invoked routine is active as soon as an SQL-statement executed by an SQL-agent causes invocation
of an SQL-invoked routine and ceases to be active when execution of that invocation is complete.
At any time during an SQL-session, containing SQL is said to be permitted or not permitted. Similarly, reading
SQL-data is said to be permitted or not permitted and modifying SQL-data is said to be permitted or not permitted.
An SQL-session has enduring characteristics. The enduring characteristics of an SQL-session are initially the
same as the default values for the corresponding SQL-session characteristics. The enduring characteristics are
changed by successful execution of a <set session characteristics statement> that specifies one or more enduring
characteristics. Enduring characteristics that are not specified in a <set session characteristics statement> are
not changed in any way by the successful execution of that statement.
SQL-sessions have the following enduring characteristics:
— enduring transaction characteristics
Each of the enduring characteristics are affected by a corresponding alternative in the <session characteristic>
appearing in the <session characteristic list> of a <set session characteristics statement>.
An SQL-session has a stack of contexts that is preserved when an SQL-session is made dormant and restored
when the SQL-session is made active. Each context in the stack comprises:
— The SQL-session identifier.
— The authorization stack.
— The identities of all instances of temporary tables.
— The original time zone displacement.
— The current default time zone displacement.
— The current constraint mode for each integrity constraint.
— The current transaction access mode.
— The cursor position of all open cursors.
— The current transaction isolation level.


©ISO/IEC 2003 – All rights reserved                                                                Concepts 123
ISO/IEC 9075-2:2003 (E)
4.37 SQL-sessions



— The current SQL diagnostics area stack and its contents, along with the current condition area limit.
— The value of all valid locators.
— The value of the SQL-path for the current SQL-session.
— A statement execution context.
— A routine execution context.
— Zero or more trigger execution contexts.
— All prepared statements prepared during the current SQL-session and not deallocated.
— The current default catalog name.
— The current default unqualified schema name.
— The current default character set name.
— For each character set known to the SQL-implementation, the SQL-session collation, if any.
— The text defining the SQL-path.
— The contents of all SQL dynamic descriptor areas.
— The text defining the default transform group name.
— The text defining the user-defined type name—transform group name pair for each user-defined type
  explicitly set by the user.
NOTE 55 — The use of the word “current” in the preceding list implies the values that are current in the SQL-session that is to be made
dormant, and not the values that will become current in the SQL-session that will become the active SQL-session.



4.37.4 Execution contexts

Execution contexts augment an SQL-session context to cater for certain special circumstances that might pertain
from time to time during invocations of SQL-statements. An execution context is either a statement execution
context, a trigger execution context, or a routine execution context. There is always a statement execution
context, a routine execution context, and zero or more trigger execution contexts. For certain SQL-statements,
the statement execution context is always atomic; for others, it is always or sometimes non-atomic. A routine
execution context is either atomic or non-atomic. Every trigger execution context is atomic. Statement execution
contexts are described in Subclause 4.33.5, “SQL-statement atomicity and statement execution contexts”, routine
execution contexts in Subclause 4.37.5, “Routine execution context”, and trigger execution contexts in
Subclause 4.38.2, “Trigger execution”.



4.37.5 Routine execution context

A routine execution context consists of:
— An indication as to whether or not an SQL-invoked routine is active.


124 Foundation (SQL/Foundation)                                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                               4.37 SQL-sessions



— An SQL-data access indication, which identifies what SQL-statements, if any, are allowed during the exe-
  cution of an SQL-invoked routine. The SQL-data access indication is one of the following: does not possibly
  contain SQL, possibly contains SQL, possibly reads SQL-data, or possibly modifies SQL-data.
— An identification of the SQL-invoked routine that is active.
— The routine SQL-path derived from the routine SQL-path if the SQL-invoked routine that is active is an
  SQL routine and from the external routine SQL-path if the SQL-invoked routine that is active is an external
  routine.
An SQL-invoked routine is active as soon as an SQL-statement executed by an SQL-agent causes invocation
of an SQL-invoked routine and ceases to be active when execution of that invocation is complete.
When an SQL-agent causes the invocation of an SQL-invoked routine, a new context for the current SQL-session
is created and the values of the current context are preserved. When the execution of that SQL-invoked routine
completes, the original context of the current SQL-session is restored and some SQL-session characteristics
are reset.
If the routine execution context of the SQL-session indicates that an SQL-invoked routine is active, then the
routine SQL-path included in the routine execution context of the SQL-session is used to effectively qualify
unqualified <routine name>s that are immediately contained in <routine invocation>s that are contained in a
<preparable statement> or in a <direct SQL statement>.



4.38 Triggers


4.38.1 General description of triggers

A trigger is a specification for a given action to take place every time a given operation takes place on a given
object. The action, known as a triggered action, is an SQL-procedure statement or a list of such statements.
The object is a persistent base table known as the subject table of the trigger. The operation, known as a trigger
event, is either deletion, insertion, or replacement of a collection of rows.
The triggered action is specified to take place either immediately before the triggering event or immediately
after it, according to its specified trigger action time, BEFORE or AFTER. The trigger is a BEFORE trigger
or an AFTER trigger, according to its trigger action time.
A trigger is either a delete trigger, an insert trigger, or an update trigger, according to the nature of its trigger
event.
Every trigger event arises as a consequence of executing some SQL-data change statement. That consequence
might be direct, as for example when the SQL-data change statement is an <insert statement> operating on a
base table, or indirect, as for example in the following cases:
— The SQL-data change statement is a <merge statement>.
— The SQL-data change statement operates on the referenced table of some foreign key whose referential
  action is CASCADE, SET NULL, or SET DEFAULT.
— The SQL-data change statement operates on a viewed table.


©ISO/IEC 2003 – All rights reserved                                                                  Concepts 125
ISO/IEC 9075-2:2003 (E)
4.38 Triggers



A triggered action is permitted to include SQL-data change statements that give rise to trigger events.
A collection of rows being deleted, inserted or replaced is known as a transition table. For a delete trigger there
is just one transition table, known as an old transition table. For an insert trigger there is just one transition
table, known as a new transition table. For an update trigger there is both an old transition table (the rows being
replaced) and a new transition table (the replacement rows), these two tables having the same cardinality.
A reference to “the transition table” of a trigger is ambiguous in the case of an update trigger but whenever
such a reference appears in this International Standard it is immaterial to which of the two transition tables it
applies.
The triggered action can be specified to take place either just once when the trigger event takes place, in which
case the trigger is a statement-level trigger, or once for each row of the transition table when the trigger event
takes place, in which case the trigger is a row-level trigger.
If the triggered action is specified to take place before the event, the trigger is a row-level trigger, and there is
a new transition table, then the action can include statements whose effect is to alter the effect of the impending
operation.
Special variables make the data in the transition table(s) available to the triggered action. For a statement-level
trigger the variable is one whose value is a transition table. For a row-level trigger, the variable is a range
variable, known as a transition variable. A transition variable ranges over the rows of a transition table, each
row giving rise to exactly one execution of the triggered action, with the row in question assigned to the transition
variable. A transition variable is either an old transition variable or a new transition variable, depending on
the transition table over whose rows it ranges.
When there are two transition tables, old and new, each row in the new transition table is one that is derived
by an update operation applied to exactly one row in the old transition table. Thus there is a 1:1 correspondence
between the rows of the two tables. However, this correspondence is visible only to a row-level trigger, each
invocation of which is able to access both the old and new transition variables, the new transition variable
representing the result of applying the update operation in question to the row in the old transition variable.
A trigger is defined by a <trigger definition>, specifying the name of the trigger, its subject table, its trigger
event, its trigger action time, whether it is statement-level or row-level, names as required for referencing
transition tables or variables, and the triggered action.
A schema might include one or more trigger descriptors, each of which includes a triggered action specifying
a <triggered SQL statement> that is to be executed (either once for each affected row, in the case of a row-level
trigger, or once for the whole trigger event in the case of a statement-level trigger) immediately before or
immediately after the trigger event takes place. The execution of a triggered action might cause the triggering
of further triggered actions. It does so if it entails execution of an SQL-procedure statement whose effect causes
the trigger event of some trigger to take place.
A trigger is described by a trigger descriptor. A trigger descriptor includes:
— The name of the trigger.
— The name of the subject table.
— The trigger action time (BEFORE or AFTER).
— The trigger event (INSERT, DELETE, or UPDATE).
— Whether the trigger is a statement-level trigger or a row-level trigger.



126 Foundation (SQL/Foundation)                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                                 4.38 Triggers



— Any old transition variable name, new transition variable name, old transition table name, or new transition
  table name.
— The triggered action.
— The trigger column list (possibly empty) for the trigger event.
— The triggered action column set of the triggered action.
— The timestamp of creation of the trigger.
The order of execution of a set of triggers is ascending by value of their timestamp of creation in their
descriptors, such that the oldest trigger executes first. If one or more triggers have the same timestamp value,
then their relative order of execution is implementation-defined.
A triggered action is always executed under the authorization of the owner of the schema that includes the
trigger.



4.38.2 Trigger execution

During the execution of an SQL-statement S, zero or more trigger execution contexts exist, no more than one
of which is active at any one time. A trigger execution context TECi comes into existence, becomes the active
one, ceases to be active, and is destroyed as and when required under the General Rules for S.
An effect causing a trigger execution context to come into existence here is typically a delete, insert or update
operation on one or more base tables, as specified in Subclause 14.16, “Effect of deleting rows from base
tables”, Subclause 14.19, “Effect of inserting tables into base tables”, and Subclause 14.22, “Effect of replacing
rows in base tables”, respectively.
If, while TECi is active, the General Rules for S require some new trigger execution context TECj to come into
existence, then TECj replaces TECi as the active trigger execution context. TECi becomes active again when
TECj is destroyed.

Multiple trigger execution contexts exist when the General Rules for S specify the execution of another SQL-
procedure statement T before the execution of S is complete, and the General Rules for T require a new trigger
execution context to come into existence.
A trigger execution context consists of a set of state changes. Within a trigger execution context, each state
change is uniquely identified by a trigger event, a subject table, and a column list. The trigger event can be
DELETE, INSERT, or UPDATE.
A state change SC consists of:
— A set of transitions.
— A trigger event.
— A subject table.
— A column list.
— A set (initially empty) of statement-level triggers considered as executed for SC.


©ISO/IEC 2003 – All rights reserved                                                                Concepts 127
ISO/IEC 9075-2:2003 (E)
4.38 Triggers



— A set of row-level triggers, each paired with the set of rows in SC for which it is considered as executed.
What constitutes a transition depends on the trigger event. If the trigger event is DELETE, a transition is a row
in the old transition table. If the trigger event is INSERT, a transition is a row in the new transition table. If the
trigger event is UPDATE, a transition is a row OR in the old transition table paired with a row NR in the new
transition table, such that NR is the row derived by applying a specified update operation to OR. OR and NR
are the old row and the new row, respectively, of the transition.
A statement-level trigger that is considered as executed for a state change SC (in a given trigger execution
context) is not subsequently executed for SC.
If a row-level trigger RLT is considered as executed for some row R in SC, then RLT is not subsequently executed
for R.
A consequence of the execution of an SQL-data change statement is called an SQL-update operation if and
only if that consequence causes at least one transition to arise in some state change.
A (possibly empty) old transition table exists if the trigger event is UPDATE or DELETE. It consists of a copy
of each row that is to be updated in or deleted from the subject table. A (possibly empty) new transition table
exists if the trigger event is UPDATE or INSERT. It consists of a copy of each row that results from updating
a row in the subject table or is to be inserted into the subject table.
A <triggered action> may refer to the old transition table only if an <old transition table name> is specified for
it in the <trigger definition>, and to the new transition table only if a <new transition table name> is specified
for it in the <trigger definition>.
The <triggered action> of a row-level trigger may refer to a range variable ranging over the rows of the old
transition table only if an <old transition variable name> is specified for it in the <trigger definition>. Similarly,
the <triggered action> of a row-level trigger may refer to a range variable ranging over the rows of the new
transition table only if a <new transition variable name> is specified for it in the <trigger definition>. The scope
of a transition variable or transition table name is the <triggered action> of the <trigger definition> that specifies
it, excluding any <SQL schema statement>s that are contained in that <triggered action>.
When execution of an SQL-data change statement causes a trigger execution context TECi to come into existence,
the set of state changes SSCi in TECi is empty. Let SCi,j be a state change in SSCi. Let TE be the trigger event
(DELETE, INSERT, or UPDATE) of SCi,j. Let ST be the subject table of SCi,j.

If TE is INSERT or DELETE, then let PSC be a set whose only element is the empty set.
If TE is UPDATE, then:
— Let CL be the list of columns being updated by SSCi.

— Let OC be the set of column names identifying the columns in CL.
— Let PSC be the set consisting of the empty set and every subset of the set of column names of ST that has
  at least one column that is in OC.
Let PSCN be the number of elements in PSC. A state change SCi,j, for j varying from 1 (one) to PSCN, identified
by TE, ST, and the j-th element in PSC, is added to SSCi, provided that SSCi does not already contain a state
change corresponding to SCi,j. Transitions are added to SCi,j as specified by the General Rules of Subclause 11.8,
“<referential constraint definition>”, Subclause 14.6, “<delete statement: positioned>”, Subclause 14.7, “<delete



128 Foundation (SQL/Foundation)                                                       ©ISO/IEC 2003 – All rights reserved
                                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                                                 4.38 Triggers



statement: searched>”, Subclause 14.8, “<insert statement>”, Subclause 14.10, “<update statement: positioned>”,
Subclause 14.11, “<update statement: searched>”, and Subclause 14.9, “<merge statement>”.
When a state change SCi,j arises in SSCi, one or more triggers are activated by SCi,j. A trigger TR is activated
by SCi,j if and only if the subject table of TR is the subject table of SCi,j, the trigger event of TR is the trigger
event of SCi,j, and the set of column names listed in the trigger column list of TR is equivalent to the set of
column names listed in SCi,j.
NOTE 56 — The trigger column list is included in the descriptor of TR; it is empty if the trigger event is DELETE or INSERT. The
trigger column list is also empty if the trigger event is UPDATE, but the <trigger event> of the <trigger definition> that defined TR
does not specify a <trigger column list>.

For each state change SCi,j in TECi, the BEFORE triggers activated by SCi,j are executed before any of their
triggering events take effect. When those triggering events have taken effect, any AFTER triggers activated by
the state changes of TECi are executed.

The <triggered action> contained in a <trigger definition> for a BEFORE or AFTER row-level trigger can refer
to columns of old transition variables and new transition variables. Such references can be specified as <column
reference>s, which can be <target specification>s and <simple target specification>s when they refer to columns
of the new transition variable.
NOTE 57 — By using such <column reference>s as <assignment target>s (see ISO/IEC 9075-4), the triggered action of a BEFORE
trigger is able to cause certain SQL-data change statements to have different effects from those specified in the statements.

When an execution of the <triggered SQL statement> TSS of a triggered action is not successful, then an
exception condition is raised and the SQL-statement that caused TSS to be executed has no effect on SQL-data
or schemas.



4.39 Client-server operation

When an SQL-agent is active, it is bound in some implementation-defined manner to a single SQL-client. That
SQL-client processes the explicit or implicit <SQL connection statement> for the first call to an externally-
invoked procedure by an SQL-agent. The SQL-client communicates with, either directly or possibly through
other agents such as RDA, one or more SQL-servers. An SQL-session involves an SQL-agent, an SQL-client,
and a single SQL-server.
SQL-client modules associated with the SQL-agent exist in the SQL-environment containing the SQL-client
associated with the SQL-agent.
Called <externally-invoked procedure>s and <direct SQL statement>s containing an <SQL connection statement>
or an <SQL diagnostics statement> are processed by the SQL-client. Following the successful execution of a
<connect statement> or a <set connection statement>, the SQL-client modules associated with the SQL-agent
are effectively materialized with an implementation-dependent <SQL-client module name> in the SQL-server.
Other called <externally-invoked procedure>s and <direct SQL statement>s are processed by the SQL-server.
A call by the SQL-agent to an <externally-invoked procedure> whose <SQL procedure statement> simply
contains an <SQL diagnostics statement> fetches information from the specified diagnostics area in the diag-
nostics area stack associated with the SQL-client. Following the execution of an <SQL procedure statement>
by an SQL-server, diagnostic information is passed in an implementation-dependent manner into the SQL-




©ISO/IEC 2003 – All rights reserved                                                                                  Concepts 129
ISO/IEC 9075-2:2003 (E)
4.39 Client-server operation



agent's diagnostics area stack in the SQL-client. The effect on diagnostic information of incompatibilities
between the character repertoires supported by the SQL-client and SQL-server is implementation-dependent.




130 Foundation (SQL/Foundation)                                               ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                               5.1 <SQL terminal character>




5 Lexical elements


5.1      <SQL terminal character>

Function
Define the terminal symbols of the SQL language and the elements of strings.


Format
<SQL terminal character> ::= <SQL language character>

<SQL language character> ::=
    <simple Latin letter>
  | <digit>
  | <SQL special character>

<simple Latin letter> ::=
    <simple Latin upper case letter>
  | <simple Latin lower case letter>

<simple Latin upper case letter> ::=
    A | B | C | D | E | F | G | H | I | J | K | L | M | N | O
  | P | Q | R | S | T | U | V | W | X | Y | Z

<simple Latin lower case letter> ::=
    a | b | c | d | e | f | g | h | i | j | k | l | m | n | o
  | p | q | r | s | t | u | v | w | x | y | z

<digit> ::=
    0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

<SQL special character> ::=
    <space>
  | <double quote>
  | <percent>
  | <ampersand>
  | <quote>
  | <left paren>
  | <right paren>
  | <asterisk>
  | <plus sign>
  | <comma>
  | <minus sign>
  | <period>
  | <solidus>
  | <colon>
  | <semicolon>




©ISO/IEC 2003 – All rights reserved                                                    Lexical elements 131
ISO/IEC 9075-2:2003 (E)
5.1 <SQL terminal character>



  |   <less than operator>
  |   <equals operator>
  |   <greater than operator>
  |   <question mark>
  |   <left bracket>
  |   <right bracket>
  |   <circumflex>
  |   <underscore>
  |   <vertical bar>
  |   <left brace>
  |   <right brace>

<space> ::= !! See the Syntax Rules

<double quote> ::= "

<percent> ::= %

<ampersand> ::= &

<quote> ::= '

<left paren> ::= (

<right paren> ::= )

<asterisk> ::= *

<plus sign> ::= +

<comma> ::= ,

<minus sign> ::= -

<period> ::= .

<solidus> ::= /

<reverse solidus> ::= \

<colon> ::= :

<semicolon> ::= ;

<less than operator> ::= <

<equals operator> ::= =

<greater than operator> ::= >

<question mark> ::= ?

<left bracket or trigraph> ::=
    <left bracket>
  | <left bracket trigraph>

<right bracket or trigraph> ::=
    <right bracket>
  | <right bracket trigraph>



132 Foundation (SQL/Foundation)       ©ISO/IEC 2003 – All rights reserved
                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                              5.1 <SQL terminal character>



<left bracket> ::= [

<left bracket trigraph> ::= ??(

<right bracket> ::= [

<right bracket trigraph> ::= ??)

<circumflex> ::= ^

<underscore> ::= _

<vertical bar> ::= |

<left brace> ::= {

<right brace> ::= }


Syntax Rules
1) Every character set shall contain a <space> character that is equivalent to U+0020.


Access Rules
    None.


General Rules
1) There is a one-to-one correspondence between the symbols contained in <simple Latin upper case letter>
   and the symbols contained in <simple Latin lower case letter> such that, for all i, the symbol defined as
   the i-th alternative for <simple Latin upper case letter> corresponds to the symbol defined as the i-th
   alternative for <simple Latin lower case letter>.


Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved                                                      Lexical elements 133
ISO/IEC 9075-2:2003 (E)
5.2 <token> and <separator>



5.2     <token> and <separator>

Function
Specify lexical units (tokens and separators) that participate in SQL language.


Format
<token> ::=
    <nondelimiter token>
  | <delimiter token>

<nondelimiter token> ::=
    <regular identifier>
  | <key word>
  | <unsigned numeric literal>
  | <national character string literal>
  | <binary string literal>
  | <large object length token>
  | <Unicode delimited identifier>
  | <Unicode character string literal>
  | <SQL language identifier>

<regular identifier> ::= <identifier body>

<identifier body> ::= <identifier start> [ <identifier part>... ]

<identifier part> ::=
    <identifier start>
  | <identifier extend>

<identifier start> ::= !! See the Syntax Rules

<identifier extend> ::= !! See the Syntax Rules

<large object length token> ::= <digit>... <multiplier>

<multiplier> ::=
    K
  | M
  | G

<delimited identifier> ::= <double quote> <delimited identifier body> <double quote>

<delimited identifier body> ::= <delimited identifier part>...

<delimited identifier part> ::=
    <nondoublequote character>
  | <doublequote symbol>

<Unicode delimited identifier> ::=
    U<ampersand><double quote> <Unicode delimiter body> <double quote>
    <Unicode escape specifier>

<Unicode escape specifier> ::= [ UESCAPE <quote><Unicode escape character><quote> ]



134 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                     ISO/IEC 9075-2:2003 (E)
                                                                 5.2 <token> and <separator>



<Unicode delimiter body> ::= <Unicode identifier part>...

<Unicode identifier part> ::=
    <delimited identifier part>
  | <Unicode escape value>

<Unicode escape value> ::=
    <Unicode 4 digit escape value>
  | <Unicode 6 digit escape value>
  | <Unicode character escape value>

<Unicode 4 digit escape value> ::= <Unicode escape character><hexit><hexit><hexit><hexit>

<Unicode 6 digit escape value> ::=
    <Unicode escape character><plus sign>
    <hexit><hexit><hexit><hexit><hexit><hexit>

<Unicode character escape value> ::= <Unicode escape character><Unicode escape character>

<Unicode escape character> ::= !! See the Syntax Rules

<nondoublequote character> ::= !! See the Syntax Rules

<doublequote symbol> ::= "" !! two consecutive double quote characters

<delimiter token> ::=
    <character string literal>
  | <date string>
  | <time string>
  | <timestamp string>
  | <interval string>
  | <delimited identifier>
  | <SQL special character>
  | <not equals operator>
  | <greater than or equals operator>
  | <less than or equals operator>
  | <concatenation operator>
  | <right arrow>
  | <left bracket trigraph>
  | <right bracket trigraph>
  | <double colon>
  | <double period>

<not equals operator> ::= <>

<greater than or equals operator> ::= >=

<less than or equals operator> ::= <=

<concatenation operator> ::= ||

<right arrow> ::= ->

<double colon> ::= ::

<double period> ::= ..

<separator> ::= { <comment> | <white space> }...




©ISO/IEC 2003 – All rights reserved                                      Lexical elements 135
ISO/IEC 9075-2:2003 (E)
5.2 <token> and <separator>



<white space> ::= !! See the Syntax Rules

<comment> ::=
    <simple comment>
  | <bracketed comment>

<simple comment> ::= <simple comment introducer> [ <comment character>... ] <newline>

<simple comment introducer> ::= <minus sign><minus sign>

<bracketed comment> ::=
    <bracketed comment introducer>
    <bracketed comment contents>
    <bracketed comment terminator>

<bracketed comment introducer> ::= /*

<bracketed comment terminator> ::= */

<bracketed comment contents> ::= !! See the Syntax Rules
    [ { <comment character> | <separator> }... ]

<comment character> ::=
    <nonquote character>
  | <quote>

<newline> ::= !! See the Syntax Rules

<key word> ::=
    <reserved word>
  | <non-reserved word>

<non-reserved word> ::=
    A | ABSOLUTE | ACTION | ADA | ADD | ADMIN | AFTER | ALWAYS | ASC
  | ASSERTION | ASSIGNMENT | ATTRIBUTE | ATTRIBUTES

  | BEFORE | BERNOULLI | BREADTH

  |   C | CASCADE | CATALOG | CATALOG_NAME | CHAIN | CHARACTER_SET_CATALOG
  |   CHARACTER_SET_NAME | CHARACTER_SET_SCHEMA | CHARACTERISTICS | CHARACTERS
  |   CLASS_ORIGIN | COBOL | COLLATION | COLLATION_CATALOG | COLLATION_NAME | COLLATION_SCHEMA
  |   COLUMN_NAME | COMMAND_FUNCTION | COMMAND_FUNCTION_CODE | COMMITTED
  |   CONDITION_NUMBER | CONNECTION | CONNECTION_NAME | CONSTRAINT_CATALOG | CONSTRAINT_NAME
  |   CONSTRAINT_SCHEMA | CONSTRAINTS | CONSTRUCTOR | CONTAINS | CONTINUE | CURSOR_NAME

  | DATA | DATETIME_INTERVAL_CODE | DATETIME_INTERVAL_PRECISION | DEFAULTS | DEFERRABLE
  | DEFERRED | DEFINED | DEFINER | DEGREE | DEPTH | DERIVED | DESC | DESCRIPTOR
  | DIAGNOSTICS | DISPATCH | DOMAIN | DYNAMIC_FUNCTION | DYNAMIC_FUNCTION_CODE

  | EQUALS | EXCEPTION | EXCLUDE | EXCLUDING

  | FINAL | FIRST | FOLLOWING | FORTRAN | FOUND

  | G | GENERAL | GENERATED | GO | GOTO | GRANTED

  | HIERARCHY




136 Foundation (SQL/Foundation)                                      ©ISO/IEC 2003 – All rights reserved
                                                                       ISO/IEC 9075-2:2003 (E)
                                                                   5.2 <token> and <separator>



  | IMMEDIATE | IMPLEMENTATION | INCLUDING | INCREMENT | INITIALLY | INPUT | INSTANCE
  | INSTANTIABLE | INVOKER | ISOLATION

  | K | KEY | KEY_MEMBER | KEY_TYPE

  | LAST | LENGTH | LEVEL | LOCATOR

  | M | MAP | MATCHED | MAXVALUE | MESSAGE_LENGTH | MESSAGE_OCTET_LENGTH
  | MESSAGE_TEXT | MINVALUE | MORE | MUMPS

  | NAME | NAMES | NESTING | NEXT | NORMALIZED | NULLABLE | NULLS | NUMBER

  | OBJECT | OCTETS | OPTION | OPTIONS | ORDERING | ORDINALITY | OTHERS
  | OUTPUT | OVERRIDING

  |   PAD | PARAMETER_MODE | PARAMETER_NAME | PARAMETER_ORDINAL_POSITION
  |   PARAMETER_SPECIFIC_CATALOG | PARAMETER_SPECIFIC_NAME | PARAMETER_SPECIFIC_SCHEMA
  |   PARTIAL | PASCAL | PATH | PLACING | PLI | PRECEDING | PRESERVE | PRIOR
  |   PRIVILEGES | PUBLIC

  | READ | RELATIVE | REPEATABLE | RESTART | RESTRICT | RETURNED_CARDINALITY
  | RETURNED_LENGTH | RETURNED_OCTET_LENGTH | RETURNED_SQLSTATE | ROLE
  | ROUTINE | ROUTINE_CATALOG | ROUTINE_NAME | ROUTINE_SCHEMA | ROW_COUNT

  |   SCALE | SCHEMA | SCHEMA_NAME | SCOPE_CATALOG | SCOPE_NAME | SCOPE_SCHEMA
  |   SECTION | SECURITY | SELF | SEQUENCE | SERIALIZABLE | SERVER_NAME | SESSION
  |   SETS | SIMPLE | SIZE | SOURCE | SPACE | SPECIFIC_NAME | STATE | STATEMENT
  |   STRUCTURE | STYLE | SUBCLASS_ORIGIN

  | TABLE_NAME | TEMPORARY | TIES | TOP_LEVEL_COUNT | TRANSACTION
  | TRANSACTION_ACTIVE | TRANSACTIONS_COMMITTED | TRANSACTIONS_ROLLED_BACK
  | TRANSFORM | TRANSFORMS | TRIGGER_CATALOG | TRIGGER_NAME | TRIGGER_SCHEMA | TYPE

  | UNBOUNDED | UNCOMMITTED | UNDER | UNNAMED | USAGE | USER_DEFINED_TYPE_CATALOG
  | USER_DEFINED_TYPE_CODE | USER_DEFINED_TYPE_NAME | USER_DEFINED_TYPE_SCHEMA

  | VIEW

  | WORK | WRITE

  | ZONE

<reserved word> ::=
    ABS | ALL | ALLOCATE | ALTER | AND | ANY | ARE | ARRAY | AS | ASENSITIVE
  | ASYMMETRIC | AT | ATOMIC | AUTHORIZATION | AVG

  | BEGIN | BETWEEN | BIGINT | BINARY | BLOB | BOOLEAN | BOTH | BY

  |   CALL | CALLED | CARDINALITY | CASCADED | CASE | CAST | CEIL | CEILING
  |   CHAR | CHAR_LENGTH | CHARACTER | CHARACTER_LENGTH | CHECK | CLOB | CLOSE
  |   COALESCE | COLLATE | COLLECT | COLUMN | COMMIT | CONDITION | CONNECT
  |   CONSTRAINT | CONVERT | CORR | CORRESPONDING | COUNT | COVAR_POP | COVAR_SAMP
  |   CREATE | CROSS | CUBE | CUME_DIST | CURRENT | CURRENT_DATE
  |   CURRENT_DEFAULT_TRANSFORM_GROUP | CURRENT_PATH | CURRENT_ROLE | CURRENT_TIME
  |   CURRENT_TIMESTAMP | CURRENT_TRANSFORM_GROUP_FOR_TYPE | CURRENT_USER
  |   CURSOR | CYCLE



©ISO/IEC 2003 – All rights reserved                                       Lexical elements 137
ISO/IEC 9075-2:2003 (E)
5.2 <token> and <separator>




  | DATE | DAY | DEALLOCATE | DEC | DECIMAL | DECLARE | DEFAULT | DELETE
  | DENSE_RANK | DEREF | DESCRIBE | DETERMINISTIC | DISCONNECT | DISTINCT
  | DOUBLE | DROP | DYNAMIC

  | EACH | ELEMENT | ELSE | END | END-EXEC | ESCAPE | EVERY | EXCEPT | EXEC
  | EXECUTE | EXISTS | EXP | EXTERNAL | EXTRACT

  | FALSE | FETCH | FILTER | FLOAT | FLOOR | FOR | FOREIGN | FREE | FROM
  | FULL | FUNCTION | FUSION

  | GET | GLOBAL | GRANT | GROUP | GROUPING

  | HAVING | HOLD | HOUR

  | IDENTITY | IN | INDICATOR | INNER | INOUT | INSENSITIVE | INSERT
  | INT | INTEGER | INTERSECT | INTERSECTION | INTERVAL | INTO | IS

  | JOIN

  | LANGUAGE | LARGE | LATERAL | LEADING | LEFT | LIKE | LN | LOCAL
  | LOCALTIME | LOCALTIMESTAMP | LOWER

  | MATCH | MAX | MEMBER | MERGE | METHOD | MIN | MINUTE
  | MOD | MODIFIES | MODULE | MONTH | MULTISET

  | NATIONAL | NATURAL | NCHAR | NCLOB | NEW | NO | NONE | NORMALIZE | NOT
  | NULL | NULLIF | NUMERIC

  | OCTET_LENGTH | OF | OLD | ON | ONLY | OPEN | OR | ORDER | OUT | OUTER
  | OVER | OVERLAPS | OVERLAY

  | PARAMETER | PARTITION | PERCENT_RANK | PERCENTILE_CONT | PERCENTILE_DISC
  | POSITION | POWER | PRECISION | PREPARE | PRIMARY | PROCEDURE

  |   RANGE | RANK | READS | REAL | RECURSIVE | REF | REFERENCES | REFERENCING
  |   REGR_AVGX | REGR_AVGY | REGR_COUNT | REGR_INTERCEPT | REGR_R2 | REGR_SLOPE
  |   REGR_SXX | REGR_SXY | REGR_SYY | RELEASE | RESULT | RETURN | RETURNS
  |   REVOKE | RIGHT | ROLLBACK | ROLLUP | ROW | ROW_NUMBER | ROWS

  |   SAVEPOINT | SCOPE | SCROLL | SEARCH | SECOND | SELECT | SENSITIVE
  |   SESSION_USER | SET | SIMILAR | SMALLINT | SOME | SPECIFIC | SPECIFICTYPE
  |   SQL | SQLEXCEPTION | SQLSTATE | SQLWARNING | SQRT | START | STATIC
  |   STDDEV_POP | STDDEV_SAMP | SUBMULTISET | SUBSTRING | SUM | SYMMETRIC
  |   SYSTEM | SYSTEM_USER

  | TABLE | TABLESAMPLE | THEN | TIME | TIMESTAMP | TIMEZONE_HOUR | TIMEZONE_MINUTE
  | TO | TRAILING | TRANSLATE | TRANSLATION | TREAT | TRIGGER | TRIM | TRUE

  | UESCAPE | UNION | UNIQUE | UNKNOWN | UNNEST | UPDATE    | UPPER | USER | USING

  | VALUE | VALUES | VAR_POP | VAR_SAMP | VARCHAR | VARYING

  | WHEN | WHENEVER | WHERE | WIDTH_BUCKET | WINDOW | WITH | WITHIN | WITHOUT

  | YEAR



138 Foundation (SQL/Foundation)                                    ©ISO/IEC 2003 – All rights reserved
                                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                                      5.2 <token> and <separator>



Syntax Rules
1) An <identifier start> is any character in the Unicode General Category classes “Lu”, “Ll”, “Lt”, “Lm”,
   “Lo”, or “Nl”.
    NOTE 58 — The Unicode General Category classes “Lu”, “Ll”, “Lt”, “Lm”, “Lo”, and “Nl” are assigned to Unicode characters
    that are, respectively, upper-case letters, lower-case letters, title-case letters, modifier letters, other letters, and letter numbers.

2) An <identifier extend> is U+00B7, “Middle Dot”, or any character in the Unicode General Category classes
   “Mn”, “Mc”, “Nd”, “Pc”, or “Cf”.
    NOTE 59 — The Unicode General Category classes “Mn”, “Mc”, “Nd”, “Pc”, and “Cf” are assigned to Unicode characters that
    are, respectively, nonspacing marks, spacing combining marks, decimal numbers, connector punctuations, and formatting codes.

3) <white space> is any consecutive sequence of characters each of which satisfies the definition of white
   space found in Subclause 3.1.6, “Definitions provided in Part 2”.
4) <newline> is the implementation-defined end-of-line indicator.
    NOTE 60 — <newline> is typically represented by U+000A (“Line Feed”) and/or U+000D (“Carriage Return”); however, this
    representation is not required by ISO/IEC 9075.

5) With the exception of the <space> character explicitly contained in <timestamp string> and <interval
   string>, a <token>, other than a <character string literal>, a <national character string literal>, a <Unicode
   character string literal>, a <delimited identifier>, or a <Unicode delimited identifier> shall not contain a
   <space> character or other <separator>.
6) A <nondoublequote character> is any character of the source language character set other than a <double
   quote>.
    NOTE 61 — “source language character set” is defined in Subclause 4.8.1, “Host languages”, in ISO/IEC 9075-1.

7) Any <token> may be followed by a <separator>. A <nondelimiter token> shall be followed by a <delimiter
   token> or a <separator>.
    NOTE 62 — If the Format does not allow a <nondelimiter token> to be followed by a <delimiter token>, then that <nondelimiter
    token> shall be followed by a <separator>.

8) There shall be no <separator> separating the <minus sign>s of a <simple comment introducer>.
9) There shall be no <separator> separating any two <digit>s or separating a <digit> and <multiplier> of a
   <large object length token>.
10) Within a <bracketed comment contents>, any <solidus> immediately followed by an <asterisk> without
    any intervening <separator> shall be considered to be the <bracketed comment introducer> of a <separator>
    that is a <bracketed comment>.
    NOTE 63 — Conforming programs should not place <simple comment> within a <bracketed comment> because if such a <simple
    comment> contains the sequence of characters “*/” without a preceding “/*” in the same <simple comment>, it will prematurely
    terminate the containing <bracketed comment>.

11) SQL text containing one or more instances of <comment> is equivalent to the same SQL text with the
    <comment> replaced with <newline>.
12) In a <regular identifier>, the number of <identifier part>s shall be less than 128.
13) The <delimited identifier body> of a <delimited identifier> shall not comprise more than 128 <delimited
    identifier part>s.



©ISO/IEC 2003 – All rights reserved                                                                              Lexical elements 139
ISO/IEC 9075-2:2003 (E)
5.2 <token> and <separator>



14) In a <Unicode delimited identifier>, there shall be no <separator> between the 'U' and the <ampersand>
    nor between the <ampersand> and the <double quote>.
15) <Unicode escape character> shall be a single character from the source language character set other than
    a <hexit>, <plus sign>, <double quote>, or <white space>.
16) If the source language character set contains <reverse solidus>, then let DEC be <reverse solidus>; otherwise,
    let DEC be an implementation-defined character from the source language character set that is not a <hexit>,
    <plus sign>, <double quote>, or <white space>.
17) If a <Unicode escape specifier> does not contain <Unicode escape character>, then “UESCAPE
    <quote>DEC<quote>” is implicit.
18) In a <Unicode escape value> there shall be no <separator> between the <Unicode escape character> and
    the first <hexit>, nor between any of the <hexit>s.
19) The <Unicode delimiter body> of a <Unicode delimited identifier> shall not comprise more than 128
    <Unicode identifier part>s.
20) <Unicode 4 digit escape value> '<Unicode escape character>xyzw' is equivalent to the Unicode code point
    specified by U+xyzw.
21) <Unicode 6 digit escape value> '<Unicode escape character>+xyzwrs' is equivalent to the character at the
    Unicode code point specified by U+xyzwrs.
    NOTE 64 — The 6-hexit notation is derived by taking the UCS-4 notation defined in ISO/IEC 10646-1 and removing the leading
    two hexits, whose values are always 0 (zero).

22) <Unicode character escape value> is equivalent to a single instance of <Unicode escape character>.
23) For every <identifier body> IB there is exactly one corresponding case-normal form CNF. CNF is an
    <identifier body> derived from IB as follows.
    Let n be the number of characters in IB. For i ranging from 1 (one) to n, the i-th character Mi of IB is
    transliterated into the corresponding character or characters of CNF as follows.
    Case:
    a) If Mi is a lower case character or a title case character for which an equivalent upper case sequence U
       is defined by Unicode, then let j be the number of characters in U; the next j characters of CNF are U.
    b) Otherwise, the next character of CNF is Mi.

24) The case-normal form of the <identifier body> of a <regular identifier> is used for purposes such as and
    including determination of identifier equivalence, representation in the Definition and Information Schemas,
    and representation in diagnostics areas.
    NOTE 65 — The Information Schema and Definition Schema are defined in ISO/IEC 9075-11.
    NOTE 66 — Any lower-case letters for which there are no upper-case equivalents are left in their lower-case form.

25) The case-normal form of <regular identifier> shall not be equal, according to the comparison rules in
    Subclause 8.2, “<comparison predicate>”, to any <reserved word> (with every letter that is a lower-case
    letter replaced by the corresponding upper-case letter or letters), treated as the repetition of a <character
    string literal> that specifies a <character set specification> of SQL_IDENTIFIER.




140 Foundation (SQL/Foundation)                                                                ©ISO/IEC 2003 – All rights reserved
                                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                                  5.2 <token> and <separator>



26) Two <regular identifier>s are equivalent if the case-normal forms of their <identifier body>s, considered
    as the repetition of a <character string literal> that specifies a <character set specification> of
    SQL_IDENTIFIER and an implementation-defined collation IDC that is sensitive to case, compare equally
    according to the comparison rules in Subclause 8.2, “<comparison predicate>”.
27) A <regular identifier> and a <delimited identifier> are equivalent if the case-normal form of the <identifier
    body> of the <regular identifier> and the <delimited identifier body> of the <delimited identifier> (with
    all occurrences of <quote> replaced by <quote symbol> and all occurrences of <doublequote symbol>
    replaced by <double quote>), considered as the repetition of a <character string literal> that specifies a
    <character set specification> of SQL_IDENTIFIER and IDC, compare equally according to the comparison
    rules in Subclause 8.2, “<comparison predicate>”.
28) Two <delimited identifier>s are equivalent if their <delimited identifier body>s, considered as the repetition
    of a <character string literal> that specifies a <character set specification> of SQL_IDENTIFIER and an
    implementation-defined collation that is sensitive to case, compare equally according to the comparison
    rules in Subclause 8.2, “<comparison predicate>”.
29) Two <Unicode delimited identifier>s are equivalent if their <Unicode delimiter body>s, considered as the
    repetition of a <character string literal> that specifies a <character set specification> of SQL_IDENTIFIER
    and an implementation-defined collation that is sensitive to case, compare equally according to the compar-
    ison rules in Subclause 8.2, “<comparison predicate>”.
30) A <Unicode delimited identifier> and a <delimited identifier> are equivalent if their <Unicode delimiter
    body> and <delimited identifier body>, respectively, each considered as the repetition of a <character string
    literal> that specifies a <character set specification> of SQL_IDENTIFIER and an implementation-defined
    collation that is sensitive to case, compare equally according to the comparison rules in Subclause 8.2,
    “<comparison predicate>”.
31) For the purposes of identifying <key word>s, any <simple Latin lower case letter> contained in a candidate
    <key word> shall be effectively treated as the corresponding <simple Latin upper case letter>.


Access Rules
    None.


General Rules
    None.


Conformance Rules
1) Without Feature F391, “Long identifiers”, in a <regular identifier>, the number of <identifier part>s shall
   be less than 18.
2) Without Feature F391, “Long identifiers”, the <delimited identifier body> of a <delimited identifier> shall
   not comprise more than 18 <delimited identifier part>s.
    NOTE 67 — Not every character set supported by a conforming SQL-implementation necessarily contains every character associated
    with <identifier start> and <identifier part> that is identified in the Syntax Rules of this Subclause. No conforming SQL-implemen-
    tation shall be required to support in <identifier start> or <identifier part> any character identified in the Syntax Rules of this
    Subclause unless that character belongs to the character set in use for an SQL-client module or in SQL-data.



©ISO/IEC 2003 – All rights reserved                                                                         Lexical elements 141
ISO/IEC 9075-2:2003 (E)
5.2 <token> and <separator>



3) Without Feature T351, “Bracketed comments”, conforming SQL language shall not contain a <bracketed
   comment>.
4) Without Feature F392, “Unicode escapes in identifiers”, conforming SQL language shall not contain a
   <Unicode delimited identifier>.




142 Foundation (SQL/Foundation)                                             ©ISO/IEC 2003 – All rights reserved
                                                                     ISO/IEC 9075-2:2003 (E)
                                                                               5.3 <literal>



5.3      <literal>

Function
Specify a non-null value.


Format
<literal> ::=
    <signed numeric literal>
  | <general literal>

<unsigned literal> ::=
    <unsigned numeric literal>
  | <general literal>

<general literal> ::=
    <character string literal>
  | <national character string literal>
  | <Unicode character string literal>
  | <binary string literal>
  | <datetime literal>
  | <interval literal>
  | <boolean literal>

<character string literal> ::=
    [ <introducer><character set specification> ]
    <quote> [ <character representation>... ] <quote>
    [ { <separator> <quote> [ <character representation>... ] <quote> }... ]

<introducer> ::= <underscore>

<character representation> ::=
    <nonquote character>
  | <quote symbol>

<nonquote character> ::= !! See the Syntax Rules.

<quote symbol> ::= <quote><quote>

<national character string literal> ::=
    N <quote> [ <character representation>... ]
    <quote> [ { <separator> <quote> [ <character representation>... ] <quote> }... ]

<Unicode character string literal> ::=
    [ <introducer><character set specification> ]
    U<ampersand><quote> [ <Unicode representation>... ] <quote>
    [ { <separator> <quote> [ <Unicode representation>... ] <quote> }... ]
    <Unicode escape specifier>

<Unicode representation> ::=
    <character representation>
  | <Unicode escape value>




©ISO/IEC 2003 – All rights reserved                                     Lexical elements 143
ISO/IEC 9075-2:2003 (E)
5.3 <literal>



<binary string literal> ::=
    X <quote> [ { <hexit> <hexit> }... ] <quote>
    [ { <separator> <quote> [ { <hexit> <hexit> }... ] <quote> }... ]

<hexit> ::=
    <digit> | A | B | C | D | E | F | a | b | c | d | e | f

<signed numeric literal> ::= [ <sign> ] <unsigned numeric literal>

<unsigned numeric literal> ::=
    <exact numeric literal>
  | <approximate numeric literal>

<exact numeric literal> ::=
    <unsigned integer> [ <period> [ <unsigned integer> ] ]
  | <period> <unsigned integer>

<sign> ::=
    <plus sign>
  | <minus sign>

<approximate numeric literal> ::= <mantissa> E <exponent>

<mantissa> ::= <exact numeric literal>

<exponent> ::= <signed integer>

<signed integer> ::= [ <sign> ] <unsigned integer>

<unsigned integer> ::= <digit>...

<datetime literal> ::=
    <date literal>
  | <time literal>
  | <timestamp literal>

<date literal> ::= DATE <date string>

<time literal> ::= TIME <time string>

<timestamp literal> ::= TIMESTAMP <timestamp string>

<date string> ::= <quote> <unquoted date string> <quote>

<time string> ::= <quote> <unquoted time string> <quote>

<timestamp string> ::= <quote> <unquoted timestamp string> <quote>

<time zone interval> ::= <sign> <hours value> <colon> <minutes value>

<date value> ::= <years value> <minus sign> <months value> <minus sign> <days value>

<time value> ::= <hours value> <colon> <minutes value> <colon> <seconds value>

<interval literal> ::= INTERVAL [ <sign> ] <interval string> <interval qualifier>

<interval string> ::= <quote> <unquoted interval string> <quote>

<unquoted date string> ::= <date value>




144 Foundation (SQL/Foundation)                                    ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)
                                                                                                     5.3 <literal>



<unquoted time string> ::= <time value> [ <time zone interval> ]

<unquoted timestamp string> ::= <unquoted date string> <space> <unquoted time string>

<unquoted interval string> ::=
    [ <sign> ] { <year-month literal> | <day-time literal> }

<year-month literal> ::=
    <years value> [ <minus sign> <months value> ]
  | <months value>

<day-time literal> ::=
    <day-time interval>
  | <time interval>

<day-time interval> ::=
    <days value> [ <space> <hours value> [ <colon> <minutes value>
    [ <colon> <seconds value> ] ] ]

<time interval> ::=
    <hours value> [ <colon> <minutes value> [ <colon> <seconds value> ] ]
  | <minutes value> [ <colon> <seconds value> ]
  | <seconds value>

<years value> ::= <datetime value>

<months value> ::= <datetime value>

<days value> ::= <datetime value>

<hours value> ::= <datetime value>

<minutes value> ::= <datetime value>

<seconds value> ::= <seconds integer value> [ <period> [ <seconds fraction> ] ]

<seconds integer value> ::= <unsigned integer>

<seconds fraction> ::= <unsigned integer>

<datetime value> ::= <unsigned integer>

<boolean literal> ::=
    TRUE
  | FALSE
  | UNKNOWN


Syntax Rules
1) In a <character string literal> or <national character string literal>, the sequence:
        <quote> <character representation>... <quote> <separator> <quote> <character representation>... <quote>
    is equivalent to the sequence
        <quote> <character representation>... <character representation>... <quote>




©ISO/IEC 2003 – All rights reserved                                                           Lexical elements 145
ISO/IEC 9075-2:2003 (E)
5.3 <literal>



    NOTE 68 — The <character representation>s in the equivalent sequence are in the same sequence and relative sequence as in the
    original <character string literal>.

2) In a <Unicode character string literal>, the sequence:
       <quote> <Unicode representation>... <quote> <separator> <quote> <Unicode representation>... <quote>
    is equivalent to the sequence:
       <quote> <Unicode representation>... <Unicode representation>... <quote>

3) In a <binary string literal>, the sequence
       <quote> { <hexit> <hexit> }... <quote> <separator> <quote> { <hexit> <hexit> }... <quote>
    is equivalent to the sequence
       <quote> { <hexit> <hexit> }... { <hexit> <hexit> }... <quote>
    NOTE 69 — The <hexit>s in the equivalent sequence are in the same sequence and relative sequence as in the original <binary
    string literal>.

4) In a <character string literal>, <national character string literal>, <Unicode character string literal>, or
   <binary string literal>, a <separator> shall contain a <newline>.
5) A <national character string literal> is equivalent to a <character string literal> with the “N” replaced by
   “<introducer><character set specification>”, where “<character set specification>” is an implementation-
   defined <character set name>.
6) In a <Unicode character string literal> that specifies “<introducer><character set specification>”, there
   shall be no <separator> between the <introducer> and the <character set specification>.
7) In a <Unicode character string literal>, there shall be no <separator> between the “U” and the <ampersand>
   nor between the <ampersand> and the <quote>.
8) The character set of a <Unicode character string literal> that specifies “<introducer><character set specifi-
   cation>” is the character set specified by the <character set specification>. The character set of a <Unicode
   character string literal> that does not specify “<introducer><character set specification>” is the character
   set of the SQL-client module that contains the <Unicode character string literal>.
9) A <Unicode character string literal> is equivalent to a <character string literal> in which every <Unicode
   escape value> has been replaced with the equivalent Unicode character. The set of characters contained in
   the <Unicode character string literal> shall be wholly contained in the character set of the <Unicode char-
   acter string literal>.
    NOTE 70 — The requirement for “wholly contained” applies after the replacement of <Unicode escape value>s with equivalent
    Unicode characters.

10) Each <character representation> is a character of the source language character set. The value of a <char-
    acter string literal>, viewed as a string in the source language character set, shall be equivalent to a character
    string of the implicit or explicit character set of the <character string literal> or <national character string
    literal>.
    NOTE 71 — “source language character set” is defined in Subclause 4.8.1, “Host languages”, in ISO/IEC 9075-1.

11) A <nonquote character> is one of:
    a) Any character of the source language character set other than a <quote>.


146 Foundation (SQL/Foundation)                                                               ©ISO/IEC 2003 – All rights reserved
                                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                                                  5.3 <literal>



    b) Any character other than a <quote> in the character set identified by the <character set specification>
       or implied by “N”.
12) Case:
    a) If a <character set specification> is not specified in a <character string literal>, then the set of characters
       contained in the <character string literal> shall be wholly contained in the character set of the <SQL-
       client module definition> that contains the <character string literal>.
    b) Otherwise, there shall be no <separator> between the <introducer> and the <character set specification>,
       and the set of characters contained in the <character string literal> shall be wholly contained in the
       character set specified by the <character set specification>.
13) The declared type of a <character string literal> is fixed-length character string. The length of a <character
    string literal> is the number of <character representation>s that it contains. Each <quote symbol> contained
    in <character string literal> represents a single <quote> in both the value and the length of the <character
    string literal>. The two <quote>s contained in a <quote symbol> shall not be separated by any <separator>.
    NOTE 72 — <character string literal>s are allowed to be zero-length strings (i.e., to contain no characters) even though it is not
    permitted to declare a <data type> that is CHARACTER with <length> 0 (zero).

14) The character set of a <character string literal> is
    Case:
    a) If the <character string literal> specifies a <character set specification>, then the character set specified
       by that <character set specification>.
    b) Otherwise, the character set of the SQL-client module that contains the <character string literal>.
15) The declared type collation of a <character string literal> is the character set collation, and the collation
    derivation is implicit.
16) The declared type of a <binary string literal> is binary string. Each <hexit> appearing in the literal is
    equivalent to a quartet of bits: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, and F are interpreted as 0000, 0001,
    0010, 0011, 0100, 0101, 0110, 0111, 1000, 1001, 1010, 1011, 1100, 1101, 1110, and 1111, respectively.
    The <hexit>s a, b, c, d, e, and f have respectively the same values as the <hexit>s A, B, C, D, E, and F.
17) An <exact numeric literal> without a <period> has an implied <period> following the last <digit>.
18) The declared type of an <exact numeric literal> ENL is an implementation-defined exact numeric type
    whose scale is the number of <digit>s to the right of the <period>. There shall be an exact numeric type
    capable of representing the value of ENL exactly.
19) The declared type of an <approximate numeric literal> ANL is an implementation-defined approximate
    numeric type. The value of ANL shall not be greater than the maximum value nor less than the minimum
    value that can be represented by the approximate numeric types.
    NOTE 73 — Thus the only syntax error for an <approximate numeric literal> is what is commonly known as “overflow”; there is
    no syntax error for specifying more significant digits than the SQL-implementation can represent internally, nor for specifying a
    value that has no exact equivalent in the SQL-implementation's internal representation. (“Underflow”, i.e., specifying a nonzero
    value so close to 0 (zero) that the closest representation in the SQL-implementation's internal representation is 0E0, is a special
    case of the latter condition, and is not a syntax error.)

20) The declared type of a <date literal> is DATE.




©ISO/IEC 2003 – All rights reserved                                                                         Lexical elements 147
ISO/IEC 9075-2:2003 (E)
5.3 <literal>



21) The declared type of a <time literal> that does not specify <time zone interval> is TIME(P) WITHOUT
    TIME ZONE, where P is the number of digits in <seconds fraction>, if specified, and 0 (zero) otherwise.
    The declared type of a <time literal> that specifies <time zone interval> is TIME(P) WITH TIME ZONE,
    where P is the number of digits in <seconds fraction>, if specified, and 0 (zero) otherwise.
22) The declared type of a <timestamp literal> that does not specify <time zone interval> is TIMESTAMP(P)
    WITHOUT TIME ZONE, where P is the number of digits in <seconds fraction>, if specified, and 0 (zero)
    otherwise. The declared type of a <timestamp literal> that specifies <time zone interval> is TIMESTAMP(P)
    WITH TIME ZONE, where P is the number of digits in <seconds fraction>, if specified, and 0 (zero) oth-
    erwise.
23) If <time zone interval> is not specified, then the effective <time zone interval> of the datetime data type
    is the current default time zone displacement for the SQL-session.
24) Let datetime component be either <years value>, <months value>, <days value>, <hours value>, <minutes
    value>, or <seconds value>.
25) Let N be the number of <primary datetime field>s in the precision of the <interval literal>, as specified by
    <interval qualifier>.
    The <interval literal> being defined shall contain N datetime components.
    The declared type of <interval literal> specified with an <interval qualifier> is INTERVAL with the
    <interval qualifier>.
    Each datetime component shall have the precision specified by the <interval qualifier>.
26) Within a <datetime literal>, the <years value> shall contain four digits. The <seconds integer value> and
    other datetime components, with the exception of <seconds fraction>, shall each contain two digits.
27) Within the definition of a <datetime literal>, the <datetime value>s are constrained by the natural rules for
    dates and times according to the Gregorian calendar.
28) Within the definition of an <interval literal>, the <datetime value>s are constrained by the natural rules for
    intervals according to the Gregorian calendar.
29) Within the definition of an <interval literal> that contains a <year-month literal>, the <interval qualifier>
    shall not specify DAY, HOUR, MINUTE, or SECOND. Within the definition of an <interval literal> that
    contains a <day-time literal>, the <interval qualifier> shall not specify YEAR or MONTH.
30) Within the definition of a <datetime literal>, the value of the <time zone interval> shall be in the range
    –12:59 to +14:00.


Access Rules
    None.


General Rules
1) The value of a <character string literal> is the result of transliterating the sequence of <character represen-
   tation>s that it contains from the source language character set to the implicit or explicit character set of
   the <character string literal>.



148 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                                    5.3 <literal>



2) If the character repertoire of a <character string literal> US is UCS, then its value is replaced by NORMAL-
   IZE(US).
3) The numeric value of an <exact numeric literal> is determined by the normal mathematical interpretation
   of positional decimal notation.
4) The numeric value of an <approximate numeric literal> is approximately the product of the exact numeric
   value represented by the <mantissa> with the number obtained by raising the number 10 to the power of
   the exact numeric value represented by the <exponent>.
5) The <sign> in a <signed numeric literal> or an <interval literal> is a monadic arithmetic operator. The
   monadic arithmetic operators + and – specify monadic plus and monadic minus, respectively. If neither
   monadic plus nor monadic minus are specified in a <signed numeric literal> or an <interval literal>, or if
   monadic plus is specified, then the literal is positive. If monadic minus is specified in a <signed numeric
   literal> or <interval literal>, then the literal is negative. If <sign> is specified in both possible locations in
   an <interval literal>, then the sign of the literal is determined by normal mathematical interpretation of
   multiple sign operators.
6) Let V be the integer value of the <unsigned integer> contained in <seconds fraction> and let N be the
   number of digits in the <seconds fraction> respectively. The resultant value of the <seconds fraction> is
   effectively determined as follows:
    Case:
    a) If <seconds fraction> is specified within the definition of a <datetime literal>, then the effective value
       of the <seconds fraction> is V * 10–N seconds.
    b) If <seconds fraction> is specified within the definition of an <interval literal>, then let M be the
       <interval fractional seconds precision> specified in the <interval qualifier>.
         Case:

         i)       If N < M, then let V1 be V * 10M–N; the effective value of the <seconds fraction> is V1 * 10–M
                  seconds.

         ii)      If N > M, then let V2 be the integer part of the quotient of V/10N–M; the effective value of the
                  <seconds fraction> is V2 * 10–M seconds.

         iii)     Otherwise, the effective value of the <seconds fraction> is V * 10–M seconds.
7) The i-th datetime component in a <datetime literal> or <interval literal> assigns the value of the datetime
   component to the i-th <primary datetime field> in the <datetime literal> or <interval literal>.
8) If <time zone interval> is specified, then the time and timestamp values in <time literal> and <timestamp
   literal> represent a datetime in the specified time zone.
9) If <date value> is specified, then it is interpreted as a date in the Gregorian calendar. If <time value> is
   specified, then it is interpreted as a time of day. Let DV be the value of the <datetime literal>, disregarding
   <time zone interval>.
    Case:




©ISO/IEC 2003 – All rights reserved                                                           Lexical elements 149
ISO/IEC 9075-2:2003 (E)
5.3 <literal>



    a) If <time zone interval> is specified, then let TZI be the value of the interval denoted by <time zone
       interval>. The value of the <datetime literal> is DV – TZI, with time zone displacement TZI.
    b) Otherwise, the value of the <datetime literal> is DV.
    NOTE 74 — If <time zone interval> is specified, then a <time literal> or <timestamp literal> is interpreted as local time with the
    specified time zone displacement. However, it is effectively converted to UTC while retaining the original time zone displacement.
    If <time zone interval> is not specified, then no assumption is made about time zone displacement. However, should a time zone
    displacement be required during subsequent processing, the current default time zone displacement of the SQL-session will be
    applied at that time.

10) The truth value of a <boolean literal> is True if TRUE is specified, is False if FALSE is specified, and is
    Unknown if UNKNOWN is specified.
    NOTE 75 — The null value of the boolean data type is equivalent to the Unknown truth value (see Subclause 4.5, “Boolean types”).


Conformance Rules
1) Without Feature T031, “BOOLEAN data type”, conforming SQL language shall not contain a <boolean
   literal>.
2) Without Feature F555, “Enhanced seconds precision”, in conforming SQL language, an <unsigned integer>
   that is a <seconds fraction> that is contained in a <timestamp literal> shall not contain more than 6 <digit>s.
3) Without Feature F555, “Enhanced seconds precision”, in conforming SQL language, a <time literal> shall
   not contain a <seconds fraction>.
4) Without Feature F421, “National character”, conforming SQL language shall not contain a <national
   character string literal>.
5) Without Feature F052, “Intervals and datetime arithmetic”, conforming SQL language shall not contain an
   <interval literal>.
6) Without Feature F271, “Compound character literals”, in conforming SQL language, a <character string
   literal> shall contain exactly one repetition of <character representation> (that is, it shall contain exactly
   one sequence of “<quote> <character representation>... <quote>”).
7) Without Feature F411, “Time zone specification”, conforming SQL language shall not contain a <time
   zone interval>.
8) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain a
   <binary string literal>.
9) Without Feature F393, “Unicode escapes in literals”, conforming SQL language shall not contain a <Unicode
   character string literal>.




150 Foundation (SQL/Foundation)                                                                   ©ISO/IEC 2003 – All rights reserved
                                                                       ISO/IEC 9075-2:2003 (E)
                                                                      5.4 Names and identifiers



5.4      Names and identifiers

Function
Specify names.


Format
<identifier> ::= <actual identifier>

<actual identifier> ::=
    <regular identifier>
  | <delimited identifier>
  | <Unicode delimited identifier>

<SQL language identifier> ::=
    <SQL language identifier start> [ <SQL language identifier part>... ]

<SQL language identifier start> ::= <simple Latin letter>

<SQL language identifier part> ::=
    <simple Latin letter>
  | <digit>
  | <underscore>

<authorization identifier> ::=
    <role name>
  | <user identifier>

<table name> ::= <local or schema qualified name>

<domain name> ::= <schema qualified name>

<schema name> ::= [ <catalog name> <period> ] <unqualified schema name>

<unqualified schema name> ::= <identifier>

<catalog name> ::= <identifier>

<schema qualified name> ::= [ <schema name> <period> ] <qualified identifier>

<local or schema qualified name> ::=
    [ <local or schema qualifier> <period> ] <qualified identifier>

<local or schema qualifier> ::=
    <schema name>
  | <local qualifier>

<qualified identifier> ::= <identifier>

<column name> ::= <identifier>

<correlation name> ::= <identifier>

<query name> ::= <identifier>




©ISO/IEC 2003 – All rights reserved                                       Lexical elements 151
ISO/IEC 9075-2:2003 (E)
5.4 Names and identifiers



<SQL-client module name> ::= <identifier>

<procedure name> ::= <identifier>

<schema qualified routine name> ::= <schema qualified name>

<method name> ::= <identifier>

<specific name> ::= <schema qualified name>

<cursor name> ::= <local qualified name>

<local qualified name> ::= [ <local qualifier> <period> ] <qualified identifier>

<local qualifier> ::= MODULE

<host parameter name> ::= <colon> <identifier>

<SQL parameter name> ::= <identifier>

<constraint name> ::= <schema qualified name>

<external routine name> ::=
    <identifier>
  | <character string literal>

<trigger name> ::= <schema qualified name>

<collation name> ::= <schema qualified name>

<character set name> ::= [ <schema name> <period> ] <SQL language identifier>

<transliteration name> ::= <schema qualified name>

<transcoding name> ::= <schema qualified name>

<schema-resolved user-defined type name> ::= <user-defined type name>

<user-defined type name> ::= [ <schema name> <period> ] <qualified identifier>

<attribute name> ::= <identifier>

<field name> ::= <identifier>

<savepoint name> ::= <identifier>

<sequence generator name> ::= <schema qualified name>

<role name> ::= <identifier>

<user identifier> ::= <identifier>

<connection name> ::= <simple value specification>

<SQL-server name> ::= <simple value specification>

<connection user name> ::= <simple value specification>

<SQL statement name> ::=
    <statement name>



152 Foundation (SQL/Foundation)                                  ©ISO/IEC 2003 – All rights reserved
                                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                                                   5.4 Names and identifiers



  | <extended statement name>

<statement name> ::= <identifier>

<extended statement name> ::= [ <scope option> ] <simple value specification>

<dynamic cursor name> ::=
    <cursor name>
  | <extended cursor name>

<extended cursor name> ::= [ <scope option> ] <simple value specification>

<descriptor name> ::= [ <scope option> ] <simple value specification>

<scope option> ::=
    GLOBAL
  | LOCAL

<window name> ::= <identifier>


Syntax Rules
1) In an <SQL language identifier>, the number of <SQL language identifier part>s shall be less than 128.
2) An <SQL language identifier> is equivalent to an <SQL language identifier> in which every letter that is
   a lower-case letter is replaced by the corresponding upper-case letter or letters. This treatment includes
   determination of equivalence, representation in the Information and Definition Schemas, representation in
   diagnostics areas, and similar uses.
    NOTE 76 — The Information Schema and Definition Schema are defined in ISO/IEC 9075-11.

3) An <SQL language identifier> (with every letter that is a lower-case letter replaced by the corresponding
   upper-case letter or letters), treated as the repetition of a <character string literal> that specifies a <character
   set specification> of SQL_IDENTIFIER, shall not be equal, according to the comparison rules in
   Subclause 8.2, “<comparison predicate>”, to any <reserved word> (with every letter that is a lower-case
   letter replaced by the corresponding upper-case letter or letters), treated as the repetition of a <character
   string literal> that specifies a <character set specification> of SQL_IDENTIFIER.
    NOTE 77 — It is the intention that no <key word> specified in ISO/IEC 9075 or revisions thereto shall end with an <underscore>.

4) If a <local or schema qualified name> does not contain a <local or schema qualifier>, then
    Case:
    a) If the <local or schema qualified name> is contained, without an intervening <schema definition>, in
       a <preparable statement> that is prepared in the current SQL-session by an <execute immediate state-
       ment> or a <prepare statement> or in a <direct SQL statement> that is invoked directly, then the default
       <unqualified schema name> for the SQL-session is implicit.
    b) If the <local or schema qualified name> is contained in a <schema definition>, then the <schema name>
       that is specified or implicit in the <schema definition> is implicit.
    c) Otherwise, the <schema name> that is specified or implicit for the SQL-client module is implicit.
5) Let TN be a <table name> with a <qualified identifier> QI and a <local or schema qualifier> LSQ.



©ISO/IEC 2003 – All rights reserved                                                                      Lexical elements 153
ISO/IEC 9075-2:2003 (E)
5.4 Names and identifiers



    Case:
    a) If LSQ is “MODULE”, then TN shall be contained in an <SQL-client module definition> M and the
       <module contents> of M shall contain a <temporary table declaration> TT whose <table name> has a
       <qualified identifier> equivalent to QI.
    b) Otherwise, LSQ shall be a <schema name> that identifies a schema that contains a <table definition>
       or <view definition> whose <table name> has a <qualified identifier> equivalent to QI.
6) If a <cursor name> CN with a <qualified identifier> QI does not contain a <local qualifier>, then the <local
   qualifier> MODULE is implicit.
7) Let CN be a <cursor name> with a <qualified identifier> QI and a <local qualifier> LQ. LQ shall be
   “MODULE” and CN shall be contained in an <SQL-client module definition> whose <module contents>
   contain a <declare cursor> whose <cursor name> is CN.
8) If <user-defined type name> UDTN with a <qualified identifier> QI is specified, then
    Case:
    a) If UDTN is simply contained in <path-resolved user-defined type name>, then
        Case:
        i)      If UDTN contains a <schema name> SN, then the schema identified by SN shall contain the
                descriptor of a user-defined type UDT such that the <qualified identifier> of UDT is equivalent
                to QI. UDT is the user-defined type identified by UDTN.
        ii)     Otherwise,
                1) Case:
                    A) If UDTN is contained, without an intervening <schema definition>, in a <preparable
                       statement> that is prepared in the current SQL-session by an <execute immediate
                       statement> or a <prepare statement> or in a <direct SQL statement> that is invoked
                       directly, then let DP be the SQL-path of the current SQL-session.
                    B) If UDTN is contained in a <schema definition>, then let DP be the SQL-path of that
                       <schema definition>.
                    C) Otherwise, let DP be the SQL-path of the <SQL-client module definition> that contains
                       UDTN.

                2) Let N be the number of <schema name>s in DP. Let Si, 1 (one) ≤ i ≤ N, be the i-th <schema
                   name> in DP.
                3) Let the set of subject types be the set containing every user-defined type T in the schema
                   identified by some Si, 1 (one) ≤ i ≤ N, such that the <qualified identifier> of T is equivalent
                   to QI. There shall be at least one type in the set of subject types.
                4) Let UDT be the user-defined type contained in the set of subject types such that there is no
                   other type UDT2 for which the <schema name> of the schema that includes the user-defined
                   type descriptor of UDT2 precedes in DP the <schema name> identifying the schema that
                   includes the user-defined type descriptor of UDT. UDTN identifies UDT.



154 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                                      5.4 Names and identifiers



                  5) The implicit <schema name> of UDTN is the <schema name> of the schema that includes
                     the user-defined type descriptor of UDT.
    b) If UDTN is simply contained in <schema-resolved user-defined type name> and UDTN does not contain
       a <schema name>, then
         Case:
         i)       If UDTN is contained, without an intervening <schema definition>, in a <preparable statement>
                  that is prepared in the current SQL-session by an <execute immediate statement> or a <prepare
                  statement> or in a <direct SQL statement> that is invoked directly, then the implicit <schema
                  name> of UDTN is the default <unqualified schema name> for the SQL-session.
         ii)      If UDTN is contained in a <schema definition>, then the implicit <schema name> of UDTN is
                  the <schema name> that is specified or implicit in <schema definition>.
         iii)     Otherwise, the implicit <schema name> of UDTN is the <schema name> that is specified or
                  implicit in <SQL-client module definition>.
9) Two <user-defined type name>s are equivalent if any only if they have equivalent <qualified identifier>s
   and equivalent <schema name>s, regardless of whether the <schema name>s are implicit or explicit.
10) No <unqualified schema name> shall specify DEFINITION_SCHEMA.
11) If a <transcoding name> does not specify a <schema name>, then INFORMATION_SCHEMA is implicit;
    otherwise, INFORMATION_SCHEMA shall be specified.
12) If a <character set name> does not specify a <schema name>, then
    Case:
    a) If <character set name> is not immediately contained in:
         i)       A <character set definition>.
         ii)      A <drop character set statement>.
         then <schema name> INFORMATION_SCHEMA is implicit.
    b) Otherwise,
         Case:
         i)       If the <character set name> is contained, without an intervening <schema definition>, in a
                  <preparable statement> that is prepared in the current SQL-session by an <execute immediate
                  statement> or a <prepare statement> or in a <direct SQL statement> that is invoked directly,
                  then the default <unqualified schema name> for the SQL-session is implicit.
         ii)      If the <character set name> is contained in a <schema definition>, then the <schema name> that
                  is specified or implicit in the <schema definition> is implicit.
         iii)     Otherwise, the <character set name> that is specified or implicit for the <SQL-client module
                  definition> is implicit.
13) If a <schema qualified name> SQN other than a <transcoding name> does not contain a <schema name>,
    then



©ISO/IEC 2003 – All rights reserved                                                       Lexical elements 155
ISO/IEC 9075-2:2003 (E)
5.4 Names and identifiers



    Case:
    a) If any of the following is true:
        i)      SQN is is immediately contained in a <collation name> that is not immediately contained in a
                <collation definition> or in a <drop collation statement>.
        ii)     SQN is immediately contained in a <transliteration name> that is not immediately contained in
                a <transliteration definition> or in a <drop transliteration statement>.
        then<schema name> INFORMATION_SCHEMA is implicit.
    b) Otherwise,
        Case:
        i)      If the <schema qualified name> is contained, without an intervening <schema definition>, in a
                <preparable statement> that is prepared in the current SQL-session by an <execute immediate
                statement> or a <prepare statement> or in a <direct SQL statement> that is invoked directly,
                then the default <unqualified schema name> for the SQL-session is implicit.
        ii)     If the <schema qualified name> is contained in a <schema definition>, then the <schema name>
                that is specified or implicit in the <schema definition> is implicit.
        iii)    Otherwise, the <schema name> that is specified or implicit for the <SQL-client module definition>
                is implicit.
14) If a <schema name> does not contain a <catalog name>, then
    Case:
    a) If the <unqualified schema name> is contained in a <preparable statement> that is prepared in the
       current SQL-session by an <execute immediate statement> or a <prepare statement> or in a <direct
       SQL statement> that is invoked directly, then the default catalog name for the SQL-session is implicit.
    b) If the <unqualified schema name> is contained in a <module authorization clause>, then an implemen-
       tation-defined <catalog name> is implicit.
    c) If the <unqualified schema name> is contained in a <schema definition> other than in a <schema name
       clause>, then the <catalog name> that is specified or implicit in the <schema name clause> is implicit.
    d) If the <unqualified schema name> is contained in a <schema name clause>, then
        Case:
        i)      If the <schema name clause> is contained in an <SQL-client module definition>, then the explicit
                or implicit <catalog name> contained in the <module authorization clause> is implicit.
        ii)     Otherwise, an implementation-defined <catalog name> is implicit.
    e) Otherwise, the explicit or implicit <catalog name> contained in the <module authorization clause> is
       implicit.
15) Two <schema qualified name>s are equivalent if and only if their <qualified identifier>s are equivalent
    and their <schema name>s are equivalent, regardless of whether the <schema name>s are implicit or explicit.




156 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                     5.4 Names and identifiers



16) Two <local or schema qualified name>s are equivalent if and only if their <qualified identifier>s are
    equivalent and either they both specify MODULE or they both specify or imply <schema name>s that are
    equivalent.
17) Two <character set name>s are equivalent if and only if their <SQL language identifier>s are equivalent
    and their <schema name>s are equivalent, regardless of whether the <schema name>s are implicit or explicit.
18) Two <schema name>s are equivalent if and only if their <unqualified schema name>s are equivalent and
    their <catalog name>s are equivalent, regardless of whether the <catalog name>s are implicit or explicit.
19) An <identifier> that is a <correlation name> is associated with a table within a particular scope. The scope
    of a <correlation name> is either a <select statement: single row>, <subquery>, or <query specification>
    (see Subclause 7.6, “<table reference>”), or is a <trigger definition> (see Subclause 11.39, “<trigger defi-
    nition>”). Scopes may be nested. In different scopes, the same <correlation name> may be associated with
    different tables or with the same table.
20) No <authorization identifier> shall specify “PUBLIC”.
21) Those <identifier>s that are valid <authorization identifier>s are implementation-defined.
22) Those <identifier>s that are valid <catalog name>s are implementation-defined.
23) The <data type> of <SQL-server name>, <connection name>, and <connection user name> shall be char-
    acter string with an implementation-defined character set and shall have an octet length of 128 characters
    or less.
24) The <simple value specification> of <extended statement name> or <extended cursor name> shall not be
    a <literal>.
25) The declared type of the <simple value specification> of <extended statement name> shall be character
    string with an implementation-defined character set and shall have an octet length of 128 octets or less.
26) The declared type of the <simple value specification> of <extended cursor name> shall be character string
    with an implementation-defined character set and shall have an octet length of 128 octets or less.
27) The declared type of the <simple value specification> of <descriptor name> shall be character string with
    an implementation-defined character set and shall have an octet length of 128 octets or less.
28) In a <descriptor name>, <extended statement name>, or <extended cursor name>, if a <scope option> is
    not specified, then a <scope option> of LOCAL is implicit.


Access Rules
    None.


General Rules
1) A <table name> identifies a table.
2) Within its scope, a <correlation name> identifies a table.
3) Within its scope, a <query name> identifies the table defined or returned by some associated <query
   expression body>.


©ISO/IEC 2003 – All rights reserved                                                       Lexical elements 157
ISO/IEC 9075-2:2003 (E)
5.4 Names and identifiers



4) A <column name> identifies a column.
5) A <domain name> identifies a domain.
6) An <authorization identifier> identifies a set of privileges.
7) An <SQL-client module name> identifies an SQL-client module.
8) A <schema qualified routine name> identifies an SQL-invoked routine.
9) A <method name> identifies an SQL-invoked method M whose descriptor is included in the schema that
   includes the descriptor of the user-defined type that is the type of M.
10) A <specific name> identifies an SQL-invoked routine.
11) A <cursor name> identifies a cursor.
12) A <host parameter name> identifies a host parameter.
13) An <SQL parameter name> identifies an SQL parameter.
14) An <external routine name> identifies an external routine.
15) A <trigger name> identifies a trigger.
16) A <constraint name> identifies a table constraint, a domain constraint, or an assertion.
17) A <catalog name> identifies a catalog.
18) A <schema name> identifies a schema.
19) A <collation name> identifies a collation.
20) A <character set name> identifies a character set.
21) A <transliteration name> identifies a character transliteration.
22) A <transcoding name> identifies a transcoding. All <transcoding name>s are implementation-defined.
23) A <connection name> identifies an SQL-connection.
24) A <user-defined type name> identifies a user-defined type.
25) An <attribute name> identifies an attribute of a structured type.
26) A <savepoint name> identifies a savepoint. The scope of a <savepoint name> is the SQL-transaction in
    which it was defined.
27) A <sequence generator name> identifies a sequence generator.
28) A <field name> identifies a field.
29) A <role name> identifies a role.
30) A <user identifier> identifies a user.
31) The value ESN of an <extended statement name> identifies a statement prepared by the execution of a
    <prepare statement>. If a <scope option> of GLOBAL is specified, then ESN is a global extended name;
    otherwise, it is a local extended name.


158 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                                ISO/IEC 9075-2:2003 (E)
                                                                                               5.4 Names and identifiers



    NOTE 78 — The scope of an extended name is defined in Subclause 4.24.2, “Dynamic SQL statements and descriptor areas”.

32) A <dynamic cursor name> is a non-extended name that identifies a cursor in an <SQL dynamic statement>.
    NOTE 79 — The scope of a non-extended name is defined in Subclause 4.24.2, “Dynamic SQL statements and descriptor areas”.

33) A <statement name> is a non-extended name that identifies a prepared statement created by the execution
    of a <prepare statement>.
34) The value ECN of an <extended cursor name> identifies a cursor created by the execution of an <allocate
    cursor statement>. If a <scope option> of GLOBAL is specified, then ECN is a global extended name;
    otherwise, it is a local extended name.
35) The value DN of a <descriptor name> identifies an SQL descriptor area created by the execution of an
    <allocate descriptor statement>. If a <scope option> of GLOBAL is specified, then DN is a global extended
    name; otherwise, it is a local extended name.
36) A <window name> identifies a window.


Conformance Rules
1) Without Feature T271, “Savepoints”, conforming SQL language shall not contain a <savepoint name>.
2) Without Feature T331, “Basic roles”, conforming SQL language shall not contain a <role name>.
3) Without Feature T121, “WITH (excluding RECURSIVE) in query expression”, conforming SQL language
   shall not contain a <query name>.
4) Without Feature S023, “Basic structured types”, conforming SQL language shall not contain a <attribute
   name>.
5) Without Feature T051, “Row types”, conforming SQL language shall not contain a <field name>.
6) Without Feature F651, “Catalog name qualifiers”, conforming SQL language shall not contain a <catalog
   name>.
7) Without Feature F771, “Connection management”, conforming SQL language shall not contain an explicit
   <connection name>.
8) Without Feature F690, “Collation support”, conforming SQL language shall not contain a <collation name>.
9) Without Feature F695, “Translation support”, conforming SQL language shall not contain a <transliteration
   name>.
10) Without Feature F695, “Translation support”, conforming SQL language shall not contain a <transcoding
    name>.
11) Without Feature F821, “Local table references”, conforming SQL language shall not contain a <local or
    schema qualifier> that contains a <local qualifier>.
12) Without Feature F251, “Domain support”, conforming SQL language shall not contain a <domain name>.
13) Without Feature F491, “Constraint management”, conforming SQL language shall not contain a <constraint
    name>.




©ISO/IEC 2003 – All rights reserved                                                                 Lexical elements 159
ISO/IEC 9075-2:2003 (E)
5.4 Names and identifiers



14) Without Feature F461, “Named character sets”, conforming SQL language shall not contain a <character
    set name>.
15) Without Feature T601, “Local cursor references”, a <cursor name> shall not contain a <local qualifier>.
16) Without Feature B032, “Extended dynamic SQL”, conforming SQL language shall not contain a <extended
    statement name> or <extended cursor name>.
17) Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain an <SQL
    statement name>.
18) Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain <dynamic
    cursor name>.
19) Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain a <descriptor
    name>.
20) Without Feature T612, “Advanced OLAP operations”, conforming SQL language shall not contain a
    <window name>.
21) Without Feature T176, “Sequence generator support”, conforming SQL language shall not contain a
    <sequence generator name>.
22) Without Feature B032, “Extended dynamic SQL”, conforming SQL language shall not contain a
    <descriptor name> that is not a <literal>.




160 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                     ISO/IEC 9075-2:2003 (E)
                                                                            6.1 <data type>




6 Scalar expressions


6.1      <data type>

Function
Specify a data type.


Format
<data type> ::=
    <predefined type>
  | <row type>
  | <path-resolved user-defined type name>
  | <reference type>
  | <collection type>

<predefined type> ::=
    <character string type> [ CHARACTER SET <character set specification> ]
    [ <collate clause> ]
  | <national character string type> [ <collate clause> ]
  | <binary large object string type>
  | <numeric type>
  | <boolean type>
  | <datetime type>
  | <interval type>

<character string type> ::=
    CHARACTER [ <left paren> <length> <right paren> ]
  | CHAR [ <left paren> <length> <right paren> ]
  | CHARACTER VARYING <left paren> <length> <right paren>
  | CHAR VARYING <left paren> <length> <right paren>
  | VARCHAR <left paren> <length> <right paren>
  | <character large object type>

<character large object type> ::=
    CHARACTER LARGE OBJECT [ <left paren> <large object length> <right paren> ]
  | CHAR LARGE OBJECT [ <left paren> <large object length> <right paren> ]
  | CLOB [ <left paren> <large object length> <right paren> ]

<national character string type> ::=
    NATIONAL CHARACTER [ <left paren> <length> <right paren> ]
  | NATIONAL CHAR [ <left paren> <length> <right paren> ]
  | NCHAR [ <left paren> <length> <right paren> ]
  | NATIONAL CHARACTER VARYING <left paren> <length> <right paren>
  | NATIONAL CHAR VARYING <left paren> <length> <right paren>
  | NCHAR VARYING <left paren> <length> <right paren>
  | <national character large object type>



©ISO/IEC 2003 – All rights reserved                                   Scalar expressions 161
ISO/IEC 9075-2:2003 (E)
6.1 <data type>



<national character large object type> ::=
    NATIONAL CHARACTER LARGE OBJECT [ <left paren> <large object length> <right paren> ]
  | NCHAR LARGE OBJECT [ <left paren> <large object length> <right paren> ]
  | NCLOB [ <left paren> <large object length> <right paren> ]

<binary large object string type> ::=
    BINARY LARGE OBJECT [ <left paren> <large object length> <right paren> ]
  | BLOB [ <left paren> <large object length> <right paren> ]

<numeric type> ::=
    <exact numeric type>
  | <approximate numeric type>

<exact numeric type> ::=
    NUMERIC [ <left paren> <precision> [ <comma> <scale> ] <right paren> ]
  | DECIMAL [ <left paren> <precision> [ <comma> <scale> ] <right paren> ]
  | DEC [ <left paren> <precision> [ <comma> <scale> ] <right paren> ]
  | SMALLINT
  | INTEGER
  | INT
  | BIGINT

<approximate numeric type> ::=
    FLOAT [ <left paren> <precision> <right paren> ]
  | REAL
  | DOUBLE PRECISION

<length> ::= <unsigned integer> [ <char length units> ]

<large object length> ::=
    <unsigned integer> [ <multiplier> ] [ <char length units> ]
  | <large object length token> [ <char length units> ]

<char length units> ::=
    CHARACTERS
  | OCTETS

<precision> ::= <unsigned integer>

<scale> ::= <unsigned integer>

<boolean type> ::= BOOLEAN

<datetime type> ::=
    DATE
  | TIME [ <left paren> <time precision> <right paren> ] [ <with or without time zone> ]
  | TIMESTAMP [ <left paren> <timestamp precision> <right paren> ]
    [ <with or without time zone> ]

<with or without time zone> ::=
    WITH TIME ZONE
  | WITHOUT TIME ZONE

<time precision> ::= <time fractional seconds precision>

<timestamp precision> ::= <time fractional seconds precision>

<time fractional seconds precision> ::= <unsigned integer>



162 Foundation (SQL/Foundation)                                   ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                                                6.1 <data type>



<interval type> ::= INTERVAL <interval qualifier>

<row type> ::= ROW <row type body>

<row type body> ::=
    <left paren> <field definition> [ { <comma> <field definition> }... ] <right paren>

<reference type> ::= REF <left paren> <referenced type> <right paren> [ <scope clause> ]

<scope clause> ::= SCOPE <table name>

<referenced type> ::= <path-resolved user-defined type name>

<path-resolved user-defined type name> ::= <user-defined type name>

<collection type> ::=
    <array type>
  | <multiset type>

<array type> ::=
    <data type> ARRAY
    [ <left bracket or trigraph> <maximum cardinality> <right bracket or trigraph> ]

<maximum cardinality> ::= <unsigned integer>

<multiset type> ::= <data type> MULTISET


Syntax Rules
1) CHAR is equivalent to CHARACTER. DEC is equivalent to DECIMAL. INT is equivalent to INTEGER.
   VARCHAR is equivalent to CHARACTER VARYING. NCHAR is equivalent to NATIONAL CHARAC-
   TER. CLOB is equivalent to CHARACTER LARGE OBJECT. NCLOB is equivalent to NATIONAL
   CHARACTER LARGE OBJECT. BLOB is equivalent to BINARY LARGE OBJECT.
2) “NATIONAL CHARACTER” is equivalent to the corresponding <character string type> with a specification
   of “CHARACTER SET CSN”, where “CSN” is an implementation-defined <character set name>.
3) If <character string type> is specified, then the collation derivation of the resulting character string type is
   implicit.
    Case:
    a) If <collate clause> is specified, then the collation specified by it shall be applicable to the explicit or
       implicit character set CS of the character string type. That collation is the declared type collation of
       the character string type.
    b) Otherwise, the character set collation of CS is the declared type collation of the character string type.
4) The value of a <length> or a <precision> shall be greater than 0 (zero).
5) If <length> is omitted, then a <length> of 1 (one) is implicit.
6) If <char length units> is specified, then the character repertoire of the explicit or implicit character set of
   the character type shall be UCS.
7) If <char length units> is not specified, CHARACTERS is implicit.


©ISO/IEC 2003 – All rights reserved                                                       Scalar expressions 163
ISO/IEC 9075-2:2003 (E)
6.1 <data type>



8) If <large object length> is omitted, then an implementation-defined <large object length> is implicit.
9) The numeric value of a <large object length> is determined as follows.
    Case:
    a) If <large object length> immediately contains <unsigned integer> and does not immediately contain
       <multiplier>, then the numeric value of <large object length> is the numeric value of the specified
       <unsigned integer>.
    b) If <large object length> immediately contains <large object length token> or immediately contains
       <unsigned integer> and <multiplier>, then let D be the value of the specified <unsigned integer> or
       the numeric value of the sequence of <digit>s of <large object length token> interpreted as an <unsigned
       integer>. The numeric value of <large object length> is the numeric value resulting from the multipli-
       cation of D and MS, then MS is:
        i)      If <multiplier> is K, then 1,024.
        ii)     If <multiplier> is M, then 1,048,576.
        iii)    If <multiplier> is G, then 1,073,741,824.
10) If a <scale> is omitted, then a <scale> of 0 (zero) is implicit.
11) If a <precision> is omitted, then an implementation-defined <precision> is implicit.
12) CHARACTER specifies the data type character string.
13) Characters in a character string are numbered beginning with 1 (one).
14) Case:
    a) If neither VARYING nor LARGE OBJECT is specified in <character string type>, then the length in
       characters of the character string is fixed and is the value of <length>.
    b) If VARYING is specified in <character string type>, then the length in characters of the character string
       is variable, with a minimum length of 0 (zero) and a maximum length of the value of <length>.
    c) If LARGE OBJECT is specified in a <character string type>, then the length in characters of the char-
       acter string is variable, with a minimum length of 0 (zero) and a maximum length of the value of <large
       object length>.
15) The maximum values of <length> and <large object length> are implementation-defined. Neither <length>
    nor <large object length> shall be greater than the corresponding maximum value.
16) If <character string type> is not contained in a <domain definition> or a <column definition> and CHAR-
    ACTER SET is not specified, then an implementation-defined <character set specification> that specifies
    an implementation-defined character set that contains at least every character that is in <SQL language
    character> is implicit.
    NOTE 80 — Subclause 11.24, “<domain definition>”, and Subclause 11.4, “<column definition>”, specify the result when
    <character string type> is contained in a <domain definition> or <column definition>, respectively.

17) BINARY LARGE OBJECT specifies the data type binary string.
18) Octets in a binary large object string are numbered beginning with 1 (one). The length in octets of the string
    is variable, with a minimum length of 0 (zero) and a maximum length of the value of <large object length>.


164 Foundation (SQL/Foundation)                                                            ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                               6.1 <data type>



19) The <scale> of an <exact numeric type> shall not be greater than the <precision> of the <exact numeric
    type>.
20) For the <exact numeric type>s DECIMAL and NUMERIC:
    a) The maximum value of <precision> is implementation-defined. <precision> shall not be greater than
       this value.
    b) The maximum value of <scale> is implementation-defined. <scale> shall not be greater than this
       maximum value.
21) NUMERIC specifies the data type exact numeric, with the decimal precision and scale specified by the
    <precision> and <scale>.
22) DECIMAL specifies the data type exact numeric, with the decimal scale specified by the <scale> and the
    implementation-defined decimal precision equal to or greater than the value of the specified <precision>.
23) SMALLINT, INTEGER, and BIGINT specify the data type exact numeric, with scale of 0 (zero) and binary
    or decimal precision. The choice of binary versus decimal precision is implementation-defined, but the
    same radix shall be chosen for all three data types. The precision of SMALLINT shall be less than or equal
    to the precision of INTEGER, and the precision of BIGINT shall be greater than or equal to the precision
    of INTEGER.
24) FLOAT specifies the data type approximate numeric, with binary precision equal to or greater than the
    value of the specified <precision>. The maximum value of <precision> is implementation-defined. <preci-
    sion> shall not be greater than this value.
25) REAL specifies the data type approximate numeric, with implementation-defined precision.
26) DOUBLE PRECISION specifies the data type approximate numeric, with implementation-defined precision
    that is greater than the implementation-defined precision of REAL.
27) For the <approximate numeric type>s FLOAT, REAL, and DOUBLE PRECISION, the maximum and
    minimum values of the exponent are implementation-defined.
28) If <time precision> is not specified, then 0 (zero) is implicit. If <timestamp precision> is not specified,
    then 6 is implicit.
29) If <with or without time zone> is not specified, then WITHOUT TIME ZONE is implicit.
30) The maximum value of <time precision> and the maximum value of <timestamp precision> shall be the
    same implementation-defined value that is not less than 6. The values of <time precision> and <timestamp
    precision> shall not be greater than that maximum value.
31) The length of a DATE is 10 positions. The length of a TIME WITHOUT TIME ZONE is 8 positions plus
    the <time fractional seconds precision>, plus 1 (one) position if the <time fractional seconds precision> is
    greater than 0 (zero). The length of a TIME WITH TIME ZONE is 14 positions plus the <time fractional
    seconds precision> plus 1 (one) position if the <time fractional seconds precision> is greater than 0 (zero).
    The length of a TIMESTAMP WITHOUT TIME ZONE is 19 positions plus the <time fractional seconds
    precision>, plus 1 (one) position if the <time fractional seconds precision> is greater than 0 (zero). The
    length of a TIMESTAMP WITH TIME ZONE is 25 positions plus the <time fractional seconds precision>
    plus 1 (one) position if the <time fractional seconds precision> is greater than 0 (zero).




©ISO/IEC 2003 – All rights reserved                                                      Scalar expressions 165
ISO/IEC 9075-2:2003 (E)
6.1 <data type>



32) An <interval type> specifying an <interval qualifier> whose <start field> and <end field> are both either
    YEAR or MONTH or whose <single datetime field> is YEAR or MONTH is a year-month interval type.
    An <interval type> that is not a year-month interval type is a day-time interval type.
    NOTE 81 — The length of interval data types is specified in the General Rules of Subclause 10.1, “<interval qualifier>”.

33) The i-th value of an interval data type corresponds to the i-th <primary datetime field>.
34) If <data type> is a <reference type>, then at least one of the following conditions shall be true:
    a) There exists a user-defined type descriptor whose user-defined type name is <user-defined type name>
       UDTN simply contained in <referenced type>. UDTN shall identify a structured type.
    b) <reference type> is contained in the <member list> of <user-defined type definition> UDTD and the
       <path-resolved user-defined type name> simply contained in <referenced type> is equivalent to the
       <schema-resolved user-defined type name> contained in UDTD.
35) The <table name> contained in a <scope clause> shall identify a referenceable table whose structured type
    is UDTN.
36) The <table name> STN specified in <scope clause> identifies the scope of the reference type. This scope
    consists of every row in the table identified by STN.
37) An <array type> AT specifies an array type. The <data type> immediately contained in AT is the element
    type of the array type. The <maximum cardinality> immediately contained in AT is the maximum cardinality
    of a site of data type AT. If the maximum cardinality is not specified, then an implementation-defined
    maximum cardinality is implicit.
38) A <multiset type> MT specifies a multiset type. The <data type> immediately contained in MT is the element
    type of the multiset type.
39) <row type> specifies the row data type.
40) BOOLEAN specifies the boolean data type.
41) If <data type> DT1 is contained in a <data type> DT2, then the root data type of DT1 is the outermost
    <data type> that contains DT1.


Access Rules
1) If <user-defined type name>, <reference type>, <row type>, or <collection type> TY is specified, and TY
   is usage-dependent on a user-defined type UDT, then
    Case:
    a) If TY is contained, without an intervening <SQL routine spec> that specifies SQL SECURITY
       INVOKER, in an <SQL schema statement>, then the applicable privileges shall include the USAGE
       privilege on UDT.
    b) Otherwise, the current privileges shall include the USAGE privilege on UDT.
    NOTE 82 — “applicable privileges” and “current privileges” are defined in Subclause 12.3, “<privileges>”.




166 Foundation (SQL/Foundation)                                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                                                 6.1 <data type>



General Rules
1) If the result of any specification or operation would be a character value one of whose characters is not in
   the character set of its declared type, then an exception condition is raised: data exception — character not
   in repertoire.
2) If any specification or operation attempts to cause an item of a character string type whose character set
   has a character repertoire of UCS to contain a code point that is a noncharacter, then an exception condition
   is raised: data exception — noncharacter in UCS string.
3) If <char length units> other than CHARACTERS is specified, then the conversion of the value of <length>
   to characters is implementation-defined.
4) For a <datetime type>,
    Case:
    a) If DATE is specified, then the data type contains the <primary datetime field>s years, months, and
       days.
    b) If TIME is specified, then the data type contains the <primary datetime field>s hours, minutes, and
       seconds.
    c) If TIMESTAMP is specified, then the data type contains the <primary datetime field>s years, months,
       days, hours, minutes, and seconds.
    d) If WITH TIME ZONE is specified, then the data type contains the time zone datetime fields.
         NOTE 83 — Within the non-null values of a <datetime type>, the value of the time zone interval is in the range –13:59 to
         +14:00. The range for time zone intervals is larger than many readers might expect because it is governed by political decisions
         in governmental bodies rather than by any natural law.
    NOTE 84 — A <datetime type> contains no other fields than those specified by the preceding Rule.

5) For a <datetime type>, a <time fractional seconds precision> that is an explicit or implicit <time precision>
   or <timestamp precision> defines the number of decimal digits following the decimal point in the SECOND
   <primary datetime field>.
6) Table 9, “Valid values for datetime fields”, specifies the constraints on the values of the <primary datetime
   field>s in datetime values. The values of TIMEZONE_HOUR and TIMEZONE_MINUTE shall either
   both be non-negative or both be non-positive.

                                               Table 9 — Valid values for datetime fields


      Keyword                         Valid values of datetime fields

      YEAR                            0001 to 9999

      MONTH                           01 to 12

      DAY                             Within the range 1 (one) to 31, but further constrained by the value of MONTH
                                      and YEAR fields, according to the rules for well-formed dates in the Gregorian
                                      calendar.



©ISO/IEC 2003 – All rights reserved                                                                        Scalar expressions 167
ISO/IEC 9075-2:2003 (E)
6.1 <data type>



     Keyword                        Valid values of datetime fields

     HOUR                           00 to 23

     MINUTE                         00 to 59

     SECOND                         00 to 61.9(N) where “9(N)” indicates the number of digits specified by <time
                                    fractional seconds precision>.

     TIMEZONE_HOUR                  -12 to 14

     TIMEZONE_MINUTE -59 to 59

    NOTE 85 — Datetime data types will allow dates in the Gregorian format to be stored in the date range 0001–01–01 CE through
    9999–12–31 CE. The range for SECOND allows for as many as two “leap seconds”. Interval arithmetic that involves leap seconds
    or discontinuities in calendars will produce implementation-defined results.

7) An interval value can be zero, positive, or negative.
8) The values of the <primary datetime field>s within an interval data type are constrained as follows:
    a) The value corresponding to the first <primary datetime field> is an integer with at most N digits, where
       N is the <interval leading field precision>.
    b) Table 10, “Valid absolute values for interval fields”, specifies the constraints for the absolute values
       of other <primary datetime field>s in interval values.
    c) If an interval value is zero, then all fields of the interval are zero.
    d) If an interval value is positive, then all fields of the interval are non-negative and at least one field is
       positive.
    e) If an interval value is negative, then all fields of the interval are non-positive, and at least one field is
       negative.

                                      Table 10 — Valid absolute values for interval fields


     Keyword            Valid values of INTERVAL fields

     MONTH              0 to 11


     HOUR               0 to 23

     MINUTE             0 to 59

     SECOND             0 to 59.9(N) where “9(N)” indicates the number of digits specified by <interval fractional
                        seconds precision> in the <interval qualifier>.

9) If <data type> specifies a character string type, then a character string type descriptor is created, including
   the following:


168 Foundation (SQL/Foundation)                                                              ©ISO/IEC 2003 – All rights reserved
                                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                                                           6.1 <data type>



    a) The name of the data type (either CHARACTER, CHARACTER VARYING, or CHARACTER
       LARGE OBJECT).
    b) The length or maximum length in characters of the character string type.
    c) The catalog name, schema name, and character set name of the character set of the character string
       type.
    d) The catalog name, schema name, and collation name of the collation of the character string type.
10) If <data type> is a <binary large object string type>, then a binary string data type descriptor is created,
    including the following:
    a) The name of the data type (BINARY LARGE OBJECT).
    b) The maximum length in octets of the binary string data type.
11) If <data type> DT specifies an exact numeric type, then:
    a) There shall be an implementation-defined function ENNF() that converts any <exact numeric type>
       ENT1 into some possibly different <exact numeric type> ENT2 (the normal form of ENT1), subject to
       the following constraints on ENNF():
         i)       For every <exact numeric type> ENT, ENNF(ENT) shall not specify DEC or INT.
                  NOTE 86 — The preceding requirement prohibits the function ENNF from returning a value that uses the abbreviated
                  spelling of the two data types; the function shall instead return the long versions of DECIMAL or INTEGER.

         ii)      For every <exact numeric type> ENT, the precision, scale, and radix of ENNF(ENT) shall be
                  the precision, scale, and radix of ENT.
         iii)     For every <exact numeric type> ENT, ENNF(ENT) shall be the same as ENNF(ENNF(ENT)).
         iv)      For every <exact numeric type> ENT, if ENNF(ENT) specifies DECIMAL, then ENNF(ENT)
                  shall specify <precision>, and the precision of ENNF(ENT) shall be the value of the <precision>
                  specified in ENNF(ENT).
    b) A numeric data type descriptor is created for DT, including the following:
         i)       The name of the type specified in ENNF(DT) (NUMERIC, DECIMAL, INTEGER, or
                  SMALLINT).
         ii)      The precision of DT.
         iii)     The scale of DT.
         iv)      An indication of whether the precision and scale are expressed in decimal or binary terms.
12) If <data type> DT specifies an approximate numeric type, then:
    a) There shall be an implementation-defined function ANNF() that converts any <approximate numeric
       type> ANT into some possibly different <approximate numeric type> ANT2 (the normal form of ANT1),
       subject to the following constraints on ANNF():
         i)       For every <approximate numeric type> ANT, the precision of ANNF(ANT) shall be the precision
                  of ANT.




©ISO/IEC 2003 – All rights reserved                                                                   Scalar expressions 169
ISO/IEC 9075-2:2003 (E)
6.1 <data type>



        ii)      For every <approximate numeric type> ANT, ANNF(ANT) shall be the same as
                 ANNF(ANNF(ANT)).
        iii)     For every <approximate numeric type> ANT, if ANNF(ANT) specifies FLOAT, then ANNF(ANT)
                 shall specify <precision>, and the precision of ANNF(ANT) shall be the value of the <precision>
                 specified in ANNF(ANT).
    b) A numeric data type descriptor is created for DT including the following:
        i)       The name of the type specified in ANNF(DT) (FLOAT, REAL, or DOUBLE PRECISION).
        ii)      The precision of DT.
        iii)     An indication that the precision is expressed in binary terms.
13) If <data type> specifies <boolean type>, then a boolean data type descriptor is created, including the name
    of the boolean type (BOOLEAN).
14) If <data type> specifies a <datetime type>, then a datetime data type descriptor is created, including the
    following:
    a) The name of the datetime type (DATE, TIME WITHOUT TIME ZONE, TIME WITH TIME ZONE,
       TIMESTAMP WITHOUT TIME ZONE, or TIMESTAMP WITH TIME ZONE).
    b) The value of the <time fractional seconds precision>, if DATE is not specified.
15) If <data type> specifies an <interval type>, then an interval data type descriptor is created, including the
    following:
    a) The name of the interval data type (INTERVAL).
    b) An indication of whether the interval data type is a year-month interval or a day-time interval.
    c) The <interval qualifier> simply contained in the <interval type>.
16) If <data type> is a <collection type>, then a collection type descriptor is created. Let KC be the kind of
    collection (either ARRAY or MULTISET) specified by <collection type>. Let ET be the element type of
    <collection type>. Let ETD be the type designator of ET. The collection type descriptor includes the type
    designator EDT KC, an indication of KC, the descriptor of ET, and (in the case of array types) the maximum
    cardinality.
17) For a <row type> RT, the degree of RT is initially set to 0 (zero). The General Rules of Subclause 6.2,
    “<field definition>”, specify the degree of RT during the definition of the fields of RT.
18) If the <data type> is a <row type>, then a row type descriptor is created. The row type descriptor includes
    a field descriptor for every <field definition> of the <row type>.
19) A <reference type> identifies a reference type.
20) If <data type> is a <reference type>, then a reference type descriptor is created. Let RDTN be the name of
    the <referenced type>. The reference type descriptor includes the type designator REF(RDTN). If a <scope
    clause> is specified, then the reference type descriptor includes STN, identifying the scope of the reference
    type.
    NOTE 87 — The user-defined type descriptor for a user-defined type is created in the General Rules of Subclause 11.41, “<user-
    defined type definition>”.




170 Foundation (SQL/Foundation)                                                                ©ISO/IEC 2003 – All rights reserved
                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                                          6.1 <data type>



Conformance Rules
1) Without Feature S023, “Basic structured types”, conforming SQL language shall not contain a <path-
   resolved user-defined type name> that identifies a structured type.
2) Without Feature T031, “BOOLEAN data type”, conforming SQL language shall not contain a <boolean
   type>.
3) Without Feature F555, “Enhanced seconds precision”, conforming SQL language shall not contain a <time
   precision> that does not specify 0 (zero).
4) Without Feature F555, “Enhanced seconds precision”, conforming SQL language shall not contain a
   <timestamp precision> that does not specify either 0 (zero) or 6.
5) Without Feature F052, “Intervals and datetime arithmetic”, conforming SQL language shall not contain an
   <interval type>.
6) Without Feature F421, “National character”, conforming SQL language shall not contain a <national
   character string type>
7) Without Feature F411, “Time zone specification”, conforming SQL language shall not contain <with or
   without time zone>.
8) Without Feature S041, “Basic reference types”, conforming SQL language shall not contain a <reference
   type>.
9) Without Feature T051, “Row types”, conforming SQL language shall not contain a <row type>.
10) Without Feature S091, “Basic array support”, conforming SQL language shall not contain an <array type>.
11) Without Feature S271, “Basic multiset support”, conforming SQL language shall not contain a <multiset
    type>.
12) Without Feature S281, “Nested collection types”, conforming SQL language shall not contain a collection
    type that is based on a <data type> that contains a <collection type>.
13) Without Feature S043, “Enhanced reference types”, conforming SQL language shall not contain a <scope
    clause> that is not simply contained in a <data type> that is simply contained in a <column definition>.
14) Without Feature S092, “Arrays of user-defined types”, conforming SQL language shall not contain an
    <array type> that is based on a <data type> that contains a <path-resolved user-defined type name>.
15) Without Feature S272, “Multisets of user-defined types”, conforming SQL language shall not contain a
    <multiset type> that is based on a <data type> that contains a <path-resolved user-defined type name>.
16) Without Feature S094, “Arrays of reference types”, conforming SQL language shall not contain an <array
    type> that is based on a <data type> that contains a <reference type>.
17) Without Feature S274, “Multisets of reference types”, conforming SQL language shall not contain a
    <multiset type> that is based on a <data type> that contains a <reference type>.
18) Without Feature S096, “Optional array bounds”, conforming SQL language shall not contain an <array
    type> that does not immediately contain <maximum cardinality>.




©ISO/IEC 2003 – All rights reserved                                                  Scalar expressions 171
ISO/IEC 9075-2:2003 (E)
6.1 <data type>



19) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain a
    <binary large object string type>, a <character large object type>, or a <national character large object
    type>.
20) Without Feature T061, “UCS support”, conforming SQL language shall not contain a <char length units>.
21) Without Feature T071, “BIGINT data type”, conforming SQL language shall not contain BIGINT.




172 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                             6.2 <field definition>



6.2       <field definition>

Function
Define a field of a row type.


Format
<field definition> ::= <field name> <data type>


Syntax Rules
1) Let RT be the <row type> that simply contains a <field definition>.
2) The <field name> shall not be equivalent to the <field name> of any other <field definition> simply contained
   in RT.
3) The declared type of the field is <data type>.
4) Let DT be the <data type>.
5) If DT is CHARACTER or CHARACTER VARYING and does not specify a <character set specification>,
   then the <character set specification> specified or implicit in the <schema character set specification> is
   implicit.


Access Rules
      None.


General Rules
1) A data type descriptor is created that describes the declared type of the field being defined.
2) The degree of the row type RT being defined in the simply containing <row type> is increased by 1 (one).
3) A field descriptor is created that describes the field being defined. The field descriptor includes the following:
      a) The <field name>.
      b) The data type descriptor of the declared type of the field.
      c) The ordinal position of the field in RT.
4) The field descriptor is included in the row type descriptor for RT.


Conformance Rules
1) Without Feature T051, “Row types”, conforming SQL language shall not contain a <field definition>.



©ISO/IEC 2003 – All rights reserved                                                         Scalar expressions 173
ISO/IEC 9075-2:2003 (E)
6.3 <value expression primary>



6.3     <value expression primary>

Function
Specify a value that is syntactically self-delimited.


Format
<value expression primary> ::=
    <parenthesized value expression>
  | <nonparenthesized value expression primary>

<parenthesized value expression> ::= <left paren> <value expression> <right paren>

<nonparenthesized value expression primary> ::=
    <unsigned value specification>
  | <column reference>
  | <set function specification>
  | <window function>
  | <scalar subquery>
  | <case expression>
  | <cast specification>
  | <field reference>
  | <subtype treatment>
  | <method invocation>
  | <static method invocation>
  | <new specification>
  | <attribute or method reference>
  | <reference resolution>
  | <collection value constructor>
  | <array element reference>
  | <multiset element reference>
  | <routine invocation>
  | <next value expression>

<collection value constructor> ::=
    <array value constructor>
  | <multiset value constructor>


Syntax Rules
1) The declared type of a <value expression primary> is the declared type of the simply contained <value
   expression>, <unsigned value specification>, <column reference>, <set function specification>, <window
   function>, <scalar subquery>, <case expression>, <cast specification>, <field reference>, <subtype treat-
   ment>, <method invocation>, <static method invocation>, <new specification>, <attribute or method ref-
   erence>, <reference resolution>, <collection value constructor>, <array element reference>, <multiset
   element reference>, or <next value expression>, or the effective returns type of the simply contained
   <routine invocation>, respectively.
2) Let NVEP be a <nonparenthesized value expression primary> of the form “A.B C”, where A satisfies the
   Format of <schema name>, B satisfies the Format of <identifier>, and C satisfies the Format of <SQL


174 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                                              6.3 <value expression primary>



    argument list>. If NVEP satisfies the Format, Syntax Rules, and Access Rules of Subclause 6.16, “<method
    invocation>”, then NVEP is treated as a <method invocation>; otherwise, NVEP is treated as a <routine
    invocation>.
    NOTE 88 — The formal grammar defined in the Format and Syntax Rules of Subclause 6.16, “<method invocation>”, and of
    Subclause 10.4, “<routine invocation>”, does not necessarily disambiguate between a <method invocation> and the invocation of
    a regular function. In such cases, the preceding Syntax Rule ensures that a <nonparenthesized value expression primary> that sat-
    isfies the Format, Syntax Rules, and Access Rules of Subclause 6.16, “<method invocation>”, is treated as a <method invocation>.

3) The declared type of a <collection value constructor> is the declared type of the <array value constructor>
   or <multiset value constructor> that it immediately contains.


Access Rules
    None.


General Rules
1) The value of a <value expression primary> is the value of the simply contained <value expression>,
   <unsigned value specification>, <column reference>, <set function specification>, <window function>,
   <scalar subquery>, <case expression>, <cast specification>, <field reference>, <subtype treatment>,
   <method invocation>, <static method invocation>, <new specification>, <attribute or method reference>,
   <reference resolution>, <collection value constructor>, <array element reference>, <multiset element ref-
   erence>, <routine invocation>, or <next value expression>.
2) The value of a <collection value constructor> is the value of the <array value constructor> or <multiset
   value constructor> that it immediately contains.


Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved                                                                     Scalar expressions 175
ISO/IEC 9075-2:2003 (E)
6.4 <value specification> and <target specification>



6.4     <value specification> and <target specification>

Function
Specify one or more values, host parameters, SQL parameters, dynamic parameters, or host variables.


Format
<value specification> ::=
    <literal>
  | <general value specification>

<unsigned value specification> ::=
    <unsigned literal>
  | <general value specification>

<general value specification> ::=
    <host parameter specification>
  | <SQL parameter reference>
  | <dynamic parameter specification>
  | <embedded variable specification>
  | <current collation specification>
  | CURRENT_DEFAULT_TRANSFORM_GROUP
  | CURRENT_PATH
  | CURRENT_ROLE
  | CURRENT_TRANSFORM_GROUP_FOR_TYPE <path-resolved user-defined type name>
  | CURRENT_USER
  | SESSION_USER
  | SYSTEM_USER
  | USER
  | VALUE

<simple value specification> ::=
    <literal>
  | <host parameter name>
  | <SQL parameter reference>
  | <embedded variable name>

<target specification> ::=
    <host parameter specification>
  | <SQL parameter reference>
  | <column reference>
  | <target array element specification>
  | <dynamic parameter specification>
  | <embedded variable specification>

<simple target specification> ::=
    <host parameter specification>
  | <SQL parameter reference>
  | <column reference>
  | <embedded variable name>

<host parameter specification> ::= <host parameter name> [ <indicator parameter> ]




176 Foundation (SQL/Foundation)                                               ©ISO/IEC 2003 – All rights reserved
                                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                        6.4 <value specification> and <target specification>



<dynamic parameter specification> ::= <question mark>

<embedded variable specification> ::= <embedded variable name> [ <indicator variable> ]

<indicator variable> ::= [ INDICATOR ] <embedded variable name>

<indicator parameter> ::= [ INDICATOR ] <host parameter name>

<target array element specification> ::=
    <target array reference>
    <left bracket or trigraph> <simple value specification> <right bracket or trigraph>

<target array reference> ::=
    <SQL parameter reference>
  | <column reference>

<current collation specification> ::=
    COLLATION FOR <left paren> <string value expression> <right paren>


Syntax Rules
1) The declared type of an <indicator parameter> shall be exact numeric with scale 0 (zero).
2) Each <host parameter name> shall be contained in an <SQL-client module definition>.
3) If USER is specified, then CURRENT_USER is implicit.
    NOTE 89 — In an environment where the SQL-implementation conforms to Core SQL, conforming SQL language that contains
    either:
    —    A specified or implied <comparison predicate> that compares the <value specification> USER with a <value specification>
         other than USER, or
    —    A specified or implied assignment in which the “value” (as defined in Subclause 9.2, “Store assignment”) contains the <value
         specification> USER
    will become non-conforming in an environment where the SQL-implementation conforms to some SQL package that supports
    character internationalization, unless the character repertoire of the implementation-defined character set in that environment is
    identical to the character repertoire of SQL_IDENTIFIER.

4) The declared type of CURRENT_USER, CURRENT_ROLE, SESSION_USER, SYSTEM_USER, and
   CURRENT_PATH is character string. Whether the character string is fixed length or variable length, and
   its length if it is fixed length or maximum length if it is variable length, are implementation-defined. The
   character set of the character string is SQL_IDENTIFIER. The declared type collation is the character set
   collation of SQL_IDENTIFIER, and the collation derivation is implicit.
5) The declared type of <string value expression> simply contained in <current collation specification> shall
   be character string. The declared type of <current collation specification> is character string. Whether the
   character string is fixed length or variable length, and its length if fixed length or maximum length if variable
   length, are implementation-defined. The character set of the character string is SQL_IDENTIFIER. The
   collation is the character set collation of SQL_IDENTIFIER, and the collation derivation is implicit.
6) The <value specification> or <unsigned value specification> VALUE shall be contained in a <domain
   constraint>. The declared type of an instance of VALUE is the declared type of the domain to which that
   domain constraint belongs.




©ISO/IEC 2003 – All rights reserved                                                                       Scalar expressions 177
ISO/IEC 9075-2:2003 (E)
6.4 <value specification> and <target specification>



7) A <target specification> or <simple target specification> that is a <column reference> shall be a new
   transition variable column reference.
    NOTE 90 — “new transition variable column reference” is defined in Subclause 6.6, “<identifier chain>”.

8) If <target array element specification> is specified, then:
    a) The declared type of the <target array reference> shall be an array type.
    b) The declared type of a <target array element specification> is the element type of the specified <target
       array reference>.
    c) The declared type of <simple value specification> shall be exact numeric with scale 0 (zero).
9) The declared type of an <indicator variable> shall be exact numeric with a scale of 0 (zero).
10) Each <embedded variable name> shall be contained in an <embedded SQL statement>.
11) Each <dynamic parameter specification> shall be contained in a <preparable statement> that is dynamically
    prepared in the current SQL-session through the execution of a <prepare statement>.
12) The declared type of CURRENT_DEFAULT_TRANSFORM_GROUP and of CURRENT_TRANS-
    FORM_GROUP_FOR_TYPE <path-resolved user-defined type name> is a character string. Whether the
    character string is fixed length or variable length, and its length if fixed length or maximum length if variable
    length, are implementation-defined. The character set of the character string is SQL_IDENTIFIER. The
    declared type collation is the character set collation of SQL_IDENTIFIER, and the collation derivation is
    implicit.


Access Rules
    None.


General Rules
1) A <value specification> or <unsigned value specification> specifies a value that is not selected from a
   table.
2) A <host parameter specification> identifies a host parameter or a host parameter and an indicator parameter
   in an <SQL-client module definition>.
3) A <target specification> specifies a host parameter, an output SQL parameter, the column of a new transition
   variable, a parameter used in a dynamically prepared statement, or a host variable that can be assigned a
   value.
4) If a <host parameter specification> contains an <indicator parameter> and the value of the indicator
   parameter is negative, then the value specified by the <host parameter specification> is null; otherwise, the
   value specified by a <host parameter specification> is the value of the host parameter identified by the
   <host parameter name>.
5) The value specified by a <literal> is the value represented by that <literal>.
6) The value specified by CURRENT_USER is
    Case:


178 Foundation (SQL/Foundation)                                                               ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)
                                                              6.4 <value specification> and <target specification>



    a) If there is a current user identifier, then the value of that current user identifier.
    b) Otherwise, the null value.
7) The value specified by SESSION_USER is the value of the SQL-session user identifier.
8) The value specified by CURRENT_ROLE is
    Case:
    a) If there is a current role name, then the value of that current role name.
    b) Otherwise, the null value.
9) The value specified by SYSTEM_USER is equal to an implementation-defined string that represents the
   operating system user who executed the SQL-client module that contains the externally-invoked procedure
   whose execution caused the SYSTEM_USER <general value specification> to be evaluated.
10) The value specified by CURRENT_PATH is a <schema name list> where <catalog name>s are <delimited
    identifier>s and the <unqualified schema name>s are <delimited identifier>s. Each <schema name> is
    separated from the preceding <schema name> by a <comma> with no intervening <space>s. The schemas
    referenced in this <schema name list> are those referenced in the SQL-path of the current SQL-session
    context, in the order in which they appear in that SQL-path.
11) The value specified by <current collation specification> is the name of the collation of the <string value
    expression>.
12) If a <simple value specification> evaluates to the null value, then an exception condition is raised: data
    exception — null value not allowed.
13) A <simple target specification> specifies a host parameter, an output SQL parameter, or a column of a new
    transition variable. A <simple target specification> can only be assigned a value that is not null.
14) If a <target specification> or <simple target specification> is assigned a value that is a zero-length character
    string, then it is implementation-defined whether an exception condition is raised: data exception — zero-
    length character string.
15) A <dynamic parameter specification> identifies a parameter used by a dynamically prepared statement.
16) An <embedded variable specification> identifies a host variable or a host variable and an indicator variable.
17) If an <embedded variable specification> contains an <indicator variable> and the value of the indicator
    variable is negative, then the value specified by the <embedded variable specification> is null; otherwise,
    the value specified by a <embedded variable specification> is the value of the host variable identified by
    the <embedded variable name>.
18) The value specified by CURRENT_DEFAULT_TRANSFORM_GROUP is the character string that repre-
    sents the default transform group name in the SQL-session context.
19) The value specified by CURRENT_TRANSFORM_GROUP_FOR_TYPE <path-resolved user-defined
    type name> is the character string that represents the transform group name associated with the data type
    specified by <path-resolved user-defined type name>.




©ISO/IEC 2003 – All rights reserved                                                         Scalar expressions 179
ISO/IEC 9075-2:2003 (E)
6.4 <value specification> and <target specification>



Conformance Rules
1) Without Feature S071, “SQL paths in function and type name resolution”, conforming SQL language shall
   not contain a <general value specification> that contains CURRENT_PATH.
2) Without Feature F251, “Domain support”, conforming SQL language shall not contain a <general value
   specification> that contains VALUE.
3) Without Feature F321, “User authorization”, conforming SQL language shall not contain a <general value
   specification> that contains CURRENT_USER, SYSTEM_USER, or SESSION_USER.
    NOTE 91 — Although CURRENT_USER and USER are semantically the same, without Feature F321, “User authorization”,
    CURRENT_USER shall be specified as USER.

4) Without Feature T332, “Extended roles”, conforming SQL language shall not contain CURRENT_ROLE.
5) Without Feature F611, “Indicator data types”, in conforming SQL language, the specific declared types of
   <indicator parameter>s and <indicator variable>s shall be the same implementation-defined data type.
6) Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain a <general
   value specification> that contains a <dynamic parameter specification>.
7) Without Feature S097, “Array element assignment”, conforming SQL language shall not contain a <target
   array element specification>.
8) Without Feature S241, “Transform functions”, conforming SQL language shall not contain CUR-
   RENT_DEFAULT_TRANSFORM_GROUP.
9) Without Feature S241, “Transform functions”, conforming SQL language shall not contain CUR-
   RENT_TRANSFORM_GROUP_FOR_TYPE.
10) Without Feature F693, “SQL-session and client module collations”, conforming SQL language shall not
    contain <current collation specification>.




180 Foundation (SQL/Foundation)                                                       ©ISO/IEC 2003 – All rights reserved
                                                                                                 ISO/IEC 9075-2:2003 (E)
                                                                              6.5 <contextually typed value specification>



6.5       <contextually typed value specification>

Function
Specify a value whose data type is to be inferred from its context.


Format
<contextually typed value specification> ::=
    <implicitly typed value specification>
  | <default specification>

<implicitly typed value specification> ::=
    <null specification>
  | <empty specification>

<null specification> ::= NULL

<empty specification> ::=
    ARRAY <left bracket or trigraph> <right bracket or trigraph>
  | MULTISET <left bracket or trigraph> <right bracket or trigraph>

<default specification> ::= DEFAULT


Syntax Rules
1) Where the element type ET is determined by the context in which ES appears, the declared type DT of an
   <empty specification> ES is
      Case:
      a) If ES simply contains ARRAY, then ET ARRAY[0].
      b) If ES simply contains MULTISET, then ET MULTISET.
      ES is effectively replaced by CAST ( ES AS DT ).
      NOTE 92 — In every such context, ES is uniquely associated with some expression or site of declared type DT, which thereby
      becomes the declared type of ES.

2) The declared type DT of a <null specification> NS is determined by the context in which NS appears. NS
   is effectively replaced by CAST ( NS AS DT ).
      NOTE 93 — In every such context, NS is uniquely associated with some expression or site of declared type DT, which thereby
      becomes the declared type of NS.

3) The declared type DT of a <default specification> DS is the declared type of a <default option> DO included
   in some site descriptor, determined by the context in which DS appears. DS is effectively replaced by CAST
   ( DO AS DT ).
      NOTE 94 — In every such context, DS is uniquely associated with some site of declared type DT, which thereby becomes the
      declared type of DS.




©ISO/IEC 2003 – All rights reserved                                                                    Scalar expressions 181
ISO/IEC 9075-2:2003 (E)
6.5 <contextually typed value specification>



Access Rules
    None.


General Rules
1) An <empty specification> specifies a collection whose cardinality is zero.
2) A <null specification> specifies the null value.
3) A <default specification> specifies the default value of some associated item.


Conformance Rules
1) Without Feature S091, “Basic array support”, conforming SQL language shall not contain an <empty
   specification> that simply contains ARRAY.
2) Without Feature S271, “Basic multiset support”, conforming SQL language shall not contain an <empty
   specification> that simply contains MULTISET.




182 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                                                      6.6 <identifier chain>



6.6       <identifier chain>

Function
Disambiguate a <period>-separated chain of identifiers.


Format
<identifier chain> ::= <identifier> [ { <period> <identifier> }... ]

<basic identifier chain> ::= <identifier chain>


Syntax Rules
1) Let IC be an <identifier chain>.
2) Let N be the number of <identifier>s immediately contained in IC.

3) Let Ii, 1 (one) ≤ i ≤ N, be the <identifier>s immediately contained in IC, in order from left to right.

4) Let PIC1 = I1. For each j between 2 and N, let PICj = PICj-1 <period> Ij. PICj is called the j-th partial
   identifier chain of IC.
5) Let M be the minimum of N and 4.
6) A column C is said to be refinable if the declared type of C is a row type or a structured type.
7) An SQL parameter P is said to be refinable if the declared type of P is a row type or a structured type.
8) For at most one j between 1 (one) and M, PICj is called the basis of IC, and j is called the basis length of
   IC. The referent of the basis is a column C of a table or an SQL parameter SP. The basis, basis length, basis
   scope, and basis referent of IC are determined as follows:
      a) If N = 1 (one), then
          Case:
          i)      If IC is contained in an <order by clause> of a <cursor specification>, and the <select list>
                  simply contained in the <cursor specification> directly contains a <derived column> DC whose
                  explicit or implicit <column name> is equivalent to IC, then PIC1 is a candidate basis, the scope
                  of PIC1 is the <cursor specification>, and the referent of PIC1 is the column referenced by DC.

          ii)     Otherwise, IC shall be contained in the scope of one or more range variables whose associated
                  tables include a column whose <column name> is equivalent to I1 or in the scope of a <routine
                  name> whose associated <SQL parameter declaration list> includes an SQL parameter whose
                  <SQL parameter name> is equivalent to I1. Let the phrase possible scope tags denote those
                  range variables and <routine name>s.
                  NOTE 95 — “range variable” is defined in Subclause 4.14.6, “Operations involving tables”.

                  Case:


©ISO/IEC 2003 – All rights reserved                                                                   Scalar expressions 183
ISO/IEC 9075-2:2003 (E)
6.6 <identifier chain>



              1) If the number of possible scope tags in the innermost scope containing a possible scope tag
                 is 1 (one), then let IPST be that possible scope tag.
                  Case:
                  A) If IPST is a range variable RV, then let T be the table associated with RV. For every
                     column C of T whose <column name> is equivalent to I1, PIC1 is a candidate basis of
                     IC, the scope of PIC1 is the scope of RV, and the referent of PIC1 is C.
                      NOTE 96 — Two or more columns with equivalent column names are distinguished by their ordinal positions
                      within T.

                  B) If the innermost possible scope tag is a <routine name>, then let SP be the SQL param-
                     eter whose <SQL parameter name> is equivalent to I1. PIC1 is the basis of IC, the basis
                     length is 1 (one), the basis scope is the scope of SP, and the basis referent is SP.
              2) Otherwise, each possible scope tag shall be a range variable RV of a <table factor> that is
                 directly contained in a <joined table> JT. I1 shall be a common column name in JT. Let C
                 be the column of JT that is identified by I1. PIC1 is a candidate basis of IC, the scope of
                 PIC1 is the scope of RV, and the referent of PIC1 is C.
                  NOTE 97 — “Common column name” is defined in Subclause 7.7, “<joined table>”.

   b) If N > 1 (one), then the basis, basis length, basis scope, and basis referent are defined in terms of a
      candidate basis as follows:
       i)     If IC is contained in the scope of a <routine name> whose associated <SQL parameter declaration
              list> includes an SQL parameter SP whose <SQL parameter name> is equivalent to I1, then
              PIC1 is a candidate basis of IC, the scope of PIC1 is the scope of SP, and the referent of PIC1
              is SP.
       ii)    If N = 2 and PIC1 is equivalent to the <qualified identifier> of a <routine name> RN whose
              scope contains IC and whose associated <SQL parameter declaration list> includes an SQL
              parameter SP whose <SQL parameter name> is equivalent to I2, then PIC2 is a candidate basis
              of IC, the scope of PIC2 is the scope of SP, and the referent of PIC2 is SP.

       iii)   If N > 2 and PIC1 is equivalent to the <qualified identifier> of a <routine name> RN whose
              scope contains IC and whose associated <SQL parameter declaration list> includes a refinable
              SQL parameter SP whose <SQL parameter name> is equivalent to I2, then PIC2 is a candidate
              basis of IC, the scope of PIC2 is the scope of SP, and the referent of PIC2 is SP.

       iv)    If N = 2 and PIC1 is equivalent to an exposed <correlation name> that is in scope, then let EN
              be the exposed <correlation name> that is equivalent to PIC1 and has innermost scope. For every
              column C in the table associated with EN whose <column name> is equivalent to I2, PIC2 is a
              candidate basis of IC, the scope of PIC2 is the scope of EN, and the referent of PIC2 is C.

       v)     If N > 2 and PIC1 is equivalent to an exposed <correlation name> that is in scope, then let EN
              be the exposed <correlation name> that is equivalent to PIC1 and has innermost scope. For every
              refinable column C in the table associated with EN whose <column name> is equivalent to I2,
              PIC2 is a candidate basis of IC, the scope of PIC2 is the scope of EN, and the referent of PIC2
              is C.


184 Foundation (SQL/Foundation)                                                           ©ISO/IEC 2003 – All rights reserved
                                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                                                         6.6 <identifier chain>



         vi)      If N = 2, 3 or 4, and if PICN-1 is equivalent to an exposed <table or query name> that is in scope,
                  then let EN be the exposed <table or query name> that is equivalent to PICN-1 and has the
                  innermost scope. For every column C in the table associated with EN whose <column name>
                  is equivalent to IN, PICN is a candidate basis of IC, the scope of PICN is the scope of EN, and
                  the referent of PICN is C.

    c) There shall be exactly one candidate basis CB with innermost scope. The basis of IC is CB. The basis
       length is the length of CB. The basis scope is the scope of CB. The referent of IC is the referent of CB.
9) Let BL be the basis length of IC.
10) If BL < N, then let TIC be the <value expression primary>:
        ( PICBL ) <period> IBL+1 <period> ... <period> IN

    The Syntax Rules of Subclause 6.25, “<value expression>”, are applied to TIC, yielding a column reference
    or an SQL parameter reference, and (N – BL) <field reference>s or <method invocation>s.
    NOTE 98 — In this transformation, (PICBL ) is interpreted as a <value expression primary> of the form <left paren> <value
    expression> <right paren>. PICBL is a <value expression> that is a <value expression primary> that is an <unsigned value specifi-
    cation> that is either a <column reference> or an <SQL parameter reference>. The identifiers IBL+1, ..., IN are parsed using the
    Syntax Rules of <field reference> and <method invocation>.

11) A <basic identifier chain> shall be an <identifier chain> whose basis is the entire identifier chain.
12) A <basic identifier chain> whose basis referent is a column is a column reference. If the basis length is 2,
    and the basis scope is a <trigger definition> whose <trigger action time> is BEFORE, and I1 is equivalent
    to the <new transition variable name> of the <trigger definition>, then the column reference is a new
    transition variable column reference.
13) A <basic identifier chain> whose basis referent is an SQL parameter is an SQL parameter reference.
14) The data type of a <basic identifier chain> BIC is the data type of the basis referent of BIC.
15) If the declared type of a <basic identifier chain> BIC is character string, then the collation derivation of
    the declared type of BIC is
    Case:
    a) If the declared type has a declared type collation DTC, then implicit.
    b) Otherwise, none.


Access Rules
    None.


General Rules
1) Let BIC be a <basic identifier chain>.
2) If BIC is a column reference, then BIC references the column C that is the basis referent of BIC.



©ISO/IEC 2003 – All rights reserved                                                                     Scalar expressions 185
ISO/IEC 9075-2:2003 (E)
6.6 <identifier chain>



3) If BIC is an SQL parameter reference, then BIC references the SQL parameter SP of a given invocation of
   the SQL-invoked routine that contains SP.


Conformance Rules
1) Without Feature T325, “Qualified SQL parameter references”, conforming SQL language shall not contain
   an SQL parameter reference whose first <identifier> is the <qualified identifier> of a <routine name>.




186 Foundation (SQL/Foundation)                                              ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                                          6.7 <column reference>



6.7       <column reference>

Function
Reference a column.


Format
<column reference> ::=
    <basic identifier chain>
  | MODULE <period> <qualified identifier> <period> <column name>


Syntax Rules
1) Every <column reference> has a qualifying table and a qualifying scope, as defined in succeeding Syntax
   Rules.
2) A <column reference> that is a <basic identifier chain> BIC shall be a column reference. The qualifying
   scope is the basis scope of BIC and the qualifying table is the table that contains the basis referent of BIC.
3) If MODULE is specified, then <qualified identifier> shall be contained in an <SQL-client module definition>
   M, and shall identify a declared local temporary table DLTT whose <temporary table declaration> is contained
   in M, and “MODULE <period> <qualified identifier>” shall be an exposed <table or query name> MPQI,
   and <column name> shall identify a column of DLTT. The qualifying table is the table identified by MPQI,
   and the qualifying scope is the scope of MPQI.
4) If a <column reference> CR is contained in a <table expression> TE and the qualifying scope of CR contains
   TE, then CR is an outer reference to the qualifying table of CR.
5) Let C be the column that is referenced by CR. The declared type of CR is
      Case:
      a) If the column descriptor of C includes a data type,then that data type.
      b) Otherwise, the data type identified in the domain descriptor that is included in the column descriptor
         of C.
6) A column reference contained in a <query specification> or a <joined table> is a queried column reference.
7) If QCR is a queried column reference, then:
      a) The qualifying query of QCR is defined as follows.
          Case:
          i)      If QCR is contained without an intervening <query specification> in a <joined table> JT that is
                  a <query primary>, then JT is the qualifying query of QCR.
          ii)     Otherwise, the <query specification> that simply contains the <from clause> that simply contains
                  the <table reference> that defines the qualifying table of QCR is the qualifying query of QCR.



©ISO/IEC 2003 – All rights reserved                                                       Scalar expressions 187
ISO/IEC 9075-2:2003 (E)
6.7 <column reference>



    b) Let QQ be the qualifying query of QCR.
        Case:
        i)      If QQ is a <joined table>, or if QQ is not grouped, or if QCR is contained in the <where clause>
                simply contained in QQ, then QCR is an ordinary column reference.
        ii)     If QCR is contained in the <having clause>, <window clause>, or <select list> simply contained
                in QQ, and QCR is contained in an aggregated argument of a <set function specification> SFS,
                and QQ is the aggregation query of SFS, then QCR is a within-group-varying column reference.
        iii)    Otherwise, QCR is a group-invariant column reference.
8) If QCR is a group-invariant column reference, then QCR shall be functionally dependent on the grouping
   columns of the qualifying query of QCR.


Access Rules
1) Let CR be the <column reference>.
2) If the qualifying table of CR is a base table or a viewed table, then
    Case:
    a) If CR is contained in a <search condition> immediately contained in an <assertion definition> or a
       <check constraint definition>, then the applicable privileges for the <authorization identifier> that
       owns the containing schema shall include REFERENCES on the column referenced by CR.
    b) Otherwise,
        Case:
        i)      If CR is contained, without an intervening <SQL routine spec> that specifies SQL SECURITY
                INVOKER, in an <SQL schema statement>, then the applicable privileges of the <authorization
                identifier> that owns the containing schema shall include SELECT on the column referenced
                by CR.
        ii)     Otherwise, the current privileges shall include SELECT on the column referenced by CR.
        NOTE 99 — “applicable privileges” and “current privileges” are defined in Subclause 12.3, “<privileges>”.


General Rules
1) Let QCR be a queried column reference. Let QT be the qualifying table of QCR, and let C be the column
   of QT that is referenced as the basis referent of QCR. The value of QCR is determined as follows:
    a) If QCR is an ordinary column reference, then QCR denotes the value of C in a given row of QT.
    b) If QCR is a within-group-varying column reference, then QCR denotes the values of C in the rows of
       a given group of the qualifying query of QCR used to construct the argument source of a <set function
       specification>.
    c) If QCR is a group-invariant column reference, then QCR denotes a value that is not distinct from the
       value of C in every row of a given group of the qualifying query of QCR. If the most specific type of


188 Foundation (SQL/Foundation)                                                              ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                                        6.7 <column reference>



         QCR is character string, datetime with time zone, or user-defined type, then the precise value is chosen
         in an implementation-dependent fashion.


Conformance Rules
1) Without Feature F821, “Local table references”, conforming SQL language shall not contain a <column
   reference> that simply contains MODULE.




©ISO/IEC 2003 – All rights reserved                                                      Scalar expressions 189
ISO/IEC 9075-2:2003 (E)
6.8 <SQL parameter reference>



6.8      <SQL parameter reference>

Function
Reference an SQL parameter.


Format
<SQL parameter reference> ::= <basic identifier chain>


Syntax Rules
1) An <SQL parameter reference> shall be a <basic identifier chain> that is an SQL parameter reference.
2) The declared type of an <SQL parameter reference> is the declared type of the SQL parameter that it refer-
   ences.


Access Rules
      None.


General Rules
      None.


Conformance Rules
      None.




190 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                6.9 <set function specification>



6.9       <set function specification>

Function
Specify a value derived by the application of a function to an argument.


Format
<set function specification> ::=
    <aggregate function>
  | <grouping operation>

<grouping operation> ::=
    GROUPING <left paren> <column reference>
    [ { <comma> <column reference> }... ] <right paren>


Syntax Rules
1) If <aggregate function> specifies a <general set function>, then the <value expression> simply contained
   in the <general set function> shall not contain a <set function specification> or a <subquery>.
2) If <aggregate function> specifies <binary set function>, then neither the <dependent variable expression>
   nor the <independent variable expression> simply contained in the <binary set function> shall contain a
   <set function specification> or a <subquery>.
3) A <value expression> VE simply contained in a <set function specification> SFE is an aggregated argument
   of SFE if either SFE is not an <ordered set function> or VE is simply contained in a <within group specifi-
   cation>; otherwise, VE is a non-aggregated argument of SFE.
4) A column reference CR contained in an aggregated argument of a <set function specification> SFS is called
   an aggregated column reference of SFS.
5) If <aggregate function> specifies a <filter clause>, then the <search condition> immediately contained in
   <filter clause> shall not contain a <set function specification>.
6) The aggregation query of a <set function specification> SFS is determined as follows.
      Case:
      a) If SFS has no aggregated column reference, then the aggregation query of SFS is the innermost <query
         specification> that contains SFS.
      b) Otherwise, the innermost qualifying query of the aggregated column references of SFS is the aggregation
         query of SFS.
7) SFS shall be contained in the <having clause>, <window clause>, or <select list> of its aggregation query.
8) Let CR be an aggregated column reference of SFS such that the qualifying query QQ of CR is not the
   aggregation query of SFS. If QQ is grouped and SFS is contained in the <having clause>, <window clause>,
   or <select list> of QQ, then CR shall be functionally dependent on the grouping columns of QQ.




©ISO/IEC 2003 – All rights reserved                                                     Scalar expressions 191
ISO/IEC 9075-2:2003 (E)
6.9 <set function specification>



9) If <aggregate function> is specified, then the declared type of the result is the declared type of the
   <aggregate function>.
10) If a <grouping operation> is specified, then:
    a) Each <column reference> shall reference a grouping column of T.
    b) The declared type of the result is exact numeric with an implementation-defined precision and a scale
       of 0 (zero).
    c) If more than one <column reference> is specified, then let N be the number of <column reference>s
       and let CRi, 1 (one) ≤ i ≤ N, be the i-th <column reference>.

            GROUPING ( CR1, ..., CRN-1, CRN )

        is equivalent to:
            ( 2 * GROUPING ( CR1, ..., CRN-1 ) + GROUPING ( CRN ) )


Access Rules
    None.


General Rules
1) If <aggregate function> is specified, then the result is the value of the <aggregate function>.
    NOTE 100 — The value of <grouping operation> is computed by means of syntactic transformations defined in Subclause 7.9,
    “<group by clause>”.


Conformance Rules
1) Without Feature T431, “Extended grouping capabilities”, conforming SQL language shall not contain a
   <grouping operation>.
2) Without Feature T433, “Multiargument GROUPING function”, conforming SQL language shall not contain
   a <grouping operation> that contains more than one <column reference>.




192 Foundation (SQL/Foundation)                                                            ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                      6.10 <window function>



6.10 <window function>

Function
Specify a window function.


Format
<window function> ::= <window function type> OVER <window name or specification>

<window function type> ::=
    <rank function type> <left paren> <right paren>
  | ROW_NUMBER <left paren> <right paren>
  | <aggregate function>

<rank function type> ::=
    RANK
  | DENSE_RANK
  | PERCENT_RANK
  | CUME_DIST

<window name or specification> ::=
    <window name>
  | <in-line window specification>

<in-line window specification> ::= <window specification>


Syntax Rules
1) An <aggregate function> simply contained in a <window function> shall not simply contain a <hypothetical
   set function>.
2) Let OF be the <window function>.
3) Case:
    a) If OF is contained in an <order by clause>, then the <order by clause> shall be contained in a <cursor
       specification> that is a simple table query. Let ST be the sort table that is obtained by applying the
       syntactic transformation of a simple table query, as specified in Subclause 14.1, “<declare cursor>”.
       Let TE be the <table expression> contained in the result of that syntactic transformation.
    b) Otherwise, OF shall be contained in a <select list> that is immediately contained in a <query specifica-
       tion> QS or a <select statement: single row> SSSR. Let QSS be the innermost <query specification>
       contained in QS that contains OF. Let TE be the <table expression> immediately contained in QSS or
       SSSR.
4) OF shall not contain an outer reference or a <subquery>.
5) Let WNS be the <window name or specification>. Let WDX be a window structure descriptor that describes
   the window defined by WNS.
6) If <rank function type> or ROW_NUMBER is specified, then:


©ISO/IEC 2003 – All rights reserved                                                    Scalar expressions 193
ISO/IEC 9075-2:2003 (E)
6.10 <window function>



    a) If RANK or DENSE_RANK is specified, then the window ordering clause WOC of WDX shall be
       present.
    b) The window framing of WDX shall not be present.
    c) Case:
        i)       If WNS is a <window name>, then let WNS1 be WNS.
        ii)      Otherwise, let WNS1 be the <window specification details> contained in WNS.
    d) RANK() OVER WNS is equivalent to:
               ( COUNT (*) OVER (WNS1 RANGE UNBOUNDED PRECEDING)
               - COUNT (*) OVER (WNS1 RANGE CURRENT ROW) + 1 )


    e) If DENSE_RANK is specified, then:
        i)       Let VE1, ..., VEN be an enumeration of the <value expression>s that are <sort key>s simply
                 contained in WOC.
        ii)      DENSE_RANK() OVER WNS is equivalent to the <window function>:
                   COUNT (DISTINCT ROW ( VE1, ..., VEN ) )
                   OVER (WNS1 RANGE UNBOUNDED PRECEDING)


    f) ROW_NUMBER() OVER WNS is equivalent to the <window function>:
              COUNT (*) OVER (WNS1 ROWS UNBOUNDED PRECEDING)


    g) Let ANT1 be an approximate numeric type with implementation-defined precision. PERCENT_RANK(
       ) OVER WNS is equivalent to:
              CASE
                WHEN COUNT(*) OVER (WNS1 RANGE BETWEEN UNBOUNDED PRECEDING
                                                   AND UNBOUNDED FOLLOWING) = 1
                THEN CAST (0 AS ANT1)
                ELSE
                     (CAST (RANK () OVER (WNS1) AS ANT1) - 1) /
                     (COUNT (*) OVER (WNS1 RANGE BETWEEN UNBOUNDED PRECEDING
                                             AND UNBOUNDED FOLLOWING) - 1)
              END


    h) Let ANT2 be an approximate numeric type with implementation-defined precision. CUME_DIST( )
       OVER WNS is equivalent to:
               ( CAST ( COUNT (*) OVER
                    ( WNS1 RANGE UNBOUNDED PRECEDING ) AS ANT2 ) /
                  COUNT(*) OVER ( WNS1 RANGE BETWEEN UNBOUNDED PRECEDING
                                                 AND UNBOUNDED FOLLOWING ) )


7) Let SL be the <select list> that simply contains OF.




194 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                                                       6.10 <window function>



    NOTE 101 — If OF is originally contained in an <order by clause> of a cursor that is a simple table query, the syntactic transfor-
    mation of Subclause 14.1, “<declare cursor>”, shall be applied prior to this rule.

8) Let SQ be the <set quantifier> of the <query specification> or <select statement: single row> that simply
   contains SL. If there is no <set quantifier>, then let SQ be a zero-length string.
9) If <in-line window specification> is specified, then:
    a) Let WS be the <window specification>.
    b) Let WSN be an implementation-dependent <window name> that is not equivalent to any other <window
       name> in the <table expression> or <select statement: single row> that simply contains WS.
    c) Let OFT be the <window function type>.
    d) Let SLNEW be the <select list> that is obtained from SL by replacing OF by:
               OFT OVER WSN


    e) Let FC, WC, GBC, and HC be <from clause>, <where clause>, <group by clause>, and <having clause>,
       respectively, of TE. If any of <where clause>, <group by clause>, or <having clause> is missing, then
       let WC, GBC, or HC, respectively, be a zero-length string.
    f) Case:
         i)       If there is no <window clause> simply contained in TE, then let WICNEW be:
                     WINDOW WSN AS WS


         ii)      Otherwise, let WIC be the <window clause> simply contained in TE and let WICNEW be:
                     WIC, WSN AS WS


    g) Let TENEW be:
               FC WC GBC HC WICNEW


    h) Case:
         i)       If OF is simply contained in a <query specification>, then that <query specification> is equivalent
                  to:
                     SELECT SQ SLNEW TENEW


         ii)      Otherwise, OF is simply contained in a <select statement: single row>. Let STL be the <select
                  target list> of that <select statement: single row>. The <select statement: single row> is equivalent
                  to:
                     SELECT SQ SLNEW INTO STL TENEW


10) If the window ordering clause or the window framing clause of the window structure descriptor that describes
    the <window name or specification> is present, then no <aggregate function> simply contained in <window
    function> shall specify DISTINCT or <ordered set function>.



©ISO/IEC 2003 – All rights reserved                                                                      Scalar expressions 195
ISO/IEC 9075-2:2003 (E)
6.10 <window function>



Access Rules
   None.


General Rules
1) The value of <window function> is the value of the <aggregate function>.


Conformance Rules
1) Without Feature T611, “Elementary OLAP operations”, conforming SQL language shall not contain a
   <window function>.
2) Without Feature T612, “Advanced OLAP operations”, conforming SQL language shall not contain a
   <window name>.
3) Without Feature T612, “Advanced OLAP operations”, conforming SQL language shall not contain PER-
   CENT_RANK or CUME_DIST.
4) Without Feature T612, “Advanced OLAP operations”, conforming SQL language shall not contain a
   <window function> that simply contains ROW_NUMBER and immediately contains a <window name or
   specification> whose window structure descriptor does not contain a window ordering clause.




196 Foundation (SQL/Foundation)                                               ©ISO/IEC 2003 – All rights reserved
                                                                     ISO/IEC 9075-2:2003 (E)
                                                                      6.11 <case expression>



6.11 <case expression>

Function
Specify a conditional value.


Format
<case expression> ::=
    <case abbreviation>
  | <case specification>

<case abbreviation> ::=
    NULLIF <left paren> <value expression> <comma> <value expression> <right paren>
  | COALESCE <left paren> <value expression>
    { <comma> <value expression> }... <right paren>

<case specification> ::=
    <simple case>
  | <searched case>

<simple case> ::= CASE <case operand> <simple when clause>... [ <else clause> ] END

<searched case> ::= CASE <searched when clause>... [ <else clause> ] END

<simple when clause> ::= WHEN <when operand list> THEN <result>

<searched when clause> ::= WHEN <search condition> THEN <result>

<else clause> ::= ELSE <result>

<case operand> ::=
    <row value predicand>
  | <overlaps predicate part 1>

<when operand list> ::= <when operand> [ { <comma> <when operand> }... ]

<when operand> ::=
    <row value predicand>
  | <comparison predicate part 2>
  | <between predicate part 2>
  | <in predicate part 2>
  | <character like predicate part 2>
  | <octet like predicate part 2>
  | <similar predicate part 2>
  | <null predicate part 2>
  | <quantified comparison predicate part 2>
  | <normalized predicate part 2>
  | <match predicate part 2>
  | <overlaps predicate part 2>
  | <distinct predicate part 2>
  | <member predicate part 2>
  | <submultiset predicate part 2>
  | <set predicate part 2>



©ISO/IEC 2003 – All rights reserved                                   Scalar expressions 197
ISO/IEC 9075-2:2003 (E)
6.11 <case expression>



  | <type predicate part 2>

<result> ::=
    <result expression>
  | NULL

<result expression> ::= <value expression>


Syntax Rules
1) If a <case specification> specifies a <case abbreviation>, then:
    a) A <value expression> generally contained in the <case abbreviation> shall not generally contain a
       <routine invocation> whose subject routine is an SQL-invoked routine that is possibly non-deterministic
       or that possibly modifies SQL-data.
    b) NULLIF (V1, V2) is equivalent to the following <case specification>:

              CASE WHEN V1=V2 THEN NULL ELSE V1 END

    c) COALESCE (V1, V2) is equivalent to the following <case specification>:

              CASE WHEN V1 IS NOT NULL THEN V1 ELSE V2 END

    d) COALESCE (V1, V2, ..., Vn), for n ≥ 3, is equivalent to the following <case specification>:

              CASE WHEN V1 IS NOT NULL THEN V1 ELSE COALESCE (V2, ..., Vn) END

2) If a <case specification> specifies a <simple case>, then let CO be the <case operand>.
    a) CO shall not generally contain a <routine invocation> whose subject routine is an SQL-invoked routine
       that is possibly non-deterministic or that possibly modifies SQL-data.
    b) If CO is <overlaps predicate part 1>, then each <when operand> shall be <overlaps predicate part 2>.
       If CO is <row value predicand>, then no <when operand> shall be an <overlaps predicate part 2>.
    c) Let N be the number of <simple when clause>s.
    d) For each i between 1 (one) and N, let WOLi be the <when operand list> of the i-th <simple when
       clause>. Let M(i be the number of <when operand>s simply contained in WOLi. For each j between 1
       and M(i), let WOi,j be the j-th <when operand> simply contained in WOLi.

    e) For each i between 1 (one) and N, and for each j between 1 (one) and M(i),
        Case:
        i)      If WOi,j is a <row value predicand>, then let EWOi,j be

                = WOi,j

        ii)     Otherwise, let EWOi,j be WOi,j.



198 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                         6.11 <case expression>



    f) Let Ri be the <result> of the i-th <simple when clause>.

    g) If <else clause> is specified, then let CEEC be that <else clause>; otherwise, let CEEC be a character
       string of length 0 (zero).
    h) The <simple case> is equivalent to a <searched case> in which the i-th <searched when clause> takes
       the form:

         WHEN ( CO EWOi,1 ) OR
         . . . OR
         ( CO EWOi,M(i) )
         THEN Ri

    i)   The <else clause> of the equivalent <searched case> takes the form:
             CEEC

3) At least one <result> in a <case specification> shall specify a <result expression>.
4) If an <else clause> is not specified, then ELSE NULL is implicit.
5) The declared type of a <case specification> is determined by applying Subclause 9.3, “Data types of results
   of aggregations”, to the declared types of all <result expression>s in the <case specification>.


Access Rules
    None.


General Rules
1) Case:
    a) If a <result> specifies NULL, then its value is the null value.
    b) If a <result> specifies a <value expression>, then its value is the value of that <value expression>.
2) Case:
    a) If the <search condition> of some <searched when clause> in a <case specification> is True, then the
       value of the <case specification> is the value of the <result> of the first (leftmost) <searched when
       clause> whose <search condition> is True, cast as the declared type of the <case specification>.
    b) If no <search condition> in a <case specification> is True, then the value of the <case expression> is
       the value of the <result> of the explicit or implicit <else clause>, cast as the declared type of the <case
       specification>.


Conformance Rules
1) Without Feature F262, “Extended CASE expression”, in conforming SQL language, a <case operand>
   immediately contained in a <simple case> shall be a <row value predicand> that is a <row value constructor
   predicand> that is a single <common value expression> or <boolean predicand>.


©ISO/IEC 2003 – All rights reserved                                                       Scalar expressions 199
ISO/IEC 9075-2:2003 (E)
6.11 <case expression>



2) Without Feature F262, “Extended CASE expression”, in conforming SQL language, a <when operand>
   contained in a <simple when clause> shall be a <row value predicand> that is a <row value constructor
   predicand> that is a single <common value expression> or <boolean predicand>.
3) Without Feature F263, “Comma-separated predicates in simple CASE expression”, in conforming SQL
   language, a <when operand list> contained in a <simple when clause> shall simply contain exactly one
   <when operand>.




200 Foundation (SQL/Foundation)                                              ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                          6.12 <cast specification>



6.12 <cast specification>

Function
Specify a data conversion.


Format
<cast specification> ::= CAST <left paren> <cast operand> AS <cast target> <right paren>

<cast operand> ::=
    <value expression>
  | <implicitly typed value specification>

<cast target> ::=
    <domain name>
  | <data type>


Syntax Rules
1) Case:
    a) If a <domain name> is specified, then let TD be the <data type> of the specified domain.
    b) If a <data type> is specified, then let TD be the specified <data type>.
2) The declared type of the result of the <cast specification> is TD.
3) If the <cast operand> is a <value expression>, then let SD be the declared type of the <value expression>.
4) Let C be some column and let CO be the <cast operand> of a <cast specification> CS. C is a leaf column
   of CS if CO consists of a single column reference that identifies C or of a single <cast specification> CS1
   of which C is a leaf column.
5) If the <cast operand> specifies an <empty specification>, then TD shall be a collection type.
6) If the <cast operand> is a <value expression>, then the valid combinations of TD and SD in a <cast speci-
   fication> are given by the following table. “Y” indicates that the combination is syntactically valid without
   restriction; “M” indicates that the combination is valid subject to other Syntax Rules in this Subclause being
   satisfied; and “N” indicates that the combination is not valid:


    <data type>
    SD of                       <data type> of TD
    <value
    expression>         EN   AN       VC   FC   D   T   TS   YM   DT   BO UDT   CL   BL   RT     CT   RW
           EN           Y    Y        Y    Y    N   N   N    M    M    N   M    Y    N    M      N    N
           AN           Y    Y        Y    Y    N   N   N    N    N    N   M    Y    N    M      N    N
           C            Y    Y        Y    Y    Y   Y   Y    Y    Y    Y   M    Y    N    M      N    N
           D            N    N        Y    Y    Y   N   Y    N    N    N   M    Y    N    M      N    N
           T            N    N        Y    Y    N   Y   Y    N    N    N   M    Y    N    M      N    N
           TS           N    N        Y    Y    Y   Y   Y    N    N    N   M    Y    N    M      N    N



©ISO/IEC 2003 – All rights reserved                                                            Scalar expressions 201
ISO/IEC 9075-2:2003 (E)
6.12 <cast specification>



           YM         M     N   Y   Y     N    N    N    Y    N     N    M    Y    N       M     N    N
           DT         M     N   Y   Y     N    N    N    N    Y     N    M    Y    N       M     N    N
           BO         N     N   Y   Y     N    N    N    N    N     Y    M    Y    N       M     N    N
         UDT          M     M   M   M     M    M    M    M    M     M    M    M    M       M     N    N
           BL         N     N   N   N     N    N    N    N    N     N    M    N    Y       M     N    N
           RT         M     M   M   M     M    M    M    M    M     M    M    M    M       M     N    N
           CT         N     N   N   N     N    N    N    N    N     N    N    N    N       N     M    N
           RW         N     N   N   N     N    N    N    N    N     N    N    N    N       N     N    M
    Where:
           EN    =   Exact Numeric
           AN    =   Approximate Numeric
           C     =   Character (Fixed- or Variable-length, or character large object)
           FC    =   Fixed-length Character
           VC    =   Variable-length Character
           CL    =   Character Large Object
           D     =   Date
           T     =   Time
           TS    =   Timestamp
           YM    =   Year-Month Interval
           DT    =   Day-Time Interval
           BO    =   Boolean
         UDT     =   User-Defined Type
           BL    =   Binary Large Object
           RT    =   Reference type
           CT    =   Collection type
           RW    =   Row type


7) If TD is an interval and SD is exact numeric, then TD shall contain only a single <primary datetime field>.
8) If TD is exact numeric and SD is an interval, then SD shall contain only a single <primary datetime field>.
9) If SD is character string and TD is fixed-length, variable-length, or large object character string, then the
   character repertoires of SD and TD shall be the same.
10) If TD is a fixed-length, variable-length, or large object character string, then TD shall not specify <collate
    clause>. The declared type collation of the <cast specification> is the character set collation of the character
    set of TD and its collation derivation is implicit.
11) If the <cast operand> is a <value expression> and either SD or TD is a user-defined type, then either TD
    shall be a supertype of SD or there shall be a data type P such that:
    a) The type designator of P is in the type precedence list of SD.
    b) There is a user-defined cast CFP whose user-defined cast descriptor includes P as the source data type
       and TD as the target data type.
    c) The type designator of no other data type Q that is included as the source data type in the user-defined
       cast descriptor of some user-defined cast CFQ that has TD as the target data type precedes the type
       designator of P in the type precedence list of SD.
12) If the <cast operand> is a <value expression> and either SD or TD is a reference type, then:
    a) Let RTSD and RTTD be the referenced types of SD and TD, respectively.




202 Foundation (SQL/Foundation)                                                        ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                                         6.12 <cast specification>



    b) If <data type> is specified and contains a <scope clause>, then let STD be that scope. Otherwise, let
       STD, possibly empty, be the scope included in the reference type descriptor of SD.
    c) Either RSTD and RTTD shall be compatible, or there shall be a data type P in the type precedence list
       of SD such that all of the following are satisfied:
         i)       There is a user-defined cast CFP whose user-defined cast descriptor includes P as the source
                  data type and TD as the target data type.
         ii)      No other data type Q that is included as the source data type in the user-defined cast descriptor
                  of some user-defined cast CFQ that has TD as the target data type precedes P in the type prece-
                  dence list of SD.
13) If SD is a collection type, then:
    a) Let ESD be the element type of SD.
    b) Let ETD be the element type of TD.
    c) CAST ( VALUE AS ETD )
         where VALUE is a <value expression> of declared type ESD, shall be a valid <cast specification>.
14) If SD is a row type, then:
    a) Let DSD be the degree of SD.
    b) Let DTD be the degree of TD.
    c) DSD shall be equal to DTD.

    d) Let FSDi and FTDi, 1 (one) ≤ i ≤ DSD, be the i-th field of SD and TD, respectively.

    e) Let TFSDi and TFTDi, 1 (one) ≤ i ≤ DSD, be the declared type of FSDi and the declared type of FTDi,
       respectively.
    f) For i varying from 1 (one) to DSD, the <cast specification>:
               CAST ( VALUEi AS TFTDi )

         where VALUEi is an arbitrary <value expression> of declared type TFSDi, shall be a valid <cast speci-
         fication>.
15) If <domain name> is specified, then let D be the domain identified by the <domain name>. The schema
    identified by the explicit or implicit qualifier of the <domain name> shall include the descriptor of D.


Access Rules
1) If <domain name> is specified, then
    Case:
    a) If <cast specification> is contained, without an intervening <SQL routine spec> that specifies SQL
       SECURITY INVOKER, in an <SQL schema statement>, then the applicable privileges of the


©ISO/IEC 2003 – All rights reserved                                                        Scalar expressions 203
ISO/IEC 9075-2:2003 (E)
6.12 <cast specification>



        <authorization identifier> that owns the containing schema shall include USAGE on the domain iden-
        tified by <domain name>.
    b) Otherwise, the current privileges shall include USAGE on the domain identified by <domain name>.
    NOTE 102 — “applicable privileges” and “current privileges” are defined in Subclause 12.3, “<privileges>”.

2) If the <cast operand> is a <value expression> and either SD or TD is a user-defined type, then
    Case:
    a) If <cast specification> is contained, without an intervening <SQL routine spec> that specifies SQL
       SECURITY INVOKER, in an <SQL schema statement>, then the applicable privileges of the
       <authorization identifier> that owns the containing schema shall include EXECUTE on CFP.

    b) Otherwise, the current privileges shall include EXECUTE on CFP.
    NOTE 103 — “applicable privileges” and “current privileges” are defined in Subclause 12.3, “<privileges>”.


General Rules
1) If the <cast operand> is a <value expression> VE, then let SV be its value.
2) Case:
    a) If the <cast operand> specifies NULL, then TV is the null value and no further General Rules of this
       Subclause are applied.
    b) If the <cast operand> specifies an <empty specification>, then TV is an empty collection of declared
       type TD and no further General Rules of this Subclause are applied.
    c) If SV is the null value, then TV is the null value and no further General Rules of this Subclause are
       applied.
    d) Otherwise, let TV be the result of the <cast specification> as specified in the remaining General Rules
       of this Subclause.
3) If either SD or TD is a user-defined type, then
    Case:
    a) If TD is a supertype of SD, then TV is TR.
    b) Otherwise:
        i)      Let CP be the cast function contained in the user-defined cast descriptor of CFP.

        ii)     The General Rules of Subclause 10.4, “<routine invocation>”, are applied with a static SQL
                argument list that has a single SQL-argument that is <value expression> and with subject routine
                CP, yielding value TR that is the result of the invocation of CP.
        iii)    Case:
                1) If TD is a user-defined type, then TV is TR.
                2) Otherwise, TV is the result of


204 Foundation (SQL/Foundation)                                                               ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                        6.12 <cast specification>



                          CAST (TR AS TD)


4) If either SD or TD is a reference type, then
    Case:
    a) If RSTD and RTTD are compatible, then:
         i)       TV is SV.
         ii)      The scope in the reference type descriptor of TV is STD.
    b) Otherwise:
         i)       Let CP be the cast function contained in the user-defined cast descriptor of CFP.

         ii)      The General Rules of Subclause 10.4, “<routine invocation>”, are applied with a static argument
                  list that has a single SQL-argument that is a <value expression> and with subject routine CP,
                  yielding value TV that is the result of the invocation of CP.
         iii)     The scope in the reference type descriptor of TV is STD.
5) If SD is an array type, then:
    a) Let SC be the cardinality of SV.
    b) Let SVEi be the i-th element of SV.

    c) For i varying from 1 (one) to SC, the following <cast specification> is applied:
               CAST ( SVEi AS ETD )

         yielding value TVEi.

    d) If TD is an array type, then let TC be the maximum cardinality of TD.
         Case:
         i)       If SC is greater than TC, then an exception condition is raised: data exception — array data,
                  right truncation.

         ii)      Otherwise, TV is the array with elements TVEi, 1 (one) ≤ i ≤ SC.

    e) If TD is a multiset type, then TV is the multiset with elements TVEi, 1 (one) ≤ i ≤ SC.

6) If SD is a multiset type, then:
    a) Let SC be the cardinality of SV.

    b) The elements of SV are placed in an implementation-dependent order. Let SVEi, 1 (one) ≤ i ≤ SC, be
       the i-th element of SV in this ordering.
    c) For i varying from 1 (one) to SC, the following <cast specification> is applied:
               CAST ( SVEi AS ETD )




©ISO/IEC 2003 – All rights reserved                                                       Scalar expressions 205
ISO/IEC 9075-2:2003 (E)
6.12 <cast specification>



        yielding value TVEi.

    d) If TD is an array type, then let TC be the maximum cardinality of TD.
        Case:
        i)      If SC is greater than TC, then an exception condition is raised: data exception — array data,
                right truncation.

        ii)     Otherwise, TV is the array with elements TVEi, 1 (one) ≤ i ≤ SC.

    e) If TD is a multiset type, then TV is the multiset with elements TVEi, 1 (one) ≤ i ≤ SC.

7) If SD is a row type, then:
    a) For i varying from 1 (one) to DSD, the <cast specification> is applied:
              CAST ( FSDi AS TFTDi )

        yielding a value TVEi.

    b) TV is ROW ( TVE1, TVE2, ..., TVEDSD ).

8) If TD is exact numeric, then
    Case:
    a) If SD is exact numeric or approximate numeric, then
        Case:
        i)      If there is a representation of SV in the data type TD that does not lose any leading significant
                digits after rounding or truncating if necessary, then TV is that representation. The choice of
                whether to round or truncate is implementation-defined.
        ii)     Otherwise, an exception condition is raised: data exception — numeric value out of range.
    b) If SD is character string, then SV is replaced by SV with any leading or trailing <space>s removed.
        Case:
        i)      If SV does not comprise a <signed numeric literal> as defined by the rules for <literal> in
                Subclause 5.3, “<literal>”, then an exception condition is raised: data exception — invalid
                character value for cast.
        ii)     Otherwise, let LT be that <signed numeric literal>. The <cast specification> is equivalent to
                  CAST ( LT AS TD )

    c) If SD is an interval data type, then
        Case:
        i)      If there is a representation of SV in the data type TD that does not lose any leading significant
                digits, then TV is that representation.



206 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                          6.12 <cast specification>



         ii)      Otherwise, an exception condition is raised: data exception — numeric value out of range.
9) If TD is approximate numeric, then
    Case:
    a) If SD is exact numeric or approximate numeric, then
         Case:
         i)       If there is a representation of SV in the data type TD that does not lose any leading significant
                  digits after rounding or truncating if necessary, then TV is that representation. The choice of
                  whether to round or truncate is implementation-defined.
         ii)      Otherwise, an exception condition is raised: data exception — numeric value out of range.
    b) If SD is character string, then SV is replaced by SV with any leading or trailing <space>s removed.
         Case:
         i)       If SV does not comprise a <signed numeric literal> as defined by the rules for <literal> in
                  Subclause 5.3, “<literal>”, then an exception condition is raised: data exception — invalid
                  character value for cast.
         ii)      Otherwise, let LT be that <signed numeric literal>. The <cast specification> is equivalent to

                  CAST ( LT AS TD )

10) If TD is fixed-length character string, then let LTD be the length in characters of TD.
    Case:
    a) If SD is exact numeric, then:
         i)       Let YP be the shortest character string that conforms to the definition of <exact numeric literal>
                  in Subclause 5.3, “<literal>”, whose scale is the same as the scale of SD and whose interpreted
                  value is the absolute value of SV.
         ii)      Case:
                  1) If SV is less than 0 (zero), then let Y be the result of '–' || YP.
                  2) Otherwise, let Y be YP.
         iii)     Case:
                  1) If Y contains any <SQL language character> that is not in the character repertoire of TD,
                     then an exception condition is raised: data exception — invalid character value for cast.
                  2) If the length in characters LY of Y is equal to LTD, then TV is Y.
                  3) If the length in characters LY of Y is less than LTD, then TV is Y extended on the right by
                     LTD–LY <space>s.
                  4) Otherwise, an exception condition is raised: data exception — string data, right truncation.
    b) If SD is approximate numeric, then:



©ISO/IEC 2003 – All rights reserved                                                         Scalar expressions 207
ISO/IEC 9075-2:2003 (E)
6.12 <cast specification>



        i)      Let YP be a character string as follows:
                Case:
                1) If SV equals 0 (zero), then YP is '0E0'.
                2) Otherwise, YP is the shortest character string that conforms to the definition of <approximate
                   numeric literal> in Subclause 5.3, “<literal>”, whose interpreted value is equal to the absolute
                   value of SV and whose <mantissa> consists of a single <digit> that is not '0' (zero), followed
                   by a <period> and an <unsigned integer>.
        ii)     Case:
                1) If SV is less than 0 (zero), then let Y be the result of '–' || YP.
                2) Otherwise, let Y be YP.
        iii)    Case:
                1) If Y contains any <SQL language character> that is not in the character repertoire of TD,
                   then an exception condition is raised: data exception — invalid character value for cast.
                2) If the length in characters LY of Y is equal to LTD, then TV is Y.
                3) If the length in characters LY of Y is less than LTD, then TV is Y extended on the right by
                   LTD–LY <space>s.
                4) Otherwise, an exception condition is raised: data exception — string data, right truncation.
    c) If SD is fixed-length character string, variable-length character string, or large object character string,
       then
        Case:
        i)      If the length in characters of SV is equal to LTD, then TV is SV.
        ii)     If the length in characters of SV is larger than LTD, then TV is the first LTD characters of SV. If
                any of the remaining characters of SV are non-<space> characters, then a completion condition
                is raised: warning — string data, right truncation.
        iii)    If the length in characters M of SV is smaller than LTD, then TV is SV extended on the right by
                LTD–M <space>s.
    d) If SD is a datetime data type or an interval data type, then let Y be the shortest character string that
       conforms to the definition of <literal> in Subclause 5.3, “<literal>”, and such that the interpreted value
       of Y is SV and the interpreted precision of Y is the precision of SD. If SV is an interval, then <sign>
       shall be specified within <unquoted interval string> in the literal Y.
        Case:
        i)      If Y contains any <SQL language character> that is not in the character repertoire of TD, then
                an exception condition is raised: data exception — invalid character value for cast.
        ii)     If the length in characters LY of Y is equal to LTD, then TV is Y.
        iii)    If the length in characters LY of Y is less than LTD, then TV is Y extended on the right by LTD–LY
                <space>s.


208 Foundation (SQL/Foundation)                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)
                                                                                           6.12 <cast specification>



         iv)      Otherwise, an exception condition is raised: data exception — string data, right truncation.
    e) If SD is boolean, then
         Case:
         i)       If SV is True and LTD is not less than 4, then TV is 'TRUE' extended on the right by LTD–4
                  <space>s.
         ii)      If SV is False and LTD is not less than 5, then TV is 'FALSE' extended on the right by LTD–5
                  <space>s.
         iii)     Otherwise, an exception condition is raised: data exception — invalid character value for cast.
11) If TD is variable-length character string or large object character string, then let MLTD be the maximum
    length in characters of TD.
    Case:
    a) If SD is exact numeric, then:
         i)       Let YP be the shortest character string that conforms to the definition of <exact numeric literal>
                  in Subclause 5.3, “<literal>”, whose scale is the same as the scale of SD and whose interpreted
                  value is the absolute value of SV.
         ii)      Case:
                  1) If SV is less than 0 (zero), then let Y be the result of '–' || YP.
                  2) Otherwise, let Y be YP.
         iii)     Case:
                  1) If Y contains any <SQL language character> that is not in the character repertoire of TD,
                     then an exception condition is raised: data exception — invalid character value for cast.
                  2) If the length in characters LY of Y is less than or equal to MLTD, then TV is Y.
                  3) Otherwise, an exception condition is raised: data exception — string data, right truncation.
    b) If SD is approximate numeric, then
         i)       Let YP be a character string as follows:
                  Case:
                  1) If SV equals 0 (zero), then YP is '0E0'.
                  2) Otherwise, YP is the shortest character string that conforms to the definition of <approximate
                     numeric literal> in Subclause 5.3, “<literal>”, whose interpreted value is equal to the absolute
                     value of SV and whose <mantissa> consists of a single <digit> that is not '0', followed by a
                     <period> and an <unsigned integer>.
         ii)      Case:
                  1) If SV is less than 0 (zero), then let Y be the result of'–' || YP.
                  2) Otherwise, let Y be YP.


©ISO/IEC 2003 – All rights reserved                                                         Scalar expressions 209
ISO/IEC 9075-2:2003 (E)
6.12 <cast specification>



        iii)    Case:
                1) If Y contains any <SQL language character> that is not in the character repertoire of TD,
                   then an exception condition is raised: data exception — invalid character value for cast.
                2) If the length in characters LY of Y is less than or equal to MLTD, then TV is Y.
                3) Otherwise, an exception condition is raised: data exception — string data, right truncation.
    c) If SD is fixed-length character string, variable-length character string, or large object character string,
       then
        Case:
        i)      If the length in characters of SV is less than or equal to MLTD, then TV is SV.
        ii)     If the length in characters of SV is larger than MLTD, then TV is the first MLTD characters of
                SV. If any of the remaining characters of SV are non-<space> characters, then a completion
                condition is raised: warning — string data, right truncation.
    d) If SD is a datetime data type or an interval data type then let Y be the shortest character string that
       conforms to the definition of <literal> in Subclause 5.3, “<literal>”, and such that the interpreted value
       of Y is SV and the interpreted precision of Y is the precision of SD. If SV is a negative interval, then
       <sign> shall be specified within <unquoted interval string> in the literal Y.
        Case:
        i)      If Y contains any <SQL language character> that is not in the character repertoire of TD, then
                an exception condition is raised: data exception — invalid character value for cast.
        ii)     If the length in characters LY of Y is less than or equal to MLTD, then TV is Y.
        iii)    Otherwise, an exception condition is raised: data exception — string data, right truncation.
    e) If SD is boolean, then
        Case:
        i)      If SV is True and MLTD is not less than 4, then TV is 'TRUE'.
        ii)     If SV is False and MLTD is not less than 5, then TV is 'FALSE'.
        iii)    Otherwise, an exception condition is raised: data exception — invalid character value for cast.
12) If TD and SD are binary string data types, then let MLTD be the maximum length in octets of TD.
    Case:
    a) If the length in octets of SV is less than or equal to MLTD, then TV is SV.
    b) If the length in octets of SV is larger than MLTD, then TV is the first MLTD octets of SV and a completion
       condition is raised: warning — string data, right truncation.
13) If TD is the datetime data type DATE, then
    Case:
    a) If SD is character string, then SV is replaced by


210 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                          6.12 <cast specification>



               TRIM ( BOTH ' ' FROM VE )
         Case:
         i)       If the rules for <literal> or for <unquoted date string> in Subclause 5.3, “<literal>”, can be
                  applied to SV to determine a valid value of the data type TD, then let TV be that value.
         ii)      If a <datetime value> does not conform to the natural rules for dates or times according to the
                  Gregorian calendar, then an exception condition is raised: data exception — invalid datetime
                  format.
         iii)     Otherwise, an exception condition is raised: data exception — invalid datetime format.
    b) If SD is a date, then TV is SV.
    c) If SD is the datetime data type TIMESTAMP WITHOUT TIME ZONE, then TV is the year, month,
       and day <primary datetime field>s of SV.
    d) If SD is the datetime data type TIMESTAMP WITH TIME ZONE, then TV is computed by:
               CAST ( CAST ( SV AS TIMESTAMP WITHOUT TIME ZONE ) AS DATE )

14) Let STZD be the current default time zone displacement of the SQL-session.
15) If TD is the datetime data type TIME WITHOUT TIME ZONE, then let TSP be the <time precision> of
    TD.
    Case:
    a) If SD is character string, then SV is replaced by:
               TRIM ( BOTH ' ' FROM VE )
         Case:
         i)       If the rules for <literal> or for <unquoted time string> in Subclause 5.3, “<literal>”, can be
                  applied to SV to determine a valid value of the data type TD, then let TV be that value.
         ii)      If the rules for <literal> or for <unquoted time string> in Subclause 5.3, “<literal>”, can be
                  applied to SV to determine a valid value of the data type TIME(TSP) WITH TIME ZONE, then
                  let TV1 be that value and let TV be the value of:
                     CAST ( TV1 AS TIME(TSP) WITHOUT TIME ZONE )

         iii)     If a <datetime value> does not conform to the natural rules for dates or times according to the
                  Gregorian calendar, then an exception condition is raised: data exception — invalid datetime
                  format.
         iv)      Otherwise, an exception condition is raised: data exception — invalid character value for cast.
    b) If SD is TIME WITHOUT TIME ZONE, then TV is SV, with implementation-defined rounding or
       truncation if necessary.
    c) If SD is TIME WITH TIME ZONE, then let SVUTC be the UTC component of SV and let SVTZ be the
       time zone displacement of SV. TV is SVUTC + SVTZ, computed modulo 24 hours, with implementation-
       defined rounding or truncation if necessary.


©ISO/IEC 2003 – All rights reserved                                                         Scalar expressions 211
ISO/IEC 9075-2:2003 (E)
6.12 <cast specification>



    d) If SD is TIMESTAMP WITHOUT TIME ZONE, then TV is the hour, minute, and second <primary
       datetime field>s of SV, with implementation-defined rounding or truncation if necessary.
    e) If SD is TIMESTAMP WITH TIME ZONE, then TV is:
        CAST ( CAST ( SV AS TIMESTAMP(TSP) WITHOUT TIME ZONE )
               AS TIME(TSP) WITHOUT TIME ZONE )

16) If TD is the datetime data type TIME WITH TIME ZONE, then let TSP be the <time precision> of TD.
    Case:
    a) If SD is character string, then SV is replaced by:
              TRIM ( BOTH ' ' FROM VE )
        Case:
        i)      If the rules for <literal> or for <unquoted time string> in Subclause 5.3, “<literal>”, can be
                applied to SV to determine a valid value of the data type TD, then let TV be that value.
        ii)     If the rules for <literal> or for <unquoted time string> in Subclause 5.3, “<literal>”, can be
                applied to SV to determine a valid value of the data type TIME(TSP) WITHOUT TIME ZONE,
                then let TV1 be that value and let TV be the value of:
                  CAST ( TV1 AS TIME(TSP) WITH TIME ZONE )

        iii)    If a <datetime value> does not conform to the natural rules for dates or times according to the
                Gregorian calendar, then an exception condition is raised: data exception — invalid datetime
                format.
        iv)     Otherwise, an exception condition is raised: data exception — invalid character value for cast.
    b) If SD is TIME WITH TIME ZONE, then TV is SV, with implementation-defined rounding or truncation
       if necessary.
    c) If SD is TIME WITHOUT TIME ZONE, then the UTC component of TV is SV – STZD, computed
       modulo 24 hours, with implementation-defined rounding or truncation if necessary, and the time zone
       component of TV is STZD.
    d) If SD is TIMESTAMP WITH TIME ZONE, then the UTC component of TV is the hour, minute, and
       second <primary datetime field>s of SV, with implementation-defined rounding or truncation if neces-
       sary, and the time zone component of TV is the time zone displacement of SV.
    e) If SD is TIMESTAMP WITHOUT TIME ZONE, then TV is:
              CAST ( CAST ( SV AS TIMESTAMP(TSP) WITH TIME ZONE )
              AS TIME(TSP) WITH TIME ZONE )

17) If TD is the datetime data type TIMESTAMP WITHOUT TIME ZONE, then let TSP be the <timestamp
    precision> of TD.
    Case:
    a) If SD is character string, then SV is replaced by:



212 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                          6.12 <cast specification>



               TRIM ( BOTH ' ' FROM VE )
         Case:
         i)       If the rules for <literal> or for <unquoted time string> in Subclause 5.3, “<literal>”, can be
                  applied to SV to determine a valid value of the data type TD, then let TV be that value.
         ii)      If the rules for <literal> or for <unquoted time string> in Subclause 5.3, “<literal>”, can be
                  applied to SV to determine a valid value of the data type TIMESTAMP(TSP) WITH TIME
                  ZONE, then let TV1 be that value and let TV be the value of:

                  CAST ( TV1 AS TIMESTAMP(TSP) WITHOUT TIME ZONE )

         iii)     If a <datetime value> does not conform to the natural rules for dates or times according to the
                  Gregorian calendar, then an exception condition is raised: data exception — invalid datetime
                  format.
         iv)      Otherwise, an exception condition is raised: data exception — invalid character value for cast.
    b) If SD is a date, then the <primary datetime field>s hour, minute, and second of TV are set to 0 (zero)
       and the <primary datetime field>s year, month, and day of TV are set to their respective values in SV.
    c) If SD is TIME WITHOUT TIME ZONE, then the <primary datetime field>s year, month, and day of
       TV are set to their respective values in an execution of CURRENT_DATE and the <primary datetime
       field>s hour, minute, and second of TV are set to their respective values in SV, with implementation-
       defined rounding or truncation if necessary.
    d) If SD is TIME WITH TIME ZONE, then TV is:

         CAST ( CAST ( SV AS TIMESTAMP WITH TIME ZONE )
         AS TIMESTAMP WITHOUT TIME ZONE )

    e) If SD is TIMESTAMP WITHOUT TIME ZONE, then TV is SV, with implementation-defined rounding
       or truncation if necessary.
    f) If SD is TIMESTAMP WITH TIME ZONE, then let SVUTC be the UTC component of SV and let
       SVTZ be the time zone displacement of SV. TV is SVUTC + SVTZ, with implementation-defined
       rounding or truncation if necessary.
18) If TD is the datetime data type TIMESTAMP WITH TIME ZONE, then let TSP be the <time precision>
    of TD.
    Case:
    a) If SD is character string, then SV is replaced by:
               TRIM ( BOTH ' ' FROM VE )
         Case:
         i)       If the rules for <literal> or for <unquoted time string> in Subclause 5.3, “<literal>”, can be
                  applied to SV to determine a valid value of the data type TD, then let TV be that value.




©ISO/IEC 2003 – All rights reserved                                                        Scalar expressions 213
ISO/IEC 9075-2:2003 (E)
6.12 <cast specification>



        ii)     If the rules for <literal> or for <unquoted time string> in Subclause 5.3, “<literal>”, can be
                applied to SV to determine a valid value of the data type TIMESTAMP(TSP) WITHOUT TIME
                ZONE, then let TV1 be that value and let TV be the value of:

                CAST ( TV1 AS TIMESTAMP(TSP) WITH TIME ZONE )

        iii)    If a <datetime value> does not conform to the natural rules for dates or times according to the
                Gregorian calendar, then an exception condition is raised: data exception — invalid datetime
                format.
        iv)     Otherwise, an exception condition is raised: data exception — invalid character value for cast.
    b) If SD is a date, then TV is:

        CAST ( CAST ( SV AS TIMESTAMP(TSP) WITHOUT TIME ZONE )
               AS TIMESTAMP(TSP) WITH TIME ZONE )

    c) If SD is TIME WITHOUT TIME ZONE, then TC is:

        CAST ( CAST ( SV AS TIMESTAMP(TSP) WITHOUT TIME ZONE )
               AS TIMESTAMP(TSP) WITH TIME ZONE )

    d) If SD is TIME WITH TIME ZONE, then the <primary datetime field>s of TV are set to their respective
       values in an execution of CURRENT_DATE and the <primary datetime field>s hour, minute, and
       second are set to their respective values in SV, with implementation-defined rounding or truncation if
       necessary. The time zone component of TV is set to the time zone component of SV.
    e) If SD is TIMESTAMP WITHOUT TIME ZONE, then the UTC component of TV is SV – STZD, with
       a time zone displacement of STZD.
    f) If SD is TIMESTAMP WITH TIME ZONE, then TV is SV with implementation-defined rounding or
       truncation, if necessary.
19) If TD is interval, then
    Case:
    a) If SD is exact numeric, then
        Case:
        i)      If the representation of SV in the data type TD would result in the loss of leading significant
                digits, then an exception condition is raised: data exception — interval field overflow.
        ii)     Otherwise, TV is that representation.
    b) If SD is character string, then SV is replaced by
              TRIM ( BOTH ' ' FROM VE )
        Case:
        i)      If the rules for <literal> or for <unquoted interval string> in Subclause 5.3, “<literal>”, can be
                applied to SV to determine a valid value of the data type TD, then let TV be that value.
        ii)     Otherwise,


214 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)
                                                                                           6.12 <cast specification>



                  Case:
                  1) If a <datetime value> does not conform to the natural rules for intervals according to the
                     Gregorian calendar, then an exception condition is raised: data exception — invalid interval
                     format.
                  2) Otherwise, an exception condition is raised: data exception — invalid datetime format.
    c) If SD is interval and TD and SD have the same interval precision, then TV is SV.
    d) If SD is interval and TD and SD have different interval precisions, then let Q be the least significant
       <primary datetime field> of TD.
         i)       Let Y be the result of converting SV to a scalar in units Q according to the natural rules for
                  intervals as defined in the Gregorian calendar (that is, there are 60 seconds in a minute, 60
                  minutes in an hour, 24 hours in a day, and 12 months in a year).
         ii)      Normalize Y to conform to the <interval qualifier> “P TO Q” of TD (again, observing the rules
                  that there are 60 seconds in a minute, 60 minutes in an hour, 24 hours in a day, and 12 months
                  in a year). Whether to truncate or round in the least significant field of the result is implementa-
                  tion-defined. If this would result in loss of precision of the leading datetime field of Y, then an
                  exception condition is raised: data exception — interval field overflow.
         iii)     TV is the value of Y.
20) If TD is boolean, then
    Case:
    a) If SD is character string, then SV is replaced by

         TRIM ( BOTH ' ' FROM VE )

         Case:
         i)       If the rules for <literal> in Subclause 5.3, “<literal>”, can be applied to SV to determine a valid
                  value of the data type TD, then let TV be that value.
         ii)      Otherwise, an exception condition is raised: data exception — invalid character value for cast.
    b) If SD is boolean, then TV is SV.
21) If the <cast specification> contains a <domain name> and that <domain name> refers to a domain that
    contains a <domain constraint> and if TV does not satisfy the <check constraint definition> simply contained
    in the <domain constraint>, then an exception condition is raised: integrity constraint violation.


Conformance Rules
1) Without Feature T042, “Extended LOB data type support”, conforming SQL language shall not contain a
   <cast operand> whose declared type is BINARY LARGE OBJECT or CHARACTER LARGE OBJECT.
2) Without Feature F421, “National character”, conforming SQL language shall not contain a <cast operand>
   whose declared type is NATIONAL CHARACTER LARGE OBJECT.




©ISO/IEC 2003 – All rights reserved                                                          Scalar expressions 215
ISO/IEC 9075-2:2003 (E)
6.12 <cast specification>



3) Without Feature T042, “Extended LOB data type support”, conforming SQL language shall not contain a
   <cast operand> whose declared type is NATIONAL CHARACTER LARGE OBJECT.
4) Without Feature S043, “Enhanced reference types”, in conforming SQL language, if the declared data type
   of <cast operand> is a reference type, then <cast target> shall contain a <data type> that is a reference type.




216 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                                  ISO/IEC 9075-2:2003 (E)
                                                                                              6.13 <next value expression>



6.13 <next value expression>

Function
Return the next value of a sequence generator.


Format
<next value expression> ::= NEXT VALUE FOR <sequence generator name>


Syntax Rules
1) A <next value expression> shall be directly contained in one of the following:
    a) A <select list> simply contained in a <query specification> that constitutes a <query expression> that
       is immediately contained in one of the following:
         i)       A <cursor specification>.
         ii)      A <subquery> simply contained in an <as subquery clause> in a <table definition>.
         iii)     A <from subquery>.
         iv)      A <select statement: single row>.
    b) A <select list> simply contained in a <query specification> that is immediately contained in a <dynamic
       single row select statement>.
    c) A <from constructor>.
    d) A <merge insert value list>.
    e) An <update source>.
2) <next value expression> shall not be contained in a <case expression>, a <search condition>, an <order by
   clause>, an <aggregate function>, a <window function>, a grouped query, or in a <query specification>
   that simply contains the <set quantifier> DISTINCT.


Access Rules
1) Case:
    a) If <next value expression> is contained in a <schema definition>, then the applicable privileges for the
       <authorization identifier> that owns the containing schema shall include USAGE privilege on the
       sequence generator identified by <sequence generator name>.
    b) Otherwise, the current privileges shall include USAGE privilege on the sequence generator identified
       by <sequence generator name>.
    NOTE 104 — “applicable privileges” and “current privileges” are defined in Subclause 12.3, “<privileges>”.




©ISO/IEC 2003 – All rights reserved                                                                  Scalar expressions 217
ISO/IEC 9075-2:2003 (E)
6.13 <next value expression>



General Rules
1) If <next value expression> NVE is specified, then let SEQ be the sequence generator descriptor identified
   by the <sequence generator name> contained in NVE.
    Case:
    a) If NVE is directly contained in a <query specification> QS, then the General Rules of Subclause 9.21,
       “Generation of the next value of a sequence generator”, are applied once per row in the result of QS
       with SEQ as SEQUENCE. The result of each evaluation of NVE for a given row is the RESULT returned
       by the General Rules of Subclause 9.21, “Generation of the next value of a sequence generator”.
    b) If NVE is directly contained in a <contextually typed table value constructor> TVC, then the General
       Rules of Subclause 9.21, “Generation of the next value of a sequence generator”, are applied once per
       <contextually typed row value expression> contained in TVC. The result of each evaluation of NVE
       for a given <row value expression> is the RESULT returned by the General Rules of Subclause 9.21,
       “Generation of the next value of a sequence generator”.
    c) If NVE is directly contained in an <update source>, then the General Rules of Subclause 9.21, “Gener-
       ation of the next value of a sequence generator”, are applied once per row to be updated by the <update
       statement: searched> or <update statement: positioned>. The result of each evaluation of NVE for a
       given row is the RESULT returned by the General Rules of Subclause 9.21, “Generation of the next
       value of a sequence generator”.


Conformance Rules
1) Without Feature T176, “Sequence generator support”, conforming SQL language shall not contain a <next
   value expression>.




218 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                  ISO/IEC 9075-2:2003 (E)
                                                                                    6.14 <field reference>



6.14 <field reference>

Function
Reference a field of a row value.


Format
<field reference> ::= <value expression primary> <period> <field name>


Syntax Rules
1) Let FR be the <field reference>, let VEP be the <value expression primary> immediately contained in FR,
   and let FN be the <field name> immediately contained in FR.
2) The declared type of VEP shall be a row type. Let RT be that row type.
3) FR is a field reference.
4) FN shall unambiguously reference a field of RT. Let F be that field.
5) The declared type of FR is the declared type of F.


Access Rules
    None.


General Rules
1) Let VR be the value of VEP.
2) Case:
    a) If VR is the null value, then the value of FR is the null value.
    b) Otherwise, the value of FR is the value of the field F of VR.


Conformance Rules
1) Without Feature T051, “Row types”, conforming SQL language shall not contain a <field reference>.




©ISO/IEC 2003 – All rights reserved                                                Scalar expressions 219
ISO/IEC 9075-2:2003 (E)
6.15 <subtype treatment>



6.15 <subtype treatment>

Function
Modify the declared type of an expression.


Format
<subtype treatment> ::=
    TREAT <left paren> <subtype operand> AS <target subtype> <right paren>

<subtype operand> ::= <value expression>

<target subtype> ::=
    <path-resolved user-defined type name>
  | <reference type>


Syntax Rules
1) The declared type VT of the <value expression> shall be a structured type or a reference type.
2) Case:
    a) If VT is a structured type, then:
        i)     <target subtype> shall specify a <path-resolved user-defined type name>.
        ii)    Let DT be the structured type identified by the <user-defined type name> simply contained in
               <path-resolved user-defined type name>.
    b) Otherwise:
        i)     <target subtype> shall specify a <reference type>.
        ii)    Let DT be the reference type identified by <reference type>.
3) VT shall be a supertype of DT.
4) The declared type of the result of the <subtype treatment> is DT.


Access Rules
    None.


General Rules
1) Let V be the value of the <value expression>.
2) Case:
    a) If V is the null value, then the value of the <subtype treatment> is the null value.


220 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                                                 6.15 <subtype treatment>



    b) Otherwise:
         i)       If the most specific type of V is not a subtype of DT, then an exception condition is raised: invalid
                  target type specification.
                  NOTE 105 — “most specific type” is defined in Subclause 4.7.5, “Subtypes and supertypes”.

         ii)      The value of the <subtype treatment> is V.


Conformance Rules
1) Without Feature S161, “Subtype treatment”, conforming SQL Language shall not contain a <subtype
   treatment>.
2) Without Feature S162, “Subtype treatment for references”, conforming SQL language shall not contain a
   <target subtype> that contains a <reference type>.




©ISO/IEC 2003 – All rights reserved                                                                  Scalar expressions 221
ISO/IEC 9075-2:2003 (E)
6.16 <method invocation>



6.16 <method invocation>

Function
Reference an SQL-invoked method of a user-defined type value.


Format
<method invocation> ::=
    <direct invocation>
  | <generalized invocation>

<direct invocation> ::=
    <value expression primary> <period> <method name> [ <SQL argument list> ]

<generalized invocation> ::=
    <left paren> <value expression primary> AS <data type> <right paren>
    <period> <method name> [ <SQL argument list> ]

<method selection> ::= <routine invocation>

<constructor method selection> ::= <routine invocation>


Syntax Rules
1) Let OR be the <method invocation>, let VEP be the <value expression primary> immediately contained
   in the <direct invocation> or <generalized invocation> of OR, and let MN be the <method name> immediately
   contained in OR.
2) The declared type of VEP shall be a user-defined type. Let UDT be that user-defined type.
3) Case:
    a) If <SQL argument list> is specified, then let AL be:
           , A1, ..., An

        where Ai, 1 (one) ≤ i ≤ n, are the <SQL argument>s immediately contained in <SQL argument list>,
        taken in order of their ordinal position in <SQL argument list>.
    b) Otherwise, let AL be a zero-length string.
4) Case:
    a) If <method invocation> is immediately contained in <new invocation>, then let TP be an SQL-path
       containing the <schema name> of the schema that includes the descriptor of UDT.
    b) Otherwise, let TP be an SQL-path, arbitrarily defined, containing the <schema name> of every schema
       that includes a descriptor of a supertype or subtype of UDT.
5) Case:



222 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                                     6.16 <method invocation>



    a) If <generalized invocation> is specified, then let DT be the <data type> simply contained in the <gen-
       eralized invocation>. Let RI be the following <method selection>:
               MN (VEP AS DT AL)

    b) Otherwise,
         Case:
         i)       If <method invocation> is immediately contained in <new invocation>, then let RI be the
                  <constructor method selection>:
                     MN (VEP AL)

         ii)      Otherwise, let RI be the following <method selection>:
                     MN (VEP AL)

6) The Syntax Rules of Subclause 10.4, “<routine invocation>”, are applied with RI and TP as the <routine
   invocation> and SQL-path, respectively, yielding subject routine SR and static SQL argument list SAL.


Access Rules
    None.


General Rules
1) The General Rules of Subclause 10.4, “<routine invocation>”, are applied with SR and SAL as the subject
   routine and SQL argument list, respectively, yielding value V that is the result of the <routine invocation>.
2) The value of <method invocation> is V.


Conformance Rules
1) Without Feature S023, “Basic structured types”, conforming SQL language shall not contain a <method
   invocation>.




©ISO/IEC 2003 – All rights reserved                                                     Scalar expressions 223
ISO/IEC 9075-2:2003 (E)
6.17 <static method invocation>



6.17 <static method invocation>

Function
Invoke a static method.


Format
<static method invocation> ::=
    <path-resolved user-defined type name> <double colon> <method name>
    [ <SQL argument list> ]

<static method selection> ::= <routine invocation>


Syntax Rules
1) Let TN be the <user-defined type name> immediately contained in <path-resolved user-defined type name>
   and let T be the user-defined type identified by TN.
2) Let MN be the <method name> immediately contained in <static method invocation>.
3) Case:
    a) If <SQL argument list> is specified, then let AL be that <SQL argument list>.
    b) Otherwise, let AL be <left paren> <right paren>.
4) Let TP be an SQL-path containing only the <schema name> of every schema that includes a descriptor of
   a supertype of T.
5) Let RI be the following <routine invocation>:
      MN AL


6) Let SMS be the following <static method selection>:
      RI


7) The Syntax Rules of Subclause 10.4, “<routine invocation>”, are applied with RI as the <routine invocation>
   immediately contained in the <static method selection> SMS, with TP as the SQL-path, and with T as the
   user-defined type of the static SQL-invoked method, yielding subject routine SR and static SQL argument
   list SAL.


Access Rules
    None.




224 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                                6.17 <static method invocation>



General Rules
1) The General Rules of Subclause 10.4, “<routine invocation>”, are applied with SR and SAL as the subject
   routine and SQL argument list, respectively, yielding a value V that is the result of the <routine invocation>.
2) The value of <static method invocation> is V.


Conformance Rules
1) Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain a <static
   method invocation>.




©ISO/IEC 2003 – All rights reserved                                                       Scalar expressions 225
ISO/IEC 9075-2:2003 (E)
6.18 <new specification>



6.18 <new specification>

Function
Invoke a method on a newly-constructed value of a structured type.


Format
<new specification> ::=
    NEW <path-resolved user-defined type name> <SQL argument list>

<new invocation> ::=
    <method invocation>
  | <routine invocation>


Syntax Rules
1) Let UDTN be the <path-resolved user-defined type name> immediately contained in the <new specification>.
   Let MN be the <qualified identifier> immediately contained in UDTN.
2) Let UDT be the user-defined type identified by UDTN. UDT shall be instantiable. Let SN be the implicit
   or explicit <schema name> of UDTN. Let S be the schema identified by SN. Let RN be NS.MN.
3) Case:
    a) If the <new specification> is of the form
              NEW UDTN()

        then
        Case:
        i)       If S does not include the descriptor of an SQL-invoked constructor method whose method name
                 is equivalent to MN and whose unaugmented parameter list is empty, then the <new specification>
                 is equivalent to the <new invocation>
                   RN()


        ii)      Otherwise, the <new specification> is equivalent to the <new invocation>
                   RN().MN()


    b) Otherwise, the <new specification>
              NEW UDTN(a1, a2, ..., an)

        is equivalent to the <new invocation>
              RN().MN(a1, a2, ..., an)




226 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                                                    6.18 <new specification>



Access Rules
    None.
NOTE 106 — The applicable privileges or current privileges (as appropriate) include EXECUTE privilege on the constructor function,
and also on the indicated constructor method, according to the Syntax Rules of Subclause 10.4, “<routine invocation>”.


General Rules
    None.


Conformance Rules
1) Without Feature S023, “Basic structured types”, conforming SQL language shall not contain a <new
   specification>.




©ISO/IEC 2003 – All rights reserved                                                                   Scalar expressions 227
ISO/IEC 9075-2:2003 (E)
6.19 <attribute or method reference>



6.19 <attribute or method reference>

Function
Return a value acquired by accessing a column of the row identified by a value of a reference type or by
invoking an SQL-invoked method.


Format
<attribute or method reference> ::=
    <value expression primary> <dereference operator> <qualified identifier>
    [ <SQL argument list> ]

<dereference operator> ::= <right arrow>


Syntax Rules
1) The declared type of the <value expression primary> VEP shall be a reference type and the scope included
   in its reference type descriptor shall not be empty. Let RT be the referenced type of VEP.
2) Let QI be the <qualified identifier>. If <SQL argument list> is specified, then let SAL be <SQL argument
   list>; otherwise, let SAL be a zero-length string.
3) Case:
    a) If QI is equivalent to the attribute name of an attribute of RT and SAL is a zero-length string, then
       <attribute or method reference> is effectively replaced by a <dereference operation> AMR of the form:
            VEP -> QI

    b) Otherwise, <attribute or method reference> is effectively replaced by a <method reference> AMR of
       the form:
            VEP -> QI SAL

4) The declared type of <attribute or method reference> is the declared type of AMR.


Access Rules
    None.


General Rules
    None.




228 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                 ISO/IEC 9075-2:2003 (E)
                                                                     6.19 <attribute or method reference>



Conformance Rules
1) Without Feature S041, “Basic reference types”, conforming SQL language shall not contain an <attribute
   or method reference>.




©ISO/IEC 2003 – All rights reserved                                                Scalar expressions 229
ISO/IEC 9075-2:2003 (E)
6.20 <dereference operation>



6.20 <dereference operation>

Function
Access a column of the row identified by a value of a reference type.


Format
<dereference operation> ::=
    <reference value expression> <dereference operator> <attribute name>


Syntax Rules
1) Let RVE be the <reference value expression>. The reference type descriptor of RVE shall include a scope.
   Let RT be the referenced type of RVE.
2) Let AN be the <attribute name>. AN shall identify an attribute AT of RT.
3) The declared type of the <dereference operation> is the declared type of AT.
4) Let S be the name of the referenceable table in the scope of the reference type of RVE.
5) Let OID be the name of the self-referencing column of S.
6) <dereference operation> is equivalent to a <scalar subquery> of the form:
        ( SELECT AN
         FROM S
         WHERE S.OID = RVE )



Access Rules
    None.


General Rules
    None.


Conformance Rules
1) Without Feature S041, “Basic reference types”, conforming SQL language shall not contain a <dereference
   operation>.




230 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                       6.21 <method reference>



6.21 <method reference>

Function
Return a value acquired from invoking an SQL-invoked routine that is a method.


Format
<method reference> ::=
    <value expression primary> <dereference operator> <method name> <SQL argument list>


Syntax Rules
1) The data type of the <value expression primary> VEP shall be a reference type and the scope included in
   its reference type descriptor shall not be empty.
2) Let MN be the method name. Let MRAL be the <SQL argument list>.
3) The Syntax Rules of Subclause 6.16, “<method invocation>”, are applied to the <method invocation>:
        DEREF (VEP) . MN MRAL
    yielding subject routine SR and static SQL argument list SAL.
4) The data type of <method reference> is the data type of the expression:
        DEREF (VEP) . MN MRAL


Access Rules
1) Let SCOPE be the table that is the scope of VEP.
    Case:
    a) If <method reference> is contained, without an intervening <SQL routine spec> that specifies SQL
       SECURITY INVOKER, in an <SQL schema statement>, then the applicable privileges of the
       <authorization identifier> that owns the containing schema shall include the table/method privilege
       for table SCOPE and method SR.
    b) Otherwise, the current privileges shall include the table/method privilege for table SCOPE and method
       SR.


General Rules
1) The General Rules of Subclause 6.16, “<method invocation>”, are applied with SR and SAL as the subject
   routine and SQL argument list, respectively, yielding a value V that is the result of the <routine invocation>.
2) The value of <method reference> is V.



©ISO/IEC 2003 – All rights reserved                                                       Scalar expressions 231
ISO/IEC 9075-2:2003 (E)
6.21 <method reference>



Conformance Rules
1) Without Feature S043, “Enhanced reference types”, conforming SQL language shall not contain a <method
   reference>.




232 Foundation (SQL/Foundation)                                             ©ISO/IEC 2003 – All rights reserved
                                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                                                6.22 <reference resolution>



6.22 <reference resolution>

Function
Obtain the value referenced by a reference value.


Format
<reference resolution> ::=
    DEREF <left paren> <reference value expression> <right paren>


Syntax Rules
1) Let RR be the <reference resolution> and let RVE be the <reference value expression>. The reference type
   descriptor of RVE shall include a scope.
2) The declared type of RR is the structured type that is referenced by the declared type of RVE.
3) Let SCOPE be the table identified by the table name included in the reference type descriptor of RVE.
   SCOPE is the scoped table of RR.
    NOTE 107 — The term “scoped table” is defined in Subclause 4.9, “Reference types”.

4) Let m be the number of subtables of SCOPE. Let Si, 1 (one) ≤ i ≤ m, be the subtables, arbitrarily ordered,
   of SCOPE.

5) For each Si, 1 (one) ≤ i ≤ m, let STNi be the name included in the descriptor of Si of the structured type STi
   associated with Si, let REFCOLi be the self-referencing column of Si, let Ni be the number of attributes of
    STi, and let Ai,j, 1 (one) ≤ j ≤ Ni, be the names of the attributes of STi, therefore also the names of the
    columns of Si.


Access Rules
1) Case:
    a) If <reference resolution> is contained in a <schema definition>, then the applicable privileges for the
       <authorization identifier> that owns the containing schema shall include SELECT WITH HIERARCHY
       OPTION on at least one supertable of SCOPE.
    b) Otherwise, the current privileges shall includes SELECT WITH HIERARCHY OPTION on at least
       one supertable of SCOPE.
    NOTE 108 — “applicable privileges” and “current privileges” are defined in Subclause 12.3, “<privileges>”.


General Rules
1) The value of <reference resolution> is the value of:



©ISO/IEC 2003 – All rights reserved                                                                  Scalar expressions 233
ISO/IEC 9075-2:2003 (E)
6.22 <reference resolution>




      (
          SELECT A1,1 ( ... A1,N1
                 ( STN1(), A1,N1 ), ... A1,1 )
        FROM ONLY S1
        WHERE S1.REFCOL1 = RVE
       UNION
        SELECT A2,1 ( ... A2,N2
               ( STN2(), A2,N2 ), ... A2,1 )
        FROM ONLY S2
        WHERE S2.REFCOL2 = RVE
       UNION
       ...
       UNION
        SELECT Am,1 ( ... Am,Nm
                   ( STNm(), Am,Nm ), ... Am,1 )
          FROM ONLY Sm
          WHERE Sm.REFCOLm = RVE
      )

   NOTE 109 — The evaluation of this General Rule is effectively performed without further Access Rule checking.


Conformance Rules
1) Without Feature S043, “Enhanced reference types”, conforming SQL language shall not contain a <reference
   resolution>.




234 Foundation (SQL/Foundation)                                                             ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                6.23 <array element reference>



6.23 <array element reference>

Function
Return an element of an array.


Format
<array element reference> ::=
    <array value expression>
    <left bracket or trigraph> <numeric value expression> <right bracket or trigraph>


Syntax Rules
1) The declared type of an <array element reference> is the element type of the specified <array value
   expression>.
2) The declared type of <numeric value expression> shall be exact numeric with scale 0 (zero).


Access Rules
    None.


General Rules
1) If the value of <array value expression> or <numeric value expression> is the null value, then the result of
   <array element reference> is the null value.
2) Let the value of <numeric value expression> be i.
    Case:
    a) If i is greater than zero and less than or equal to the cardinality of <array value expression>, then the
       result of <array element reference> is the value of the i-th element of the value of <array value
       expression>.
    b) Otherwise, an exception condition is raised: data exception — array element error.


Conformance Rules
1) Without Feature S091, “Basic array support”, conforming SQL language shall not contain an <array element
   reference>.




©ISO/IEC 2003 – All rights reserved                                                      Scalar expressions 235
ISO/IEC 9075-2:2003 (E)
6.24 <multiset element reference>



6.24 <multiset element reference>

Function
Return the sole element of a multiset of one element.


Format
<multiset element reference> ::=
    ELEMENT <left paren> <multiset value expression> <right paren>


Syntax Rules
1) Let MVE be the <multiset value expression>. The <multiset element reference> is equivalent to the <scalar
   subquery>
        ( SELECT M.E
          FROM UNNEST (MSE) AS M(E) )



Access Rules
    None.


General Rules
    None.


Conformance Rules
1) Without Feature S271, “Basic multiset support”, conforming SQL language shall not contain a <multiset
   element reference>.




236 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                      6.25 <value expression>



6.25 <value expression>

Function
Specify a value.


Format
<value expression> ::=
    <common value expression>
  | <boolean value expression>
  | <row value expression>

<common value expression> ::=
    <numeric value expression>
  | <string value expression>
  | <datetime value expression>
  | <interval value expression>
  | <user-defined type value expression>
  | <reference value expression>
  | <collection value expression>

<user-defined type value expression> ::= <value expression primary>

<reference value expression> ::= <value expression primary>

<collection value expression> ::=
    <array value expression>
  | <multiset value expression>


Syntax Rules
1) The declared type of a <value expression> is the declared type of the simply contained <common value
   expression>, <boolean value expression>, or <row value expression>.
2) The declared type of a <common value expression> is the declared type of the <numeric value expression>,
   <string value expression>, <datetime value expression>, <interval value expression>, <user-defined type
   value expression>, <collection value expression>, or <reference value expression>, respectively.
3) The declared type of a <user-defined type value expression> is the declared type of the immediately contained
   <value expression primary>, which shall be a user-defined type.
4) The declared type of a <reference value expression> is the declared type of the immediately contained
   <value expression primary>, which shall be a reference type.
5) The declared type of a <collection value expression> is the declared type of the immediately contained
   <array value expression> or <multiset value expression>.
6) Let C be some column. Let VE be the <value expression>. C is an underlying column of VE if and only if
   C is identified by some column reference contained in VE.




©ISO/IEC 2003 – All rights reserved                                                     Scalar expressions 237
ISO/IEC 9075-2:2003 (E)
6.25 <value expression>



7) A <value expression> or <nonparenthesized value expression primary> is possibly non-deterministic if it
   generally contains any of the following:
   a) A <datetime value function>.
   b) A <next value expression>.
   c) A <cast specification> that either is, or recursively implies through the execution of the General Rules
      of Subclause 6.12, “<cast specification>”, one of the following:
        i)     A <cast specification> whose result type is datetime with time zone and whose <cast operand>
               has declared type that is not datetime with time zone.
        ii)    A <cast specification> whose result type is an array type and whose <cast operand> has a declared
               type that is a multiset type.
   d) An <array value constructor by query>.
   e) A <datetime factor> that simply contains a <datetime primary> whose declared type is datetime without
      time zone and that simply contains an explicit <time zone>.
   f) An <interval value expression> that computes the difference of a <datetime value expression> and a
      <datetime term>, such that the declared type of one operand is datetime with time zone and the other
      operand is datetime without time zone.
   g) A <comparison predicate> , <overlaps predicate>, or <distinct predicate> simply containing <row
      value predicand>s RVP1 and RVP2 such that the declared types of RVP1 and RVP2 have corresponding
      constituents such that one constituent is datetime with time zone and the other is datetime without time
      zone.
        NOTE 110 — This includes <between predicate> because of a syntactic transformation to <comparison predicate>.

   h) A <quantified comparison predicate> or a <match predicate> simply containing a <row value predicand>
      RVP and a <table subquery> TS such that the declared types of RVP and TS have corresponding con-
      stituents such that one constituent is datetime with time zone and the other is datetime without time
      zone.
        NOTE 111 — This includes <in predicate> because of a syntactic transformation to <quantified comparison predicate>.

   i)   A <member predicate> simply containing a <row value predicand> RVP and a <multiset value
        expression> MVP such that the declared type of the only field F of RVP and the element type of MVP
        have corresponding constituents such that one constituent is datetime with time zone and the other is
        datetime without time zone.
   j)   A <submultiset predicate> simply containing a <row value predicand> RVP and a <multiset value
        expression> MVP such that the declared type of the only field F of RVP and the declared type of MVP
        have corresponding constituents such that one constituent is datetime with time zone and the other is
        datetime without time zone.
   k) A <multiset value expression> that specifies or implies MULTISET UNION, MULTISET EXCEPT,
      or MULTISET INTERSECT such that the element types of the operands have corresponding constituents
      such that one constituent is datetime with time zone and the other is datetime without time zone.
   l)   A <value specification> that is CURRENT_USER, CURRENT_ROLE, SESSION_USER, SYS-
        TEM_USER, or CURRENT_PATH.



238 Foundation (SQL/Foundation)                                                             ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                      6.25 <value expression>



    m) A <routine invocation> whose subject routine is an SQL-invoked routine that is possibly non-determin-
       istic.
    n) An <aggregate function> that specifies MIN or MAX and that simply contains a <value expression>
       whose declared type is based on a character string type, user-defined type, or datetime with time zone
       type.
    o) An <aggregate function> that specifies INTERSECTION and that simply contains a <value expression>
       whose declared element type is based on a character string type, a user-defined type, or a datetime type
       with time zone.
    p) A <multiset value expression> that specifies MULTISET UNION DISTINCT, MULTISET EXCEPT,
       or MULTISET INTERSECT and whose result type's declared element type is based on character string
       type, a user-defined type, or a datetime type with time zone.
    q) A <multiset set function> whose declared element type is based on a character string type, a user-
       defined type, or a datetime type with time zone.
    r) A <window function> that specifies ROW_NUMBER or whose associated <window specification>
       specifies ROWS.
    s) A <query specification> or <query expression> that is possibly non-deterministic.


Access Rules
    None.


General Rules
1) The value of a <value expression> is the value of the simply contained <common value expression>,
   <boolean value expression>, or <row value expression>.
2) The value of a <common value expression> is the value of the immediately contained <numeric value
   expression>, <string value expression>, <datetime value expression>, <interval value expression>, <user-
   defined type value expression>, <collection value expression>, or <reference value expression>.
3) When a <value expression> V is evaluated for a row R of a table, each reference to a column of that table
   by a column reference CR directly contained in V is the value of that column in that row.
4) The value of a <collection value expression> is the value of its immediately contained <array value
   expression> or <multiset value expression>.
5) The value of a <reference value expression> RVE is the value of the <value expression primary> immediately
   contained in RVE.


Conformance Rules
1) Without Feature T031, “BOOLEAN data type”, conforming SQL language shall not contain a <value
   expression> that is a <boolean value expression>.




©ISO/IEC 2003 – All rights reserved                                                    Scalar expressions 239
ISO/IEC 9075-2:2003 (E)
6.25 <value expression>



2) Without Feature S041, “Basic reference types”, conforming SQL language shall not contain a <reference
   value expression>.




240 Foundation (SQL/Foundation)                                             ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                             6.26 <numeric value expression>



6.26 <numeric value expression>

Function
Specify a numeric value.


Format
<numeric value expression> ::=
    <term>
  | <numeric value expression> <plus sign> <term>
  | <numeric value expression> <minus sign> <term>

<term> ::=
    <factor>
  | <term> <asterisk> <factor>
  | <term> <solidus> <factor>

<factor> ::= [ <sign> ] <numeric primary>

<numeric primary> ::=
    <value expression primary>
  | <numeric value function>


Syntax Rules
1) If the declared type of both operands of a dyadic arithmetic operator is exact numeric, then the declared
   type of the result is an implementation-defined exact numeric type, with precision and scale determined as
   follows:
    a) Let S1 and S2 be the scale of the first and second operands respectively.
    b) The precision of the result of addition and subtraction is implementation-defined, and the scale is the
       maximum of S1 and S2.
    c) The precision of the result of multiplication is implementation-defined, and the scale is S1 + S2.
    d) The precision and scale of the result of division are implementation-defined.
2) If the declared type of either operand of a dyadic arithmetic operator is approximate numeric, then the
   declared type of the result is an implementation-defined approximate numeric type.
3) The declared type of a <factor> is that of the immediately contained <numeric primary>.
4) The declared type of a <numeric primary> shall be numeric.
5) If a <numeric value expression> immediately contains a <minus sign> NMS and immediately contains a
   <term> that immediately contains a <factor> that immediately contains a <sign> that is a <minus sign>
   FMS, then there shall be a <separator> between NMS and FMS.




©ISO/IEC 2003 – All rights reserved                                                    Scalar expressions 241
ISO/IEC 9075-2:2003 (E)
6.26 <numeric value expression>



Access Rules
    None.


General Rules
1) If the value of any <numeric primary> simply contained in a <numeric value expression> is the null value,
   then the result of the <numeric value expression> is the null value.
2) If the <numeric value expression> contains only a <numeric primary>, then the result of the <numeric
   value expression> is the value of the specified <numeric primary>.
3) The monadic arithmetic operators <plus sign> and <minus sign> (+ and –, respectively) specify monadic
   plus and monadic minus, respectively. Monadic plus does not change its operand. Monadic minus reverses
   the sign of its operand.
4) The dyadic arithmetic operators <plus sign>, <minus sign>, <asterisk>, and <solidus> (+, –, *, and /,
   respectively) specify addition, subtraction, multiplication, and division, respectively. If the value of a
   divisor is zero, then an exception condition is raised: data exception — division by zero.
5) If the most specific type of the result of an arithmetic operation is exact numeric, then
    Case:
    a) If the operator is not division and the mathematical result of the operation is not exactly representable
       with the precision and scale of the result data type, then an exception condition is raised: data exception
       — numeric value out of range.
    b) If the operator is division and the approximate mathematical result of the operation represented with
       the precision and scale of the result data type loses one or more leading significant digits after rounding
       or truncating if necessary, then an exception condition is raised: data exception — numeric value out
       of range. The choice of whether to round or truncate is implementation-defined.
6) If the most specific type of the result of an arithmetic operation is approximate numeric and the exponent
   of the approximate mathematical result of the operation is not within the implementation-defined exponent
   range for the result data type, then an exception condition is raised: data exception — numeric value out
   of range.


Conformance Rules
    None.




242 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                     ISO/IEC 9075-2:2003 (E)
                                                                6.27 <numeric value function>



6.27 <numeric value function>

Function
Specify a function yielding a value of type numeric.


Format
<numeric value function> ::=
    <position expression>
  | <extract expression>
  | <length expression>
  | <cardinality expression>
  | <absolute value expression>
  | <modulus expression>
  | <natural logarithm>
  | <exponential function>
  | <power function>
  | <square root>
  | <floor function>
  | <ceiling function>
  | <width bucket function>

<position expression> ::=
    <string position expression>
  | <blob position expression>

<string position expression> ::=
    POSITION <left paren> <string value expression> IN <string value expression>
    [ USING <char length units> ] <right paren>

<blob position expression> ::=
    POSITION <left paren> <blob value expression> IN <blob value expression> <right paren>

<length expression> ::=
    <char length expression>
  | <octet length expression>

<char length expression> ::=
    { CHAR_LENGTH | CHARACTER_LENGTH } <left paren> <string value expression>
    [ USING <char length units> ] <right paren>

<octet length expression> ::=
    OCTET_LENGTH <left paren> <string value expression> <right paren>

<extract expression> ::=
    EXTRACT <left paren> <extract field> FROM <extract source> <right paren>

<extract field> ::=
    <primary datetime field>
  | <time zone field>

<time zone field> ::=
    TIMEZONE_HOUR



©ISO/IEC 2003 – All rights reserved                                     Scalar expressions 243
ISO/IEC 9075-2:2003 (E)
6.27 <numeric value function>



  | TIMEZONE_MINUTE

<extract source> ::=
    <datetime value expression>
  | <interval value expression>

<cardinality expression> ::=
    CARDINALITY <left paren> <collection value expression> <right paren>

<absolute value expression> ::= ABS <left paren> <numeric value expression> <right paren>

<modulus expression> ::=
    MOD <left paren> <numeric value expression dividend> <comma>
    <numeric value expression divisor><right paren>

<numeric value expression dividend> ::= <numeric value expression>

<numeric value expression divisor> ::= <numeric value expression>

<natural logarithm> ::= LN <left paren> <numeric value expression> <right paren>

<exponential function> ::= EXP <left paren> <numeric value expression> <right paren>

<power function> ::=
    POWER <left paren> <numeric value expression base> <comma>
    <numeric value expression exponent> <right paren>

<numeric value expression base> ::= <numeric value expression>

<numeric value expression exponent> ::= <numeric value expression>

<square root> ::= SQRT <left paren> <numeric value expression> <right paren>

<floor function> ::= FLOOR <left paren> <numeric value expression> <right paren>

<ceiling function> ::=
    { CEIL | CEILING } <left paren> <numeric value expression> <right paren>

<width bucket function> ::=
    WIDTH_BUCKET <left paren> <width bucket operand> <comma> <width bucket bound 1> <comma>
    <width bucket bound 2> <comma> <width bucket count> <right paren>

<width bucket operand> ::= <numeric value expression>

<width bucket bound 1> ::= <numeric value expression>

<width bucket bound 2> ::= <numeric value expression>

<width bucket count> ::= <numeric value expression>


Syntax Rules
1) If <position expression> is specified, then the declared type of the result is an implementation-defined
   exact numeric type with scale 0 (zero).
2) If <string position expression> is specified, then both <string value expression>s shall be <character value
   expression>s that are comparable.



244 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                 6.27 <numeric value function>



3) Case:
    a) If the character encoding form of <string value expression> is not UTF8, UTF16, or UTF32, then <char
       length units> shall not be specified.
    b) Otherwise, if <char length units> is not specified, then CHARACTERS is implicit.
4) If <extract expression> is specified, then
    Case:
    a) If <extract field> is a <primary datetime field>, then it shall identify a <primary datetime field> of the
       <interval value expression> or <datetime value expression> immediately contained in <extract source>.
    b) If <extract field> is a <time zone field>, then the declared type of the <extract source> shall be TIME
       WITH TIME ZONE or TIMESTAMP WITH TIME ZONE.
5) If <extract expression> is specified, then
    Case:
    a) If <primary datetime field> does not specify SECOND, then the declared type of the result is an
       implementation-defined exact numeric type with scale 0 (zero).
    b) Otherwise, the declared type of the result is an implementation-defined exact numeric type with scale
       not less than the specified or implied <time fractional seconds precision> or <interval fractional seconds
       precision>, as appropriate, of the SECOND <primary datetime field> of the <extract source>.
6) If a <length expression> is specified, then the declared type of the result is an implementation-defined exact
   numeric type with scale 0 (zero).
7) If <cardinality expression> is specified, then the declared type of the result is an implementation-defined
   exact numeric type with scale 0 (zero).
8) If <absolute value expression> is specified, then the declared type of the result is the declared type of the
   immediately contained <numeric value expression>.
9) If <modulus expression> is specified, then the declared type of each <numeric value expression> shall be
   exact numeric with scale 0 (zero). The declared type of the result is the declared type of the immediately
   contained <numeric value expression divisor>.
10) The declared type of the result of <natural logarithm> is an implementation-defined approximate numeric
    type.
11) The declared type of the result of <exponential function> is an implementation-defined approximate numeric
    type.
12) The declared type of the result of <power function> is an implementation-defined approximate numeric
    type.
13) If <square root> is specified, then let NVE be the simply contained <numeric value expression>. The <square
    root> is equivalent to
        POWER (NVE, 0.5)

14) If <floor function> or <ceiling function> is specified, then


©ISO/IEC 2003 – All rights reserved                                                      Scalar expressions 245
ISO/IEC 9075-2:2003 (E)
6.27 <numeric value function>



    Case:
    a) If the declared type of the simply contained <numeric value expression> NVE is exact numeric, then
       the declared type of the result is exact numeric with implementation-defined precision, with the radix
       of NVE, and with scale 0 (zero).
    b) Otherwise, the declared type of the result is approximate numeric with implementation-defined precision.
15) If <width bucket function> is specified, then the declared type of <width bucket count> shall be exact
    numeric with scale 0 (zero). The declared type of the result of <width bucket function> is the declared type
    of <width bucket count>.


Access Rules
    None.


General Rules
1) If the value of one or more <string value expression>s, <datetime value expression>s, <interval value
   expression>s, and <collection value expression>s that are simply contained in a <numeric value function>
   is the null value, then the result of the <numeric value function> is the null value.
2) If <string position expression> is specified, then let SVE1 be the value of the first <string value expression>
   and let SVE2 be the value of the second <string value expression>.
    Case:
    a) If CHAR_LENGTH(SVE1) is 0 (zero), then the result is 1 (one).
    b) If <char length units> is specified, then let CLU be <char length units>; otherwise, let CLU be
       CHARACTERS. If there is at least one value P such that

        SVE1 = SUBSTRING ( SVE2 FROM P FOR CHAR_LENGTH (SVE1 USING CLU ) USING CLU )

        then the result is the least such P.
        NOTE 112 — The collation used is determined in the normal way.

    c) Otherwise, the result is 0 (zero).
3) If <blob position expression> is specified, then
    Case:
    a) If the first <blob value expression> has a length of 0 (zero), then the result is 1 (one).
    b) If the value of the first <blob value expression> is equal to an identical-length substring of contiguous
       octets from the value of the second <blob value expression>, then the result is 1 (one) greater than the
       number of octets within the value of the second <blob value expression> preceding the start of the first
       such substring.
    c) Otherwise, the result is 0 (zero).
4) If <extract expression> is specified, then


246 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                                               6.27 <numeric value function>



    Case:
    a) If <extract field> is a <primary datetime field>, then the result is the value of the datetime field identified
       by that <primary datetime field> and has the same sign as the <extract source>.
         NOTE 113 — If the value of the identified <primary datetime field> is zero or if <extract source> is not an <interval value
         expression>, then the sign is irrelevant.

    b) Otherwise, let TZ be the interval value of the implicit or explicit time zone displacement associated
       with the <datetime value expression>.
         Case:
         i)       If <extract field> is TIMEZONE_HOUR, then the result is calculated as EXTRACT (HOUR
                  FROM TZ).
         ii)      Otherwise, the result is calculated as EXTRACT (MINUTE FROM TZ)
5) If a <char length expression> is specified, then
    Case:
    a) If the character encoding form of <character value expression> is not UTF8, UTF16, or UTF32, then
       let S be the <string value expression>.
         Case:
         i)       If the most specific type of S is character string, then the result is the number of characters in
                  the value of S.
                  NOTE 114 — The number of characters in a character string is determined according to the semantics of the character
                  set of that character string.

         ii)      Otherwise, the result is OCTET_LENGTH(S).
    b) Otherwise, the result is the number of explicit or implicit <char length units> in <char length expression>,
       counted in accordance with the definition of those units in the relevant normatively referenced document.
6) If an <octet length expression> is specified, then let S be the <string value expression>. Let BL be the
   number of bits (binary digits) in the value of S. The result of the <octet length expression> is the smallest
   integer not less than the quotient of the division (BL/8).
7) The result of <cardinality expression> is the number of elements of the result of the <collection value
   expression>.
8) If <absolute value expression> is specified, then let N be the value of the immediately contained <numeric
   value expression>.
    Case:
    a) If N is the null value, then the result is the null value.

    b) If N ≥ 0, then the result is N.
    c) Otherwise, the result is –1 * N. If –1 * N is not representable by the result data type, then an exception
       condition is raised: data exception — numeric value out of range.




©ISO/IEC 2003 – All rights reserved                                                                      Scalar expressions 247
ISO/IEC 9075-2:2003 (E)
6.27 <numeric value function>



9) If <modulus expression> is specified, then let N be the value of the immediately contained <numeric value
   expression dividend> and let M be the value of the immediately contained <numeric value expression
   divisor>.
    Case:
    a) If either N or M is the null value, then the result is the null value.
    b) If M is zero, then an exception condition is raised: data exception — division by zero.
    c) Otherwise, the result is the unique nonnegative exact numeric value R with scale 0 (zero) such that all
       of the following are true:
        i)     R has the same sign as N.
        ii)    The absolute value of R is less than the absolute value of M.
        iii)   N = M * K + R for some exact numeric value K with scale 0 (zero).
10) If <natural logarithm> is specified, then let V be the value of the simply contained <numeric value
    expression>.
    Case:
    a) If V is the null value, then the result is the null value.
    b) If V is 0 (zero) or negative, then an exception condition is raised: data exception — invalid argument
       for natural logarithm.
    c) Otherwise, the result is the natural logarithm of V.
11) If <exponential function> is specified, then let V be the value of the simply contained <numeric value
    expression>.
    Case:
    a) If V is the null value, then the result is the null value.
    b) Otherwise, the result is e (the base of natural logarithms) raised to the power V. If the result is not
       representable in the the declared type of the result, then an exception condition is raised: data exception
       — numeric value out of range.
12) If <power function> is specified, then let NVEB be the <numeric value expression base>, then let VB be
    the value of NVEB, let NVEE be the <numeric value expression exponent>, and let VE be the value of
    NVEE.
    Case:
    a) If either VB or VE is the null value, then the result is the null value.
    b) If VB is 0 (zero) and VE is negative, then an exception condition is raised: data exception — invalid
       argument for power function.
    c) If VB is 0 (zero) and VE is 0 (zero), then the result is 1 (one).
    d) If VB is 0 (zero) and VE is positive, then the result is 0 (zero).



248 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)
                                                                                      6.27 <numeric value function>



    e) If VB is negative and VE is not equal to an exact numeric value with scale 0 (zero), then an exception
       condition is raised: data exception — invalid argument for power function.
    f) If VB is negative and VE is equal to an exact numeric value with scale 0 (zero) that is an even number,
       then the result is the result of
               EXP(NVEE*LN(-NVEB))

    g) If VB is negative and VE is equal to an exact numeric value with scale 0 (zero) that is an odd number,
       then the result is the result of
               -EXP(NVEE*LN(-NVEB))

    h) Otherwise, the result is the result of
               EXP(NVEE*LN(NVEB))

13) If <floor function> is specified, then let V be the value of the simply contained <numeric value expression>
    NVE.
    Case:
    a) If V is the null value, then the result is the null value.
    b) Otherwise,
         Case:
         i)       If the most specific type of NVE is exact numeric, then the result is the greatest exact numeric
                  value with scale 0 (zero) that is less than or equal to V. If this result is not representable by the
                  result data type, then an exception condition is raised: data exception — numeric value out of
                  range.
         ii)      Otherwise, the result is the greatest whole number that is less than or equal to V. If this result is
                  not representable by the result data type, then an exception condition is raised: data exception
                  — numeric value out of range.
14) If <ceiling function> is specified, then let V be the value of the simply contained <numeric value expression>
    NVE.
    Case:
    a) If V is the null value, then the result is the null value.
    b) Otherwise,
         Case:
         i)       If the most specific type of NVE is exact numeric, then the result is the least exact numeric value
                  with scale 0 (zero) that is greater than or equal to V. If this result is not representable by the
                  result data type, then an exception condition is raised: data exception — numeric value out of
                  range.




©ISO/IEC 2003 – All rights reserved                                                           Scalar expressions 249
ISO/IEC 9075-2:2003 (E)
6.27 <numeric value function>



       ii)     Otherwise, the result is the least whole number that is greater than or equal to V. If this result is
               not representable by the result data type, then an exception condition is raised: data exception
               — numeric value out of range.
15) If <width bucket function> is specified, then let WBO be the value of <width bucket operand>, let WBB1
    be the value of <width bucket bound 1>, let WBB2 be the value of <width bucket bound 2>, and let WBC
    be the value of <width bucket count>.
   Case:
   a) If any of WBO, WBB1, WBB2, or WBC is the null value, then the result is the null value.
   b) If WBC is less than or equal to 0 (zero), then an exception condition is raised: data exception — invalid
      argument for width bucket function.
   c) If WBB1 equals WBB2, then an exception condition is raised: data exception — invalid argument for
      width bucket function.
   d) If WBB1 is less than WBB2, then
       Case:
       i)      If WBO is less than WBB1, then the result is 0 (zero).
       ii)     If WBO is greater than or equal to WBB2, then the result is WBC+1. If the result is not repre-
               sentable in the declared type of the result, then an exception condition is raised: data exception
               — numeric value out of range.
       iii)    Otherwise, the result is the greatest exact numeric value with scale 0 (zero) that is less than or
               equal to ((WBC * (WBO - WBB1) / (WBB2 - WBB1)) + 1)
   e) If WBB1 is greater than WBB2, then
       Case:
       i)      If WBO is greater than WBB1, then the result is 0 (zero).
       ii)     If WBO is less than or equal to WBB2, then the result is WBC+1. If the result is not representable
               in the declared type of the result, then an exception condition is raised: data exception — numeric
               value out of range.
       iii)    Otherwise, the result is the greatest exact numeric value with scale 0 (zero) that is less than or
               equal to ((WBC * (WBB1 - WBO) / (WBB1 - WBB2)) + 1)


Conformance Rules
1) Without Feature S091, “Basic array support”, or Feature S271, “Basic multiset support”, conforming SQL
   language shall not contain a <cardinality expression>.
2) Without Feature F052, “Intervals and datetime arithmetic”, conforming SQL language shall not contain an
   <extract expression>.
3) Without Feature F052, “Intervals and datetime arithmetic”, conforming SQL language shall not contain an
   <extract expression> that specifies a <time zone field>.



250 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                              6.27 <numeric value function>



4) Feature F411, “Time zone specification”, conforming SQL language shall not contain an <extract expression>
   that specifies a <time zone field>.
5) Without Feature F421, “National character”, conforming SQL language shall not contain a <length
   expression> that simply contains a <string value expression> that has a declared type of NATIONAL
   CHARACTER LARGE OBJECT.
6) Without Feature T441, “ABS and MOD functions”, conforming language shall not contain an <absolute
   value expression>.
7) Without Feature T441, “ABS and MOD functions”, conforming language shall not contain a <modulus
   expression>.
8) Without Feature T621, “Enhanced numeric functions”, conforming SQL language shall not contain a
   <natural logarithm>.
9) Without Feature T621, “Enhanced numeric functions”, conforming SQL language shall not contain an
   <exponential function>.
10) Without Feature T621, “Enhanced numeric functions”, conforming SQL language shall not contain a
    <power function>.
11) Without Feature T621, “Enhanced numeric functions”, conforming SQL language shall not contain a
    <square root>.
12) Without Feature T621, “Enhanced numeric functions”, conforming SQL language shall not contain a <floor
    function>.
13) Without Feature T621, “Enhanced numeric functions”, conforming SQL language shall not contain a
    <ceiling function>.
14) Without Feature T612, “Advanced OLAP operations”, conforming SQL language shall not contain a <width
    bucket function>.




©ISO/IEC 2003 – All rights reserved                                                   Scalar expressions 251
ISO/IEC 9075-2:2003 (E)
6.28 <string value expression>



6.28 <string value expression>

Function
Specify a character string value or a binary string value.


Format
<string value expression> ::=
    <character value expression>
  | <blob value expression>

<character value expression> ::=
    <concatenation>
  | <character factor>

<concatenation> ::= <character value expression> <concatenation operator> <character factor>

<character factor> ::= <character primary> [ <collate clause> ]

<character primary> ::=
    <value expression primary>
  | <string value function>

<blob value expression> ::=
    <blob concatenation>
  | <blob factor>

<blob factor> ::= <blob primary>

<blob primary> ::=
    <value expression primary>
  | <string value function>

<blob concatenation> ::= <blob value expression> <concatenation operator> <blob factor>


Syntax Rules
1) The declared type of a <character primary> shall be character string.
2) Character strings of different character repertoires shall not be mixed in a <character value expression>.
3) The character set of a <character value expression> is that character set of its character string operands that
   has the character encoding form with the highest precedence.
4) Case:
    a) If <concatenation> is specified, then:
        Let D1 be the declared type of the <character value expression> and let D2 be the declared type of the
        <character factor>. Let M be the length in characters of D1 plus the length in characters of D2. Let VL
        be the implementation-defined maximum length of variable-length character strings, let LOL be the



252 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                     6.28 <string value expression>



         implementation-defined maximum length of large object character strings, and let FL be the implemen-
         tation-defined maximum length of fixed-length character strings.
         Case:
         i)       If the declared type of the <character value expression> or <character factor> is a character large
                  object type, then the declared type of the <concatenation> is a character large object type with
                  maximum length equal to the lesser of M and LOL.
         ii)      If the declared type of the <character value expression> or <character factor> is variable-length
                  character string, then the declared type of the <concatenation> is variable-length character string
                  with maximum length equal to the lesser of M and VL.
         iii)     If the declared type of the <character value expression> and <character factor> is fixed-length
                  character string, then M shall not be greater than FL and the declared type of the <concatenation>
                  is fixed-length character string with length M.
    b) Otherwise, the declared type of the <character value expression> is the declared type of the <character
       factor>.
5) Case:
    a) If <character factor> is specified, then
         Case:
         i)       If <collate clause> is specified, then the declared type collation of the <character value expres-
                  sion> is the collation identified by <collate clause>, and its collation derivation is explicit.
         ii)      Otherwise, the declared type of the <character factor> is the declared type of the <character
                  primary>.
    b) If <concatenation> is specified, then its declared type is determined by applying Subclause 9.3, “Data
       types of results of aggregations”, to the declared types of its operands.
6) The declared type of <blob primary> shall be binary string.
7) If <blob concatenation> is specified, then let M be the length in octets of the <blob value expression> plus
   the length in octets of the <blob factor> and let VL be the implementation-defined maximum length of a
   binary string. The declared type of <blob concatenation> is binary string with maximum length equal to
   the lesser of M and VL.


Access Rules
    None.


General Rules
1) If the value of any <character primary> or <blob primary> simply contained in a <string value expression>
   is the null value, then the result of the <string value expression> is the null value.
2) If <concatenation> is specified, then:



©ISO/IEC 2003 – All rights reserved                                                         Scalar expressions 253
ISO/IEC 9075-2:2003 (E)
6.28 <string value expression>



    a) If the character repertoire of <character factor> is UCS, then, in the remainder of this General Rule,
       the term “length” shall be taken to mean “length in characters”.
    b) Let S1 and S2 be the result of the <character value expression> and <character factor>, respectively.
        Case:
        i)      If either S1 or S2 is the null value, then the result of the <concatenation> is the null value.
        ii)     Otherwise:
                1) Let S be the string consisting of S1 followed by S2 and let M be the length of S.
                2) If the character repertoire of <character factor> is UCS, then S is replaced by:
                    Case:
                    A) If the <search condition> S1 IS NORMALIZED AND S2 IS NORMALIZED eval-
                       uates to True, then

                        NORMALIZE (S)

                    B) Otherwise, an implementation-defined string.
                3) Case:
                    A) If the most specific type of either S1 or S2 is a character large object type, then let LOL
                       be the implementation-defined maximum length of large object character strings.
                        Case:
                        I)      If M is less than or equal to LOL, then the result of the <concatenation> is S with
                                length M.
                        II)     If M is greater than LOL and the right-most M–LOL characters of S are all the
                                <space> character, then the result of the <concatenation> is the first LOL charac-
                                ters of S with length LOL.
                        III)    Otherwise, an exception condition is raised: data exception — string data, right
                                truncation.
                    B) If the most specific type of either S1 or S2 is variable-length character string, then let
                       VL be the implementation-defined maximum length of variable-length character strings.
                        Case:
                        I)      If M is less than or equal to VL, then the result of the <concatenation> is S with
                                length M.
                        II)     If M is greater than VL and the right-most M–VL characters of S are all the <space>
                                character, then the result of the <concatenation> is the first VL characters of S
                                with length VL.
                        III)    Otherwise, an exception condition is raised: data exception — string data, right
                                truncation.




254 Foundation (SQL/Foundation)                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                                    6.28 <string value expression>



                      C) If the most specific types of both S1 and S2 are fixed-length character string, then the
                         result of the <concatenation> is S.
3) If <blob concatenation> is specified, then let S1 and S2 be the result of the <blob value expression> and
   <blob factor>, respectively.
    Case:
    a) If either S1 or S2 is the null value, then the result of the <blob concatenation> is the null value.
    b) Otherwise, let S be the string consisting of S1 followed by S2 and let M be the length in octets of S.
         Case:
         i)       If M is less or equal to VL, then the result of the <blob concatenation> is S with length M.
         ii)      If M is greater than VL and the right-most M–VL octets of S are all X'00', then the result of the
                  <blob concatenation> is the first VL octets of S with length VL.
         iii)     Otherwise, an exception condition is raised: data exception — string data, right truncation.
4) If the result of the <character value expression> is a zero-length character string, then it is implementation-
   defined whether an exception condition is raised: data exception — zero-length character string.


Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved                                                        Scalar expressions 255
ISO/IEC 9075-2:2003 (E)
6.29 <string value function>



6.29 <string value function>

Function
Specify a function yielding a value of type character string or binary string.


Format
<string value function> ::=
    <character value function>
  | <blob value function>

<character value function> ::=
    <character substring function>
  | <regular expression substring function>
  | <fold>
  | <transcoding>
  | <character transliteration>
  | <trim function>
  | <character overlay function>
  | <normalize function>
  | <specific type method>

<character substring function> ::=
    SUBSTRING <left paren> <character value expression> FROM <start position>
    [ FOR <string length> ] [ USING <char length units> ] <right paren>

<regular expression substring function> ::=
    SUBSTRING <left paren> <character value expression> SIMILAR <character value expression>
    ESCAPE <escape character> <right paren>

<fold> ::= { UPPER | LOWER } <left paren> <character value expression> <right paren>

<transcoding> ::=
    CONVERT <left paren> <character value expression>
    USING <transcoding name> <right paren>

<character transliteration> ::=
    TRANSLATE <left paren> <character value expression>
    USING <transliteration name> <right paren>

<trim function> ::= TRIM <left paren> <trim operands> <right paren>

<trim operands> ::= [ [ <trim specification> ] [ <trim character> ] FROM ] <trim source>

<trim source> ::= <character value expression>

<trim specification> ::=
    LEADING
  | TRAILING
  | BOTH

<trim character> ::= <character value expression>

<character overlay function> ::=



256 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                                 6.29 <string value function>



     OVERLAY <left paren> <character value expression> PLACING <character value expression>
     FROM <start position> [ FOR <string length> ]
     [ USING <char length units> ] <right paren>

<normalize function> ::= NORMALIZE <left paren> <character value expression> <right paren>

<specific type method> ::=
    <user-defined type value expression> <period> SPECIFICTYPE
    [ <left paren> <right paren> ]

<blob value function> ::=
    <blob substring function>
  | <blob trim function>
  | <blob overlay function>

<blob substring function> ::=
    SUBSTRING <left paren> <blob value expression> FROM <start position>
    [ FOR <string length> ] <right paren>

<blob trim function> ::= TRIM <left paren> <blob trim operands> <right paren>

<blob trim operands> ::=
    [ [ <trim specification> ] [ <trim octet> ] FROM ] <blob trim source>

<blob trim source> ::= <blob value expression>

<trim octet> ::= <blob value expression>

<blob overlay function> ::=
    OVERLAY <left paren> <blob value expression> PLACING <blob value expression>
    FROM <start position> [ FOR <string length> ] <right paren>

<start position> ::= <numeric value expression>

<string length> ::= <numeric value expression>


Syntax Rules
1) The declared type of <string value function> is the declared type of the immediately contained <character
   value function> or <blob value function>.
2) The declared type of <character value function> is the declared type of the immediately contained <char-
   acter substring function>, <regular expression substring function>, <fold>, <transcoding>, <character
   transliteration>, <trim function>, <character overlay function>, <normalize function>, or <specific type
   method>.
3) The declared type of a <start position> and <string length> shall be exact numeric with scale 0 (zero).
4) If <character substring function> CSF is specified, then let DTCVE be the declared type of the <character
   value expression> immediately contained in CSF. The maximum length, character set, and collation of the
   declared type DTCSF of CSF are determined as follows:
    a) Case:




©ISO/IEC 2003 – All rights reserved                                                   Scalar expressions 257
ISO/IEC 9075-2:2003 (E)
6.29 <string value function>



        i)     If the declared type of <character value expression> is fixed-length character string or variable-
               length character string, then DTCSF is a variable-length character string type with maximum
               length equal to the fixed length or maximum length of DTCVE.
        ii)    Otherwise, the DTCSF is a large object character string type with maximum length equal to the
               maximum length of DTCVE.
    b) The character set and collation of the <character substring function> are those of DTCVE.
5) If the character repertoire of <character value expression> is not UCS, then <char length units> shall not
   be specified.
6) If USING <char length units> is not specified, then USING CHARACTERS is implicit.
7) If <regular expression substring function> is specified, then:
    a) The declared types of the <escape character> and the <character value expression>s of the <regular
       expression substring function> shall be character string with the same character repertoire.
    b) Case:
        i)     If the declared type of the first <character value expression> is fixed-length character string or
               variable-length character string, then the declared type of the <regular expression substring
               function> is variable-length character string with maximum length equal to the maximum variable
               length of the first <character value expression>.
        ii)    Otherwise, the declared type of the <regular expression substring function> is a character large
               object type with maximum length equal to the maximum variable length of the first <character
               value expression>.
    c) The declared type of the <regular expression substring function> is that of the first <character value
       expression>.
    d) The value of the <escape character> shall have length 1 (one).
8) If <fold> is specified, then the declared type of the result of <fold> is that of the <character value expres-
   sion>.
9) If <transcoding> is specified, then:
    a) <transcoding> shall be simply contained in a <value expression> that is immediately contained in a
       <derived column> that is immediately contained in a <select sublist> or shall immediately contain
       either a <simple value specification> that is a <host parameter name> or a <value specification> that
       is a <host parameter specification>.
    b) A <transcoding name> shall identify a transcoding.
    c) Case:
        i)     If the declared type of <character value expression> is fixed-length character string or variable-
               length character string, then the declared type of the result is variable-length character string
               with implementation-defined maximum length.
        ii)    Otherwise, the declared type of the result is a character large object type with implementation-
               defined maximum length.



258 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                            ISO/IEC 9075-2:2003 (E)
                                                                                        6.29 <string value function>



    d) The character set of the result is an implementation-defined character set CS whose character repertoire
       is the same as the character repertoire of the <character value expression> and whose character
       encoding form is that determined by the transcoding identified by the <transcoding name>. The declared
       type collation of the result is the character set collation of CS.
10) If <character transliteration> is specified, then:
    a) A <transliteration name> shall identify a character transliteration.
    b) Case:
         i)       If the declared type of <character value expression> is fixed-length character string or variable-
                  length character string, then the declared type of the <character transliteration> is variable-length
                  character string with implementation-defined maximum length.
         ii)      Otherwise, the declared type of the <character transliteration> is a character large object type
                  with implementation-defined maximum length.
    c) The declared type of the <character transliteration> has the character set CS that is the target character
       set of the transliteration. The declared type collation of the result is the character set collation of CS.
11) If <trim function> is specified, then
    a) Case:
         i)       If FROM is specified, then:
                  1) Either <trim specification> or <trim character> or both shall be specified.
                  2) If <trim specification> is not specified, then BOTH is implicit.
                  3) If <trim character> is not specified, then ' ' is implicit.
         ii)      Otherwise, let SRC be <trim source>. TRIM ( SRC ) is equivalent to TRIM ( BOTH ' '
                  FROM SRC ).
    b) Case:
         i)       If the declared type of <character value expression> is fixed-length character string or variable-
                  length character string, then the declared type of the <trim function> is variable-length character
                  string with maximum length equal to the fixed length or maximum variable length of the <trim
                  source>.
         ii)      Otherwise, the declared type of the <trim function> is a character large object type with maximum
                  length equal to the maximum variable length of the <trim source>.
    c) If a <trim character> is specified, then <trim character> and <trim source> shall be comparable.
    d) The declared type of the <trim function> is that of the <trim source>.
12) If <character overlay function> is specified, then:
    a) Let CV be the first <character value expression>, let SP be the <start position>, and let RS be the second
       <character value expression>.
    b) If <string length> is specified, then let SL be <string length>; otherwise, let SL be CHAR_LENGTH(RS).



©ISO/IEC 2003 – All rights reserved                                                           Scalar expressions 259
ISO/IEC 9075-2:2003 (E)
6.29 <string value function>



    c) The <character overlay function> is equivalent to:
                 SUBSTRING ( CV FROM 1 FOR SP - 1 )
              || RS
              || SUBSTRING ( CV FROM SP + SL )


13) If <normalize function> is specified, then the declared type of the result is the declared type of <string
    value expression>.
14) If <specific type method> is specified, then the declared type of the <specific type method> is variable-
    length character string with maximum length implementation-defined. The character set of the character
    string is SQL_IDENTIFIER.
15) The declared type of <blob value function> is the declared type of the immediately contained <blob substring
    function>, <blob trim function>, or <blob overlay function>.
16) If <blob substring function> is specified, then the declared type of the <blob substring function> is binary
    string with maximum length equal to the maximum length of the <blob value expression>.
17) If <blob trim function> is specified, then:
    a) Case:
        i)       If FROM is specified, then:
                 1) Either <trim specification> or <trim octet> or both shall be specified.
                 2) If <trim specification> is not specified, then BOTH is implicit.
                 3) If <trim octet> is not specified, then X'00' is implicit.
        ii)      Otherwise, let SRC be <trim source>. TRIM ( SRC ) is equivalent to TRIM ( BOTH X'00'
                 FROM SRC ).
    b) The declared type of the <blob trim function> is binary string with maximum length equal to the
       maximum length of the <blob trim source>.
18) If <blob overlay function> is specified, then:
    a) Let BV be the first <blob value expression>, let SP be the <start position>, and let RS be the second
       <blob value expression>.
    b) If <string length> is specified, then let SL be <string length>; otherwise, let SL be
       OCTET_LENGTH(RS).
    c) The <blob overlay function> is equivalent to:
                 SUBSTRING ( BV FROM 1 FOR SP - 1 )
              || RS
              || SUBSTRING ( BV FROM SP + SL )



Access Rules
1) Case:


260 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                                               6.29 <string value function>



    a) If <string value function> is contained, without an intervening <SQL routine spec> that specifies SQL
       SECURITY INVOKER, in an <SQL schema statement>, then the applicable privileges of the
       <authorization identifier> that owns the containing schema shall include USAGE for every transliteration
       identified by a <transliteration name> contained in the <string value expression>.
    b) Otherwise, the current privileges shall include USAGE for every transliteration identified by a
       <transliteration name> contained in the <string value expression>.
    NOTE 115 — “applicable privileges” and “current privileges” are defined in Subclause 12.3, “<privileges>”.


General Rules
1) The result of <string value function> is the result of the immediately contained <character value function>
   or <blob value function>.
2) The result of <character value function> is the result of the immediately contained <character substring
   function>, <regular expression substring function>, <fold>, <transcoding>, <character transliteration>,
   <trim function>, <character overlay function>, or <specific type method>.
3) If <character substring function> is specified, then:
    a) If the character encoding form of <character value expression> is UTF8, UTF16, or UTF32, then, in
       the remainder of this General Rule, the term “character” shall be taken to mean “unit specified by <char
       length units>”.
    b) Let C be the value of the <character value expression>, let LC be the length in characters of C, and let
       S be the value of the <start position>.
    c) If <string length> is specified, then let L be the value of <string length> and let E be S+L. Otherwise,
       let E be the larger of LC + 1 and S.
    d) If either C, S, or L is the null value, then the result of the <character substring function> is the null
       value.
    e) If E is less than S, then an exception condition is raised: data exception — substring error.
    f) Case:
         i)       If S is greater than LC or if E is less than 1 (one), then the result of the <character substring
                  function> is a zero-length string.
         ii)      Otherwise,
                  1) Let S1 be the larger of S and 1 (one). Let E1 be the smaller of E and LC+1. Let L1 be E1–S1.
                  2) The result of the <character substring function> is a character string containing the L1
                     characters of C starting at character number S1 in the same order that the characters appear
                     in C.
4) If <normalize function> is specified, then the result is the value of <string value expression> in the normal-
   ized form of the result, in accordance with Unicode Standard Annex #15 Unicode Normalization Forms.
5) If <regular expression substring function> is specified, then:




©ISO/IEC 2003 – All rights reserved                                                                  Scalar expressions 261
ISO/IEC 9075-2:2003 (E)
6.29 <string value function>



    a) Let C be the result of the first <character value expression>, let R be the result of the second <character
       value expression>, and let E be the result of the <escape character>.
    b) If one or more of C, R or E is the null value, then the result of the <regular expression substring function>
       is the null value.
    c) If the length in characters of E is not equal to 1 (one), then an exception condition is raised: data
       exception — invalid escape character.
    d) If R does not contain exactly two occurrences of the two-character sequence consisting of E, each
       immediately followed by <double quote>, then an exception condition is raised: data exception —
       invalid use of escape character.
    e) Let R1, R2, and R3 be the substrings of R, such that
              'R' = 'R1' || 'E' || '"' || 'R2' || 'E' || '"' || 'R3'

        is True.
    f) If any one of R1, R2, or R3 is not a zero-length string and does not have the format of a <regular
       expression>, then an exception condition is raised: data exception — invalid regular expression.
    g) If the predicate
              'C' SIMILAR TO 'R1' || 'R2' || 'R3' ESCAPE 'E'

        is not True, then the result of the <regular expression substring function> is the null value.
    h) Otherwise, the result S of the <regular expression substring function> is computed as follows:
        i)       Let S1 be the shortest initial substring of C such that there is a substring S23 of C such that the
                 following <search condition> is True:

                   'C' = 'S1' || 'S23' AND
                   'S1' SIMILAR TO 'R1' ESCAPE 'E' AND
                   'S23' SIMILAR TO '(R2R3)' ESCAPE 'E'


        ii)      Let S3 be the shortest final substring of S23 such that there is a substring S2 of S23 such that
                 the following <search condition> is True:
                   'S23' = 'S2' || 'S3' AND
                   'S2' SIMILAR TO 'R2' ESCAPE 'E' AND
                   'S3' SIMILAR TO 'R3' ESCAPE 'E'


        iii)     The result of the <regular expression substring function> is S2.
6) If <fold> is specified, then:
    a) Let S be the value of the <character value expression>.
    b) If S is the null value, then the result of the <fold> is the null value.
    c) Let FRML be the length or maximum length in characters of the declared type of <fold>.
    d) Case:


262 Foundation (SQL/Foundation)                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                      6.29 <string value function>



         i)       If UPPER is specified, then let FR be a copy of S in which every lower case character that has
                  a corresponding upper case character or characters in the character set of S and every title case
                  character that has a corresponding upper case character or characters in the character set of S is
                  replaced by that upper case character or characters.
         ii)      If LOWER is specified, then let FR be a copy of S in which every upper case character that has
                  a corresponding lower case character or characters in the character set of S and every title case
                  character that has a corresponding lower case character or characters in the character set of S is
                  replaced by that lower case character or characters.
    e) If the character set of <character factor> is UTF8, UTF16, or UTF32, then FR is replaced by
         Case:
         i)       If the <search condition> S IS NORMALIZED evaluated to True, then
                  NORMALIZE (FR)

         ii)      Otherwise, FR.
    f) Let FRL be the length in characters of FR.
    g) Case:
         i)       If FRL is less than or equal to FRML, then the result of the <fold> is FR. If the declared type of
                  FR is fixed-length character string, then the result is padded on the right with (FRML – FRL)
                  <space>s.
         ii)      If FRL is greater than FRML, then the result of the <fold> is the first FRML characters of FR
                  with length FRML. If any of the right-most (FRL – FRML) characters of FR are not <space>
                  characters, then a completion condition is raised: warning — string data, right truncation.
7) If a <character transliteration> is specified, then
    Case:
    a) If the value of <character value expression> is the null value, then the result of the <character translit-
       eration> is the null value.
    b) If <transliteration name> identifies a transliteration descriptor whose indication of how the transliteration
       is performed specifies an SQL-invoked routine TR, then the result of the <character transliteration> is
       the result of the invocation of TR with a single SQL argument that is the <character value expression>
       contained in the <character transliteration>.
    c) Otherwise, the value of the <character transliteration> is the value returned by the transliteration iden-
       tified by the <existing transliteration name> specified in the transliteration descriptor of the transliter-
       ation identified by <transliteration name>.
8) If a <transcoding> is specified, then
    Case:
    a) If the value of <character value expression> is the null value, then the result of the <transcoding> is
       the null value.




©ISO/IEC 2003 – All rights reserved                                                         Scalar expressions 263
ISO/IEC 9075-2:2003 (E)
6.29 <string value function>



    b) Otherwise, the value of the <transcoding> is the value of the <character value expression> after the
       application of the transcoding specified by <transcoding name>.
9) If <trim function> is specified, then:
    a) Let S be the value of the <trim source>.
    b) If <trim character> is specified, then let SC be the value of <trim character>; otherwise, let SC be
       <space>.
    c) If either S or SC is the null value, then the result of the <trim function> is the null value.
    d) If the length in characters of SC is not 1 (one), then an exception condition is raised: data exception —
       trim error.
    e) Case:
        i)     If BOTH is specified or if no <trim specification> is specified, then the result of the <trim
               function> is the value of S with any leading or trailing characters equal to SC removed.
        ii)    If TRAILING is specified, then the result of the <trim function> is the value of S with any
               trailing characters equal to SC removed.
        iii)   If LEADING is specified, then the result of the <trim function> is the value of S with any leading
               characters equal to SC removed.
10) If <specific type method> is specified, then:
    a) Let V be the value of the <user-defined type value expression>.
    b) Case:
        i)     If V is the null value, then RV is the null value.
        ii)    Otherwise:
               1) Let UDT be the most specific type of V.
               2) Let UDTN be the <user-defined type name> of UDT.
               3) Let CN be the <catalog name> contained in UDTN, let SN be the <unqualified schema name>
                  contained in UDTN, and let UN be the <qualified identifier> contained in UDTN. Let CND,
                  SND, and UND be CN, SN, and UN, respectively, with every occurrence of <double quote>
                  replaced by <doublequote symbol>. Let RV be:
                      "CND"."SND"."UND"

    c) The result of <specific type method> is RV.
11) The result of <blob value function> is the result of the simply contained <blob substring function>, <blob
    trim function>, or <blob overlay function>.
12) If <blob substring function> is specified, then
    a) Let B be the value of the <blob value expression>, let LB be the length in octets of B, and let S be the
       value of the <start position>.



264 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                             ISO/IEC 9075-2:2003 (E)
                                                                                         6.29 <string value function>



    b) If <string length> is specified, then let L be the value of <string length> and let E be S+L. Otherwise,
       let E be the larger of LB+1 and S.
    c) If either B, S, or L is the null value, then the result of the <blob substring function> is the null value.
    d) If E is less than S, then an exception condition is raised: data exception — substring error.
    e) Case:
         i)       If S is greater than LB or if E is less than 1 (one), then the result of the <blob substring function>
                  is a zero-length string.
         ii)      Otherwise:
                  1) Let S1 be the larger of S and 1 (one). Let E1 be the smaller of E and LB+1. Let L1 be E1–S1.
                  2) The result of the <blob substring function> is a binary large object string containing L1
                     octets of B starting at octet number S1 in the same order that the octets appear in B.
13) If <blob trim function> is specified, then
    a) Let S be the value of the <trim source>.
    b) Let SO be the value of <trim octet>.
    c) If either S or SO the null value, then the result of the <blob trim function> is the null value.
    d) If the length in octets of SO is not 1 (one), then an exception condition is raised: data exception — trim
       error.
    e) Case:
         i)       If BOTH is specified or if no <trim specification> is specified, then the result of the <blob trim
                  function> is the value of S with any leading or trailing octets equal to SO removed.
         ii)      If TRAILING is specified, then the result of the <blob trim function> is the value of S with any
                  trailing octets equal to SO removed.
         iii)     If LEADING is specified, then the result of the <blob trim function> is the value of S with any
                  leading octets equal to SO removed.
14) If the result of <string value expression> is a zero-length character string, then it is implementation-defined
    whether an exception condition is raised: data exception — zero-length character string.


Conformance Rules
1) Without Feature T581, “Regular expression substring function”, conforming SQL language shall not contain
   a <regular expression substring function>.
2) Without Feature T312, “OVERLAY function”, conforming SQL language shall not contain a <character
   overlay function>.
3) Without Feature T312, “OVERLAY function”, conforming SQL language shall not contain a <blob overlay
   function>.




©ISO/IEC 2003 – All rights reserved                                                            Scalar expressions 265
ISO/IEC 9075-2:2003 (E)
6.29 <string value function>



4) Without Feature T042, “Extended LOB data type support”, conforming SQL language shall not contain a
   <blob value function>.
5) Without Feature F695, “Translation support”, conforming SQL language shall not contain a <character
   transliteration>.
6) Without Feature F695, “Translation support”, conforming SQL language shall not contain a <transcoding>.
7) Without Feature T061, “UCS support”, conforming SQL language shall not contain a <normalize function>.
8) Without Feature S261, “Specific type method”, conforming SQL language shall not contain a <specific
   type method>.




266 Foundation (SQL/Foundation)                                              ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                             6.30 <datetime value expression>



6.30 <datetime value expression>

Function
Specify a datetime value.


Format
<datetime value expression> ::=
    <datetime term>
  | <interval value expression> <plus sign> <datetime term>
  | <datetime value expression> <plus sign> <interval term>
  | <datetime value expression> <minus sign> <interval term>

<datetime term> ::= <datetime factor>

<datetime factor> ::= <datetime primary> [ <time zone> ]

<datetime primary> ::=
    <value expression primary>
  | <datetime value function>

<time zone> ::= AT <time zone specifier>

<time zone specifier> ::=
    LOCAL
  | TIME ZONE <interval primary>


Syntax Rules
1) The declared type of a <datetime primary> shall be datetime.
2) If the <datetime value expression> immediately contains neither <plus sign> nor <minus sign>, then the
   precision of the result of the <datetime value expression> is the precision of the <value expression primary>
   or <datetime value function> that it simply contains.
3) If the declared type of the <datetime primary> is DATE, then <time zone> shall not be specified.
4) Case:
    a) If <time zone> is specified and the declared type of <datetime primary> is TIMESTAMP WITHOUT
       TIME ZONE or TIME WITHOUT TIME ZONE, then the declared type of <datetime term> is
       TIMESTAMP WITH TIME ZONE or TIME WITH TIME ZONE, respectively, with the same fractional
       seconds precision as <datetime primary>.
    b) Otherwise, the declared type of <datetime term> is the same as the declared type of <datetime primary>.
5) If the <datetime value expression> immediately contains either <plus sign> or <minus sign>, then:
    a) The <interval value expression> or <interval term> shall contain only <primary datetime field>s that
       are contained within the <datetime value expression> or <datetime term>.




©ISO/IEC 2003 – All rights reserved                                                     Scalar expressions 267
ISO/IEC 9075-2:2003 (E)
6.30 <datetime value expression>



    b) The result of the <datetime value expression> contains the same <primary datetime field>s that are
       contained in the <datetime value expression> or <datetime term>, with a fractional seconds precision
       that is the greater of the fractional seconds precisions, if any, of either the <datetime value expression>
       and <interval term>, or the <datetime term> and <interval value expression> that it simply contains.
6) The declared type of the <interval primary> immediately contained in a <time zone specifier> shall be
   INTERVAL HOUR TO MINUTE.


Access Rules
    None.


General Rules
1) If the value of any <datetime primary>, <interval value expression>, <datetime value expression>, or
   <interval term> simply contained in a <datetime value expression> is the null value, then the result of the
   <datetime value expression> is the null value.
2) If <time zone> is specified and the <interval primary> immediately contained in <time zone specifier> is
   null, then the result of the <datetime value expression> is the null value.
3) The value of a <datetime primary> is the value of the immediately contained <value expression primary>
   or <datetime value function>.
4) In the following General Rules, arithmetic is performed so as to maintain the integrity of the datetime data
   type that is the result of the <datetime term> or <datetime value expression>. This may involve carry from
   or to the immediately next more significant <primary datetime field>. If the data type of the <datetime
   term> or <datetime value expression> is time with or without time zone, then arithmetic on the HOUR
   <primary datetime field> is undertaken modulo 24. If the <interval value expression> or <interval term>
   is a year-month interval, then the DAY field of the result is the same as the DAY field of the <datetime
   term> or <datetime value expression>.
5) The value of a <datetime term> is determined as follows. Let DT be the declared type, DV the UTC com-
   ponent of the value, and TZD the time zone component, if any, of the <datetime primary> simply contained
   in the <datetime term>, and let STZD be the current default time zone displacement of the SQL-session.
    Case:
    a) If <time zone> is not specified, then the value of <datetime term> is DV.
    b) Otherwise:
        i)     Case:
               1) If DT is datetime with time zone, then the UTC component of the <datetime term> is DV.
               2) Otherwise, the UTC component of the <datetime term> is DV – STZD.
        ii)    Case:
               1) If LOCAL is specified, then let TZ be STZD.




268 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                                ISO/IEC 9075-2:2003 (E)
                                                                                         6.30 <datetime value expression>



                  2) If TIME ZONE is specified, then, if the value of the <interval primary> immediately con-
                     tained in <time zone specifier> is less than INTERVAL -'12:59' or greater than
                     INTERVAL +'14:00', then an exception condition is raised: data exception — invalid
                     time zone displacement value. Otherwise, let TZ be the value of the <interval primary>
                     simply contained in <time zone>.
         iii)     The time zone component of the value of the <datetime term> is TZ.
6) If a <datetime value expression> immediately contains the operator <plus sign> or <minus sign>, then the
   time zone component, if any, of the result is the same as the time zone component of the immediately
   contained <datetime term> or <datetime value expression>. The result (if the result type is without time
   zone) or the UTC component of the result (if the result type has time zone) is effectively evaluated as follows:
    a) Case:
         i)       If <datetime value expression> immediately contains the operator <plus sign> and the <interval
                  value expression> or <interval term> is not negative, or if <datetime value expression> imme-
                  diately contains the operator <minus sign> and the <interval term> is negative, then successive
                  <primary datetime field>s of the <interval value expression> or <interval term> are added to
                  the corresponding fields of the <datetime value expression> or <datetime term>.
         ii)      Otherwise, successive <primary datetime field>s of the <interval value expression> or <interval
                  term> are subtracted from the corresponding fields of the <datetime value expression> or
                  <datetime term>.
    b) If, after the preceding step, any <primary datetime field> of the result is outside the permissible range
       of values for the field or the result is invalid based on the natural rules for dates and times, then an
       exception condition is raised: data exception — datetime field overflow.
         NOTE 116 — For the permissible range of values for <primary datetime field>s, see Table 9, “Valid values for datetime
         fields”.


Conformance Rules
1) Without Feature F052, “Intervals and datetime arithmetic”, conforming SQL language shall not contain
   <datetime value expression> that immediately contains a <plus sign> or a <minus sign>.
2) Without Feature F411, “Time zone specification”, conforming SQL language shall not contain a <time
   zone>.




©ISO/IEC 2003 – All rights reserved                                                                  Scalar expressions 269
ISO/IEC 9075-2:2003 (E)
6.31 <datetime value function>



6.31 <datetime value function>

Function
Specify a function yielding a value of type datetime.


Format
<datetime value function> ::=
    <current date value function>
  | <current time value function>
  | <current timestamp value function>
  | <current local time value function>
  | <current local timestamp value function>

<current date value function> ::= CURRENT_DATE

<current time value function> ::=
    CURRENT_TIME [ <left paren> <time precision> <right paren> ]

<current local time value function> ::=
    LOCALTIME [ <left paren> <time precision> <right paren> ]

<current timestamp value function> ::=
    CURRENT_TIMESTAMP [ <left paren> <timestamp precision> <right paren> ]

<current local timestamp value function> ::=
    LOCALTIMESTAMP [ <left paren> <timestamp precision> <right paren> ]


Syntax Rules
1) The declared type of a <current date value function> is DATE. The declared type of a <current time value
   function> is TIME WITH TIME ZONE. The declared type of a <current timestamp value function> is
   TIMESTAMP WITH TIME ZONE.
    NOTE 117 — See the Syntax Rules of Subclause 6.1, “<data type>”, for rules governing <time precision> and <timestamp precision>.

2) If <time precision> TP is specified, then LOCALTIME(TP) is equivalent to:
       CAST (CURRENT_TIME(TP) AS TIME(TP) WITHOUT TIME ZONE)
    Otherwise, LOCALTIME is equivalent to:
       CAST (CURRENT_TIME AS TIME WITHOUT TIME ZONE)

3) If <timestamp precision> TP is specified, then LOCALTIMESTAMP(TP) is equivalent to:
       CAST (CURRENT_TIMESTAMP(TP) AS TIMESTAMP(TP) WITHOUT TIME ZONE)
    Otherwise, LOCALTIMESTAMP is equivalent to:
       CAST (CURRENT_TIMESTAMP AS TIMESTAMP WITHOUT TIME ZONE)



270 Foundation (SQL/Foundation)                                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                                             6.31 <datetime value function>



Access Rules
    None.


General Rules
1) The <datetime value function>s CURRENT_DATE, CURRENT_TIME, and CURRENT_TIMESTAMP
   respectively return the current date, current time, and current timestamp; the time and timestamp values
   are returned with time zone displacement equal to the current default time zone displacement of the SQL-
   session.
2) If specified, <time precision> and <timestamp precision> respectively determine the precision of the time
   or timestamp value returned.
3) Let S be an <SQL procedure statement> that is not generally contained in a <triggered action>. All <datetime
   value function>s that are contained in <value expression>s that are generally contained, without an inter-
   vening <routine invocation> whose subject routines do not include an SQL function, either in S without
   an intervening <SQL procedure statement> or in an <SQL procedure statement> contained in the <triggered
   action> of a trigger activated as a consequence of executing S, are effectively evaluated simultaneously.
   The time of evaluation of a <datetime value function> during the execution of S and its activated triggers
   is implementation-dependent.
    NOTE 118 — Activation of triggers is defined in Subclause 4.38.2, “Trigger execution”.


Conformance Rules
1) Without Feature F555, “Enhanced seconds precision”, conforming SQL language shall not contain a
   <current local time value function> that contains a <time precision> that is not 0 (zero).
2) Without Feature F555, “Enhanced seconds precision”, conforming SQL language shall not contain a
   <current local timestamp value function> that contains a <timestamp precision> that is neither 0 (zero) nor
   6.
3) Without Feature F411, “Time zone specification”, conforming SQL language shall not contain a <current
   time value function>.
4) Without Feature F411, “Time zone specification”, conforming SQL language shall not contain a <current
   timestamp value function>.




©ISO/IEC 2003 – All rights reserved                                                                 Scalar expressions 271
ISO/IEC 9075-2:2003 (E)
6.32 <interval value expression>



6.32 <interval value expression>

Function
Specify an interval value.


Format
<interval value expression> ::=
    <interval term>
  | <interval value expression 1> <plus sign> <interval term 1>
  | <interval value expression 1> <minus sign> <interval term 1>
  | <left paren> <datetime value expression> <minus sign> <datetime term> <right paren>
    <interval qualifier>

<interval term> ::=
    <interval factor>
  | <interval term 2> <asterisk> <factor>
  | <interval term 2> <solidus> <factor>
  | <term> <asterisk> <interval factor>

<interval factor> ::= [ <sign> ] <interval primary>

<interval primary> ::=
    <value expression primary> [ <interval qualifier> ]
  | <interval value function>

<interval value expression 1> ::= <interval value expression>

<interval term 1> ::= <interval term>

<interval term 2> ::= <interval term>


Syntax Rules
1) The declared type of an <interval value expression> is interval. The declared type of a <value expression
   primary> immediately contained in an <interval primary> shall be interval.
2) Case:
    a) If the <interval value expression> simply contains an <interval qualifier> IQ, then the declared type
       of the result is INTERVAL IQ.
    b) If the <interval value expression> is an <interval term>, then the result of the <interval value expression>
       contains the same interval fields as the <interval primary>. If the <interval primary> contains a seconds
       field, then the result's fractional seconds precision is the same as the <interval primary>'s fractional
       seconds precision. The result's <interval leading field precision> is implementation-defined, but shall
       not be less than the <interval leading field precision> of the <interval primary>.
    c) If <interval term 1> is specified, then the result contains every interval field that is contained in the
       result of either <interval value expression 1> or <interval term 1>, and, if both contain a seconds field,
       then the fractional seconds precision of the result is the greater of the two fractional seconds precisions.


272 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                               ISO/IEC 9075-2:2003 (E)
                                                                                        6.32 <interval value expression>



         The <interval leading field precision> is implementation-defined, but shall be sufficient to represent
         all interval values with the interval fields and <interval leading field precision> of <interval value
         expression 1> as well as all interval values with the interval fields and <interval leading field precision>
         of <interval term 1>.
         NOTE 119 — Interval fields are effectively defined by Table 4, “Fields in year-month INTERVAL values”, and Table 5,
         “Fields in day-time INTERVAL values”.

3) Case:
    a) If <interval term 1> is a year-month interval, then <interval value expression 1> shall be a year-month
       interval.
    b) If <interval term 1> is a day-time interval, then <interval value expression 1> shall be a day-time
       interval.
4) If <datetime value expression> is specified, then <datetime value expression> and <datetime term> shall
   be comparable.
5) An <interval primary> shall specify <interval qualifier> only if the <interval primary> specifies a <dynamic
   parameter specification>.


Access Rules
    None.


General Rules
1) If an <interval term> specifies “<term> * <interval factor>”, then let T and F be respectively the value of
   the <term> and the value of the <interval factor>. The result of the <interval term> is the result of F * T.
2) If the value of any <interval primary>, <datetime value expression>, <datetime term>, or <factor> that is
   simply contained in an <interval value expression> is the null value, then the result of the <interval value
   expression> is the null value.
3) If IP is an <interval primary>, then
    Case:
    a) If IP immediately contains a <value expression primary> VEP and an explicit <interval qualifier> IQ,
       then the value of IP is computed by:
             CAST ( VEP AS INTERVAL IQ )

    b) If IP immediately contains a <value expression primary> VEP, then the value of IP is the value of VEP.
    c) If IP is an <interval value function> IVF, then the value of IP is the value of IVF.
4) If the <sign> of an <interval factor> is <minus sign>, then the value of the <interval factor> is the negative
   of the value of the <interval primary>; otherwise, the value of an <interval factor> is the value of the
   <interval primary>.
5) If <interval term 2> is specified, then:



©ISO/IEC 2003 – All rights reserved                                                                Scalar expressions 273
ISO/IEC 9075-2:2003 (E)
6.32 <interval value expression>



    a) Let X be the value of <interval term 2> and let Y be the value of <factor>.
    b) Let P and Q be respectively the most significant and least significant <primary datetime field>s of
       <interval term 2>.
    c) Let E be an exact numeric result of the operation
           CAST ( CAST ( X AS INTERVAL Q ) AS E1 )
        where E1 is an exact numeric data type of sufficient scale and precision so as to not lose significant
        digits.
    d) Let OP be the operator * or / specified in the <interval value expression>.
    e) Let I, the result of the <interval value expression> expressed in terms of the <primary datetime field>
       Q, be the result of
           CAST ( (E OP Y) AS INTERVAL Q )

    f) The result of the <interval value expression> is
           CAST ( I AS INTERVAL W )
        where W is an <interval qualifier> identifying the <primary datetime field>s P TO Q, but with <interval
        leading field precision> such that significant digits are not lost.
6) If <interval term 1> is specified, then let P and Q be respectively the most significant and least significant
   <primary datetime field>s in <interval term 1> and <interval value expression 1>, let X be the value of
   <interval value expression 1>, and let Y be the value of <interval term 1>.
    a) Let A be an exact numeric result of the operation
           CAST ( CAST ( X AS INTERVAL Q ) AS E1 )
        where E1 is an exact numeric data type of sufficient scale and precision so as to not lose significant
        digits.
    b) Let B be an exact numeric result of the operation
           CAST ( CAST ( Y AS INTERVAL Q ) AS E2 )
        where E2 is an exact numeric data type of sufficient scale and precision so as to not lose significant
        digits.
    c) Let OP be the operator + or – specified in the <interval value expression>.
    d) Let I, the result of the <interval value expression> expressed in terms of the <primary datetime field>
       Q, be the result of:
           CAST ( (A OP B) AS INTERVAL Q )

    e) The result of the <interval value expression> is
           CAST ( I AS INTERVAL W )




274 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                               6.32 <interval value expression>



         where W is an <interval qualifier> identifying the <primary datetime field>s P TO Q, but with <interval
         leading field precision> such that significant digits are not lost.
7) If <datetime value expression> is specified, then let Y be the least significant <primary datetime field>
   specified by <interval qualifier>. Let DTE be the <datetime value expression>, let DT be the <datetime
   term>, and let MSP be the implementation-defined maximum seconds precision. Evaluation of <interval
   value expression> proceeds as follows:
    a) Case:
         i)       If the declared type of <datetime value expression> is TIME WITH TIME ZONE, then let A be
                  the value of:
                     CAST ( DTE AT LOCAL AS TIME(MSP) WITHOUT TIME ZONE )

         ii)      If the declared type of <datetime value expression> is TIMESTAMP WITH TIME ZONE, then
                  let A be the value of:
                     CAST ( DTE AT LOCAL AS TIMESTAMP(MSP) WITHOUT TIME ZONE )

         iii)     Otherwise, let A be the value of DTE.
    b) Case:
         i)       If the declared type of <datetime term> is TIME WITH TIME ZONE, then let B be the value
                  of:
                     CAST ( DT AT LOCAL AS TIME(MSP) WITHOUT TIME ZONE )

         ii)      If the declared type of <datetime term> is TIMESTAMP WITH TIME ZONE, then let B be the
                  value of:
                     CAST ( DT AT LOCAL AS TIMESTAMP(MSP) WITHOUT TIME ZONE )

         iii)     Otherwise, let B be the value of DTE.
    c) A and B are converted to integer scalars A2 and B2 respectively in units Y as displacements from some
       implementation-dependent start datetime.
    d) The result is determined by effectively computing A2–B2 and then converting the difference to an
       interval using an <interval qualifier> whose <end field> is Y and whose <start field> is sufficiently
       significant to avoid loss of significant digits. The difference of two values of type TIME (with or
       without time zone) is constrained to be between –24:00:00 and +24:00:00 (excluding each end point);
       it is implementation-defined which of two non-zero values in this range is the result, although the
       computation shall be deterministic. That interval is then converted to an interval using the specified
       <interval qualifier>, rounding or truncating if necessary. The choice of whether to round or truncate
       is implementation-defined. If the required number of significant digits exceeds the implementation-
       defined maximum number of significant digits, then an exception condition is raised: data exception
       — interval field overflow.




©ISO/IEC 2003 – All rights reserved                                                     Scalar expressions 275
ISO/IEC 9075-2:2003 (E)
6.32 <interval value expression>



Conformance Rules
1) Without Feature F052, “Intervals and datetime arithmetic”, conforming SQL language shall not contain an
   <interval value expression>.




276 Foundation (SQL/Foundation)                                              ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                                  6.33 <interval value function>



6.33 <interval value function>

Function
Specify a function yielding a value of type interval.


Format
<interval value function> ::= <interval absolute value function>

<interval absolute value function> ::=
    ABS <left paren> <interval value expression> <right paren>


Syntax Rules
1) If <interval absolute value function> is specified, then the declared type of the result is the declared type
   of the <interval value expression>.


Access Rules
    None.


General Rules
1) If <interval absolute value function> is specified, then let N be the value of the <interval value expression>.
    Case:
    a) If N is the null value, then the result is the null value.

    b) If N ≥ 0 (zero), then the result is N.
    c) Otherwise, the result is –1 * N.


Conformance Rules
1) Without Feature F052, “Intervals and datetime arithmetic”, conforming SQL shall not contain an <interval
   value function>.




©ISO/IEC 2003 – All rights reserved                                                       Scalar expressions 277
ISO/IEC 9075-2:2003 (E)
6.34 <boolean value expression>



6.34 <boolean value expression>

Function
Specify a boolean value.


Format
<boolean value expression> ::=
    <boolean term>
  | <boolean value expression> OR <boolean term>

<boolean term> ::=
    <boolean factor>
  | <boolean term> AND <boolean factor>

<boolean factor> ::= [ NOT ] <boolean test>

<boolean test> ::= <boolean primary> [ IS [ NOT ] <truth value> ]

<truth value> ::=
    TRUE
  | FALSE
  | UNKNOWN

<boolean primary> ::=
    <predicate>
  | <boolean predicand>

<boolean predicand> ::=
    <parenthesized boolean value expression>
  | <nonparenthesized value expression primary>

<parenthesized boolean value expression> ::=
    <left paren> <boolean value expression> <right paren>


Syntax Rules
1) The declared type of a <nonparenthesized value expression primary> shall be boolean.
2) If NOT is specified in a <boolean test>, then let BP be the contained <boolean primary> and let TV be the
   contained <truth value>. The <boolean test> is equivalent to:

    ( NOT ( BP IS TV ) )

3) Let X denote either a column C or the <key word> VALUE. Given a <boolean value expression> BVE and
   X, the notion “BVE is a known-not-null condition for X” is defined recursively as follows:
    a) If BVE is a <predicate>, then
        Case:




278 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                              ISO/IEC 9075-2:2003 (E)
                                                                                       6.34 <boolean value expression>



         i)       If BVE is a <predicate> of the form “RVE IS NOT NULL”, where RVE is a <row value predicand>
                  that is a <row value constructor predicand> that simply contains a <common value expression>,
                  <boolean predicand>, or <row value constructor element> that is a <column reference> that
                  references C, then BVE is a known-not-null condition for C.
         ii)      If BVE is the <predicate> “VALUE IS NOT NULL”, then BVE is a known-not-null condition
                  for VALUE.
         iii)     Otherwise, BVE is not a known-not-null condition for X.
    b) If BVE is a <parenthesized boolean value expression> and the simply contained <boolean value
       expression> is a known-not-null condition for X, then BVE is a known-not-null condition for X.
    c) If BVE is a <nonparenthesized value expression primary>, then BVE is not a known-not-null condition
       for X.
    d) If BVE is a <boolean test>, then let BP be the <boolean primary> immediately contained in BVE. If
       BP is a known-not-null condition for X, and <truth value> is not specified, then BVE is a known-not-
       null condition for X. Otherwise, BVE is not a known-not-null condition for X.
    e) If BVE is of the form “NOT BT”, where BT is a <boolean test>, then
         Case:
         i)       If BT is “CR IS NULL”, where CR is a column reference that references column C, then BVE
                  is a known-not-null condition for C.
         ii)      If BT is “VALUE IS NULL”, then BVE is a known-not-null condition for VALUE.
         iii)     Otherwise, BVE is not a known-not-null condition for X.
         NOTE 120 — For simplicity, this rule does not attempt to analyze conditions such as “NOT NOT A IS NULL”, or “NOT (A
         IS NULL OR NOT (B = 2))”

    f) If BVE is of the form “BVE1 AND BVE2”, then
         Case:
         i)       If either BVE1 or BVE2 is a known-not-null condition for X, then BVE is aknown-not-null con-
                  dition for X.
         ii)      Otherwise, BVE is not a known-not-null condition for X.
    g) If BVE is of the form “BVE1 OR BVE2”, then BVE is not a known-not-null condition for X.
         NOTE 121 — For simplicity, this rule does not detect cases such as “A IS NOT NULL OR A IS NOT NULL”, which might
         be classified as a known-not-null condition.

4) The notion of “retrospectively deterministic” is defined recursively as follows:
    a) A <parenthesized boolean value expression> is retrospectively deterministic if the simply contained
       <boolean value expression> is retrospectively deterministic.
    b) A <nonparenthesized value expression primary> is retrospectively deterministic if it is not possibly
       non-deterministic.
    c) A <predicate> P is retrospectively deterministic if one of the following is true:



©ISO/IEC 2003 – All rights reserved                                                              Scalar expressions 279
ISO/IEC 9075-2:2003 (E)
6.34 <boolean value expression>



       i)     P is not possibly non-deterministic.
       ii)    P is a <comparison predicate> of the form “X < Y”, “X <= Y”, “Y > X”, “Y >= X”, “X < Y + Z”,
              “X <= Y + Z”, “Y + Z > X”, “Y + Z >= X”, “X < Y – Z”, “X <= Y – Z”, “Y – Z > X”, or “Y – Z >=
              X”, where Y is CURRENT_DATE, CURRENT_TIMESTAMP or LOCALTIMESTAMP, X and
              Z are not possibly non-deterministic <value expression>s, and the declared types of the left and
              right comparands are either both datetime with time zone or both datetime without time zone.
       iii)   P is a <quantified comparison predicate> of the form “Y > <quantifier> <table subquery>”, “Y
              + Z > <quantifier> <table subquery>”, “Y – Z > <quantifier> <table subquery>”, “Y >= <quan-
              tifier> <table subquery>”, “Y + Z >= <quantifier> <table subquery>”, or “Y - Z >= <quantifier>
              <table subquery>”, where Y is CURRENT_DATE, CURRENT_TIMESTAMP or LOCALTIMES-
              TAMP, Z is a <value expression> that is not possibly non-deterministic, the <query expression>
              simply contained in the <table subquery> is not possibly non-deterministic, and the declared
              types of the left and right comparands are either both datetime with time zone or both datetime
              without time zone.
       iv)    P is a <between predicate> that is transformed into a retrospectively deterministic <boolean
              value expression>.
   d) A <boolean primary> is retrospectively deterministic if the simply contained <predicate>, <parenthesized
      boolean value expression> or <nonparenthesized value expression primary> is retrospectively deter-
      ministic.
   e) Let BF be a <boolean factor>. Let BP be the <boolean primary> simply contained in BF.
       i)     BF is called negative if BF is of any of the following forms:
                NOT BP
                BP IS FALSE
                BP IS NOT TRUE
                NOT BP IS NOT FALSE
                NOT BP IS TRUE



       ii)    BF is retrospectively deterministic if one of the following is true:
              1) BF is negative and BF does not generally contain a possibly nondeterministic <value
                 expression>.
              2) BF is not negative and BP is retrospectively deterministic.
   f) A <boolean value expression> is retrospectively deterministic if every simply contained <boolean
      factor> is retrospectively deterministic.


Access Rules
   None.




280 Foundation (SQL/Foundation)                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                              6.34 <boolean value expression>



General Rules
1) The result is derived by the application of the specified boolean operators (“AND”, “OR”, “NOT”, and
   “IS”) to the results derived from each <boolean primary>. If boolean operators are not specified, then the
   result of the <boolean value expression> is the result of the specified <boolean primary>.
2) NOT (True) is False, NOT (False) is True, and NOT (Unknown) is Unknown.
3) Table 11, “Truth table for the AND boolean operator”, Table 12, “Truth table for the OR boolean operator”,
   and Table 13, “Truth table for the IS boolean operator” specify the semantics of AND, OR, and IS,
   respectively.

                                      Table 11 — Truth table for the AND boolean operator


      AND             True            False      Unknown

      True            True            False      Unknown

      False           False           False      False

      Unknown         Unknown         False      Unknown


                                       Table 12 — Truth table for the OR boolean operator


      OR              True            False      Unknown

      True            True            True       True

      False           True            False      Unknown

      Unknown         True            Unknown    Unknown


                                       Table 13 — Truth table for the IS boolean operator


      IS              TRUE            FALSE      UNKNOWN

      True            True            False      False

      False           False           True       False

      Unknown         False           False      True




©ISO/IEC 2003 – All rights reserved                                                    Scalar expressions 281
ISO/IEC 9075-2:2003 (E)
6.34 <boolean value expression>



Conformance Rules
1) Without Feature T031, “BOOLEAN data type”, conforming SQL language shall not contain a <boolean
   primary> that simply contains a <nonparenthesized value expression primary>.
2) Without Feature F571, “Truth value tests”, conforming SQL language shall not contain a <boolean test>
   that simply contains a <truth value>.




282 Foundation (SQL/Foundation)                                              ©ISO/IEC 2003 – All rights reserved
                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                              6.35 <array value expression>



6.35 <array value expression>

Function
Specify an array value.


Format
<array value expression> ::=
    <array concatenation>
  | <array primary>

<array concatenation> ::= <array value expression 1> <concatenation operator> <array primary>

<array value expression 1> ::= <array value expression>

<array primary> ::= <value expression primary>


Syntax Rules
1) The declared type of the <array value expression> is the declared type of the immediately contained <array
   concatenation> or <array primary>.
2) The declared type of <array primary> is the declared type of the immediately contained <value expression
   primary>, which shall be an array type.
3) If <array concatenation> is specified, then:
    a) Let DT be the data type determined by applying Subclause 9.3, “Data types of results of aggregations”,
       to the declared types of <array value expression 1> and <array primary>.
    b) Let IMDC be the implementation-defined maximum cardinality of an array type.
    c) The declared type of the result of <array concatenation> is an array type whose element type is the
       element type of DT and whose maximum cardinality is the lesser of IMDC and the sum of the maximum
       cardinality of <array value expression 1> and the maximum cardinality of <array primary>.


Access Rules
    None.


General Rules
1) The value of the result of <array value expression> is the value of the immediately contained <array con-
   catenation> or <array primary>.
2) If <array concatenation> is specified, then let AV1 be the value of <array value expression 1> and let AV2
   be the value of <array primary>.



©ISO/IEC 2003 – All rights reserved                                                   Scalar expressions 283
ISO/IEC 9075-2:2003 (E)
6.35 <array value expression>



   Case:
   a) If either AV1 or AV2 is the null value, then the result of the <array concatenation> is the null value.
   b) If the sum of the cardinality of AV1 and the cardinality of AV2 is greater than IMDC, then an exception
      condition is raised: data exception — array data, right truncation.
   c) Otherwise, the result is the array comprising every element of AV1 followed by every element of AV2.


Conformance Rules
1) Without Feature S091, “Basic array support”, conforming SQL language shall not contain an <array value
   expression>.




284 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                               6.36 <array value constructor>



6.36 <array value constructor>

Function
Specify construction of an array.


Format
<array value constructor> ::=
    <array value constructor by enumeration>
  | <array value constructor by query>

<array value constructor by enumeration> ::=
    ARRAY <left bracket or trigraph> <array element list> <right bracket or trigraph>

<array element list> ::=
    <array element> [ { <comma> <array element> }... ]

<array element> ::= <value expression>

<array value constructor by query> ::=
    ARRAY <left paren> <query expression> [ <order by clause> ] <right paren>


Syntax Rules
1) The declared type of <array value constructor> is the declared type of the immediately contained <array
   value constructor by enumeration> or <array value constructor by query>.
2) The declared type of the <array value constructor by enumeration> is an array type with element type DT,
   where DT is the declared type determined by applying Subclause 9.3, “Data types of results of aggregations”,
   to the declared types of the <array element>s immediately contained in the <array element list> of this
   <array value constructor by enumeration>. The maximum cardinality is the number of <array element>s
   in the <array element list>, which shall not be greater than the implementation-defined maximum cardinality
   for array types whose element type is DT.
3) If <array value constructor by query> is specified, then
    a) The <query expression> shall be of degree 1 (one). Let ET be the declared type of the column in the
       result of <query expression>.
    b) The declared type of the <array value constructor by query> is array with element type ET and maximum
       cardinality equal to the implementation-defined maximum cardinality IMDC for such array types.


Access Rules
    None.




©ISO/IEC 2003 – All rights reserved                                                    Scalar expressions 285
ISO/IEC 9075-2:2003 (E)
6.36 <array value constructor>



General Rules
1) The value of <array value constructor> is the value of the immediately contained <array value constructor
   by enumeration> or <array value constructor by query>.
2) The result of <array value constructor by enumeration> is an array whose i-th element is the value of the
   i-th <array element> immediately contained in the <array element list>, cast as the data type of DT.
3) The result of <array value constructor by query> is determined as follows:
    a) The <query expression> is evaluated, producing a table T. Let N be the number of rows in T.
    b) If N is greater than IMDC, then an exception condition is raised: data exception — array data, right
       truncation.
    c) T is ordered according to the <sort specification list>. If there is no <sort specification list>, then the
       ordering is implementation-dependent.
    d) The result of <array value constructor by query> is an array of N elements such that for all i, 1 (one)
       ≤ i ≤ N, the value of the i-th element is the value of the only column in the i-th row of T, as ordered by
       GR 3)c)the .


Conformance Rules
1) Without Feature S091, “Basic array support”, conforming SQL language shall not contain an <array value
   constructor by enumeration>.
2) Without Feature S095, “Array constructors by query”, conforming SQL language shall not contain an
   <array value constructor by query>.




286 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                             6.37 <multiset value expression>



6.37 <multiset value expression>

Function
Specify a multiset value.


Format
<multiset value expression> ::=
    <multiset term>
  | <multiset value expression> MULTISET UNION [ ALL | DISTINCT ] <multiset term>
  | <multiset value expression> MULTISET EXCEPT [ ALL | DISTINCT ] <multiset term>

<multiset term> ::=
    <multiset primary>
  | <multiset term> MULTISET INTERSECT [ ALL | DISTINCT ] <multiset primary>

<multiset primary> ::=
    <multiset value function>
  | <value expression primary>


Syntax Rules
1) The declared type of a <multiset primary> is the declared type of the immediately contained <multiset
   value function> or <value expression primary>, which shall be a multiset type.
2) If MI is a <multiset term> that immediately contains MULTISET INTERSECT, then let OP1 be the first
   operand (the <multiset term>) and let OP2 be the second operand (the <multiset primary>).
    a) OP1 and OP2 are multiset operands of a multiset element grouping operation. The Syntax Rules of
       Subclause 9.11, “Multiset element grouping operations”, apply.
    b) Let ET1 be the element type of OP1 and let ET2 be the element type of OP2. Let ET be the data type
       determined by Subclause 9.3, “Data types of results of aggregations”, using the types ET1 and ET2.
       The result type of the MULTISET INTERSECT operation is multiset with element type ET.
    c) If DISTINCT is specified, then let SQ be DISTINCT. Otherwise, let SQ be ALL.
    d) MI is equivalent to

         ( CASE WHEN OP1 IS NULL OR OP2 IS NULL THEN NULL
                 ELSE MULTISET ( SELECT T1.V
                                 FROM UNNEST (OP1) AS T1(V)
                               INTERSECT SQ
                                 SELECT T2.V
                                 FROM UNNEST (OP2) AS T2(V)
                               )
           END )

3) If MU is a <multiset value expression> that immediately contains MULTISET UNION, then let OP1 be
   the first operand (the <multiset value expression>) and let OP2 be the second operand (the <multiset term>).



©ISO/IEC 2003 – All rights reserved                                                    Scalar expressions 287
ISO/IEC 9075-2:2003 (E)
6.37 <multiset value expression>



    a) If DISTINCT is specified, then OP1 and OP2 are multiset operands of a multiset element grouping
       operation. The Syntax Rules of Subclause 9.11, “Multiset element grouping operations”, apply.
    b) Let ET1 be the element type of OP1 and let ET2 be the element type of OP2. Let ET be the data type
       determined by Subclause 9.3, “Data types of results of aggregations”, using the types ET1 and ET2.
       The result type of the MULTISET UNION operation is multiset with element type ET.
    c) If DISTINCT is specified, then let SQ be DISTINCT. Otherwise, let SQ be ALL.
    d) MU is equivalent to

        ( CASE WHEN OP1 IS NULL OR OP2 IS NULL THEN NULL
                ELSE MULTISET ( SELECT T1.V
                                FROM UNNEST (OP1) AS T1(V)
                              UNION SQ
                                SELECT T2.V
                                FROM UNNEST (OP2) AS T2(V)
                              )
          END )

4) If ME is a <multiset value expression> that immediately contains MULTISET EXCEPT, then let OP1 be
   the first operand (the <multiset term>) and let OP2 be the second operand (the <multiset primary>).
    a) OP1 and OP2 are multiset operands of a multiset element grouping operation. The Syntax Rules of
       Subclause 9.11, “Multiset element grouping operations”, apply.
    b) Let ET1 be the element type of OP1 and let ET2 be the element type of OP2. Let ET be the data type
       determined by Subclause 9.3, “Data types of results of aggregations”, using the types ET1 and ET2.
       The result type of the MULTISET EXCEPT operation is multiset with element type ET.
    c) If DISTINCT is specified, then let SQ be DISTINCT. Otherwise, let SQ be ALL.
    d) ME is equivalent to

        ( CASE WHEN OP1 IS NULL OR OP2 IS NULL THEN NULL
                ELSE MULTISET ( SELECT T1.V
                                FROM UNNEST (OP1) AS T1(V)
                              EXCEPT SQ
                                SELECT T2.V
                                FROM UNNEST (OP2) AS T2(V)
                              )
          END )


Access Rules
    None.


General Rules
1) The value of a <multiset primary> is the value of the immediately contained <multiset value function> or
   <value expression primary>.
2) The value of a <multiset term> that is a <multiset primary> is the value of the <multiset primary>.


288 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                            6.37 <multiset value expression>



3) The value of a <multiset value expression> that is a <multiset term> is the value of <multiset term>.


Conformance Rules
1) Without Feature S275, “Advanced multiset support”, conforming SQL language shall not contain MULTISET
   UNION, MULTISET INTERSECTION, or MULTISET EXCEPT.
    NOTE 122 — If MULTISET UNION DISTINCT, MULTISET INTERSECTION, or MULTISET EXCEPT is specified, then the
    Conformance Rules of Subclause 9.11, “Multiset element grouping operations”, also apply.




©ISO/IEC 2003 – All rights reserved                                                   Scalar expressions 289
ISO/IEC 9075-2:2003 (E)
6.38 <multiset value function>



6.38 <multiset value function>

Function
Specify a function yielding a value of a multiset type.


Format
<multiset value function> ::= <multiset set function>

<multiset set function> ::=
    SET <left paren> <multiset value expression> <right paren>


Syntax Rules
1) Let MVE be the <multiset value expression> simply contained in <multiset set function>. MVE is a multiset
   operand of a multiset element grouping operation. The Syntax Rules of Subclause 9.11, “Multiset element
   grouping operations”, apply.
2) The <multiset set function> is equivalent to

    ( CASE WHEN MVE IS NULL THEN NULL
            ELSE MULTISET ( SELECT DISTINCT M.E
                            FROM UNNEST (MVE) AS M(E) )
      END )


Access Rules
    None.


General Rules
    None.


Conformance Rules
1) Without Feature S271, “Basic multiset support”, conforming SQL language shall not contain a <multiset
   value function>.
    NOTE 123 — The Conformance Rules of Subclause 9.11, “Multiset element grouping operations”, also apply.




290 Foundation (SQL/Foundation)                                                           ©ISO/IEC 2003 – All rights reserved
                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                            6.39 <multiset value constructor>



6.39 <multiset value constructor>

Function
Specify construction of a multiset.


Format
<multiset value constructor> ::=
    <multiset value constructor by enumeration>
  | <multiset value constructor by query>
  | <table value constructor by query>

<multiset value constructor by enumeration> ::=
    MULTISET <left bracket or trigraph> <multiset element list> <right bracket or trigraph>

<multiset element list> ::=
    <multiset element> [ { <comma> <multiset element> }... ]

<multiset element> ::= <value expression>

<multiset value constructor by query> ::=
    MULTISET <left paren> <query expression> <right paren>

<table value constructor by query> ::=
    TABLE <left paren> <query expression> <right paren>


Syntax Rules
1) If <multiset value constructor> immediately contains a <table value constructor by query> TVCBQ, then:
    a) Let QE be the <query expression> simply contained in TVCBQ.
    b) Let n be the number of columns in the result of QE.
    c) Let C1, ..., Cn be implementation-dependent identifiers that are all distinct from one another.

    d) TVCBQ is equivalent to

         MULTISET ( SELECT ROW ( C1, ..., Cn )
         FROM ( QE ) AS T ( C1, ..., Cn ) )

2) The declared type of <multiset value constructor> is the declared type of the immediately contained
   <multiset value constructor by enumeration> or <multiset value constructor by query>.
3) The declared type of the <multiset value constructor by enumeration> is a multiset type with element type
   DT, where DT is the declared type determined by applying Subclause 9.3, “Data types of results of aggre-
   gations”, to the declared types of the <multiset element>s immediately contained in the <multiset element
   list> of this <multiset value constructor by enumeration>.
4) If <multiset value constructor by query> is specified, then



©ISO/IEC 2003 – All rights reserved                                                    Scalar expressions 291
ISO/IEC 9075-2:2003 (E)
6.39 <multiset value constructor>



    a) The <query expression> shall be of degree 1 (one). Let ET be the declared type of the column in the
       result of <query expression>.
    b) The declared type of the <multiset value constructor by query> is multiset with element type ET.


Access Rules
    None.


General Rules
1) The value of <multiset value constructor> is the value of the immediately contained <multiset value con-
   structor by enumeration> or <multiset value constructor by query>.
2) The result of <multiset value constructor by enumeration> is a multiset whose elements are the values of
   the <multiset element>s immediately contained in the <multiset element list>, cast as the data type of DT.
3) If <multiset value constructor by query> is specified, then:
    a) The <query expression> is evaluated, producing a table T. Let N be the number of rows in T.
    b) The result of <multiset value constructor by query> is a multiset of N elements, with one element for
       each row of T, where the value of each element is the value of the only column in the corresponding
       row of T.


Conformance Rules
1) Without Feature S271, “Basic multiset support”, conforming SQL language shall not contain a <multiset
   value constructor>.
2) Without Feature T326, “Table functions”, a <multiset value constructor> shall not contain a <table value
   constructor by query>.




292 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                      ISO/IEC 9075-2:2003 (E)
                                                                  7.1 <row value constructor>




7 Query expressions


7.1      <row value constructor>

Function
Specify a value or list of values to be constructed into a row.


Format
<row value constructor> ::=
    <common value expression>
  | <boolean value expression>
  | <explicit row value constructor>

<explicit row value constructor> ::=
    <left paren> <row value constructor element> <comma>
    <row value constructor element list> <right paren>
  | ROW <left paren> <row value constructor element list> <right paren>
  | <row subquery>

<row value constructor element list> ::=
    <row value constructor element> [ { <comma> <row value constructor element> }... ]

<row value constructor element> ::= <value expression>

<contextually typed row value constructor> ::=
    <common value expression>
  | <boolean value expression>
  | <contextually typed value specification>
  | <left paren> <contextually typed row value specification> <right paren>
  | <left paren> <contextually typed row value constructor element> <comma>
    <contextually typed row value constructor element list> <right paren>
  | ROW <left paren> <contextually typed row value constructor element list> <right paren>

<contextually typed row value constructor element list> ::=
    <contextually typed row value constructor element>
    [ { <comma> <contextually typed row value constructor element> }... ]

<contextually typed row value constructor element> ::=
    <value expression>
  | <contextually typed value specification>

<row value constructor predicand> ::=
    <common value expression>
  | <boolean predicand>
  | <explicit row value constructor>




©ISO/IEC 2003 – All rights reserved                                    Query expressions 293
ISO/IEC 9075-2:2003 (E)
7.1 <row value constructor>



Syntax Rules
1) If a <row value constructor> is a <common value expression> or a <boolean value expression> X, then the
   <row value constructor> is equivalent to

    ROW ( X )

2) If a <row value constructor predicand> is a <common value expression> or a <boolean predicand> X, then
   the <row value constructor predicand> is equivalent to

    ROW ( X )

3) Let ERVC be an <explicit row value constructor>.
    Case:
    a) If ERVC simply contains a <row subquery>, then the declared type of ERVC is the declared type of
       that <row subquery>.
    b) Otherwise, the declared type of ERVC is a row type described by a sequence of (<field name>, <data
       type>) pairs, corresponding in order to each <row value constructor element> X simply contained in
       ERVC. The data type is the declared type of X and the <field name> is implementation-dependent.
4) If a <row value constructor> or <row value constructor predicand> RVC is an <explicit row value construc-
   tor> ERVC, then the declared type of RVC is the declared type of ERVC.
5) Let CTRVC be the <contextually typed row value constructor>.
    a) If CTRVC is a <common value expression>, <boolean value expression>, or <contextually typed value
       specification> X, then CTRVC is equivalent to:

        ROW ( X )

    b) After the syntactic transformation specified in SR 5)a) has been performed, if necessary, the declared
       type of CTRVC is a row type described by a sequence of (<field name>, <data type>) pairs, corresponding
       in order to each <contextually typed row value constructor element> X simply contained in CTRVC.
       The <data type> is the declared type of X and the <field name> is implementation-dependent.
6) The degree of a <row value constructor>, <contextually typed row value constructor>, or <row value con-
   structor predicand> is the degree of its declared type.


Access Rules
    None.


General Rules
1) The value of a <null specification> is the null value.
2) The value of a <default specification> is determined according to the General Rules of Subclause 11.5,
   “<default clause>”.



294 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                                   7.1 <row value constructor>



3) The value of an <empty specification> is an empty collection.
4) Case:
    a) If a <row value constructor>, <row value constructor predicand>, or <contextually typed row value
       constructor> immediately contains a <common value expression>, <boolean value expression>, or
       <contextually typed row value constructor element> X, then the result of the <row value constructor>,
       <row value constructor predicand>, or <contextually typed row value constructor> is a row containing
       a single column whose value is the value of X.
    b) If an <explicit row value constructor> is specified, then the result of the <row value constructor> or
       <row value constructor predicand> is a row of columns, the value of whose i-th column is the value
       of the i-th <row value constructor element> simply contained in the <explicit row value constructor>.
    c) If a <contextually typed row value constructor element list> is specified, then the result of the <contex-
       tually typed row value constructor> is a row of columns, the value of whose i-th column is the value
       of the i-th <contextually typed row value constructor element> in the <contextually typed row value
       constructor element list>.


Conformance Rules
1) Without Feature T051, “Row types”, conforming SQL language shall not contain an <explicit row value
   constructor> that immediately contains ROW.
2) Without Feature T051, “Row types”, conforming SQL language shall not contain a <contextually typed
   row value constructor> that immediately contains ROW.
3) Without Feature F641, “Row and table constructors”, conforming SQL language shall not contain an
   <explicit row value constructor> that is not simply contained in a <table value constructor> and that contains
   more than one <row value constructor element>.
4) Without Feature F641, “Row and table constructors”, conforming SQL language shall not contain an
   <explicit row value constructor> that is a <row subquery>.
5) Without Feature T031, “BOOLEAN data type”, conforming SQL language shall not contain a <row value
   constructor predicand> that immediately contains a <boolean predicand>.
6) Without Feature F641, “Row and table constructors”, conforming SQL language shall not contain a <con-
   textually typed row value constructor> that is not simply contained in a <contextually typed table value
   constructor> and that contains more than one <row value constructor element>.
7) Without Feature F641, “Row and table constructors”, conforming SQL language shall not contain a <con-
   textually typed row value constructor> that is a <row subquery>.




©ISO/IEC 2003 – All rights reserved                                                      Query expressions 295
ISO/IEC 9075-2:2003 (E)
7.2 <row value expression>



7.2      <row value expression>

Function
Specify a row value.


Format
<row value expression> ::=
    <row value special case>
  | <explicit row value constructor>

<table row value expression> ::=
    <row value special case>
  | <row value constructor>

<contextually typed row value expression> ::=
    <row value special case>
  | <contextually typed row value constructor>

<row value predicand> ::=
    <row value special case>
  | <row value constructor predicand>

<row value special case> ::= <nonparenthesized value expression primary>


Syntax Rules
1) The declared type of a <row value special case> shall be a row type.
2) The declared type of a <row value expression> is the declared type of the immediately contained <row
   value special case> or <explicit row value constructor>.
3) The declared type of a <table row value expression> is the declared type of the immediately contained
   <row value special case> or <row value constructor>.
4) The declared type of a <contextually typed row value expression> is the declared type of the immediately
   contained <row value special case> or <contextually typed row value constructor>. The declared type of
   a <row value predicand> is the declared type of the immediately contained <row value special case> or
   <row value constructor predicand>.


Access Rules
      None.


General Rules
1) A <row value special case> specifies the row value denoted by the <nonparenthesized value expression
   primary>.


296 Foundation (SQL/Foundation)                                               ©ISO/IEC 2003 – All rights reserved
                                                                                  ISO/IEC 9075-2:2003 (E)
                                                                               7.2 <row value expression>



2) A <row value expression> specifies the row value denoted by the <row value special case> or <explicit
   row value constructor>.
3) A <table row value expression> specifies the row value denoted by the <row value special case> or <row
   value constructor>.
4) A <contextually typed row value expression> specifies the row value denoted by the <row value special
   case> or <contextually typed row value constructor>.
5) A <row value predicand> specifies the row value denoted by the <row value special case> or <row value
   constructor predicand>.


Conformance Rules
1) Without Feature T051, “Row types”, conforming SQL language shall not contain a <row value special
   case>.




©ISO/IEC 2003 – All rights reserved                                                Query expressions 297
ISO/IEC 9075-2:2003 (E)
7.3 <table value constructor>



7.3      <table value constructor>

Function
Specify a set of <row value expression>s to be constructed into a table.


Format
<table value constructor> ::= VALUES <row value expression list>

<row value expression list> ::=
    <table row value expression> [ { <comma> <table row value expression> }... ]

<contextually typed table value constructor> ::=
    VALUES <contextually typed row value expression list>

<contextually typed row value expression list> ::=
    <contextually typed row value expression>
    [ { <comma> <contextually typed row value expression> }... ]


Syntax Rules
1) All <table row value expression>s immediately contained in a <row value expression list> shall be of the
   same degree.
2) All <contextually typed row value expression>s immediately contained in a <contextually typed row value
   expression list> shall be of the same degree.
3) A <table value constructor> or a <contextually typed table value constructor> is possibly non-deterministic
   if it generally contains a possibly non-deterministic <value expression>.
4) Let TVC be some <table value constructor> consisting of n <table row value expression>s or some <con-
   textually typed table value constructor> consisting of n <contextually typed row value expression>s. Let
   RVEi, 1 (one) ≤ i ≤ n, denote the i-th <table row value expression> or the i-th <contextually typed row
   value expression>. The row type of TVC is determined by applying Subclause 9.3, “Data types of results
   of aggregations”, to the row types RVEi, 1 (one) ≤ i ≤ n. The column names are implementation-dependent.


Access Rules
      None.


General Rules
1) If the result of any <table row value expression> or <contextually typed row value expression> is the null
   value, then an exception condition is raised: data exception — null row not permitted in table.




298 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                               7.3 <table value constructor>



2) The result T of a <table value constructor> or <contextually typed table value constructor> TVC is a table
   whose cardinality is the number of <table row value expression>s or the number of <contextually typed
   row value expression>s in TVC. If R is the result of n such expressions, then R occurs n times in T.


Conformance Rules
1) Without Feature F641, “Row and table constructors”, in conforming SQL language, the <contextually typed
   row value expression list> of a <contextually typed table value constructor> shall contain exactly one
   <contextually typed row value constructor> RVE. RVE shall be of the form “(<contextually typed row value
   constructor element list>)”.
2) Without Feature F641, “Row and table constructors”, conforming SQL language shall not contain a <table
   value constructor>.




©ISO/IEC 2003 – All rights reserved                                                   Query expressions 299
ISO/IEC 9075-2:2003 (E)
7.4 <table expression>



7.4      <table expression>

Function
Specify a table or a grouped table.


Format
<table expression> ::=
    <from clause>
    [ <where clause> ]
    [ <group by clause> ]
    [ <having clause> ]
    [ <window clause> ]


Syntax Rules
1) The result of a <table expression> is a derived table whose row type RT is the row type of the result of the
   application of last of the immediately contained <from clause>, <where clause>, <group by clause>, or
   <having clause> specified in the <table expression>, together with the window structure descriptors defined
   by the <window clause>, if specified.
2) Let C be some column. Let TE be the <table expression>. C is an underlying column of TE if and only if
   C is an underlying column of some column reference contained in TE.


Access Rules
      None.


General Rules
1) If all optional clauses are omitted, then the result of the <table expression> is the same as the result of the
   <from clause>. Otherwise, each specified clause is applied to the result of the previously specified clause
   and the result of the <table expression> is the result of the application of the last specified clause.


Conformance Rules
      None.




300 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)
                                                                                                7.5 <from clause>



7.5       <from clause>

Function
Specify a table derived from one or more tables.


Format
<from clause> ::= FROM <table reference list>

<table reference list> ::=
    <table reference> [ { <comma> <table reference> }... ]


Syntax Rules
1) Let TRL be the ordering of <table reference list>. No element TRi in TRL shall contain an outer reference
      to an element TRj, where i ≤ j.

2) Case:
      a) If the <table reference list> immediately contains a single <table reference>, then the descriptor of the
         result of the <table reference list> is the same as the descriptor of the table identified by that <table
         reference>. The row type RT of the result of the <table reference list> is the row type of the table
         identified by the <table reference>.
      b) If the <table reference list> immediately contains more than one <table reference>, then the descriptors
         of the columns of the result of the <table reference list> are the descriptors of the columns of the tables
         identified by the <table reference>s, in the order in which the <table reference>s appear in the <table
         reference list> and in the order in which the columns are defined within each table. The row type RT
         of the result of the <table reference list> is determined by the sequence SCD of column descriptors of
         the result as follows:
          i)      Let n be the number of column descriptors in SCD. RT has n fields.
          ii)     For i ranging from 1 (one) to n, the field name of the i-th field descriptor in RT is the column
                  name included in the i-th column descriptor in SCD.
          iii)    For i ranging from 1 (one) to n, the data type descriptor of the i-th field descriptor in RT is
                  Case:
                  1) If the i-th descriptor in SCD includes a domain name DN, then the data type descriptor
                     included in the descriptor of the domain identified by DN.
                  2) Otherwise, the data type descriptor included in the i-th column descriptor in SCD.
3) The descriptor of the result of the <from clause> is the same as the descriptor of the result of the <table
   reference list>.




©ISO/IEC 2003 – All rights reserved                                                          Query expressions 301
ISO/IEC 9075-2:2003 (E)
7.5 <from clause>



Access Rules
   None.


General Rules
1) Let TRLR be the result of TRL.
   Case:
   a) If TRL simply contains a single <table reference> TR, then TRLR is the result of TR.
   b) If TRL simply contains n <table reference>s, where n > 1, then let TRLP be the <table reference list>
      formed by taking the first n–1 elements of TRL in order, let TRLL be the last element of TRL, and let
      TRLPR be the result of TRLP. For every row Ri, 1 (one) ≤ i ≤ n, in TRLPR, let TRLLRi be the corre-
      sponding evaluation of TRLL under all outer references contained in TRLL. Let SUBRi be the table
      containing every row formed by concatenating Ri with some row of TRLLRi. Every row RR in SUBRi
      is a row in TRLR, and the number of occurrences of RR in TRLR is the sum of the numbers of occurrences
      of RR in every occurrence of SUBRi.

   The result of the <table reference list> is TRLR with the columns reordered according to the ordering of
   the descriptors of the columns of the <table reference list>.
2) The result of the <from clause> is TRLR.


Conformance Rules
   None.




302 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                        ISO/IEC 9075-2:2003 (E)
                                                                          7.6 <table reference>



7.6      <table reference>

Function
Reference a table.


Format
<table reference> ::=
    <table factor>
  | <joined table>

<table factor> ::= <table primary> [ <sample clause> ]

<sample clause> ::=
    TABLESAMPLE <sample method> <left paren> <sample percentage> <right paren>
    [ <repeatable clause> ]

<sample method> ::=
    BERNOULLI
  | SYSTEM

<repeatable clause> ::= REPEATABLE <left paren> <repeat argument> <right paren>

<sample percentage> ::= <numeric value expression>

<repeat argument> ::= <numeric value expression>

<table primary> ::=
    <table or query name> [ [ AS ] <correlation name>
    [ <left paren> <derived column list> <right paren> ] ]
  | <derived table> [ AS ] <correlation name>
    [ <left paren> <derived column list> <right paren> ]
  | <lateral derived table> [ AS ] <correlation name>
    [ <left paren> <derived column list> <right paren> ]
  | <collection derived table> [ AS ] <correlation name>
    [ <left paren> <derived column list> <right paren> ]
  | <table function derived table> [ AS ] <correlation name>
    [ <left paren> <derived column list> <right paren> ]
  | <only spec> [ [ AS ] <correlation name>
    [ <left paren> <derived column list> <right paren> ] ]
  | <left paren> <joined table> <right paren>

<only spec> ::= ONLY <left paren> <table or query name> <right paren>

<lateral derived table> ::= LATERAL <table subquery>

<collection derived table> ::=
    UNNEST <left paren> <collection value expression> <right paren>
    [ WITH ORDINALITY ]

<table function derived table> ::=
    TABLE <left paren> <collection value expression> <right paren>

<derived table> ::= <table subquery>



©ISO/IEC 2003 – All rights reserved                                      Query expressions 303
ISO/IEC 9075-2:2003 (E)
7.6 <table reference>



<table or query name> ::=
    <table name>
  | <transition table name>
  | <query name>

<derived column list> ::= <column name list>

<column name list> ::= <column name> [ { <comma> <column name> }... ]


Syntax Rules
1) The declared type of <repeat argument> shall be an exact numeric type with scale 0 (zero).
2) If a <table primary> TP simply contains a <table function derived table> TFDT, then:
    a) The <collection value expression> immediately contained in TFDT shall be a <routine invocation>.
    b) Let CN be the <correlation name> simply contained in TP.
    c) Let CVE be the <collection value expression> simply contained in TP.
    d) Case:
        i)       If TP specifies a <derived column list> DCL, then let TFDCL be
                  ( DCL )

        ii)      Otherwise, let TFDCL be a zero-length string.
    e) TP is equivalent to the <table primary>
        UNNEST ( CVE ) AS CN TFDCL

3) If a <table primary> TP simply contains a <collection derived table> CDT, then let CVE be the <collection
   value expression> simply contained in CDT, let CN be the <correlation name> simply contained in TP,
   and let TEMP be an <identifier> that is not equivalent to CN nor to any other <identifier> contained in TP.
   Let ET be the element type of the declared type of CVE.
    a) Case:
        i)       If the declared type of CVE is a multiset, then WITH ORDINALITY shall not be specified. Let
                 IMDC be the implementation-defined maximum cardinality of an array whose declared element
                 type is ET. Let C be
                    ( CAST (CVE AS ET ARRAY[IMDC]) )


        ii)      Otherwise, let C be CVE.
    b) Let N1 and N2 be two <column name>s that are not equivalent to one another nor to CN, TEMP, or
       any other <identifier> contained in TP.
    c) Let RECQP be:
              WITH RECURSIVE TEMP(N1, N2) AS
                (   SELECT C[1] AS N1, 1 AS N2
                    FROM (VALUES(1)) AS CN
                    WHERE 0 < CARDINALITY(C)



304 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)
                                                                                             7.6 <table reference>



                    UNION
                      SELECT C[N2+1] AS N1, N2+1 AS N2
                      FROM TEMP
                      WHERE N2 < CARDINALITY(C)
                )


    d) Case:
         i)         If TP specifies a <derived column list> DCL, then:
                    1) Case:
                        A) If CDT specifies WITH ORDINALITY, then
                            Case:
                            I)        If ET is a row type, then let DET be the degree of ET. DCL shall contain DET+1
                                      (one) <column name>s.
                            II)       Otherwise, DCL shall contain 2 <column name>s.
                        B) Otherwise,
                            Case:
                            I)        If ET is a row type, then let DET be the degree of ET. DCL shall contain DET
                                      <column name>s.
                            II)       Otherwise, DCL shall contain 1 (one) <column name>.
                    2) Let PDCLP be
                            ( DCL )


         ii)        Otherwise,
                    Case:
                    1) If ET is a row type, then:
                        A) Let DET be the degree of ET.

                        B) Let FNi, 1 (one) ≤ i ≤ DET, be the name of the i-th field in ET.

                        C) Case:
                            I)        If CDT specifies WITH ORDINALITY, then let PDCLP be:
                                       ( FN1, FN2, ..., FNDET, N2 )

                            II)       Otherwise, let PDCLP be:
                                       ( FN1, FN2, ..., FNDET )

                    2) Otherwise, let PDCLP be a zero-length string.
    e) Case:



©ISO/IEC 2003 – All rights reserved                                                           Query expressions 305
ISO/IEC 9075-2:2003 (E)
7.6 <table reference>



        i)      If CDT specifies WITH ORDINALITY, then
                Case:
                1) If ET is a row type, then let ELDT be:
                        LATERAL ( RECQP SELECT N1.*, N2
                                        FROM TEMP ) AS CN PDCLP


                2) Otherwise, let ELDT be:
                        LATERAL ( RECQP SELECT *
                                        FROM TEMP ) AS CN PDCLP


        ii)     Otherwise,
                Case:
                1) If ET is a row type, then let ELDT be:
                        LATERAL ( RECQP SELECT N1.*
                                        FROM TEMP ) AS CN PDCLP


                2) Otherwise, let ELDT be:
                        LATERAL ( RECQP SELECT N1
                                        FROM TEMP ) AS CN PDCLP


    f) TP is equivalent to the <table primary> ELDT.
4) If a <table factor> TF simply contains a <correlation name>, then let RV be that <correlation name>; oth-
   erwise, let RV be the <table or query name> simply contained in TF. RV is a range variable. RV is exposed
   by TF.
    NOTE 124 — “range variable” is defined in Subclause 4.14.6, “Operations involving tables”.

5) If a <table factor> TF is contained in a <from clause> FC with no intervening <query expression>, then
   the scope clause SC of TF is the <select statement: single row> or innermost <query specification> that
   contains FC. The scope of the range variable of TF is the <select list>, <where clause>, <group by clause>,
   <having clause>, and <window clause> of SC, together with every <lateral derived table> that is simply
   contained in FC and is preceded by TF, and every <collection derived table> that is simply contained in
   FC and is preceded by TF, and the <join condition> of all <joined table>s contained in SC that contain TF.
   If SC is the <query specification> that is the <query expression body> of a simple table query STQ, then
   the scope of the range variable of TF also includes the <order by clause> of STQ.
    NOTE 125 — “simple table query” is defined in Subclause 14.1, “<declare cursor>”.

6) If a <table factor> TF is simply contained in a <merge statement> MS, then the scope clause SC of TF is
   MS. The scope of the range variable of TF is the <search condition>, <set clause list>, and <merge insert
   value list> of SC.
7) Let RV be the range variable that is exposed by a <table factor> TF. Let RV1 be the range variable that is
   exposed by a <table factor> TF1 that has the same scope clause as TF.
    Case:


306 Foundation (SQL/Foundation)                                                              ©ISO/IEC 2003 – All rights reserved
                                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                                                     7.6 <table reference>



    a) If RV is a <table name>, then
         Case:
         i)       If RV1 is a <table name>, then RV1 shall not be equivalent to RV.
         ii)      Otherwise, RV1 shall not be equivalent to the <qualified identifier> of RV.
    b) Otherwise,
         Case:
         i)       If RV1 is a <table name>, then the <qualified identifier> of RV1 shall not be equivalent to RV.
         ii)      Otherwise, RV1 shall not be equivalent to RV.
8) A <table or query name> simply contained in a <table factor> TF has a scope clause and scope defined by
   TF if and only if the <table or query name> is exposed by TF.
9) If a <table primary> TP simply contains <table or query name> TOQN, then
    Case:
    a) If TOQN is an <identifier> that is equivalent to a <query name> QN, then let WLE be the <with list
       element> simply contained in the <query expression> that simply contains TP such that the <query
       name> QN1 simply contained in WLE is equivalent to QN and QN1 is the innermost query name in
       scope. Let the table specified by the <query name> be the result of WLE.
         NOTE 126 — “query name in scope” is defined in Subclause 7.13, “<query expression>”.

    b) If TOQN is an <identifier> that is equivalent to a <transition table name> that is in scope, then let the
       table specified by the <transition table name> be the table identified by TOQN.
         NOTE 127 — The scope of a <transition table name> is defined in Subclause 11.39, “<trigger definition>”.

    c) Otherwise, let the table specified by the <table name> be the table identified by the <table name>
       simply contained in TP.
         NOTE 128 — The preceding cases disambiguate whether TOQN is interpreted as a <query name>, <transition table name>,
         or <table name>.

10) If a <table primary> TP simply contains <only spec> OS and the table identified by the <table or query
    name> TN is not a typed table, then OS is equivalent to TN.
11) No <column name> shall be specified more than once in a <derived column list>.
12) If a <derived column list> is specified in a <table primary> TP, then the number of <column name>s in
    the <derived column list> shall be the same as the degree of the table specified by the <derived table>, the
    <lateral derived table>, or the <table or query name> simply contained in TP, and the name of the i-th
    column of that <derived table> or <lateral derived table> or the effective name of the i-th column of that
    <table or query name> is the i-th <column name> in that <derived column list>.
13) The row type of a <lateral derived table> is the row type of the simply contained <query expression>.
14) Case:




©ISO/IEC 2003 – All rights reserved                                                                  Query expressions 307
ISO/IEC 9075-2:2003 (E)
7.6 <table reference>



    a) If no <derived column list> is specified in a <table primary> TP, then the row type RT of TP is the row
       type of its simply contained <table or query name>, <derived table>, <lateral derived table>, or <joined
       table>.
    b) Otherwise, the row type RT of TP is described by a sequence of (<field name>, <data type>) pairs,
       where the <field name> in the i-th pair is the i-th <column name> in the <derived column list> and the
       <data type> in the i-th pair is the declared type of the i-th column of the <derived table>, <joined table>,
       <lateral derived table>, or of the table identified by the <table or query name> simply contained in TP.
15) A <derived table> or <lateral derived table> is an updatable derived table if and only if the <query
    expression> simply contained in the <derived table> or <lateral derived table> is updatable.
16) A <derived table> or <lateral derived table> is a simply updatable derived table if and only if the <query
    expression> simply contained in the <derived table> or <lateral derived table> simply is updatable.
17) A <derived table> or <lateral derived table> is an insertable-into derived table if and only if the <query
    expression> simply contained in the <derived table> or <lateral derived table> is insertable-into.
18) A <collection derived table> is not updatable and is not simply updatable.
19) If a <table reference> TR immediately contains a <table factor> TF, then
    Case:
    a) If TF simply contains a <table name> that identifies a base table, then every column of the table iden-
       tified by TF is called an updatable column of TR.
    b) If TF simply contains a <table name> that identifies a view, then every updatable column of the view
       identified by TF is called an updatable column of TR.
    c) If TF simply contains a <derived table> or <lateral derived table>, then every updatable column of the
       table identified by the <query expression> simply contained in <derived table> or <lateral derived
       table> is called an updatable column of TR.
20) If a <table reference> TR immediately contains a <table factor> and the <table or query name> simply
    contained in TR immediately contains a <table name> TN, then let T be the table identified by TN. The
    schema identified by the explicit or implicit qualifier of TN shall include the descriptor of T.
21) A <table name> is possibly non-deterministic if the table identified by the <table name> is a viewed table,
    and the original <query expression> in the view descriptor identified by the <table name> is possibly non-
    deterministic.
22) A <query name> is possibly non-deterministic if the <query expression> identified by the <query name>
    is possibly non-deterministic.
23) A <derived table> or <lateral derived table> is possibly non-deterministic if the simply contained <query
    expression> is possibly non-deterministic.
24) A <table primary> is possibly non-deterministic if the simply contained <table name>, <query name>,
    <derived table>, <lateral derived table>, or <joined table> is possibly non-deterministic.
25) A <table reference> is possibly non-deterministic if the simply contained <table primary> or <joined table>
    is possibly non-deterministic or if <sample clause> is specified.




308 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                                          7.6 <table reference>



Access Rules
1) If a <table primary> TP simply contains a <table or query name> that simply contains a <table name> TN,
   then:
    a) Let T be the table identified by TN.
    b) Case:
         i)       If TN is contained in a <search condition> immediately contained in an <assertion definition>or
                  a <check constraint definition>, then the applicable privileges for the <authorization identifier>
                  that owns the containing schema shall include REFERENCES on at least one column of T.
         ii)      Otherwise:
                  1) Case:
                      A) If TP is contained, without an intervening <SQL routine spec> that specifies SQL
                         SECURITY INVOKER, in an <SQL schema statement>, then the applicable privileges
                         of the <authorization identifier> that owns the containing schema shall include SELECT
                         on at least one column of T.
                      B) Otherwise, the current privileges shall include SELECT on at least one column of T.
                  2) If TP simply contains <only spec> and TN identifies a typed table, then
                      Case:
                      A) If TP is contained, without an intervening <SQL routine spec> that specifies SQL
                         SECURITY INVOKER, in an <SQL schema statement>, then the applicable privileges
                         for the <authorization identifier> that owns the containing schema shall include SELECT
                         WITH HIERARCHY OPTION on at least one supertable of T.
                      B) Otherwise, the current privileges shall include SELECT WITH HIERARCHY OPTION
                         on at least one supertable of T.
                      NOTE 129 — “applicable privileges” and “current privileges” are defined in Subclause 12.3, “<privileges>”.


General Rules
1) If a <table primary> TP simply contains a <table or query name> TOQN, then
    Case:
    a) If TOQN simply contains a <query name> QN, then the result of TP is the table specified by QN.
    b) If TOQN simply contains a <transition table name> TTN, then the result of TP is the table specified by
       TTN.
         NOTE 130 — The table identified by a <transition table name> is a transition table as defined by the General Rules of
         Subclause 14.16, “Effect of deleting rows from base tables”, Subclause 14.19, “Effect of inserting tables into base tables”,
         or Subclause 14.22, “Effect of replacing rows in base tables”, as appropriate.

    c) Otherwise, let T be the table specified by the <table name> simply contained in TP.
         Case:


©ISO/IEC 2003 – All rights reserved                                                                       Query expressions 309
ISO/IEC 9075-2:2003 (E)
7.6 <table reference>



        i)     If ONLY is specified, then the result of TP is a table that consists of every row in T, except those
               rows that have a subrow in a proper subtable of T.
        ii)    Otherwise, the result of TP is a table that consists of every row of T.
2) If a <derived table> or <lateral derived table> LDT simply containing <query expression> QE is specified,
   then the result of LDT is the result of QE.
3) Let TP be the <table primary> immediately contained in a <table factor> TF. Let RT be the result of TP.
    Case:
    a) If <sample clause> is specified, then:
        i)     Let N be the number of rows in RT and let S be the value of <sample percentage>.
        ii)    If S is the null value or if S < 0 (zero) or if S > 100, then an exception condition is raised: data
               exception — invalid sample size.
        iii)   If <repeatable clause> is specified, then let RPT be the value of <repeat argument>. If RPT is
               the null value, then an exception condition is raised: data exception — invalid repeat argument
               in a sample clause.
        iv)    Case:
               1) If <sample method> specifies BERNOULLI, then the result of TF is a table containing
                  approximately (N*S/100) rows of RT. The probability of a row of RT being included in result
                  of TF is S/100. Further, whether a given row of RT is included in result of TF is independent
                  of whether other rows of RT are included in result of TF.
               2) Otherwise, result of TF is a table containing approximately (N*S/100) rows of RT. The
                  probability of a row of RT being included in result of TF is S/100.
    b) Otherwise, result of TF is RT.
4) The result of a <table reference> TR is the result of immediately contained <table factor> or <joined table>.
5) Let RV be the range variable that is exposed by a <table factor> TF. The table associated with RV is the
   result of TF.


Conformance Rules
1) Without Feature S091, “Basic array support”, or Feature S271, “Basic multiset support”, conforming SQL
   language shall not contain a <collection derived table>.
2) Without Feature T491, “LATERAL derived table”, conforming SQL language shall not contain a <lateral
   derived table>.
3) Without Feature T121, “WITH (excluding RECURSIVE) in query expression”, conforming SQL language
   shall not contain a <query name>.
4) Without Feature S111, “ONLY in query expressions”, conforming SQL language shall not contain a <table
   reference> that contains an <only spec>.
5) Without Feature F591, “Derived tables”, conforming SQL language shall not contain a <derived table>.


310 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                                     7.6 <table reference>



6) Without Feature T326, “Table functions”, conforming SQL language shall not contain a <table function
   derived table>.
7) Without Feature T613, “Sampling”, conforming SQL language shall not contain a <sample clause>.
8) Without Feature T211, “Basic trigger capability”, conforming SQL language shall not contain a <transition
   table name>.




©ISO/IEC 2003 – All rights reserved                                                  Query expressions 311
ISO/IEC 9075-2:2003 (E)
7.7 <joined table>



7.7     <joined table>

Function
Specify a table derived from a Cartesian product, inner join, or outer join.


Format
<joined table> ::=
    <cross join>
  | <qualified join>
  | <natural join>

<cross join> ::=
    <table reference> CROSS JOIN <table factor>

<qualified join> ::=
    <table reference> [ <join type> ] JOIN <table reference> <join specification>

<natural join> ::=
    <table reference> NATURAL [ <join type> ] JOIN <table factor>

<join specification> ::=
    <join condition>
  | <named columns join>

<join condition> ::= ON <search condition>

<named columns join> ::= USING <left paren> <join column list> <right paren>

<join type> ::=
    INNER
  | <outer join type> [ OUTER ]

<outer join type> ::=
    LEFT
  | RIGHT
  | FULL

<join column list> ::= <column name list>


Syntax Rules
1) Let TR1 be the first <table reference>, and let TR2 be the <table reference> or <table factor> that is the
   second operand of the <joined table>. Let RT1 and RT2 be the row types of TR1 and TR2, respectively. Let
   TA and TB be the range variables of TR1 and TR2, respectively. Let CP be:
       SELECT *
       FROM TR1, TR2




312 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                               7.7 <joined table>



2) If TR2 contains a <lateral derived table> containing an outer reference that references TR1, then <join type>
   shall not contain RIGHT or FULL.
3) If a <qualified join> or <natural join> is specified and a <join type> is not specified, then INNER is implicit.
4) If a <qualified join> containing a <join condition> is specified and a <value expression> directly contained
   in the <search condition> is a <set function specification>, then the <joined table> shall be contained in a
   <having clause> or <select list>, the <set function specification> shall contain an aggregated argument AA
   that contains an outer reference, and every column reference contained in AA shall be an outer reference.
    NOTE 131 — “outer reference” is defined in Subclause 6.7, “<column reference>”.

5) The <search condition> shall not contain a <window function> without an intervening <subquery>.
6) If neither NATURAL is specified nor a <join specification> immediately containing a <named columns
   join> is specified, then the descriptors of the columns of the result of the <joined table> are the same as
   the descriptors of the columns of CP, with the possible exception of the nullability characteristics of the
   columns.
7) If NATURAL is specified or if a <join specification> immediately containing a <named columns join> is
   specified, then:
    a) If NATURAL is specified, then let common column name be a <field name> that is equivalent to the
       <field name> of exactly one field of RT1 and the <field name> of exactly one field of RT2. RT1 shall
       not have any duplicate common column names and RT2 shall not have any duplicate common column
       names. Let corresponding join columns refer to all fields of RT1 and RT2 that have common column
       names, if any.
    b) If a <named columns join> is specified, then every <column name> in the <join column list> shall be
       equivalent to the <field name> of exactly one field of RT1 and the <field name> of exactly one field
       of RT2. Let common column name be the name of such a column. Let corresponding join columns refer
       to the columns identified in the <join column list>.
    c) Let C1 and C2 be a pair of corresponding join columns of RT1 and RT2, respectively. C1 and C2 shall
       be comparable. C1 and C2 are operands of an equality operation, and the Syntax Rules of Subclause 9.9,
       “Equality operations”, apply.
    d) If there is at least one corresponding join column, then let SLCC be a <select list> of <derived column>s
       of the form

         COALESCE ( TA.C, TB.C ) AS C

         for every column C that is a corresponding join column, taken in order of their ordinal positions in
         RT1.

    e) If RT1 contains at least one field that is not a corresponding join column, then let SLT1 be a <select
       list> of <derived column>s of the form
             TA.C
         for every field C of RT1 that is not a corresponding join column, taken in order of their ordinal positions
         in RT1.



©ISO/IEC 2003 – All rights reserved                                                        Query expressions 313
ISO/IEC 9075-2:2003 (E)
7.7 <joined table>



    f) If RT2 contains at least one field that is not a corresponding join column, then let SLT2 be a <select
       list> of <derived column>s of the form
              TB.C
        for every field C of RT2 that is not a corresponding join column, taken in order of their ordinal positions
        in RT2.

    g) Let the <select list> SL be defined as
        Case:
        i)      If all of the fields of RT1 and RT2 are corresponding join columns, then let SL be “SLCC”.

        ii)     If RT1 contains no corresponding join columns and RT2 contains no corresponding join columns,
                then let SL be “SLT1, SLT2”.

        iii)    If RT1 contains no fields other than corresponding join columns, then let SL be “SLCC, SLT2”.

        iv)     If RT2 contains no fields other than corresponding join columns, then let SL be “SLCC, SLT1”.

        v)      Otherwise, let SL be “SLCC, SLT1, SLT2”.

        The descriptors of the columns of the result of the <joined table>, with the possible exception of the
        nullability characteristics of the columns, are the same as the descriptors of the columns of the result
        of
              SELECT SL FROM TR1, TR2

8) A <joined table> is possibly non-deterministic if at least one of the following conditions is true:
    a) Either TR1 or TR2 is possibly non-deterministic.

    b) A <join condition> that generally contains a possibly non-deterministic <value expression>, possibly
       non-deterministic <query specification>, or possibly non-deterministic <query expression> is specified.
    c) NATURAL is specified, or a <join specification> immediately containing a <named columns join> is
       specified, and there is a common column name CCN such that the declared types of the two correspond-
       ing join columns identified by CCN have corresponding constituents such that one constituent is datetime
       with time zone and the other is datetime without time zone.
9) The declared type of the rows of the <joined table> is the row type RT defined by the sequence of (<field
   name>, <data type>) pairs indicated by the sequence of column descriptors of the <joined table> taken in
   order.
10) For every column CR of the result of the <joined table> that corresponds to a field C1 of RT1 that is not a
    corresponding join column, CR is possibly nullable if any of the following conditions are true:
    a) RIGHT or FULL is specified.
    b) INNER, LEFT, or CROSS JOIN is specified or implicit and C1 is possibly nullable.




314 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                                              7.7 <joined table>



11) For every column CR of the result of the <joined table> that corresponds to a field C2 of RT2 that is not a
    corresponding join column, CR is possibly nullable if any of the following conditions are true:
    a) LEFT or FULL is specified.
    b) INNER, RIGHT, or CROSS JOIN is specified or implicit and C2 is possibly nullable.

12) For every column CR of the result of the <joined table> that corresponds to a corresponding join column
    C1 of RT1 and a corresponding join column C2 of RT2, CR is possibly nullable if any of the following
    conditions are true:
    a) LEFT or FULL is specified and C1 is possibly nullable, or

    b) RIGHT or FULL is specified and C2 is possibly nullable.


Access Rules
    None.


General Rules
1) Let T1 be the result of evaluating TR1.

2) Case:
    a) If a <cross join> is specified, then let T be CP.
    b) If a <join condition> is specified, then let SC be the <search condition> and let T be
               CP
               WHERE SC


    c) If NATURAL is specified or <named columns join> is specified, then
         Case:
         i)       If there are corresponding join columns, then let N be the number of corresonding join columns
                  and let CJCNi, 1 (one) ≤ i ≤ N, be the field name of the i-th corresponding join column, and let
                  T be

                  CP
                  WHERE TA.CJCN1 = TB.CJCN1
                     AND ...
                     AND TA.CJCNN = TB.CJCNN

         ii)      Otherwise, let T be CP.
3) Let TR be the result of evaluating T.
4) Let P1 be the collection of rows of T1 for which there exists in TR some row that is a subrow of some row
   R1 of T1.


©ISO/IEC 2003 – All rights reserved                                                       Query expressions 315
ISO/IEC 9075-2:2003 (E)
7.7 <joined table>



5) Let U1 be those rows of T1 that are not in P1.

6) Let D1 and D2 be the degrees of TR1 and TR2, respectively. Let X1 be U1 extended on the right with D2
   columns containing the null value.
7) Let XN1 be an effective distinct name for X1. Let TN be an effective name for T.

8) If RIGHT or FULL is specified, then:
    a) Let T2 be the result of evaluating TR2.

    b) Let P2 be the collection of rows of T2 for which there exists in TR some row that is a subrow of some
       row R1 of T1.

    c) Let U2 be those rows of T2 that are not in P2.

    d) Let X2 be U2 extended on the left with D1 columns containing the null value.

    e) Let XN2 be an effective distinct name for X2.

9) Case:
    a) If INNER or <cross join> is specified, then let S be TR.
    b) If LEFT is specified, then let S be the result of:

        SELECT * FROM TN
        UNION ALL
        SELECT * FROM XN1

    c) If RIGHT is specified, then let S be the result of:

        SELECT * FROM TN
        UNION ALL
        SELECT * FROM XN2

    d) If FULL is specified, then let S be the result of:

        SELECT * FROM TN
        UNION ALL
        SELECT * FROM XN1
        UNION ALL
        SELECT * FROM XN2

10) Let SN be an effective name of S.
    Case:
    a) If NATURAL is specified or a <named columns join> is specified, then:
        i)     Let CSi be a name for the i-th column of S. Column CSi of S corresponds to the i-th field of RT1
               if i is less than or equal to D1. Column CSj of S corresponds to the (j–D1)-th field of RT2 for j
               greater than D1.



316 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                                              7.7 <joined table>



         ii)      If there is at least one corresponding join column, then let SLCC be a <select list> of derived
                  columns of the form

                  COALESCE (CSi, CSj)

                  for every pair of columns CSi and CSj, where CSi and CSj correspond to fields of RT1 and RT2
                  that are a pair of corresponding join columns.
         iii)     If RT1 contains one or more fields that are not corresponding join columns, then let SLT1 be a
                  <select list> of the form:

                  CSi

                  for every column CSi of S that corresponds to a field of RT1 that is not a corresponding join
                  column, taken in order of their ordinal position in S.
         iv)      If RT2 contains one or more fields that are not corresponding join columns, then let SLT2 be a
                  <select list> of the form:

                  CSj

                  for every column CSj of S that corresponds to a field of RT2 that is not a corresponding join
                  column, taken in order of their ordinal position in S.
         v)       Let the <select list> SL be defined as
                  Case:
                  1) If all the fields of RT1 and RT2 are corresponding join columns, then let SL be

                          SLCC

                  2) If RT1 contains no corresponding join columns and RT2 contains no corresponding join
                     columns, then let SL be
                          SLT1, SLT2

                  3) If RT1 contains no fields other than corresponding join columns, then let SL be

                          SLCC, SLT2

                  4) If RT2 contains no fields other than corresponding join columns, then let SL be

                          SLCC, SLT1

                  5) Otherwise, let SL be
                          SLCC, SLT1, SLT2

         vi)      The result of the <joined table> is the result of:



©ISO/IEC 2003 – All rights reserved                                                        Query expressions 317
ISO/IEC 9075-2:2003 (E)
7.7 <joined table>



                   SELECT SL FROM SN


    b) Otherwise, the result of the <joined table> is S.


Conformance Rules
1) Without Feature F401, “Extended joined table”, conforming SQL language shall not contain a <cross join>.
2) Without Feature F401, “Extended joined table”, conforming SQL language shall not contain a <natural
   join>.
3) Without Feature F401, “Extended joined table”, conforming SQL language shall not contain FULL.
4) Without Feature F402, “Named column joins for LOBs, arrays, and multisets”, conforming SQL language
   shall not contain a <joined table> that simply contains either <natural join> or <named columns join> in
   which, if C is a corresponding join column, the declared type of C is LOB-ordered, array-ordered, or mul-
   tiset-ordered.
    NOTE 132 — If C is a corresponding join column, then the Conformance Rules of Subclause 9.9, “Equality operations”, also
    apply.




318 Foundation (SQL/Foundation)                                                              ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                          7.8 <where clause>



7.8       <where clause>

Function
Specify a table derived by the application of a <search condition> to the result of the preceding <from clause>.


Format
<where clause> ::= WHERE <search condition>


Syntax Rules
1) If a <value expression> directly contained in the <search condition> is a <set function specification>, then
   the <where clause> shall be contained in a <having clause> or <select list>, the <set function specification>
   shall contain a column reference, and every column reference contained in an aggregated argument of the
   <set function specification> shall be an outer reference.
      NOTE 133 — outer reference is defined in Subclause 6.7, “<column reference>”.

2) The <search condition> shall not contain a <window function> without an intervening <subquery>.


Access Rules
      None.


General Rules
1) Let T be the result of the preceding <from clause>.
2) The <search condition> is applied to each row of T. The result of the <where clause> is a table of those
   rows of T for which the result of the <search condition> is True.
3) Each <subquery> that is directly contained in the <search condition> is effectively executed for each row
   of T and the results used in the application of the <search condition> to the given row of T.


Conformance Rules
1) Without Feature F441, “Extended set function support”, conforming SQL language shall not contain a
   <value expression> directly contained in a <where clause> that contains a <column reference> that references
   a <derived column> that generally contains a <set function specification> without an intervening <routine
   invocation>.




©ISO/IEC 2003 – All rights reserved                                                     Query expressions 319
ISO/IEC 9075-2:2003 (E)
7.9 <group by clause>



7.9     <group by clause>

Function
Specify a grouped table derived by the application of the <group by clause> to the result of the previously
specified clause.


Format
<group by clause> ::=
    GROUP BY [ <set quantifier> ] <grouping element list>

<grouping element list> ::=
    <grouping element> [ { <comma> <grouping element> }... ]

<grouping element> ::=
    <ordinary grouping set>
  | <rollup list>
  | <cube list>
  | <grouping sets specification>
  | <empty grouping set>

<ordinary grouping set> ::=
    <grouping column reference>
  | <left paren> <grouping column reference list> <right paren>

<grouping column reference> ::=
    <column reference> [ <collate clause> ]

<grouping column reference list> ::=
    <grouping column reference> [ { <comma> <grouping column reference> }... ]

<rollup list> ::=
    ROLLUP <left paren> <ordinary grouping set list> <right paren>

<ordinary grouping set list> ::=
    <ordinary grouping set> [ { <comma> <ordinary grouping set> }... ]

<cube list> ::=
    CUBE <left paren> <ordinary grouping set list> <right paren>

<grouping sets specification> ::=
    GROUPING SETS <left paren> <grouping set list> <right paren>

<grouping set list> ::=
    <grouping set> [ { <comma> <grouping set> }... ]

<grouping set> ::=
    <ordinary grouping set>
  | <rollup list>
  | <cube list>
  | <grouping sets specification>
  | <empty grouping set>




320 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                          7.9 <group by clause>



<empty grouping set> ::= <left paren> <right paren>


Syntax Rules
1) Each <grouping column reference> shall unambiguously reference a column of the table resulting from
   the <from clause>. A column referenced in a <group by clause> is a grouping column.
    NOTE 134 — “Column reference” is defined in Subclause 6.7, “<column reference>”.

2) Each <grouping column reference> is an operand of a grouping operation. The Syntax Rules of
   Subclause 9.10, “Grouping operations”, apply.
3) For every <grouping column reference> GC,
    Case:
    a) If <collate clause> is specified, then let CS be the collation identified by <collation name>. The declared
       type of the column reference shall be character string. The declared type of GC is that of its column
       reference, except that CS is the declared type collation and the collation derivation is explicit.
    b) Otherwise, the declared type of GC is the declared type of its column reference.
4) Let QS be the <query specification> that simply contains the <group by clause>, and let SL, FC, WC, GBC,
   and HC be the <select list>, the <from clause>, the <where clause> if any, the <group by clause>, and the
   <having clause> if any, respectively, that are simply contained in QS.
5) Let QSSQ be the explicit or implicit <set quantifier> immediately contained in QS.
6) Let GBSQ be the <set quantifier> immediately contained in <group by clause>, if any; otherwise, let GBSQ
   be ALL.
7) Let SL1 be obtained from SL by replacing every <asterisk> and <asterisked identifier chain> using the
   syntactic transformations in the Syntax Rules of Subclause 7.12, “<query specification>”.
8) A <group by clause> is primitive if it does not contain a <rollup list>, <cube list>, <grouping sets specifi-
   cation>, or <grouping column reference list>, and does not contain both a <grouping column reference>
   and an <empty grouping set>.
9) A <group by clause> is simple if it does not contain a <rollup list>, <cube list> or <grouping sets specifi-
   cation>.
10) If GBC is a simple <group by clause> that is not primitive, then GBC is transformed into a primitive <group
    by clause> as follows:
    a) Let NSGB be the number of <grouping column reference>s contained in GBC.
    b) Case:
         i)       If NSGB is 0 (zero), then GBC is replaced by
                     GROUP BY ()

         ii)      Otherwise:




©ISO/IEC 2003 – All rights reserved                                                       Query expressions 321
ISO/IEC 9075-2:2003 (E)
7.9 <group by clause>



                1) Let SGCR1, ... SGCRNSGB be an enumeration of the <grouping column reference>s contained
                   in GBC.
                2) GBC is replaced by
                         GROUP BY SGCR1, ... SGCRNSGB

                NOTE 135 — That is, a simple <group by clause> that is not primitive may be transformed into a primitive <group
                by clause> by deleting all parentheses, and deleting extra <comma>s as necessary for correct syntax. If there are no
                grouping columns at all (for example, GROUP BY (), ()), this is transformed to the canonical form GROUP BY
                ().

11) If GBC is a primitive <group by clause>, then let SLNEW and HCNEW be obtained from SL1 and HC,
    respectively, by replacing every <grouping operation> by the exact numeric literal 0 (zero). QS is equivalent
    to:
       SELECT QSSQ SLNEW FC WC GBC HCNEW

12) If OGSL is an <ordinary grouping set list>, then the concatenation of OGSL is defined as follows:
    a) Let NGCR be the number of <grouping column reference>s simply contained in OGSL and let GCRj,
        1 (one) ≤ j ≤ NGCR, be an enumeration of those <grouping column reference>s, in order from left to
        right.
    b) The concatenation of OGSL is the <ordinary grouping set list>
           GCR1, ..., GCRNGCR
        NOTE 136 — Thus, the concatenation of OGSL may be formed by erasing all parentheses. For example, the concatenation
        of “(A, B), (C, D)” is “A, B, C, D”.

13) If RL is a <rollup list>, then let OGSi range over the n <ordinary grouping set>s contained in RL.

    a) For each i between 1 (one) and n, let COGSi be the concatenation of the <ordinary grouping set list>

           ORG1, ORG2, ..., ORGi

    b) RL is equivalent to:
           GROUPING SETS (
              ( COGSn ),
              ( COGSn-1 ),
              ( COGSn-2 ),
              ...
              ( COGS1 ),
              ( ) )

        NOTE 137 — The result of the transform is to replace RL with a <grouping sets specification> that contains a <grouping set>
        for every initial sublist of the <ordinary grouping set list> of the <rollup list>, obtained by dropping <ordinary grouping set>s
        from the right, one by one, and concatenating each <ordinary grouping set list> so obtained. The <empty grouping set> is
        regarded as the shortest such initial sublist. For example, “ROLLUP ( (A, B), (C, D) )” is equivalent to “GROUPING SETS
        ( (A, B, C, D), (A, B), () )”.

14) If CL is a <cube list>, then let OGSi range over the n <ordinary grouping set>s contained in CL. CL is
    transformed as follows:


322 Foundation (SQL/Foundation)                                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                                                           7.9 <group by clause>



    a) Let M = 2n – 1 (one).
    b) For each i between 1 (one) and M:
         i)       Let BSLi be the binary number consisting of n bits (binary digits) whose value is i.

         ii)      For each j between 1 (one) and n, let Bi,j be the j-th bit, counting from left to right, in BSLi.

         iii)     For each j between 1 (one) and n, let GSLCRi,j be

                  Case:
                  1) If Bi,j is 0 (zero), then the zero-length string.

                  2) If Bi,j is 1 (one) and Bi,k is 0 (zero) for all k < j, then OGSj.

                  3) Otherwise, <comma> followed by OGSj.

         iv)      Let GSLi be the concatenation of the <ordinary grouping set list>
                     GSLCRi,1 GSLCRi,2 ... GSLCRi,n


    c) CL is equivalent to
               GROUPING SETS ( ( GSLM ), ( GSLM-1 ), ..., ( GSL1 ), ( ) )


    NOTE 138 — The result of the transform is to replace CL with a <grouping sets specification> that contains a <grouping set> for
    all possible subsets of the set of <ordinary grouping set>s in the <ordinary grouping set list> of the <cube list>, including <empty
    grouping set> as the empty subset with no <ordinary grouping set>s.
    For example, CUBE (A, B, C) is equivalent to:
    GROUPING SETS ( /* BSLi */
      (A, B, C),        /* 111 */
      (A, B       ),    /* 110 */
      (A,       C),     /* 101 */
      (A          ),    /* 100 */
      (     B, C),      /* 011 */
      (     B     ),    /* 010 */
      (         C),     /* 001 */
      (           )
    )

    As another example, CUBE     ((A, B), (C, D)) is equivalent to:
    GROUPING SETS ( /*           BSLi */
      (A, B, C, D), /*           11 */
      (A, B           ), /*      10 */
      (          C, D), /*       01 */
      (               )
    )

15) If <grouping sets specification> GSSA simply contains another <grouping sets specification> GSSB, then
    GSSA is transformed as follows:




©ISO/IEC 2003 – All rights reserved                                                                        Query expressions 323
ISO/IEC 9075-2:2003 (E)
7.9 <group by clause>



    a) Let NA be the number of <grouping set>s simply contained in GSSA, and let NB be the number of
       <grouping set>s simply contained in GSSB.

    b) Let GSAi be an enumeration of the <grouping set>s simply contained in GSSA, for 1 (one) ≤ i ≤ NA.

    c) Let GSBi be an enumeration of the <grouping set>s simply contained in GSSB, 1 (one) ≤ i ≤ NB.

    d) Let k be the value such that GSSB = GSAk .

    e) GSSA is equivalent to
              GROUPING SETS (
                  GSA1, GSA2, ... GSAk-1,
                  GSB1, ... , GSBNB,
                  GSAk+1, ..., GSANA )

              NOTE 139 — Thus, the nested <grouping sets specification> is removed by simply “promoting” each of its <grouping
              set>s to be a <grouping set> of the encompassing <grouping sets specification>.

16) If CGB is a <group by clause> that is not simple, then CGB is transformed as follows:
    a) The preceding Syntax Rules are applied repeatedly to eliminate any <grouping sets specification> that
       is nested in another <grouping sets specification>, as well as any <rollup list> and any <cube list>.
        NOTE 140 — As a result, CGB is a list of two or more <grouping set>s, each of which is an <ordinary grouping set>, an
        <empty grouping set>, or a <grouping sets specification> that contains only <ordinary grouping set>s and <empty grouping
        set>s. There are no remaining <rollup list>s, <cube list>s, or nested <grouping sets specification>s.

    b) Any <grouping element> GS that is an <ordinary grouping set> or an <empty grouping set> is replaced
       by the <grouping sets specification>
              GROUPING SETS ( GS )
        NOTE 141 — As a result, CGB is a list of two or more <grouping sets specification>s.

    c) Let GSSX and GSSY be the first two <grouping sets specification>s in CGB. CGB is transformed by
       replacing “GSSX <comma> GSSY” as follows:
        i)        Let NX be the number of <grouping set>s in GSSX and let NY be the number of <grouping set>s
                  in GSSY.

        ii)       Let GSXi, 1 (one) ≤ i ≤ NX, be the <grouping set>s contained in GSSX, and let GSYi, 1 (one) ≤
                  i ≤ NY, be the <grouping set>s contained in GSSY.
        iii)      Let MX(i) be the number of <grouping column reference>s in GSXi, and let MY(i) be the number
                  of <grouping column reference>s in GSYi.
                  NOTE 142 — If GSXi is <empty grouping set>, then MX(i) is 0 (zero); and similarly for GSYi.

        iv)       Let GCRXi,j, 1 (one) ≤ j ≤ MX(i) be the <grouping column reference>s contained in GSXi, and
                  let GCRYi,j, 1 (one) ≤ j ≤ MY(i) be the <grouping column reference>s contained in GSYi.
                  NOTE 143 — If GSXi is <empty grouping set>, then there are no GCRXi,j; and similarly for GSYi.




324 Foundation (SQL/Foundation)                                                                ©ISO/IEC 2003 – All rights reserved
                                                                                                 ISO/IEC 9075-2:2003 (E)
                                                                                                   7.9 <group by clause>



         v)       For each a between 1 (one) and NX and each b between 1 (one) and NY, let GSTa,b be

                     ( GCRXa,1, ..., GCRXa,MX(a), GCRYb,1 , ..., GCRYb,MY(b) )

                  that is, an <ordinary grouping set> consisting of GCRAa,j for all j between 1 (one) and MX(a),
                  followed by GCRYb,j for all j between 1 (one) and MY(b).

         vi)      CGB is transformed by replacing “GSSX <comma> GSSY” with
                     GROUPING     SETS (
                       GST1,1,    ..., GST1,NY,
                       GST2,1,    ..., GST2,NY,
                       ...
                       GSTNX,1        , ..., GSTNX,NY
                     )

                  NOTE 144 — Thus each <ordinary grouping set> in GSSA is “concatenated” with each <ordinary grouping set> in
                  GSSB. For example,

                     GROUP BY GROUPING SETS ((A, B), (C)),
                              GROUPING SETS ((X, Y), ())

                  is transformed to

                     GROUP BY GROUPING SETS ((A, B, X, Y), (A, B),
                              (C, X, Y), (C))


    d) The previous subrule of this Syntax Rule is applied repeatedly until CGB consists of a single <grouping
       sets specification>.
17) If <grouping element list> consists of a single <grouping sets specification> GSS that contains only
    <ordinary grouping set>s or <empty grouping set>s, then:
    a) Let m be the number of <grouping set>s contained in GSS.

    b) Let GSi, 1 ≤ i ≤ m, range over the <grouping set>s contained in GSS.

    c) Let p be the number of distinct <column reference>s that are contained in GSS.
    d) Let PC be an ordered list of these <column reference>s ordered according to their left-to-right occurrence
       in the list.

    e) Let PCk, 1 ≤ k ≤ p, be the k-th <column reference> in PC.

    f) Let DTPCk be the declared type of the column identified by PCk.

    g) Let NDC be the number of <derived column>s simply contained in SL1.

    h) Let DCq, 1 ≤ q ≤ NDC, be an enumeration of the <derived column>s simply contained in SL1, in order
       from left to right.

    i)   Let DCNq be the column name of DCq, 1 (one) ≤ q ≤ NDC.




©ISO/IEC 2003 – All rights reserved                                                                Query expressions 325
ISO/IEC 9075-2:2003 (E)
7.9 <group by clause>



   j)   Let VEq, 1 (one) ≤ q ≤ NDC, be the <value expression> simply contained in DCq.

   k) Let XNk, 1 (one) ≤ k ≤ p, YNk, 1 (one) ≤ k ≤ p, and ZNq, 1 (one) ≤ q ≤ NDC, be implementation-
      dependent column names that are all distinct from one another.
   l)   Let SL2 be the <select list>:
              PC1 AS XN1, GROUPING (PC1) AS YN1,
              ...,
              PCp AS XNp, GROUPING (PCp) AS YNp,
              VE1 AS XN1, ..., VENDC AS ZNNDC


   m) For each GSi:

        i)       If GSi is an <empty grouping set>, then let n(i) be 0 (zero). If GSi is a <grouping column refer-
                 ence>, then let n(i) be 1 (one). Otherwise, let n(i) be the number of <grouping column reference>s
                 contained in the <grouping column reference list>.

        ii)      Let GCRi,j, 1 ≤ j ≤ n(i), range over the <grouping column reference>s contained in GSi.

        iii)     Case:
                 1) If GSi is an <ordinary grouping set>, then

                     A) Transform SL2 to obtain SL3, and transform HC to obtain HC3, as follows:
                         For every PCk, if there is no j such that PCk = GCRi,j, then make the following
                         replacements in SL2 and HC:
                         I)       Replace each <grouping operation> in SL2 and HC that contains a <column ref-
                                  erence> that references PCk by the <literal> 1 (one).

                         II)      Replace each <column reference> in SL2 and HC that references PCk by
                                    CAST ( NULL AS DTPCk )


                     B) Transform SL3 to obtain SLNEW, and transform HC3 to obtain HCNEW by replacing
                        each <grouping operation> that remains in SL3 and HC3 by the <literal> 0 (zero).
                         NOTE 145 — Thus the value of a <grouping operation> is 0 (zero) if the grouping column referenced by
                         the <grouping operation> is among the GCRi,j and 1(one) if it is not.

                     C) Let GSSQLi be:
                               SELECT QSSQ SLNEW
                               FC
                               WC
                               GROUP BY GCRi,1, ..., GCRi,n(i)
                               HCNEW


                 2) If GSi is an <empty grouping set>, then



326 Foundation (SQL/Foundation)                                                            ©ISO/IEC 2003 – All rights reserved
                                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                                                       7.9 <group by clause>



                      A) Transform SL2 to obtain SLNEW, and transform HC to obtain HCNEW, as follows:

                           For every k, 1 ≤ k ≤ p:
                           I)         Replace each <grouping operation> in SL2 and HC that contains a <column ref-
                                      erence> that references PCkby the <literal> 1 (one).

                           II)        Replace each <column reference> in SL2 and HC that references PCk by
                                        CAST ( NULL AS DTPCk )


                      B) Let GSSQLi be
                                 SELECT QSSQ SLNEW
                                 FC
                                 WC
                                 GROUP BY ()
                                 HCNEW


    n) Let GU be:
         GSSQL1
           UNION GBSQ
         GSSQL2
           UNION GBSQ
         ...
           UNION GBSQ
         GSSQLm

    o) QS is equivalent to

             SELECT QSSQ ZN1 AS DC1, ..., ZNNDC AS DCNDC
             FROM ( GU )



Access Rules
    None.


General Rules
NOTE 146 — As a result of the syntactic transformations specified in the Syntax Rules of this Subclause, only primitive <group by
clause>s are left to consider.

1) If no <where clause> is specified, then let T be the result of the preceding <from clause>; otherwise, let T
   be the result of the preceding <where clause>.
2) Case:
    a) If there are no grouping columns, then the result of the <group by clause> is the grouped table consisting
       of T as its only group.


©ISO/IEC 2003 – All rights reserved                                                                    Query expressions 327
ISO/IEC 9075-2:2003 (E)
7.9 <group by clause>



   b) Otherwise, the result of the <group by clause> is a partitioning of the rows of T into the minimum
      number of groups such that, for each grouping column of each group, no two values of that grouping
      column are distinct. If the declared type of a grouping column is a user-defined type and the comparison
      of that column results in Unknown for two rows of T, then the assignment of those rows to groups in
      the result of the <group by clause> is implementation-dependent.
3) When a <search condition> or <value expression> is applied to a group, a reference CR to a column that
   is functionally dependent on the grouping columns is understood as follows.
   Case:
   a) If CR is a group-invariant column reference, then it is a reference to the common value in that column
      of the rows in that group. If the most specific type of the column is character, datetime with time zone,
      or a user-defined type, then the value is an implementation-dependent value that is not distinct from
      the value of the column in each row of the group.
   b) Otherwise, CR is a within-group-varying column reference, and as such, it is a reference to the value
      of the column in each row of a given group determined by the grouping columns, to be used to construct
      the argument source of a <set function specification>.


Conformance Rules
1) Without Feature T431, “Extended grouping capabilities”, conforming SQL language shall not contain a
   <rollup list>.
2) Without Feature T431, “Extended grouping capabilities”, conforming SQL language shall not contain a
   <cube list>.
3) Without Feature T431, “Extended grouping capabilities”, conforming SQL language shall not contain a
   <grouping sets specification>.
4) Without Feature T431, “Extended grouping capabilities”, conforming SQL language shall not contain an
   <empty grouping set>.
5) Without Feature T431, “Extended grouping capabilities”, conforming SQL language shall not contain an
   <ordinary grouping set> that contains a <grouping column reference list>.
6) Without Feature T432, “Nested and concatenated GROUPING SETS”, conforming SQL language shall
   not contain a <grouping set list> that contains a <grouping sets specification>.
7) Without Feature T432, “Nested and concatenated GROUPING SETS”, conforming SQL language shall
   not contain a <group by clause> that simply contains a <grouping sets specification> GSS where GSS is
   not the only <grouping element> simply contained in the <group by clause>.
   NOTE 147 — The Conformance Rules of Subclause 9.10, “Grouping operations”, also apply.

8) Without Feature T434, “GROUP BY DISTINCT”, conforming SQL language shall not contain a <group
   by clause> that simply contains a <set quantifier>.




328 Foundation (SQL/Foundation)                                                         ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                           7.10 <having clause>



7.10 <having clause>

Function
Specify a grouped table derived by the elimination of groups that do not satisfy a <search condition>.


Format
<having clause> ::= HAVING <search condition>


Syntax Rules
1) Let HC be the <having clause>. Let TE be the <table expression> that immediately contains HC. If TE
   does not immediately contain a <group by clause>, then “GROUP BY ()” is implicit. Let T be the
   descriptor of the table defined by the <group by clause> GBC immediately contained in TE and let R be
   the result of GBC.
2) Let G be the set consisting of every column referenced by a <column reference> contained in GBC.
3) Each column reference directly contained in the <search condition> shall be one of the following:
    a) An unambiguous reference to a column that is functionally dependent on G.
    b) An outer reference.
         NOTE 148 — See also the Syntax Rules of Subclause 6.7, “<column reference>”.

4) The <search condition> shall not contain a <window function> without an intervening <subquery>.
5) The row type of the result of the <having clause> is the row type RT of T.


Access Rules
    None.


General Rules
1) The <search condition> is applied to each group of R. The result of the <having clause> is a grouped table
   of those groups of R for which the result of the <search condition> is True.
2) Each <subquery> that is directly contained in the <search condition> is effectively evaluated for each group
   of R and the result used in the application of the <search condition> to the given group of R.


Conformance Rules
1) Without Feature T301, “Functional dependencies”, in conforming SQL language, each column reference
   directly contained in the <search condition> shall be one of the following:



©ISO/IEC 2003 – All rights reserved                                                      Query expressions 329
ISO/IEC 9075-2:2003 (E)
7.10 <having clause>



    a) An unambiguous reference to a grouping column of T.
    b) An outer reference.
2) Without Feature T301, “Functional dependencies”, in conforming SQL language, each column reference
   contained in a <subquery> in the <search condition> that references a column of T shall be one of the fol-
   lowing:
    a) An unambiguous reference to a grouping column of T.
    b) Contained in an aggregated argument of a <set function specification>.




330 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                      ISO/IEC 9075-2:2003 (E)
                                                                        7.11 <window clause>



7.11 <window clause>

Function
Specify one or more window definitions.


Format
<window clause> ::= WINDOW <window definition list>

<window definition list> ::=
    <window definition> [ { <comma> <window definition> }... ]

<window definition> ::= <new window name> AS <window specification>

<new window name> ::= <window name>

<window specification> ::=
    <left paren> <window specification details> <right paren>

<window specification details> ::=
    [ <existing window name> ]
    [ <window partition clause> ]
    [ <window order clause> ]
    [ <window frame clause> ]

<existing window name> ::= <window name>

<window partition clause> ::=
    PARTITION BY <window partition column reference list>

<window partition column reference list> ::=
    <window partition column reference>
    [ { <comma> <window partition column reference> }... ]

<window partition column reference> ::=
    <column reference> [ <collate clause> ]

<window order clause> ::=
    ORDER BY <sort specification list>

<window frame clause> ::=
    <window frame units> <window frame extent>
    [ <window frame exclusion> ]

<window frame units> ::=
    ROWS
  | RANGE

<window frame extent> ::=

    <window frame start>
  | <window frame between>

<window frame start> ::=



©ISO/IEC 2003 – All rights reserved                                    Query expressions 331
ISO/IEC 9075-2:2003 (E)
7.11 <window clause>



    UNBOUNDED PRECEDING
  | <window frame preceding>
  | CURRENT ROW

<window frame preceding> ::= <unsigned value specification> PRECEDING

<window frame between> ::= BETWEEN <window frame bound 1> AND <window frame bound 2>

<window frame bound 1> ::= <window frame bound>

<window frame bound 2> ::= <window frame bound>

<window frame bound> ::=
    <window frame start>
  | UNBOUNDED FOLLOWING
  | <window frame following>

<window frame following> ::= <unsigned value specification> FOLLOWING

<window frame exclusion> ::=
    EXCLUDE CURRENT ROW
  | EXCLUDE GROUP
  | EXCLUDE TIES
  | EXCLUDE NO OTHERS


Syntax Rules
1) Let TE be the <table expression> that immediately contains the <window clause>.
2) <new window name> NWN1 shall not be contained in the scope of another <new window name> NWN2
   such that NWN1 and NWN2 are equivalent.
3) Let WDEF be a <window definition>.
4) Each <column reference> contained in the <window partition clause> or <window order clause> of WDEF
   shall unambiguously reference a column of the derived table T that is the result of TE. A column referenced
   in a <window partition clause> is a partitioning column. Each partitioning column is an operand of a
   grouping operation, and the Syntax Rules of Subclause 9.10, “Grouping operations”, apply.
    NOTE 149 — If T is a grouped table, then the <column reference>s contained in <window partition clause> or <window order
    clause> shall reference columns of the grouped table obtained by performing the syntactic transformation in Subclause 7.12,
    “<query specification>”.

5) For every <window partition column reference> PC,
    Case:
    a) If <collate clause> is specified, then let CS be the collation identified by <collation name>. The declared
       type of the column reference shall be character string. The declared type of PC is that of its column
       reference, except that CS is the declared type collation and the collation derivation is explicit.
    b) Otherwise, the declared type of PC is the declared type of its column reference.
6) If T is a grouped table, then let G be the set of grouping columns of T. Each column reference contained
   in <window clause> that references a column of T shall reference a column that is functionally dependent
   on G or be contained in an aggregated argument of a <set function specification>.



332 Foundation (SQL/Foundation)                                                               ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                        7.11 <window clause>



7) A <window clause> shall not contain a <window function> without an intervening <subquery>.
8) If WDEF specifies <window frame between>, then:
    a) <window frame bound 1> shall not specify UNBOUNDED FOLLOWING.
    b) <window frame bound 2> shall not specify UNBOUNDED PRECEDING.
    c) If <window frame bound 1> specifies CURRENT ROW, then <window frame bound 2> shall not
       specify <window frame preceding>.
    d) If <window frame bound 1> specifies <window frame following>, then <window frame bound 2> shall
       not specify <window frame preceding> or CURRENT ROW.
9) If WDEF specifies <window frame extent>, and does not specify <window frame between>, then let WAGS
   be the <window frame start>. The <window frame extent> is equivalent to
        BETWEEN WAGS AND CURRENT ROW


10) If WDEF specifies an <existing window name> EWN, then:
    a) WDEF shall be within the scope of a <window name> that is equivalent to <existing window name>.
    b) Let WDX be the window structure descriptor identified by EWN.
    c) WDEF shall not specify <window partition clause>.
    d) If WDX has a window ordering clause, then WDEF shall not specify <window order clause>.
    e) WDX shall not have a window framing clause.
11) If WDEF's <window frame clause> specifies <window frame preceding> or <window frame following>,
    then let UVS be the <unsigned value specification> simply contained in the <window frame preceding> or
    <window frame following>.
    Case:
    a) If RANGE is specified, then WDEF's <window order clause> shall contain a single <sort key> SK.
       The declared type of SK shall be numeric, datetime, or interval. The declared type of UVS shall be
       numeric if the declared type of SK is numeric; otherwise, it shall be an interval type that may be added
       to or subtracted from the declared type of SK according to the Syntax Rules of Subclause 6.30,
       “<datetime value expression>”, and Subclause 6.32, “<interval value expression>”, in this part of
       ISO/IEC 9075.
    b) If ROWS is specified, then the declared type of UVS shall be exact numeric with scale 0 (zero).
12) The scope of the <new window name> simply contained in WDEF consists of any <window definition>s
    that follow WDEF in the <window clause>, together with the <select list> of the <query specification> or
    <select statement: single row> that simply contains the <window clause>. If the <window clause> is simply
    contained in a <query specification> that is the <query expression body> of a <declare cursor> that is a
    simple table query, then the scope of <new window name> also includes the <order by clause> of the
    <declare cursor>.
13) Two window structure descriptors WD1 and WD2 are order-equivalent if all of the following conditions
    are met:



©ISO/IEC 2003 – All rights reserved                                                    Query expressions 333
ISO/IEC 9075-2:2003 (E)
7.11 <window clause>



    a) Let WPCR1i, 1 (one) ≤ i ≤ N1, and WPCR2i, 1 (one) ≤ i ≤ N2, be enumerations of the <window partition
       column reference>s contained in the window partitioning clauses of WD1 and WD2, respectively, in
       order from left to right. N1 = N2, and, for all i, WPCR1i and WPCR2i are equivalent column references.

    b) Let SS1i, 1 (one) ≤ i ≤ M1, and SS2i, 1 (one) ≤ i ≤ M2, be enumerations of the <sort specification>s
       contained in the window ordering clauses of WD1 and WD2, respectively, in order from left to right.
       M1 = M2, and, for all i, SS1i and SS2i contain <sort key>s that are equivalent column references,
       specify or imply the same <ordering specification>, specify or imply the same <collate clause>, if any,
       and specify or imply the same <null ordering>.


Access Rules
    None.


General Rules
1) Let TE be the <table expression> that simply contains the <window clause>. Let SL be the <select list> of
   the <query specification> or <select statement: single row> that immediately contains TE.
    Case:
    a) If SL does not simply contain a <window function>, then the <window clause> is disregarded, and the
       result of TE is the result of the last <from clause>, <where clause>, <group by clause> or <having
       clause> of TE.
    b) Otherwise, let RTE be the result of the last <from clause> or <where clause> simply contained in TE.
        NOTE 150 — Although it is permissible to have a <group by clause> or a <having clause> with a <window clause>, if there
        are any <window function>s, then the <group by clause> and <having clause> are removed by a syntactic transformation in
        Subclause 7.12, “<query specification>”, and so are not considered here.

        i)      A window structure descriptor WDESC is created for each <window definition> WDEF, as fol-
                lows:
                1) WDESC's window name is the <new window name> simply contained in WDEF.
                2) If <existing window name> is specified, then let EWN be the <existing window name>
                   simply contained in WDEF and let WDX be the window structure descriptor identified by
                   EWN.
                3) If <existing window name> is specified and the window ordering clause of WDX is present,
                   then the ordering window name of WDESC is EWN; otherwise, there is no ordering window
                   name.
                4) Case:
                    A) If WDEF simply contains <window partition clause> WDEFWPC, then WDESC's window
                       partitioning clause is WDEFWPC.
                    B) If <existing window name> is specified, then WDESC's window partitioning clause is
                       the window partitioning clause of WDX.



334 Foundation (SQL/Foundation)                                                             ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                                           7.11 <window clause>



                      C) Otherwise, WDESC has no window partitioning.
                  5) Case:
                      A) If WDEF simply contains <window order clause> WDEFWOC, then WDESC's window
                         ordering clause is WDEFWOC.
                      B) If <existing window name> is specified, then WDESC's window ordering clause is the
                         window ordering clause of WDX.
                      C) Otherwise, WDESC has no window ordering.
                  6) If WDEF simply contains <window frame clause> WDEFWFC, then WDESC's window
                     framing clause is WDEFWFC; otherwise, WDESC has no windows framing.
         ii)      The result of <window clause> is RTE, together with the window structure descriptors defined
                  by the <window clause>.
2) Let WD be a window structure descriptor.
3) WD defines, for each row R of RTE, the window partition of R under WD, consisting of the collection of
   rows of RTE that are not distinct from R in the window partitioning columns of WD. If WD has no window
   partitioning clause, then the window partition of R is the entire result RTE.
4) WD also defines the window ordering of the rows of each window partition defined by WD, according to
   the General Rules of Subclause 10.10, “<sort specification list>”, using the <sort specification list> simply
   contained in WD's window ordering clause. If WD has no window ordering clause, then the window
   ordering is implementation-dependent, and all rows are peers. Although the window ordering of peer rows
   within a window partition is implementation-dependent, the window ordering shall be the same for all
   window structure descriptors that are order-equivalent. It shall also be the same for any pair of windows
   W1 and W2 such that W1 is the ordering window for W2.
5) WD also defines for each row R of RTE the window frame WF of R, consisting of a collection of rows. WF
   is defined as follows.
    Case:
    a) If WD has no window framing clause, then
         Case:
         i)       If the window ordering clause of WD is not present, then WF is the window partition of R.
         ii)      Otherwise, WF consists of all rows of the partition of R that precede R or are peers of R in the
                  window ordering of the window partition defined by the window ordering clause.
    b) Otherwise, let WF initially be the window partition of R defined by WD. Let WFC be the window
       framing clause of WD. Let WFB1 be the <window frame bound 1> and let WFB2 be the <window
       frame bound 2> contained in WFC.
         i)       If RANGE is specified, then:
                  1) In the following subrules, when performing addition or subtraction to combine a datetime
                     and a year-month interval, if the result would raise the exception condition data exception
                     — datetime field overflow because the <primary datetime field> DAY is not valid for the
                     computer value of the <primary datetime field>s YEAR and MONTH, then the <primary


©ISO/IEC 2003 – All rights reserved                                                        Query expressions 335
ISO/IEC 9075-2:2003 (E)
7.11 <window clause>



                 datetime field> DAY is set to the last day that is valid for the <primary datetime field>s
                 YEAR and MONTH, and no exception condition is raised.
              2) Case:
                 NOTE 151 — In the following subrules, if WFB1 specifies UNBOUNDED PRECEDING, then no rows are
                 removed from WF by this step. WFB1 may not be UNBOUNDED FOLLOWING.

                 A) If WFB1 specifies <window frame preceding>, then let V1P be the value of the <unsigned
                    value specification>.
                     Case:
                     I)      If V1P is negative or the null value, then an exception condition is raised: data
                             exception — invalid preceding or following size in window function.
                     II)     Otherwise, let SK be the only <sort key> contained in the window ordering clause
                             of WD. Let VSK be the value of SK for the current row.
                             Case:
                             1) If VSK is the null value and if NULLS LAST is specified or implied, then
                                remove from WF all rows R2 such that the value of SK in row R2 is not the
                                null value.
                             2) If VSK is not the null value, then:
                                 a) If NULLS FIRST is specified or implied, then remove from WF all rows
                                    R2 such that the value of SK in row R2 is the null value.
                                 b) Case:
                                     i)     If the <ordering specification> contained in the window ordering
                                            clause specifies DESC, then let BOUND be the value VSK+V1P.
                                            Remove from WF all rows R2 such that the value of SK in row
                                            R2 is greater than BOUND.
                                     ii)    Otherwise, let BOUND be the value VSK–V1P. Remove from WF
                                            all rows R2 such that the value of SK in row R2 is less than
                                            BOUND.
                 B) If WFB1 specifies CURRENT ROW, then remove from WF all rows that are not peers
                    of the current row and that precede the current row in the window ordering defined by
                    WD.
                 C) If WFB1 specifies <window frame following>, then let V1F be the value of the <unsigned
                    value specification>.
                     Case:
                     I)      If V1F is negative or the null value, then an exception condition is raised: data
                             exception — invalid preceding or following size in window function.
                     II)     Otherwise, let SK be the only <sort key> contained in the window ordering clause
                             of WD. Let VSK be the value of SK for the current row.
                             Case:


336 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                              ISO/IEC 9075-2:2003 (E)
                                                                                                7.11 <window clause>



                                      1) If VSK is the null value and if NULLS LAST is specified or implied, then
                                         remove from WF all rows R2 such that the value of SK in row R2 is not the
                                         null value.
                                      2) If VSK is not the null value, then:
                                          a) If NULLS FIRST is specified or implied, then remove from WF all rows
                                             R2 such that the value of SK in row R2 is the null value.
                                          b) Case:
                                              i)     If the <ordering specification> contained in the window ordering
                                                     clause specifies DESC, then let BOUND be the value VSK–V1F.
                                                     Remove from WF all rows R2 such that the value of SK in row
                                                     R2 is greater than BOUND.
                                              ii)    Otherwise, let BOUND be the value VSK+V1F. Remove from WF
                                                     all rows R2 such that the value of SK in row R2 is less than
                                                     BOUND.
                  3) Case:
                      NOTE 152 — In the following subrules, if WFB2 specifies UNBOUNDED FOLLOWING, then no rows are
                      removed from WF by this step. WFB2 may not be UNBOUNDED PRECEDING.

                      A) If WFB2 specifies <window frame preceding>, then let V2P be the value of the <unsigned
                         value specification>.
                           Case:
                           I)         If V2P is negative or the null value, then an exception condition is raised: data
                                      exception — invalid preceding or following size in window function.
                           II)        Otherwise, let SK be the only <sort key> contained in the window ordering clause
                                      of WD. Let VSK be the value of SK for the current row.
                                      Case:
                                      1) If VSK is the null value and if NULLS FIRST is specified or implied, then
                                         remove from WF all rows R2 such that the value of SK in row R2 is not the
                                         null value.
                                      2) If VSK is not the null value, then:
                                          a) If NULLS LAST is specified or implied, then remove from WF all rows
                                             R2 such that the value of SK in row R2 is the null value.
                                          b) Case:
                                              i)     If the <ordering specification> contained in the window ordering
                                                     clause specifies DESC, then let BOUND be the value VSK+V2P.
                                                     Remove from WF all rows R2 such that the value of SK in row
                                                     R2 is less than BOUND.




©ISO/IEC 2003 – All rights reserved                                                             Query expressions 337
ISO/IEC 9075-2:2003 (E)
7.11 <window clause>



                                     ii)    Otherwise, let BOUND be the value VSK–V2P. Remove from WF
                                            all rows R2 such that the value of SK in row R2 is greater than
                                            BOUND.
                 B) If WFB2 specifies CURRENT ROW, then remove from WF all rows following the
                    current row in the ordering defined by WD that are not peers of the current row.
                 C) If WFB2 specifies <window frame following>, then let V2F be the value of the <unsigned
                    value specification>.
                     Case:
                     I)      If V2F is negative or the null value, then an exception condition is raised: data
                             exception — invalid preceding or following size in window function.
                     II)     Otherwise, let SK be the only <sort key> contained in the window ordering clause
                             of WD. Let VSK be the value of SK for the current row.
                             Case:
                             1) If VSK is the null value and if NULLS FIRST is specified or implied, then
                                remove from WF all rows R2 such that the value of SK in row R2 is not the
                                null value.
                             2) If VSK is not the null value, then:
                                 a) If NULLS LAST is specified or implied, then remove from WF all rows
                                    R2 such that the value of SK in row R2 is the null value.
                                 b) Case:
                                     i)     If the <ordering specification> contained in the <window order
                                            clause> specifies DESC, then let BOUND be the value VSK–V2F.
                                            Remove from WF all rows R2 such that the value of SK in row
                                            R2 is less than BOUND.
                                     ii)    Otherwise, let BOUND be the value VSK+V2F. Remove from WF
                                            all rows R2 such that the value of SK in row R2 is greater than
                                            BOUND.
       ii)    If ROWS is specified, then:
              1) Case:
                 NOTE 153 — In the following subrules, if WFB1 specifies UNBOUNDED PRECEDING, then no rows are
                 removed from WF by this step. WFB1 may not be UNBOUNDED FOLLOWING.

                 A) If WFB1 specifies <window frame preceding>, then let V1P be the value of the <unsigned
                    value specification>.
                     Case:
                     I)      If V1P is negative or the null value, then an exception condition is raised: data
                             exception — invalid preceding or following size in window function.
                     II)     Otherwise, remove from WF all rows that are more than V1P rows preceding the
                             current row in the window ordering defined by WD.


338 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                                                         7.11 <window clause>



                      B) If WFB1 specifies CURRENT ROW, then remove from WF all rows that precede the
                         current row in the window ordering defined by WD.
                           NOTE 154 — This step removes any peers of the current row that precede it in the implementation-
                           dependent window ordering.

                      C) If WFB1 specifies <window frame following>, then let V1F be the value of the <unsigned
                         value specification>.
                           Case:
                           I)         If V1F is negative or the null value, then an exception condition is raised: data
                                      exception — invalid preceding or following size in window function.
                           II)        Otherwise, remove from WF all rows that precede the current row and all rows
                                      that are less than V1F rows following the current row in the window ordering
                                      defined by WD.
                                      NOTE 155 — If V1F is zero, then the current row is not removed from WF by this step; otherwise,
                                      the current row is removed from WF.

                  2) Case:
                      NOTE 156 — In the following subrules, if WFB2 specifies UNBOUNDED FOLLOWING, then no rows are
                      removed from WF by this step. WFB2 may not be UNBOUNDED PRECEDING.

                      A) If WFB2 specifies <window frame preceding>, then let V2P be the value of the <unsigned
                         value specification>.
                           Case:
                           I)         If V2P is negative or the null value, then an exception condition is raised: data
                                      exception — invalid preceding or following size in window function.
                           II)        Otherwise, remove from WF all rows that follow the current row and all rows
                                      that are less than V2P rows preceding the current row in the window ordering
                                      defined by WD.
                                      NOTE 157 — If V2P is zero, then the current row is not removed from WF by this step; otherwise,
                                      the current row is removed from WF.

                      B) If WFB2 specifies CURRENT ROW, then remove from WF all rows that follow the
                         current row in the window ordering defined by WD.
                           NOTE 158 — This step removes any peers of the current row that follow it in the implementation-dependent
                           window ordering.

                      C) If WFB2 specifies <window frame following>, then let V2F be the value of the <unsigned
                         value specification>.
                           Case:
                           I)         If V2F is negative or the null value, then an exception condition is raised: data
                                      exception — invalid preceding or following size in window function.
                           II)        Otherwise, remove from WF all rows that are more than V2F rows following the
                                      current row in the window ordering defined by WD.
         iii)     If <window frame exclusion> WFE is specified, then


©ISO/IEC 2003 – All rights reserved                                                                      Query expressions 339
ISO/IEC 9075-2:2003 (E)
7.11 <window clause>



                Case:
                1) If EXCLUDE CURRENT ROW is specified and the current row is still a member of WF,
                   then remove the current row from WF.
                2) If EXCLUDE GROUP is specified, then remove the current row and any peers of the current
                   row from WF.
                3) If EXCLUDE TIES is specified, then remove any rows other than the current row that are
                   peers of the current row from WF.
                    NOTE 159 — If the current row is already removed from WF, then it remains removed from WF.
                NOTE 160 — If EXCLUDE NO OTHERS is specified, then no additional rows are removed from WF by this Rule.


Conformance Rules
1) Without Feature T611, “Elementary OLAP operations”, conforming SQL language shall not contain a
   <window specification>.
2) Without Feature T612, “Advanced OLAP operations”, conforming SQL language shall not contain a
   <window clause>.
3) Without Feature T612, “Advanced OLAP operations”, conforming SQL language shall not contain an
   <existing window name>.
4) Without Feature T301, “Functional dependencies”, in conforming SQL language, if T is a grouped table,
   then each column reference contained in <window clause> that references a column of T shall be a reference
   to a grouping column of T or be contained in an aggregated argument of a <set function specification>.
5) Without Feature T612, “Advanced OLAP operations”, conforming SQL language shall not contain a
   <window frame exclusion>.
    NOTE 161 — The Conformance Rules of Subclause 9.10, “Grouping operations”, also apply.




340 Foundation (SQL/Foundation)                                                          ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                                   7.12 <query specification>



7.12 <query specification>

Function
Specify a table derived from the result of a <table expression>.


Format
<query specification> ::=
    SELECT [ <set quantifier> ] <select list> <table expression>

<select list> ::=
    <asterisk>
  | <select sublist> [ { <comma> <select sublist> }... ]

<select sublist> ::=
    <derived column>
  | <qualified asterisk>

<qualified asterisk> ::=
    <asterisked identifier chain> <period> <asterisk>
  | <all fields reference>

<asterisked identifier chain> ::=
    <asterisked identifier> [ { <period> <asterisked identifier> }... ]

<asterisked identifier> ::= <identifier>

<derived column> ::= <value expression> [ <as clause> ]

<as clause> ::= [ AS ] <column name>

<all fields reference> ::=
    <value expression primary> <period> <asterisk>
    [ AS <left paren> <all fields column name list> <right paren> ]

<all fields column name list> ::= <column name list>


Syntax Rules
1) Let T be the result of the <table expression>.
2) Let TQS be the table that is the result of a <query specification>.
3) Case:
    a) If the <select list> “*” is simply contained in a <subquery> that is immediately contained in an <exists
       predicate>, then the <select list> is equivalent to a <value expression> that is an arbitrary <literal>.
    b) Otherwise, the <select list> “*” is equivalent to a <value expression> sequence in which each <value
       expression> is a column reference that references a column of T and each column of T is referenced
       exactly once. The columns are referenced in the ascending sequence of their ordinal position within T.



©ISO/IEC 2003 – All rights reserved                                                    Query expressions 341
ISO/IEC 9075-2:2003 (E)
7.12 <query specification>



4) The degree of the table specified by a <query specification> is equal to the cardinality of the <select list>.
5) If a <set quantifier> DISTINCT is specified, then each column of T is an operand of a grouping operation.
   The Syntax Rules of Subclause 9.10, “Grouping operations”, apply.
6) The ambiguous case of an <all fields reference> whose <value expression primary> takes the form of an
   <asterisked identifier chain> shall be analyzed first as an <asterisked identifier chain> to resolve the
   ambiguity.
7) If <asterisked identifier chain> is specified, then:
    a) Let IC be an <asterisked identifier chain>.
    b) Let N be the number of <asterisked identifier>s immediately contained in IC.

    c) Let Ii, 1 (one) ≤ i ≤ N, be the <asterisked identifier>s immediately contained in IC, in order from left
       to right.
    d) Let PIC1 be I1. For each J between 2 and N, let PICJ be PICJ-1.IJ. PICJ is called the J-th partial iden-
       tifier chain of IC.
    e) Let M be the minimum of N and 3.
    f) For at most one J between 1 and M, PICJ is called the basis of IC, and J is called the basis length of
       IC. The referent of the basis is a table T, a column C of a table, or an SQL parameter SP. The basis
       and basis scope of IC are defined in terms of a candidate basis, according to the following rules:
        i)     If IC is contained in the scope of a <routine name> whose associated <SQL parameter declaration
               list> includes an SQL parameter SP whose <SQL parameter name> is equivalent to I1, then
               PIC1 is a candidate basis of IC, and the scope of PIC1 is the scope of SP.

        ii)    If N = 2 and PIC1 is equivalent to the <qualified identifier> of a <routine name> RN whose
               scope contains IC and whose associated <SQL parameter declaration list> includes an SQL
               parameter SP whose <SQL parameter name> is equivalent to I2, then PIC2 is a candidate basis
               of IC, the scope of PIC2 is the scope of SP, and the referent of PIC2 is SP.

        iii)   If N > 2 and PIC1 is equivalent to the <qualified identifier> of a <routine name> RN whose
               scope contains IC and whose associated <SQL parameter declaration list> includes a refinable
               SQL parameter SP whose <SQL parameter name> is equivalent to I2, then PIC2 is a candidate
               basis of IC, the scope of PIC2 is the scope of SP, and the referent of PIC2 is SP.

        iv)    If N = 2 and PIC1 is equivalent to an exposed <correlation name> that is in scope, then let EN
               be the exposed <correlation name> that is equivalent to PIC1 and has innermost scope. If the
               table associated with EN has a column C of row type whose <identifier> is equivalent to I2, then
               PIC2 is a candidate basis of IC and the scope of PIC2 is the scope of EN.

        v)     If N > 2 and PIC1 is equivalent to an exposed <correlation name> that is in scope, then let EN
               be the exposed <correlation name> that is equivalent to PIC1 and has innermost scope. If the
               table associated with EN has a column C of row type or structured type whose <identifier> is
               equivalent to I2, then PIC2 is a candidate basis of IC and the scope of PIC2 is the scope of EN.



342 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                                    7.12 <query specification>



         vi)      If N ≤ 3 and PICN is equivalent to an exposed <table or query name> that is in scope, then let
                  EN be the exposed <table or query name> that is equivalent to PICN and has the innermost
                  scope. PICN is a candidate basis of IC, and the scope of PICN is the scope of EN.

         vii)     There shall be exactly one candidate basis CB with innermost scope. The basis of IC is CB. The
                  basis scope is the scope of CB.
    g) Case:
         i)       If the basis is a <table or query name> or <correlation name>, then let TQ be the table associated
                  with the basis. The <select sublist> is equivalent to a <value expression> sequence in which
                  each <value expression> is a column reference CR that references a column of TQ that is not a
                  common column of a <joined table>. Each column of TQ that is not a referenced common column
                  shall be referenced exactly once. The columns shall be referenced in the ascending sequence of
                  their ordinal positions within TQ.
         ii)      Otherwise let BL be the length of the basis of IC.
                  Case:
                  1) If BL = N, then the <select sublist> IC.* is equivalent to (IC).*.
                  2) Otherwise, the <select sublist> IC.* is equivalent to:
                           ( PICBL ) . IBL+1 . ...             . IN . *

                      NOTE 162 — The equivalent syntax in either case will be analyzed as <all fields reference> ::= <value expression
                      primary> <period> <asterisk>

8) The data type of the <value expression primary> VEP specified in an <all fields reference> AFR shall be
   some row type VER. Let n be the degree of VER. Let F1, ..., FN be the field names of VER.

    Case:
    a) If <all fields column name list> AFCNL is specified, then the number of <column name>s simply
       contained in AFCNL shall be n. Let AFCNi, 1 (one) ≤ i ≤ n, be these <column name>s in order from
       left to right. AFR is equivalent to
               VEP . F1 AS AFCN1, ... , VEP . Fn AS AFCNn)

    b) Otherwise, AFR is equivalent to:
               VEP . F1 , ... , VEP . Fn

9) Let C be some column. Let QS be the <query specification>. Let DCi, for i ranging from 1 (one) to the
   number of <derived column>s inclusively, be the i-th <derived column> simply contained in the <select
   list> of QS. For all i, C is an underlying column of DCi, and of any column reference that identifies DCi,
   if and only if C is an underlying column of the <value expression> of DCi, or C is an underlying column
   of the <table expression> immediately contained in QS.
10) Each column reference contained in a <window function> shall unambiguously reference a column of T.
11) If both of the following two conditions are satisfied, then QS is a grouped, windowed query:


©ISO/IEC 2003 – All rights reserved                                                                      Query expressions 343
ISO/IEC 9075-2:2003 (E)
7.12 <query specification>



   a) T is a grouped table.
   b) Some <derived column> simply contained in QS simply contains a <window function>.
12) A grouped, windowed query GWQ is transformed to an equivalent <query specification> as follows:
   a) If GWQ contains an <in-line window specification>, then apply the syntactic transformation specified
      in Subclause 6.10, “<window function>”.
   b) If the <select list> of GWQ contains <asterisk> or <qualified asterisk>, then apply the syntactic trans-
      formations specified in Subclause 7.12, “<query specification>”.
   c) Let GWQ2 be the result of the preceding transformations, if any.
   d) Let SL, FC, WC, GBC, HC, and WIC be the <select list>, <from clause>, <where clause>, <group by
      clause>, <having clause>, and <window clause>, respectively, of GWQ2. If any of <where clause>,
      <group by clause>, or <having clause>, are missing, then let WC, GBC, and HC, respectively, be a
      zero-length string. Let SQ be the <set quantifier> immediately contained in the <query specification>
      of GWQ2, if any; otherwise, let SQ be a zero-length string.
        NOTE 163 — GWQ2 can not lack a <window clause>, since the syntactic transformation of Subclause 6.10, “<window
        function>”, will create one if there is not one in GWQ already.

   e) Let N1 be the number of <set function specification>s simply contained in GWQ2.

   f) Let SFSi, 1 (one) ≤ i ≤ N1, be an enumeration of the <set function specification>s simply contained in
      GWQ2.

   g) Let SFSIi, 1 (one) ≤ i ≤ N1, be a list of <identifier>s that are distinct from each other and distinct from
      all <identifier>s contained in GWQ2.
   h) If N1 = 0 (zero), then let SFSL be a zero-length string; otherwise, let SFSL be:
           SFS1 AS SFSI1, SFS2 AS SFSI2, ..., SFSN1 AS SFSIN1

   i)   Let HCNEW be obtained from HC by replacing each <set function specification> SFSi by the corre-
        sponding <identifier> SFSIi .

   j)   Let N2 be the number of <column reference>s that are contained in SL or WIC without an intervening
        <subquery> or <set function specification>.

   k) Let CRj, 1 (one) ≤ j ≤ N2, be an enumeration of the <column reference>s that are contained in SL or
      WIC without an intervening <subquery> or <set function specification>.

   l)   Let CRIj, 1 (one) ≤ j ≤ N2, be a list of <identifier>s that are distinct from each other, distinct from all
        identifiers in GWQ2, and distinct from all SFSIi.

   m) If N2 = 0 (zero), then let CRL be a zero-length string; otherwise, let CRL be:
           CR1 AS CRI1, CR2 AS CRI2, ..., CRN2 AS CRIN2

   n) Let N3 be the number of <derived column>s simply contained in SL that do not specify <as clause>.



344 Foundation (SQL/Foundation)                                                          ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                                   7.12 <query specification>



    o) Let DCOLk, 1 (one) ≤ k ≤ N3, be the <derived column>s simply contained in SL that do not specify an
       <as clause>. For each k, let COLNk be the <column name> determined as follows.

         Case:
         i)       If DCOLk is a single column reference, then let COLNk be the <column name> of the column
                  designated by the column reference.
         ii)      Otherwise, let COLNk be an implementation-dependent <column name>,

    p) Let SL2 be obtained from SL by replacing each <derived column> DCOLk by

               DCOLk AS COLNk

    q) Let GWQN be an arbitrary <identifier>.
    r) Let SLNEW be the <select list> obtained from SL2 by replacing each simply contained <set function
       specification> SFSi by GWQN.SFSIi and replacing each <column reference> CRj that is contained
       without an intervening <subquery> or <set function specification> by GWQN.CRIj.

    s) Let WICNEW be the <window clause> obtained from WIC by replacing each <set function specification>
       SFSi by GWQN.SFSIi and by replacing each <column reference> CRj by GWQN.CRIj.

    t)   If either SFSL or CRL is a zero-length string, then let COMMA be a zero-length string; otherwise, let
         COMMA be “,” (a <comma>).
    u) GWQ is equivalent to the following <query specification>:
               SELECT SLNEW
               FROM ( SELECT SQ SFSL COMMA CRL
                      FC
                      WC
                      GBC
                      HC ) AS GWQN
               WICNEW


13) A <query specification> is possibly non-deterministic if any of the following conditions are true:
    a) The <set quantifier> DISTINCT is specified and one of the columns of T has a data type of character
       string, user-defined type, TIME WITH TIME ZONE, or TIMESTAMP WITH TIME ZONE.
    b) The <query specification> generally contains a <value expression>, <query specification>, or <query
       expression> that is possibly non-deterministic.
    c) The <select list>, <having clause>, or <window clause> contains a reference to a column C of T that
       has a data type of character string, user-defined type, TIME WITH TIME ZONE, or TIMESTAMP
       WITH TIME ZONE, and the functional dependency G ↦ C, where G is the set consisting of the
       grouping columns of T, holds in T.
14) If <table expression> does not immediately contain a <group by clause> and <table expression> is simply
    contained in a <query expression> that is the aggregation query of some <set function specification>, then
    GROUP BY () is implicit.



©ISO/IEC 2003 – All rights reserved                                                    Query expressions 345
ISO/IEC 9075-2:2003 (E)
7.12 <query specification>



    NOTE 164 — “aggregation query” is defined in Subclause 6.9, “<set function specification>”.

15) If T is a grouped table, then let G be the set of grouping columns of T. In each <value expression> contained
    in <select list> , each column reference that references a column of T shall reference some column C that
    is functionally dependent on G or shall be contained in an aggregated argument of a <set function specifi-
    cation> whose aggregation query is QS.
    NOTE 165 — See also the Syntax Rules of Subclause 6.7, “<column reference>”.

16) Each column of TQS has a column descriptor that includes a data type descriptor that is the same as the
    data type descriptor of the <value expression> simply contained in the <derived column> defining that
    column.
17) Case:
    a) If the i-th <derived column> in the <select list> specifies an <as clause> that contains a <column name>
       CN, then the <column name> of the i-th column of the result is CN.
    b) If the i-th <derived column> in the <select list> does not specify an <as clause> and the <value
       expression> of that <derived column> is a single column reference, then the <column name> of the
       i-th column of the result is the <column name> of the column designated by the column reference.
    c) Otherwise, the <column name> of the i-th column of the <query specification> is implementation-
       dependent.
18) A column of TQS is known not null if and only if at least one of the following conditions applies:
    a) It is not defined by a <derived column> containing any of the following:
        i)      A column reference for a column C that is possibly nullable.
        ii)     An <indicator parameter>.
        iii)    An <indicator variable>.
        iv)     A <dynamic parameter specification>.
        v)      An SQL parameter.
        vi)     A <routine invocation>, <method reference>, or <method invocation> whose subject routine is
                an SQL-invoked routine that either is an SQL routine or is an external routine that specifies or
                implies PARAMETER STYLE SQL.
        vii)    A <subquery>.
        viii)   CAST ( NULL AS X ) (where X represents a <data type> or a <domain name>).
        ix)     A <window function> whose <window function type> does not contain <rank function type>,
                ROW_NUMBER, or an <aggregate function> that simply contains COUNT.
        x)      CURRENT_USER, CURRENT_ROLE, or SYSTEM_USER.
        xi)     A <set function specification> that does not contain COUNT.
        xii)    A <case expression>.
        xiii)   A <field reference>.



346 Foundation (SQL/Foundation)                                                              ©ISO/IEC 2003 – All rights reserved
                                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                                                 7.12 <query specification>



         xiv)     An <array element reference>.
         xv)      A <multiset element reference>.
         xvi)     A <dereference operation>.
         xvii) A <reference resolution>.
         xviii) A <comparison predicate>, <between predicate>, <in predicate>, or <quantified comparison
                predicate> P such that the declared type of a field of a <row value predicand> that is simply
                contained in P is a row type, a user-defined type, an array type, or a multiset type.
         xix)     A <member predicate>.
         xx)      A <submultiset predicate>.
    b) An implementation-defined rule by which the SQL-implementation can correctly deduce that the value
       of the column cannot be null.
19) Let TREF be the <table reference>s that are simply contained in the <from clause> of the <table expression>.
    The simply underlying tables of the <query specification> are the <table or query name>s and <derived
    table>s contained in TREF without an intervening <derived table>.
20) The terms key-preserving and one-to-one are defined as follows:
    a) Let UT denote some simply underlying table of QS, let UTCOLS be the set of columns of UT, let
       QSCOLS be the set of columns of QS, and let QSCN be an exposed range variable for UT whose scope
       clause is QS.
    b) QS is said to be key-preserving with respect to UT if there is some strong candidate key CKUT of UT
       such that every member of CKUT has some counterpart under QSCN in QSCOLS.
         NOTE 166 — “strong candidate key” is defined in Subclause 4.19, “Candidate keys”.
         NOTE 167 — “Counterpart” is defined in Subclause 4.18.2, “General rules and definitions”. It follows from this condition
         that every row in QS corresponds to exactly one row in UT, namely that row in UT that has the same combined value in the
         columns of CKUT as the row in QS. There may be more than one row in QS that corresponds to a single row in UT.

    c) QS is said to be one-to-one with respect to UT if and only if QS is key-preserving with respect to UT,
       UT is updatable, and there is some strong candidate key CKQS of QS such that every member of CKQS
       is a counterpart under UT of some member of UTCOLS.
         NOTE 168 — It follows from this condition that every row in UT corresponds to at most one row in QS, namely that row in
         QS that has the same combined value in the columns of CKQS as the row in UT.

21) A <query specification> is potentially updatable if and only if the following conditions hold:
    a) DISTINCT is not specified.
    b) Of those <derived column>s in the <select list> that are column references that have a counterpart in
       a base table, no column of a table table is referenced more than once in the <select list>.
    c) The <table expression> immediately contained in QS does not simply contain an explicit or implicit
       <group by clause> or a <having clause>.
22) If a <query specification> QS is potentially updatable, then
    Case:



©ISO/IEC 2003 – All rights reserved                                                                   Query expressions 347
ISO/IEC 9075-2:2003 (E)
7.12 <query specification>



    a) If the <from clause> of the <table expression> specifies exactly one <table reference>, then a column
       of QS is said to be a potentially updatable column if it has a counterpart in TR that is updatable.
        NOTE 169 — The notion of updatable columns of table references is defined in Subclause 7.6, “<table reference>”.

    b) Otherwise, a column of QS is said to be a potentially updatable column if it has a counterpart in some
       updatable column of some simply underlying table UT of QS such that QS is one-to-one with respect
       to UT.
23) A <query specification> is updatable if it is potentially updatable and it has at least one potentially updatable
    column.
24) A <query specification> QS is simply updatable if the following conditions hold:
    a) QS is updatable.
    b) The <from clause> immediately contained in the <table expression> immediately contained in QS
       contains exactly one <table reference>, and the table referenced by that <table reference> is simply
       updatable.
    c) Every result column of QS is updatable.
    d) If the <table expression> immediately contained in QS immediately contains a <where clause> WC,
       then no leaf generally underlying table of QS is a generally underlying table of any <query expression>
       contained in WC.
25) A <query specification> QS is insertable-into if and only if every simply underlying table of QS is insertable-
    into.
26) A column C of QS is updatable if at least one of the following is true:
    a) QS is simply updatable.
    b) QS is updatable, C is potentially updatable, and the SQL implementation supports Feature T111,
       “Updatable joins, unions, and columns”.
27) The row type RT of TQS is defined by the sequence of (<field name>, <data type>) pairs indicated by the
    sequence of column descriptors of TQS taken in order.


Access Rules
    None.


General Rules
1) If QS is contained in a <subquery> SQ, then certain <set function specification>s and outer references are
   resolved, such that their values are constant for every row in the result of QS, as follows:
    Case:
    a) If SQ is being evaluated for a given group G, then, for every <set function specification> SFS contained
       in QS such that the aggregation query of SFS simply contains the <table expression> of whose result
       G is a group, the value of SFS is the result of evaluating SFS for G.



348 Foundation (SQL/Foundation)                                                              ©ISO/IEC 2003 – All rights reserved
                                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                                    7.12 <query specification>



    b) Otherwise, let R be the row for which SQ is being evaluated. For every <column reference> CR contained
       in SQ that is an outer reference whose qualifying scope is simply contained in a <query specification>
       that contains SQ, the value of CR is the value of the field in R corresponding to the column referenced
       by CR.
    NOTE 170 — An expression having been resolved under this rule is not resolved again in the case where it is contained in a <query
    expression> contained in SQ.
    NOTE 171 — The circumstances in which a <subquery> is evaluated for a given group, rather than a given row, are defined in
    the General Rules of this Subclause and the General Rules of Subclause 7.10, “<having clause>”.

2) Case:
    a) If T is not a grouped table, then each <value expression> is applied to each row of T yielding a table
       TEMP of M rows, where M is the cardinality of T. The i-th column of the table contains the values
       derived by the evaluation of the i-th <value expression>.
    b) If T is a grouped table, then
         Case:
         i)       If T has 0 (zero) groups, then let TEMP be an empty table.
         ii)      If T has one or more groups, then each <value expression> is applied to each group of T yielding
                  a table TEMP of M rows, where M is the number of groups in T. The i-th column of TEMP
                  contains the values derived by the evaluation of the i-th <value expression>. When a <value
                  expression> is applied to a given group of T, that group is the argument source of each <set
                  function specification> in the <value expression>.
3) Case:
    a) If the <set quantifier> DISTINCT is not specified, then the result of the <query specification> is TEMP.
    b) If the <set quantifier> DISTINCT is specified, then the result of the <query specification> is the table
       derived from TEMP by the elimination of all redundant duplicate rows. If the most specific type of any
       column is character string, datetime with time zone, or a user-defined type, then the precise values in
       those columns are chosen in an implementationdependent fashion.


Conformance Rules
1) Without Feature F801, “Full set function”, conforming SQL language shall not contain a <query specifica-
   tion> that contains more than 1 (one) <set quantifier> that contains DISTINCT, excluding any <subquery>
   of that <query specification>.
2) Without Feature T051, “Row types”, conforming SQL language shall not contain an <all fields reference>.
3) Without Feature T301, “Functional dependencies”, in conforming SQL language, if T is a grouped table,
   then in each <value expression> contained in the <select list>, each <column reference> that references a
   column of T shall reference a grouping column or be specified in an aggregated argument of a <set function
   specification>.
4) Without Feature T325, “Qualified SQL parameter references”, conforming SQL language shall not contain
   an <asterisked identifier chain> whose referent is an SQL parameter and whose first <identifier> is the
   <qualified identifier> of a <routine name>.



©ISO/IEC 2003 – All rights reserved                                                                     Query expressions 349
ISO/IEC 9075-2:2003 (E)
7.12 <query specification>



5) Without Feature T053, “Explicit aliases for all-fields reference”, conforming SQL language shall not contain
   an <all fields column name list>.
    NOTE 172 — If a <set quantifier> DISTINCT is specified, then the Conformance Rules of Subclause 9.10, “Grouping operations”,
    also apply.




350 Foundation (SQL/Foundation)                                                              ©ISO/IEC 2003 – All rights reserved
                                                                     ISO/IEC 9075-2:2003 (E)
                                                                     7.13 <query expression>



7.13 <query expression>

Function
Specify a table.


Format
<query expression> ::=
    [ <with clause> ] <query expression body>

<with clause> ::=
    WITH [ RECURSIVE ] <with list>

<with list> ::=
    <with list element> [ { <comma> <with list element> }... ]

<with list element> ::=
    <query name> [ <left paren> <with column list> <right paren> ]
    AS <left paren> <query expression> <right paren> [ <search or cycle clause> ]

<with column list> ::= <column name list>

<query expression body> ::=
    <query term>
  | <query expression body> UNION [ ALL | DISTINCT ]
    [ <corresponding spec> ] <query term>
  | <query expression body> EXCEPT [ ALL | DISTINCT ]
    [ <corresponding spec> ] <query term>

<query term> ::=
    <query primary>
  | <query term> INTERSECT [ ALL | DISTINCT ]
    [ <corresponding spec> ] <query primary>

<query primary> ::=
    <simple table>
  | <left paren> <query expression body> <right paren>

<simple table> ::=
    <query specification>
  | <table value constructor>
  | <explicit table>

<explicit table> ::= TABLE <table or query name>

<corresponding spec> ::=
    CORRESPONDING [ BY <left paren> <corresponding column list> <right paren> ]

<corresponding column list> ::= <column name list>




©ISO/IEC 2003 – All rights reserved                                   Query expressions 351
ISO/IEC 9075-2:2003 (E)
7.13 <query expression>



Syntax Rules
1) Let QE be the <query expression>.
2) If <with clause> is specified, then:
    a) If a <with clause> WC immediately contains RECURSIVE, then WC, its <with list>, and its <with list
       element>s are said to be potentially recursive. Otherwise they are said to be non-recursive.

    b) Let n be the number of <with list element>s. For each i , 1 (one) ≤ i < n, for each j, i < j ≤ n, the j-th
       <with list element> shall not immediately contain a <query name> that is equivalent to the <query
       name> immediately contained in the i-th <with list element>.
    c) If the <with clause> is non-recursive, then for all i between 1 (one) and n, the scope of the <query
       name> WQN immediately contained in the i-th <with list element> WLEi is the <query expression>
       immediately contained in every <with list element> WLEk, where k ranges from i+1 to n, and the <query
       expression body> immediately contained in <query expression>. A <table or query name> contained
       in this scope that immediately contains WQN is a query name in scope.
    d) If the <with clause> is potentially recursive, then for all i between 1 (one) and n, the scope of the <query
       name> WQN immediately contained in the i-th <with list element> WLEi is the <query expression>
       immediately contained in every <with list element> WLEk, where k ranges from 1 (one) to n, and the
       <query expression body> immediately contained in <query expression>. A <table or query name>
       contained in this scope that immediately contains WQN is a query name in scope.
    e) For every <with list element> WLE, let WQE be the <query expression> specified by WLE and let WQT
       be the table defined by WQE.
        i)     If any two columns of WQT have equivalent names or if WLE is potentially recursive, then WLE
               shall specify a <with column list>. If WLE specifies a <with column list> WCL, then:
               1) Equivalent <column name>s shall not be specified more than once in WCL.
               2) The number of <column name>s in WCL shall be the same as the degree of WQT.
        ii)    Every column of a character string type in WQT shall have a declared type collation.
    f) A query name dependency graph QNDG of a potentially recursive <with list> WL is a directed graph
       such that, for i ranging from 1 (one) to the number of <query name>s simply contained in WL:
        i)     Each node represents a <query name> WQNi immediately contained in a <with list element>
               WLEi of WL.

        ii)    Each arc from a node WQNi to a node WQNj represents the fact that WQNj is referenced by a
               <query name> contained in the <query expression> immediately contained in WLEi. WQNi is
               said to depend immediately on WQNj.

    g) For a potentially recursive <with list> WL with n elements, and for i ranging from 1 (one) to n, let WLEi
       be the i-th <with list element> of WL, let WQNi be the <query name> immediately contained in WLEi,
       let WQEi be the <query expression> immediately contained in WLEi, let WQTi be the table defined by
       WQEi, and let QNDG be the query name dependency graph of WL.



352 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)
                                                                                           7.13 <query expression>



         i)       WL is said to be recursive if QNDG contains at least one cycle.
                  Case:
                  1) If QNDG contains an arc from WQNi to itself, then WLEi, WQNi, and WQTi are said to be
                     recursive. WQNi is said to belong to the stratum of WQEi.

                  2) If QNDG contains a cycle comprising WQNi, ..., WQNk, with k ≠ i, then it is said that WQNi,
                     ..., WQNk are recursive and mutually recursive to each other, WQTi, ..., WQTk are recursive
                     and mutually recursive to each other, and WLEi, ..., WLEk are recursive and mutually
                     recursive to each other.
                      For each j ranging from i to k, WQNj belongs to the stratum of WQEi,..., and WQEk.

                  3) Among the WQEi, ... WQEk of a given stratum, there shall be at least one <query expression>,
                     say WQEj, such that:

                      A) WQEj is a <query expression body> that immediately contains UNION.

                      B) WQEj has one operand that does not contain a <query name> referencing any of WQNi,
                         ..., WQNk. This operand is said to be the non-recursive operand of WQEj.

                      C) WQEj is said to be an anchor expression, and WQNj an anchor name.

                      D) Let CCCG be the subgraph of QNDG that contains no nodes other than WQNi, ..., WQNk.
                         For any anchor name WQNj, remove the arcs to those query names WQNl that are refer-
                         enced by any <query name> contained in WQEj. The remaining graph SCCGP shall not
                         contain a cycle.
         ii)      If WLEi is recursive, then

                  Case:
                  1) If WQEi contains at most one WQNk that belongs to the stratum of WQEi, then WLEi is lin-
                     early recursive.
                  2) Otherwise, let WQEi contain any two <query name>s referencing WQNk and WQNl, both
                     of which belong to the stratum of WQEi.

                      Case:
                      A) WLEi is linearly recursive if each of the following conditions is satisfied:

                           I)         WQEi does not contain a <table reference list> that contains <query name>s
                                      referencing both WQNk and WQNl.

                           II)        WQEi does not contain a <joined table> such that TR1 and TR2 are the first and
                                      second <table reference>s, respectively, and TR1 and TR2 contain <query name>s
                                      referencing WQNk and WQNl, respectively.




©ISO/IEC 2003 – All rights reserved                                                          Query expressions 353
ISO/IEC 9075-2:2003 (E)
7.13 <query expression>



                      III)   WQEi does not contain a <table expression> that immediately contains a <from
                             clause> that contains WQNk, and immediately contains a <where clause> contain-
                             ing a <subquery> that contains a <query name> referencing WQNl.

                  B) Otherwise, WLEi is said to be non-linearly recursive.

       iii)   For each WLEi, for i ranging from 1 (one) to n, and for each WQNj that belongs to the stratum
              of WQEi:

              1) WQEi shall not contain a <query expression body> that contains a <query name> referencing
                 WQNj and immediately contains EXCEPT where the right operand of EXCEPT contains
                 WQNj.

              2) WQEi shall not contain a <routine invocation> with an <SQL argument list> that contains
                 one or more <SQL argument>s that immediately contain a <value expression> that contains
                 a <query name> referencing WQNj.

              3) WQEi shall not contain a <table subquery> TSQ that contains a <query name> referencing
                 WQNj, unless TSQ is a <derived table> that is immediately contained in a <table primary>
                 that is immediately contained in a <table reference> that is immediately contained in a <from
                 clause> that is immediately contained in a <table expression> that is immediately contained
                 in a <query specification> that constitutes a <simple table> that constitutes a <query primary>
                 that constitutes a <query term> that is immediately contained in a <query expression body>
                 that is WQEi.

              4) WQEi shall not contain a <query specification> QS such that:

                  A) QS immediately contains a <table expression> TE that contains a <query name> refer-
                     encing WQNj, and

                  B) QS immediately contains a <select list> SL or TE immediately contains a <having clause>
                     HC and SL or TE contain a <set function specification>.
              5) WQEi shall not contain a <query expression body> that contains a <query name> referencing
                 WQNj and simply contains INTERSECT ALL or EXCEPT ALL.

              6) WQEi shall not contain a <qualified join> QJ in which:

                  A) QJ immediately contains a <join type> that specifies FULL and a <table reference> or
                     <table factor> that contains a <query name> referencing WQNj.

                  B) QJ immediately contains a <join type> that specifies LEFT and a <table factor> following
                     the <join type> that contains a <query name> referencing WQNj.

                  C) QJ immediately contains a <join type> that specifies RIGHT and a <table reference>
                     preceding the <join type> that contains a <query name> referencing WQNj.

              7) WQEi shall not contain a <natural join> QJ in which:

                  A) QJ immediately contains a <join type> that specifies FULL and a <table reference> or
                     <table primary> that contains a <query name> referencing WQNj.


354 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                                     7.13 <query expression>



                      B) QJ immediately contains a <join type> that specifies LEFT and a <table primary> fol-
                         lowing the <join type> that contains a <query name> referencing WQNj.

                      C) QJ immediately contains a <join type> that specifies RIGHT and a <table reference>
                         preceding the <join type> that contains a <query name> referencing WQNj.

         iv)      If WLEi is recursive, then WLEi shall be linearly recursive.

         v)       WLEi is said to be expandable if all of the following are true:

                  1) WLEi is recursive.

                  2) WLEi is linearly recursive.

                  3) WQEi is a <query expression body> that immediately contains UNION or UNION ALL.
                     Let WQEBi be the <query expression body> immediately contained in WQEi. Let QELi and
                     QTRi be the <query expression body> and the <query term> immediately contained in
                     WQEBi. WQNi shall not be contained in QELi, and QTRi shall be a <query specification>.

                  4) WQNi is not mutually recursive.

    h) If a <with list element> WLE is not expandable, then it shall not immediately contain a <search or cycle
       clause>.
3) Let T be the table specified by the <query expression>.
4) The <explicit table>
        TABLE <table or query name>
    is equivalent to the <query expression>
        ( SELECT * FROM <table or query name> )

5) Let set operator be UNION ALL, UNION DISTINCT, EXCEPT ALL, EXCEPT DISTINCT, INTERSECT
   ALL, or INTERSECT DISTINCT.
6) If UNION, EXCEPT, or INTERSECT is specified and neither ALL nor DISTINCT is specified, then
   DISTINCT is implicit.
7) <query expression> QE1 is simply updatable if for every <query expression> or <query specification>
   QE2 that is simply contained in the <query expression body> of QE1:
    a) QE1 contains QE2 without an intervening <query expression body> that specifies UNION ALL, UNION
       DISTINCT, EXCEPT ALL, or EXCEPT DISTINCT.
    b) QE1 contains QE2 without an intervening <query term> that specifies INTERSECT.
    c) QE2 is simply updatable.
8) <query expression> QE1 is updatable if for every <simple table> QE2 that is simply contained in QE1:
    a) QE2 is not a <table value constructor>.




©ISO/IEC 2003 – All rights reserved                                                    Query expressions 355
ISO/IEC 9075-2:2003 (E)
7.13 <query expression>



   b) QE1 contains QE2 without an intervening <query expression body> that specifies UNION DISTINCT,
      EXCEPT ALL, or EXCEPT DISTINCT.
   c) If QE1 simply contains a <query expression body> QEB that specifies UNION ALL, then:
       i)     QEB immediately contains a <query expression body> LO and a <query term> RO such that no
              leaf generally underlying table of LO is also a leaf generally underlying table of RO.
       ii)    For every column of QEB, the underlying columns in the tables identified by LO and RO,
              respectively, are either both updatable or not updatable.
   d) QE1 contains QE2 without an intervening <query term> that specifies INTERSECT.
   e) QE2 is updatable.
9) A table specified by a <query name> immediately contained in a <with list element> WLE is updatable if
   and only if the <query expression> simply contained in WLE is updatable.
10) A table specified by a <query name> immediately contained in a <with list element> WLE is simply
    updatable if and only if the <query expression> simply contained in WLE is simply updatable.
11) <query expression> QE1 is insertable-into if the <query expression body> of QE1 is a <query primary>
    that is one of the following:
   a) An insertable-into <query specification>.
   b) An <explicit table> that identifies a table that is insertable-into.
   c) Of the form <left paren> <query expression body> <right paren>, where the parenthesized <query
      expression body> recursively satisfies this condition.
12) A table specified by a <query name> immediately contained in a <with list element> WLE is insertable-
    into if the <query expression> simply contained in WLE is insertable-into.
13) For every <simple table> ST contained in QE,
   Case:
   a) If ST is a <query specification> QS, then the column descriptor of each column of ST is the same as
      the column descriptor of the corresponding column of QS.
   b) If ST is an <explicit table> ET, then the column descriptor of each column of ST is the same as the
      column descriptor of the corresponding column of the table identified by the <table or query name>
      contained in ET.
   c) Otherwise, the column descriptor of each column of ST is the same as the column descriptor of the
      corresponding column of the <table value constructor> immediately contained in ST.
14) For every <query primary> QP contained in QE,
   Case:
   a) If QP is a <simple table> ST, then the column descriptor of each column of QP is the same as the column
      descriptor of the corresponding column of ST.
   b) Otherwise, the column descriptor of each column of QP is the same as the column descriptor of the
      corresponding column of the <query expression body> immediately contained in QP.


356 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)
                                                                                           7.13 <query expression>



15) If a set operator is specified in a <query term> or a <query expression body>, then:
    a) Let T1, T2, and TR be respectively the first operand, the second operand, and the result of the <query
       term> or <query expression body>.
    b) Let TN1 and TN2 be the effective names for T1 and T2, respectively.
    c) If the set operator is UNION DISTINCT, EXCEPT ALL, EXCEPT DISTINCT, INTERSECT ALL,
       or INTERSECT DISTINCT, then each column of T1 and T2 is an operand of a grouping operation.
       The Syntax Rules of Subclause 9.10, “Grouping operations”, apply.
16) If a set operator is specified in a <query term> or a <query expression body>, then let OP be the set operator.
    Case:
    a) If CORRESPONDING is specified, then:
         i)       Within the columns of T1, equivalent <column name>s shall not be specified more than once
                  and within the columns of T2, equivalent <column name>s shall not be specified more than
                  once.
         ii)      At least one column of T1 shall have a <column name> that is the <column name> of some
                  column of T2.
         iii)     Case:
                  1) If <corresponding column list> is not specified, then let SL be a <select list> of those <column
                     name>s that are <column name>s of both T1 and T2 in the order that those <column name>s
                     appear in T1.
                  2) If <corresponding column list> is specified, then let SL be a <select list> of those <column
                     name>s explicitly appearing in the <corresponding column list> in the order that these
                     <column name>s appear in the <corresponding column list>. Every <column name> in the
                     <corresponding column list> shall be a <column name> of both T1 and T2.
         iv)      The <query term> or <query expression body> is equivalent to:
                     ( SELECT SL FROM TN1 ) OP ( SELECT SL FROM TN2 )

    b) If CORRESPONDING is not specified, then T1 and T2 shall be of the same degree.
17) If a <query term> is a <query primary>, then the declared type of the <query term> is that of the <query
    primary>. The column descriptor of the i-th column of the <query term> is the same as the column
    descriptor of the i-th column of the <query primary>.
18) If a <query term> immediately contains a set operator, then:
    a) Let C be the <column name> of the i-th column of T1. If the <column name> of the i-th column of T2
       is C, then the <column name> of the i-th column of TR is C; otherwise, the <column name> of the i-th
       column of TR is implementation-dependent.
    b) The declared type of the i-th column of TR is determined by applying Subclause 9.3, “Data types of
       results of aggregations”, to the declared types of the i-th column of T1 and the i-th column of T2. If
       the i-th columns of either T1 or T2 are known not nullable, then the i-th column of TR is known not
       nullable; otherwise, the i-th column of TR is possibly nullable.


©ISO/IEC 2003 – All rights reserved                                                         Query expressions 357
ISO/IEC 9075-2:2003 (E)
7.13 <query expression>



19) If a <query term> is a <query primary>, then the column descriptors of the <query term> are the same as
    the column descriptors of the <query primary>.
20) Case:
    a) If a <query expression body> is a <query term>, then the column descriptors of the <query expression
       body> are the same as the column descriptors of the <query term>.
    b) If a <query expression body> immediately contains a set operator, then:
        i)     Let C be the <column name> of the i-th column of T1. If the <column name> of the i-th column
               of T2 is C, then the <column name> of the i-th column of TR is C; otherwise, the <column name>
               of the i-th column of TR is implementation-dependent.
        ii)    If TR is not the result of an anchor expression, then the declared type of the i-th column of TR
               is determined by applying the Syntax Rules of Subclause 9.3, “Data types of results of aggrega-
               tions”, to the declared types of the i-th column of T1 and the i-th column of T2.
               Case:
               1) If the <query expression body> immediately contains EXCEPT, then if the i-th column of
                  T1 is known not nullable, then the i-th column of TR is known not nullable; otherwise, the
                  i-th column of TR is possibly nullable.
               2) Otherwise, if the i-th columns of both T1 and T2 are known not nullable, then the i-th column
                  of TR is known not nullable; otherwise, the i-th column of TR is possibly nullable.
        iii)   If TR is the result of an anchor expression ARE, then:
               1) Let l be the number of recursive tables that belong to the stratum of ARE. For j ranging from
                  1 (one) to l, let WQTj be those tables. Of the operands T1 and T2 of TR, let TNREC be the
                  operand that is the result of the non-recursive operand of ARE and let TREC be the other
                  operand. The i-th column of TR is said to be recursively referred to if there exists at least
                  one k, 1 ≤ k ≤ l, such that a column of WQTk is an underlying column of the i-th column of
                  TREC. Otherwise, that column is said to be not recursively referred to.
               2) If the i-th column of TR is not recursively referred to, then the declared type of the i-th column
                  of TR is determined by applying Subclause 9.3, “Data types of results of aggregations”, to
                  the declared types of the i-th column of T1 and the i-th column of T2. If the i-th columns of
                  either T1 or T2 are known not nullable, then the i-th column of TR is known not nullable;
                  otherwise, the i-th column of TR is possibly nullable.
               3) If the i-th column of TR is recursively referred to, then:
                   A) The i-th column of TR is possibly nullable.
                   B) Case:
                       I)      If T1 is TNREC, then if the i-th column of TR is recursively referred to, then the
                               declared type of the i-th column of TR is the same as the declared type of the i-th
                               column of T1.




358 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                               ISO/IEC 9075-2:2003 (E)
                                                                                               7.13 <query expression>



                           II)        If T2 is TNREC, then if the i-th column of TR is recursively referred to, then the
                                      declared type of the i-th column of TR is the same as the declared type of the i-th
                                      column of T2.
21) The simply underlying tables of QE are the <table or query name>s, <query specification>s, and <derived
    table>s contained, without an intervening <derived table> or an intervening <join condition>, in the <query
    expression body> immediately contained in QE.
22) An <explicit table> is possibly non-deterministic if the simply contained <table or query name> identifies
    a viewed table whose original <query expression> is possibly non-deterministic.
23) A <query expression> is possibly non-deterministic if any of the following are true:
    a) The <query expression> is a <query primary> that is possibly non-deterministic.
    b) UNION, EXCEPT, or INTERSECT is specified and either of the first or second operands is possibly
       non-deterministic.
    c) UNION, EXCEPT, or INTERSECT is specified and there is a column of the result such that the declared
       types DT1 and DT2 of the column in the two operands have corresponding constituents such that one
       constituent is datetime with time zone and the other is datetime without time zone.
    d) Both of the following are true:
         i)       T contains a set operator UNION and ALL is not specified, or T contains either of the set oper-
                  ators EXCEPT or INTERSECT.
         ii)      Exactly one of the following is true:
                  1) The first or second operand contains a column that has a declared type of character string.
                  2) The first or second operand contains a column that has a declared type of datetime with time
                     zone.
                  3) The first or second operand contains a column that has a declared type that is a user-defined
                     type.
24) The underlying columns of each column of QE and of QE itself are defined as follows:
    a) A column of a <table value constructor> has no underlying columns.
    b) The underlying columns of every i-th column of a <simple table> ST are the underlying columns of
       the i-th column of the table immediately contained in ST.
    c) If no set operator is specified, then the underlying columns of every i-th column of QE are the underlying
       columns of the i-th column of the <simple table> simply contained in QE.
    d) If a set operator is specified, then the underlying columns of every i-th column of QE are the underlying
       columns of the i-th column of T1 and those of the i-th column of T2.
    e) Let C be some column. C is an underlying column of QE if and only if C is an underlying column of
       some column of QE.
25) The updatable columns of QE are defined as follows:
    a) A column of a <table value constructor> is not an updatable column.



©ISO/IEC 2003 – All rights reserved                                                              Query expressions 359
ISO/IEC 9075-2:2003 (E)
7.13 <query expression>



    b) A column of a <simple table> is an updatable column of ST if the underlying column of ST is updatable.
    c) If no set operator is specified, then a column of QE is an updatable column of QE if its underlying
       column is updatable.
    d) If a set operator is specified, then
        Case:
        i)      If the SQL implementation supports Feature T111, “Updatable joins, unions, and columns”, a
                set operator UNION ALL is specified and both underlying columns of the i-th column of QE
                are updatable, then the i-th column of QE is an updatable column of QE.
        ii)     Otherwise, the i-th column of QE is not updatable.
                NOTE 173 — If a set operator UNION DISTINCT, EXCEPT, or INTERSECT is specified, or if the SQL implemen-
                tation does not support Feature T111, “Updatable joins, unions and columns”, then there are no updatable columns.

26) A <query expression> QE shall not generally contain a <routine invocation> whose subject routine is an
    SQL-invoked routine that possibly modifies SQL-data.


Access Rules
    None.


General Rules
1) If a non-recursive <with clause> is specified, then:
    a) For every <with list element> WLE, let WQN be the <query name> immediately contained in WLE.
       Let WQE be the <query expression> immediately contained in WLE. Let WLT be the table resulting
       from evaluation of WQE, with each column name replaced by the corresponding element of the <with
       column list>, if any, immediately contained in WLE.
    b) Every <table reference> contained in <query expression> that specifies WQN identifies WLT.
2) If a potentially recursive <with clause> WC is specified, then:
    a) Let n be the number of <with list element>s WLEi of the <with list> WL immediately contained in WC.
       For i ranging from 1 (one) to n, let WQNi and WQEi be the <query name>s and the <query expression>s
       immediately contained in WLEi. Let WLPj be the elements of a partitioning of WL such that each WLPj
       contains all WLEi that belong to one stratum, and let m be the number of partitions. Let the partition
       dependency graph PDG of WL be a directed graph such that:
        i)      Each partition WLPj of WL is represented by exactly one node of PDG.

        ii)     There is an arc from the node representing WLPj to the node representing WLPk if and only if
                WLPj contains at least one WLEi, WLPk contains at least one WLEh, and WQEi contains a <query
                name> referencing WQNh.

    b) While the set of nodes of PDG is not empty, do:



360 Foundation (SQL/Foundation)                                                               ©ISO/IEC 2003 – All rights reserved
                                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                                                    7.13 <query expression>



         i)       Evaluate the partitions of PDG that have no outgoing arc.
         ii)      Remove the partitions and their incoming arcs from PDG.
    c) Let LIP be some partition of WL. Let m be the number of <with list element>s in LIP, and for i ranging
       from 1 (one) to m, let WLEi be a <with list element> of LIP, and let WQNi and WQEi be the <query
       name> and <query expression> immediately contained in WLEi. Let SQEi be the set of <query
       expression>s contained in WQEi. Let SQE be a set of <query expression>s such that a <query expres-
       sion> belongs to SQE if and only if it is contained in some WQEi. Let p be the number of <query
         expression>s in SQE and let AQEi, 1 ≤ k ≤ p be the k-th <query expression> belonging to SQE.

         i)       Every <query expression> AQEk that contains a recursive query name in scope is marked as
                  recursive.
         ii)      Let RTk and WTk be tables whose row type is the row type of AQEk. Let RTk and WTk be initially
                  empty. RTk and WTk are said to be associated with AQEk. If AQEk is immediately contained in
                  some WQEi, then RTk and WTk are said to be the intermediate result table and working table,
                  respectively, associated with the <query name> WQNi.

         iii)     If a <query expression> AQEk not marked as recursive is immediately contained in a <query
                  expression body> that is marked as recursive and that specifies UNION, then AQEi is marked
                  as iteration ignorable.
         iv)      For each AQEk,

                  Case:
                  1) If AQEk consists of a <query specification> that immediately contains DISTINCT, then
                     AQEk suppresses duplicates.

                  2) If AQEk consists of a <query expression body> or <query term> that explicitly or implicitly
                     immediately contains DISTINCT, then AQEk suppresses duplicates.

                  3) Otherwise, AQEk does not suppress duplicates.

         v)       If an AQEk is not marked as recursive, then let RTk and WTk be the result of AQEk.

         vi)      For every RTk, let RTNk be the name of RTk. If AQEk is not marked as recursive, then replace
                  AQEk with:

                     TABLE RTNk

         vii)     For every WQEi of LIP, let the recursive query names in scope denote the associated result
                  tables. Evaluate every WQEi. For every AQEk contained in any such WQEi, let RTk and WTk be
                  the result of AQEk.
                  NOTE 174 — This ends the initialization phase of the evaluation of a partition.

         viii)    For every AQEk of LIP that is marked as iteration ignorable, let RTk be an empty table.




©ISO/IEC 2003 – All rights reserved                                                                  Query expressions 361
ISO/IEC 9075-2:2003 (E)
7.13 <query expression>



        ix)    While some WTk of LIP is not empty, do:

               1) Let the recursive query names in scope of LIP denote the associated working tables.
               2) Evaluate every WQEi of LIP.

               3) For every AQEk that is marked as recursive,

                    Case:
                    A) If AQEk suppresses duplicates, then let WTk be the result of AQEk EXCEPT RTNk.

                    B) Otherwise, let WTk be the result of AQEk.

               4) For every WTk, let WTNk be the table name of WTk. Let RTk be the result of:

                       TABLE WTNk UNION ALL TABLE RTNk

        x)     Any reference to WQNi identifies the intermediate result table RTk associated with WQNi.

3) If a set operator is specified, then for each column C of T, let UDT be the declared type of C and let SV be
   the value of the column corresponding to C in each row of each operand. The value of C in the corresponding
   row of T is

    CAST ( SV AS UDT )

4) Case:
    a) If no set operator is specified, then T is the result of the specified <simple table> or <joined table>.
    b) If a set operator is specified, then the result of applying the set operator is a table containing the following
       rows:
        i)     Let R be a row that is a duplicate of some row in T1 or of some row in T2 or both. Let m be the
               number of duplicates of R in T1 and let n be the number of duplicates of R in T2, where m ≥ 0
               and n ≥ 0.
        ii)    If DISTINCT is specified or implicit, then
               Case:
               1) If UNION is specified, then
                    Case:
                    A) If m > 0 or n > 0, then T contains exactly one duplicate of R.
                    B) Otherwise, T contains no duplicate of R.
               2) If EXCEPT is specified, then
                    Case:
                    A) If m > 0 and n = 0, then T contains exactly one duplicate of R.



362 Foundation (SQL/Foundation)                                                        ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                                       7.13 <query expression>



                      B) Otherwise, T contains no duplicate of R.
                  3) If INTERSECT is specified, then
                      Case:
                      A) If m > 0 and n > 0, then T contains exactly one duplicate of R.
                      B) Otherwise, T contains no duplicates of R.
         iii)     If ALL is specified, then
                  Case:
                  1) If UNION is specified, then the number of duplicates of R that T contains is (m + n).
                  2) If EXCEPT is specified, then the number of duplicates of R that T contains is the maximum
                     of (m – n) and 0 (zero).
                  3) If INTERSECT is specified, then the number of duplicates of R that T contains is the mini-
                     mum of m and n.
    NOTE 175 — See the General Rules of Subclause 8.2, “<comparison predicate>”.

5) Case:
    a) If EXCEPT is specified and a row R of T is replaced by some row RR, then the row of T1 from which
       R is derived is replaced by RR.
    b) If INTERSECT is specified, then:
         i)       If a row R is inserted into T, then:
                  1) If T1 does not contain a row whose value equals the value of R, then R is inserted into T1.
                  2) If T1 contains a row whose value equals the value of R and no row of T is derived from that
                     row, then R is inserted into T1.
                  3) If T2 does not contain a row whose value equals the value of R, then R is inserted into T2.
                  4) If T2 contains a row whose value equals the value of R and no row of T is derived from that
                     row, then R is inserted into T2.
         ii)      If a row R is replaced by some row RR, then:
                  1) The row of T1 from which R is derived is replaced with RR.
                  2) The row of T2 from which R is derived is replaced with RR.


Conformance Rules
1) Without Feature T121, “WITH (excluding RECURSIVE) in query expression”, in conforming SQL language,
   a <query expression> shall not contain a <with clause>.
2) Without Feature T122, “WITH (excluding RECURSIVE) in subquery”, in conforming SQL language, a
   <query expression> contained in a <subquery>, a <multiset value constructor by query>, or an <array value
   constructor by query> shall not contain a <with clause>.


©ISO/IEC 2003 – All rights reserved                                                        Query expressions 363
ISO/IEC 9075-2:2003 (E)
7.13 <query expression>



3) Without Feature T131, “Recursive query”, conforming SQL language shall not contain a <query expression>
   that contains RECURSIVE.
4) Without Feature T132, “Recursive query in subquery”, in conforming SQL language, a <query expression>
   contained in a <subquery>, a <multiset value constructor by query>, or an <array value constructor by
   query> shall not contain RECURSIVE.
5) Without Feature F661, “Simple tables”, conforming SQL language shall not contain a <simple table> that
   immediately contains a <table value constructor> except in an <insert statement>.
6) Without Feature F661, “Simple tables”, conforming SQL language shall not contain an <explicit table>.
7) Without Feature F302, “INTERSECT table operator”, conforming SQL language shall not contain a <query
   term> that contains INTERSECT.
8) Without Feature F301, “CORRESPONDING in query expressions”, conforming SQL language shall not
   contain a <query expression> that contains CORRESPONDING.
9) Without Feature T551, “Optional key words for default syntax”, conforming SQL language shall not contain
   UNION DISTINCT, EXCEPT DISTINCT, or INTERSECT DISTINCT.
10) Without Feature F304, “EXCEPT ALL table operator”, conforming SQL language shall not contain a
    <query expression> that contains EXCEPT ALL.
   NOTE 176 — If DISTINCT, INTERSECT or EXCEPT is specified, then the Conformance Rules of Subclause 9.10, “Grouping
   operations”, apply.




364 Foundation (SQL/Foundation)                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                  7.14 <search or cycle clause>



7.14 <search or cycle clause>

Function
Specify the generation of ordering and cycle detection information in the result of recursive query expressions.


Format
<search or cycle clause> ::=
    <search clause>
  | <cycle clause>
  | <search clause> <cycle clause>

<search clause> ::=
    SEARCH <recursive search order> SET <sequence column>

<recursive search order> ::=
    DEPTH FIRST BY <sort specification list>
  | BREADTH FIRST BY <sort specification list>

<sequence column> ::= <column name>

<cycle clause> ::=
    CYCLE <cycle column list> SET <cycle mark column> TO <cycle mark value>
    DEFAULT <non-cycle mark value> USING <path column>

<cycle column list> ::=
    <cycle column> [ { <comma> <cycle column> }... ]

<cycle column> ::= <column name>

<cycle mark column> ::= <column name>

<path column> ::= <column name>

<cycle mark value> ::= <value expression>

<non-cycle mark value> ::= <value expression>


Syntax Rules
1) Let WLEC be an expandable <with list element> immediately containing a <search or cycle clause>.
2) Let WQN be the <query name>, WCL the <with column list>, and WQE the <query expression> immediately
   contained in WLEC. Let WQEB be the <query expression body> immediately contained in WQE. Let OP
   be the set operator immediately contained in WQEB. Let TLO be the <query expression body> that constitutes
   the first operand of OP and let TRO be the <query specification> that (necessarily) constitutes the second
   operand of OP.
    a) Let TROSL be the <select list> immediately contained in TRO. Let WQNTR be the <table reference>
       simply contained in the <from clause> immediately contained in the <table expression> TROTE
       immediately contained in TRO such that WQNTR immediately contains WQN.



©ISO/IEC 2003 – All rights reserved                                                     Query expressions 365
ISO/IEC 9075-2:2003 (E)
7.14 <search or cycle clause>



        Case:
        i)      If WQNTR simply contains a <correlation name>, then let WQNCRN be that <correlation name>.
        ii)     Otherwise, let WQNCRN be WQN.
    b) Case:
        i)      If WLEC simply contains a <search clause> SC, then let SQC be the <sequence column> and
                SO be the <recursive search order> immediately contained in SC. Let SPL be the <sort specifi-
                cation list> immediately contained in SO.
                1) WCL shall not contain a <column name> that is equivalent to SQC.
                2) Every <column name> of SPL shall be equivalent to some <column name> contained in
                   WCL. No <column name> shall be contained more than once in SPL.
                3) Case:
                    A) If SO immediately contains DEPTH, then let SCEX1 be:
                           WQNCRN.SQC
                        let SCEX2 be:
                           SQC || ARRAY [ROW(SPL)]
                        and let SCIN be:
                           ARRAY [ROW(SPL)]

                    B) If SO immediately contains BREADTH, then let SCEX1 be:
                           ( SELECT OC.*
                           FROM ( VALUES (WQNCRN.SQC) )
                           OC(LEVEL, SPL) )
                        let SCEX2 be:
                           ROW(SQC.LEVEL + 1, SPL)
                        and let SCIN be:
                           ROW(0, SPL)

        ii)     If WLEC simply contains a <cycle clause> CC, then let CCL be the <cycle column list>, let
                CMC be the <cycle mark column>, let CMV be the <cycle mark value>, let CMD be the <non-
                cycle mark value>, and let CPA be the <path column> immediately contained in CC.
                1) Every <column name> of CCL shall be equivalent to some <column name> contained in
                   WCL. No <column name> shall be contained more than once in CCL.
                2) CMC and CPA shall not be equivalent to each other and not equivalent to any <column
                   name> of WCL.




366 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                                7.14 <search or cycle clause>



                  3) The declared type of CMV and CMD shall be character string of length 1 (one). CMV and
                     CMD shall be literals and CMV shall not be equal to CMD.
                  4) Let CCEX1 be:
                          WQNCRN.CMC, WQNCRN.CPA
                      Let CCEX2 be:
                          CASE WHEN ROW(CCL) IN (SELECT P.* FROM TABLE(CPA) P)
                          THEN CMV ELSE CMD END,
                          CPA || ARRAY [ROW(CCL)]
                      Let CCIN be:
                          CMD, ARRAY [ROW(CCL)]
                      Let NCCON1 be:
                          CMC <> CMV

         iii)     Case:
                  1) If WLEC simply contains a <search clause> and does not simply contain a <cycle clause>,
                     then let EWCL be:
                          WCL, SQC
                      Let ETLOSL be:
                          WCL, SCIN
                      Let ETROSL be:
                          WCL, SCEX2
                      Let ETROSL1 be:
                          TROSL, SCEX1
                      Let NCCON be:
                          TRUE

                  2) If WLEC simply contains a <cycle clause> and does not simply contain a <search clause>,
                     then let EWCL be:
                          WCL, CMC, CPA
                      Let ETLOSL be:
                          WCL, CCIN
                      Let ETROSL be:
                          WCL, CCEX2



©ISO/IEC 2003 – All rights reserved                                                   Query expressions 367
ISO/IEC 9075-2:2003 (E)
7.14 <search or cycle clause>



                  Let ETROSL1 be:
                     TROSL, CCEX1
                  Let NCCON be:
                     NCCON1

               3) If WLEC simply contains both a <search clause> and a <cycle clause> CC, then:
                  A) The <column name>s SQC, CMC, and CPA shall not be equivalent to each other.
                  B) Let EWCL be:
                         WCL, SQC, CMC, CPA
                       Let ETLOSL be:
                         WCL, SCIN, CCIN
                       Let ETROSL be:
                         WCL, SCEX2, CCEX2
                       Let ETROSL1 be:
                         TROSL, SCEX1, CCEX1

                  C) Let NCCON be:
                         NCCON1

    c) WLEC is equivalent to the expanded <with list element>:

            WQN(EWCL) AS
              ( SELECT ETLOSL FROM (TLO) TLOCRN(WCL)
                OP
                SELECT ETROSL
                FROM (SELECT ETROSL1 TROTE) TROCRN(EWCL)
                WHERE NCCON
              )



Access Rules
    None.


General Rules
    None.




368 Foundation (SQL/Foundation)                                             ©ISO/IEC 2003 – All rights reserved
                                          ISO/IEC 9075-2:2003 (E)
                                      7.14 <search or cycle clause>



Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved         Query expressions 369
ISO/IEC 9075-2:2003 (E)
7.15 <subquery>



7.15 <subquery>

Function
Specify a scalar value, a row, or a table derived from a <query expression>.


Format
<scalar subquery> ::= <subquery>

<row subquery> ::= <subquery>

<table subquery> ::= <subquery>

<subquery> ::= <left paren> <query expression> <right paren>


Syntax Rules
1) The degree of a <scalar subquery> shall be 1 (one).
2) The degree of a <row subquery> shall be greater than 1 (one).
3) Let QE be the <query expression> simply contained in <subquery>.
4) The declared type of a <scalar subquery> is the declared type of the column of QE.
5) The declared type of a <row subquery> is a row type consisting of one field for each column of QE. The
   declared type and field name of each field of this row type is the declared type and column name of the
   corresponding column of QE.
6) The declared types of the columns of a <table subquery> are the declared types of the respective columns
   of QE.


Access Rules
    None.


General Rules
1) Let OLDSEC be the most recent statement execution context. A new statement execution context NEWSEC
   is established. NEWSEC becomes the most recent statement execution context and is atomic.
2) Let RS be a <row subquery>. Let RRS be the result of the <query expression> simply contained in RS. Let
   D be the degree of RRS.
    Case:
    a) If the cardinality of RRS is greater than 1 (one), then an exception condition is raised: cardinality vio-
       lation.



370 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)
                                                                                                 7.15 <subquery>



    b) If the cardinality of RRS is 0 (zero), then the value of the <row subquery> is a row whose degree is D
       and whose fields are all the null value.
    c) Otherwise, the value of RS is RRS.
3) Let SS be a <scalar subquery>.
    Case:
    a) If the cardinality of SS is greater than 1 (one), then an exception condition is raised: cardinality violation.
    b) If the cardinality of SS is 0 (zero), then the value of the <scalar subquery> is the null value.
    c) Otherwise, let C be the column of <query expression> simply contained in SS. The value of SS is the
       value of C in the unique row of the result of the <scalar subquery>.
4) All savepoints that were established during the existence of NEWSEC are destroyed. NEWSEC ceases to
   exist and OLDSEC becomes the most recent statement execution context.
5) A <subquery> SQ that simply contains a <sample clause> returns a table with identical rows for a given
   set of values for outer references every time SQ is evaluated.
    NOTE 177 — “Outer reference” is defined in Subclause 6.7, “<column reference>”.


Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved                                                          Query expressions 371
ISO/IEC 9075-2:2003 (E)




                                  This page intentionally left blank.




372 Foundation (SQL/Foundation)                                         ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                             8.1 <predicate>




8 Predicates


8.1      <predicate>

Function
Specify a condition that can be evaluated to give a boolean value.


Format
<predicate> ::=
    <comparison predicate>
  | <between predicate>
  | <in predicate>
  | <like predicate>
  | <similar predicate>
  | <null predicate>
  | <quantified comparison predicate>
  | <exists predicate>
  | <unique predicate>
  | <normalized predicate>
  | <match predicate>
  | <overlaps predicate>
  | <distinct predicate>
  | <member predicate>
  | <submultiset predicate>
  | <set predicate>
  | <type predicate>


Syntax Rules
      None.


Access Rules
      None.


General Rules
1) The result of a <predicate> is the truth value of the immediately contained <comparison predicate>, <between
   predicate>, <in predicate>, <like predicate>, <similar predicate>, <null predicate>, <quantified comparison
   predicate>, <exists predicate>, <unique predicate>, <match predicate>, <overlaps predicate>, <distinct
   predicate>, <member predicate>, <submultiset predicate>, <set predicate>, or <type predicate>.


©ISO/IEC 2003 – All rights reserved                                                            Predicates 373
ISO/IEC 9075-2:2003 (E)
8.1 <predicate>



Conformance Rules
   None.




374 Foundation (SQL/Foundation)   ©ISO/IEC 2003 – All rights reserved
                                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                                                  8.2 <comparison predicate>



8.2      <comparison predicate>

Function
Specify a comparison of two row values.


Format
<comparison predicate> ::= <row value predicand> <comparison predicate part 2>

<comparison predicate part 2> ::= <comp op> <row value predicand>

<comp op> ::=
    <equals operator>
  | <not equals operator>
  | <less than operator>
  | <greater than operator>
  | <less than or equals operator>
  | <greater than or equals operator>


Syntax Rules
1) The two <row value predicand>s shall be of the same degree.
2) Let corresponding fields be fields with the same ordinal position in the two <row value predicand>s.
3) The declared types of the corresponding fields of the two <row value predicand>s shall be comparable.
4) Let Rx and Ry respectively denote the first and second <row value predicand>s.

5) Let N be the number of fields in the declared type of Rx. Let Xi, 1 (one) ≤ i ≤ N, be the i-th field in the
   declared type of Rx and let Yi be the i-th field in the declared type of Ry. For each i:

      a) Case:
         i)       If <comp op> is <equals operator> or <not equals operator>, then Xi and Yi are operands of an
                  equality operation. The Syntax Rules of Subclause 9.9, “Equality operations”, apply.
         ii)      Otherwise, Xi and Yi are operands of an ordering operation. The Syntax Rules of Subclause 9.12,
                  “Ordering operations”, apply.
      b) Case:
         i)       If the declared types of Xi and Yi are user-defined types, then let UDT1 and UDT2 be respectively
                  the declared types of Xi and Yi. UDT1 and UDT2 shall be in the same subtype family. UDT1
                  and UDT2 shall have comparison types.
                  NOTE 178 — “Comparison type” is defined in Subclause 4.7.6, “User-defined type comparison and assignment”.
                  NOTE 179 — The comparison form and comparison categories included in the user-defined type descriptors of both
                  UDT1 and UDT2 are constrained to be the same and to be the same as those of all their supertypes. If the comparison




©ISO/IEC 2003 – All rights reserved                                                                               Predicates 375
ISO/IEC 9075-2:2003 (E)
8.2 <comparison predicate>



               category is either STATE or RELATIVE, then UDT1 and UDT2 are constrained to have the same comparison function;
               if the comparison category is MAP, they are not constrained to have the same comparison function.

       ii)     If the declared types of Xi and Yi are reference types, then the referenced type of the declared
               type of Xi and the referenced type of the declared type of Yi shall have a common supertype.

       iii)    If the declared types of Xi and Yi are collection types in which the declared type of the elements
               are ETx and ETy, respectively, then let RV1 and RV2 be <value expression>s whose declared
               types are respectively ETx and ETy. The Syntax Rules of this Subclause are applied to:
                  RV1 <comp op> RV2


       iv)     If the declared types of Xi and Yi are row types, then let RV1 and RV2 be <value expression>s
               whose declared types are respectively that of Xi and Yi. The Syntax Rules of this Subclause are
               applied to:
                  RV1 <comp op> RV2


6) Let CP be the <comparison predicate> “Rx <comp op> Ry”.

   Case:
   a) If the <comp op> is <not equals operator>, then CP is equivalent to:
             NOT(Rx = Ry )

   b) If the <comp op> is <greater than operator>, then CP is equivalent to:
             (Ry < Rx )

   c) If the <comp op> is <less than or equals operator>, then CP is equivalent to:
             (Rx < Ry
             OR
             Ry = Rx )

   d) If the <comp op> is <greater than or equals operator>, then CP is equivalent to:
             (Ry < Rx
             OR
             Ry = Rx )


Access Rules
   None.




376 Foundation (SQL/Foundation)                                                            ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                       8.2 <comparison predicate>



General Rules
1) Let XV and YV be two values represented by <value expression>s X and Y, respectively. The result of:
        X <comp op> Y

    is determined as follows:
    Case:
    a) If either XV or YV is the null value, then
               X <comp op> Y

         is Unknown.
    b) Otherwise,
         Case:

         i)       If the declared types of XV and YV are row types with degree N, then let Xi, 1 (one) ≤ i ≤ N,
                  denote a <value expression> whose value and declared type is that of the i-th field of XV and
                  let Yi denote a <value expression> whose value and declared type is that of the i-th field of YV.
                  The result of
                     X <comp op> Y

                  is determined as follows:
                  1) X = Y is True if and only if Xi = Yi is True for all i.

                  2) X < Y is True if and only if Xi = Yi is True for all i < n and Xn < Yn for some n.

                  3) X = Y is False if and only if NOT (Xi = Yi) is True for some i.

                  4) X < Y is False if and only if X = Y is True or Y < X is True.
                  5) X <comp op> Y is Unknown if X <comp op> Y is neither True nor False.
         ii)      If the declared types of XV and YV are array types with cardinalities N1 and N2, respectively,
                  then let Xi, 1 (one) ≤ i ≤ N1, denote a <value expression> whose value and declared type is that
                  of the i-th element of XV and let Yi denote a <value expression> whose value and declared type
                  is that of the i-th element of YV. The result of
                     X <comp op> Y

                  is determined as follows:
                  1) X = Y is True if N1 = 0 (zero) and N2 = 0 (zero).
                  2) X = Y is True if N1 = N2 and, for all i, Xi = Yi is True.

                  3) X = Y is False if and only if N1 ≠ N2 or NOT (Xi = Yi) is True, for some i.



©ISO/IEC 2003 – All rights reserved                                                                Predicates 377
ISO/IEC 9075-2:2003 (E)
8.2 <comparison predicate>



              4) X <comp op> Y is Unknown if X <comp op> Y is neither True nor False.
       iii)   If the declared types of XV and YV are multiset types with cardinalities N1 and N2, respectively,
              then the result of
                X <comp op> Y
              is determined as follows:
              Case:

              1) X = Y is True if N1 = N2, and there exist an enumeration XVEj, 1 (one) ≤ j ≤ N1, of the ele-
                  ments of XV and an enumeration YVEj, 1 (one) ≤ j ≤ N1, of the elements of YV such that for
                  all j, XVEj = YVEj.

              2) X = Y is Unknown if N1 = N2, and there exist an enumeration XVEj, 1 (one) ≤ j ≤ N1, of the
                  elements of XV and an enumeration YVEj, 1 (one) ≤ j ≤ N1, of the elements of YV such that
                  for all j, “XVEj = YVEj” is either True or Unknown.

              3) Otherwise, X = Y is False.
       iv)    If the declared types of XV and YV are user-defined types, then let UDTx and UDTy be respectively
              the declared types of XV and YV. The result of
                X <comp op> Y

              is determined as follows:
              1) If the comparison category of UDTx is MAP, then let HF1 be the <routine name> with
                 explicit <schema name> of the comparison function of UDTx and let HF2 be the <routine
                 name> with explicit <schema name> of the comparison function of UDTy. If HF1 identifies
                 an SQL-invoked method, then let HFX be X.HF1; otherwise, let HFX be HF1(X). If HF2
                 identifies an SQL-invoked method, then let HFY be Y.HF2; otherwise, let HFY be HF2(Y).
                      X <comp op> Y

                  has the same result as
                      HFX <comp op> HFY


              2) If the comparison category of UDTx is RELATIVE, then:

                  A) Let RF be the <routine name> with explicit <schema name> of the comparison function
                     of UDTx.

                  B) X = Y
                       has the same result as
                         RF (X, Y ) = 0


                  C) X < Y


378 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                                   8.2 <comparison predicate>



                            has the same result as
                               RF (X, Y ) = -1


                       D) X <> Y
                            has the same result as
                               RF (X, Y ) <> 0


                       E) X > Y
                            has the same result as
                               RF (X, Y ) = 1


                       F) X <= Y
                            has the same result as
                               RF (X, Y ) = -1 OR RF (X, Y ) = 0


                       G) X >= Y
                            has the same result as
                               RF (X, Y ) = 1 OR RF (X, Y ) = 0


                  3) If the comparison category of UDTx is STATE, then:

                       A) Let SF be the <routine name> of the comparison function of UDTx.

                       B) X = Y
                            has the same result as
                               SF (X, Y ) = TRUE


                       C) X <> Y
                            has the same result as
                               SF (X, Y ) = FALSE

                  NOTE 180 — Rules for the comparison of user-defined types in which <comp op> is other than <equals operator>
                  or <less than operator> are included for informational purposes only, since such predicates are equivalent to other
                  <comparison predicate>s whose <comp op> is <equals operator> or <less than operator>.

         v)       Otherwise, the result of
                     X <comp op> Y

                  is True or False as follows:



©ISO/IEC 2003 – All rights reserved                                                                               Predicates 379
ISO/IEC 9075-2:2003 (E)
8.2 <comparison predicate>



               1) X = Y
                    is True if and only if XV and YV are equal.
               2) X < Y
                    is True if and only if XV is less than YV.
               3) X <comp op> Y
                    is False if and only if
                      X <comp op> Y

                    is not True
2) Numbers are compared with respect to their algebraic value.
3) The comparison of two character strings is determined as follows:
    a) Let CS be the collation as determined by Subclause 9.13, “Collation determination”, for the declared
       types of the two character strings.
    b) If the length in characters of X is not equal to the length in characters of Y, then the shorter string is
       effectively replaced, for the purposes of comparison, with a copy of itself that has been extended to
       the length of the longer string by concatenation on the right of one or more pad characters, where the
       pad character is chosen based on CS. If CS has the NO PAD characteristic, then the pad character is
       an implementation-dependent character different from any character in the character set of X and Y
       that collates less than any string under CS. Otherwise, the pad character is a <space>.
    c) The result of the comparison of X and Y is given by the collation CS.
    d) Depending on the collation, two strings may compare as equal even if they are of different lengths or
       contain different sequences of characters. When any of the operations MAX, MIN, and DISTINCT
       reference a grouping column, and the UNION, EXCEPT, and INTERSECT operators refer to character
       strings, the specific value selected by these operations from a set of such equal values is implementation-
       dependent.
4) The comparison of two binary string values, X and Y, is determined by comparison of their octets with the
   same ordinal position. If Xi and Yi are the values of the i-th octets of X and Y, respectively, and if Lx is the
   length in octets of X AND Ly is the length in octets of Y, then X is equal to Y if and only if Lx = Ly and if
   Xi = Yi for all i.

5) The comparison of two datetimes is determined according to the interval resulting from their subtraction.
   Let X and Y be the two values to be compared and let H be the least significant <primary datetime field>
   of X and Y, including fractional seconds precision if the data type is time or timestamp.
    a) X is equal to Y if and only if
            ( X - Y ) INTERVAL H = INTERVAL '0' H

        is True.
    b) X is less than Y if and only if
            ( X - Y ) INTERVAL H < INTERVAL '0' H



380 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                                                 8.2 <comparison predicate>




         is True.
    NOTE 181 — Two datetimes are comparable only if they have the same <primary datetime field>s; see Subclause 4.6.2, “Datetimes”.

6) The comparison of two intervals is determined by the comparison of their corresponding values after con-
   version to integers in some common base unit. Let X and Y be the two intervals to be compared. Let A TO
   B be the specified or implied datetime qualifier of X and C TO D be the specified or implied datetime
   qualifier of Y. Let T be the least significant <primary datetime field> of B and D and let U be a datetime
   qualifier of the form T(N), where N is an <interval leading field precision> large enough so that significance
   is not lost in the CAST operation.
    Let XVE be the <value expression>
        CAST ( X AS INTERVAL U )

    Let YVE be the <value expression>
        CAST ( Y AS INTERVAL U )

    a) X is equal to Y if and only if
             CAST ( XVE AS INTEGER ) = CAST ( YVE AS INTEGER )

         is True.
    b) X is less than Y if and only if
             CAST ( XVE AS INTEGER ) < CAST ( YVE AS INTEGER )

         is True.
7) In comparisons of boolean values, True is greater than False
8) The result of comparing two reference values X and Y is determined by the comparison of their octets with
   the same ordinal position. Let Lx be the length in octets of X and let Ly be the length in octets of Y. Let Xi
    and Yi, 1 (one) ≤ i ≤ Lx, be the values of the i-th octets of X and Y, respectively. X is equal to Y if and only
    if Lx = Ly and, for all i, Xi = Yi.


Conformance Rules
    None.
NOTE 182 — If <comp op> is <equals operator> or <not equals operator>, then the Conformance Rules of Subclause 9.9, “Equality
operations”, apply. Otherwise, the Conformance Rules of Subclause 9.12, “Ordering operations”, apply.




©ISO/IEC 2003 – All rights reserved                                                                             Predicates 381
ISO/IEC 9075-2:2003 (E)
8.3 <between predicate>



8.3       <between predicate>

Function
Specify a range comparison.


Format
<between predicate> ::= <row value predicand> <between predicate part 2>

<between predicate part 2> ::=
    [ NOT ] BETWEEN [ ASYMMETRIC | SYMMETRIC ]
    <row value predicand> AND <row value predicand>


Syntax Rules
1) If neither SYMMETRIC nor ASYMMETRIC is specified, then ASYMMETRIC is implicit.
2) Let X, Y, and Z be the first, second, and third <row value predicand>s, respectively.
3) “X NOT BETWEEN SYMMETRIC Y AND Z” is equivalent to “NOT ( X BETWEEN SYMMETRIC Y
   AND Z )”.
4) “X BETWEEN SYMMETRIC Y AND Z” is equivalent to “((X BETWEEN ASYMMETRIC Y AND Z)
   OR (X BETWEEN ASYMMETRIC Z AND Y))”.
5) “X NOT BETWEEN ASYMMETRIC Y AND Z” is equivalent to “NOT ( X BETWEEN ASYMMETRIC
   Y AND Z )”.
6) “X BETWEEN ASYMMETRIC Y AND Z” is equivalent to “X>=Y AND X<=Z”.


Access Rules
      None.


General Rules
      None.


Conformance Rules
1) Without Feature T461, “Symmetric BETWEEN predicate”, conforming SQL language shall not contain
   SYMMETRIC or ASYMMETRIC.
      NOTE 183 — Since <between predicate> is an ordering operation, the Conformance Rules of Subclause 9.12, “Ordering operations”,
      also apply.




382 Foundation (SQL/Foundation)                                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                                            ISO/IEC 9075-2:2003 (E)
                                                                                                                 8.4 <in predicate>



8.4        <in predicate>

Function
Specify a quantified comparison.


Format
<in predicate> ::= <row value predicand> <in predicate part 2>

<in predicate part 2> ::= [ NOT ] IN <in predicate value>

<in predicate value> ::=
    <table subquery>
  | <left paren> <in value list> <right paren>

<in value list> ::= <row value expression> [ { <comma> <row value expression> }... ]


Syntax Rules
1) If <in value list> consists of a single <row value expression>, then that <row value expression> shall not
   be a <scalar subquery>.
      NOTE 184 — This Syntax Rule resolves an ambiguity in which <in predicate value> might be interperted either as a <table subquery>
      or as a <scalar subquery>. The ambiguity is resolved by adopting the interpretation that the <in predicate value> will be interpreted
      as a <table subquery>.

2) Let IVL be an <in value list>.
         ( IVL )
      is equivalent to the <table value constructor>:
         ( VALUES IVL )

3) Let RVC be the <row value predicand> and let IPV be the <in predicate value>.
4) The expression
         RVC NOT IN IPV
      is equivalent to
         NOT ( RVC IN IPV )

5) The expression
         RVC IN IPV
      is equivalent to
         RVC = ANY IPV



©ISO/IEC 2003 – All rights reserved                                                                                    Predicates 383
ISO/IEC 9075-2:2003 (E)
8.4 <in predicate>



Access Rules
   None.


General Rules
   None.


Conformance Rules
1) Without Feature F561, “Full value expressions”, conforming SQL language shall not contain a <row value
   expression> immediately contained in an <in value list> that is not a <value specification>.
   NOTE 185 — Since <in predicate> is an equality operation, the Conformance Rules of Subclause 9.9, “Equality operations”, also
   apply.




384 Foundation (SQL/Foundation)                                                              ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                         8.5 <like predicate>



8.5       <like predicate>

Function
Specify a pattern-match comparison.


Format
<like predicate> ::=
    <character like predicate>
  | <octet like predicate>

<character like predicate> ::=
    <row value predicand> <character like predicate part 2>

<character like predicate part 2> ::=
    [ NOT ] LIKE <character pattern> [ ESCAPE <escape character> ]

<character pattern> ::= <character value expression>

<escape character> ::= <character value expression>

<octet like predicate> ::=
    <row value predicand> <octet like predicate part 2>

<octet like predicate part 2> ::=
    [ NOT ] LIKE <octet pattern> [ ESCAPE <escape octet> ]

<octet pattern> ::= <blob value expression>

<escape octet> ::= <blob value expression>


Syntax Rules
1) The <row value predicand> immediately contained in <character like predicate> shall be a <row value
   constructor predicand> that is a <common value expression> CVE. The declared types of CVE, <character
   pattern>, and <escape character> shall be character string. CVE, <character pattern>, and <escape character>
   shall be comparable.
2) The <row value predicand> immediately contained in <octet like predicate> shall be a <row value constructor
   element> that is a <common value expression> OVE. The declared types of OVE, <octet pattern>, and
   <escape octet> shall be binary string.
3) If <character like predicate> is specified, then:
      a) Let MC be the <character value expression> of CVE, let PC be the <character value expression> of
         the <character pattern>, and let EC be the <character value expression> of the <escape character> if
         one is specified.
      b) MC NOT LIKE PC
          is equivalent to



©ISO/IEC 2003 – All rights reserved                                                            Predicates 385
ISO/IEC 9075-2:2003 (E)
8.5 <like predicate>



              NOT (MC LIKE PC)

    c) MC NOT LIKE PC ESCAPE EC
        is equivalent to
              NOT (MC LIKE PC ESCAPE EC)

    d) The collation used for <like predicate> is determined by applying Subclause 9.13, “Collation determi-
       nation”, with operands CVE, PC, and (if specified) EC.
        It is implementation-defined which collations can be used as collations for the <like predicate>.
4) If <octet like predicate> is specified, then:
    a) Let MB be the <blob value expression> of the OVE, let PB be the <blob value expression> of the <octet
       pattern>, and let EB be the <blob value expression> of the <escape octet> if one is specified.
    b) MB NOT LIKE PB
        is equivalent to
              NOT (MB LIKE PB)

    c) MB NOT LIKE PB ESCAPE EB
        is equivalent to
              NOT (MB LIKE PB ESCAPE EB)


Access Rules
    None.


General Rules
1) Let MCV be the value of MC and let PCV be the value of PC. If EC is specified, then let ECV be its value.
2) Let MBV be the value of MB and let PBV be the value of PB. If EB is specified, then let EBV be its value.
3) If <character like predicate> is specified, then:
    a) Case:
        i)      If ESCAPE is not specified and either MCV or PCV are null values, then the result of
                  MC LIKE PC
                is Unknown.
        ii)     If ESCAPE is specified and one or more of MCV, PCV and ECV are null values, then the result
                of



386 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                                                       8.5 <like predicate>



                     MC LIKE PC ESCAPE EC
                  is Unknown.
         NOTE 186 — If none of MCV, PCV, and ECV (if present) are null values, then the result is either True or False.

    b) Case:
         i)       If an <escape character> is specified, then:
                  1) If the length in characters of ECV is not equal to 1, then an exception condition is raised:
                     data exception — invalid escape character.
                  2) If there is not a partitioning of the string PCV into substrings such that each substring has
                     length 1 (one) or 2, no substring of length 1 (one) is the escape character ECV, and each
                     substring of length 2 is the escape character ECV followed by either the escape character
                     ECV, an <underscore> character, or the <percent> character, then an exception condition
                     is raised: data exception — invalid escape sequence.
                      If there is such a partitioning of PCV, then in that partitioning, each substring with length
                      2 represents a single occurrence of the second character of that substring and is called a
                      single character specifier.
                      Each substring with length 1 (one) that is the <underscore> character represents an arbitrary
                      character specifier. Each substring with length 1 (one) that is the <percent> character rep-
                      resents an arbitrary string specifier. Each substring with length 1 (one) that is neither the
                      <underscore> character nor the <percent> character represents the character that it contains
                      and is called a single character specifier.
         ii)      If an <escape character> is not specified, then each <underscore> character in PCV represents
                  an arbitrary character specifier, each <percent> character in PCV represents an arbitrary string
                  specifier, and each character in PCV that is neither the <underscore> character nor the <percent>
                  character represents itself and is called a single character specifier.
    c) Case:
         i)       If MCV and PCV are character strings whose lengths are variable and if the lengths of both MCV
                  and PCV are 0 (zero), then
                     MC LIKE PC
                  is True.
         ii)      The <predicate>
                     MC LIKE PC
                  is True if there exists a partitioning of MCV into substrings such that:
                  1) A substring of MCV is a sequence of 0 (zero) or more contiguous characters of MCV and
                     each character of MCV is part of exactly one substring.
                  2) If the i-th substring of PCV is an arbitrary character specifier, then the i-th substring of MCV
                     is any single character.




©ISO/IEC 2003 – All rights reserved                                                                            Predicates 387
ISO/IEC 9075-2:2003 (E)
8.5 <like predicate>



                3) If the i-th substring of PCV is an arbitrary string specifier, then the i-th substring of MCV
                   is any sequence of 0 (zero) or more characters.
                4) If the i-th substring of PCV is a single character specifier, then the i-th substring of MCV
                   contains exactly 1 (one) character that is equal to the character represented by the single
                   character specifier according to the collation of the <like predicate>.
                5) The number of substrings of MCV is equal to the number of substring specifiers of PCV.
        iii)    Otherwise,
                   MC LIKE PC
                is False.
4) If <octet like predicate> is specified, then:
    a) Case:
        i)      If ESCAPE is not specified and either MBV or PBV are null values, then the result of
                   MB LIKE PB
                is Unknown.
        ii)     If ESCAPE is specified and one or more of MBV, PBV and EBV are null values, then the result
                of
                   MB LIKE PB ESCAPE EB
                is Unknown.
        NOTE 187 — If none of MBV, PBV, and EBV (if present) are null values, then the result is either True or False.

    b) <percent> in the context of an <octet like predicate> has the same bit pattern as the encoding of a
       <percent> in the SQL_TEXT character set.
    c) <underscore> in the context of an <octet like predicate> has the same bit pattern as the encoding of an
       <underscore> in the SQL_TEXT character set.
    d) Case:
        i)      If an <escape octet> is specified, then:
                1) If the length in octets of EBV is not equal to 1, then an exception condition is raised: data
                   exception — invalid escape octet.
                2) If there is not a partitioning of the string PBV into substrings such that each substring has
                   length 1 (one) or 2, no substring of length 1 (one) is the escape octet EBV, and each substring
                   of length 2 is the escape octet EBV followed by either the escape octet EBV, an <underscore>
                   octet, or the <percent> octet, then an exception condition is raised: data exception — invalid
                   escape sequence.
                     If there is such a partitioning of PBV, then in that partitioning, each substring with length 2
                     represents a single occurrence of the second octet of that substring. Each substring with
                     length 1 (one) that is the <underscore> octet represents an arbitrary octet specifier. Each
                     substring with length 1 (one) that is the <percent> octet represents an arbitrary string


388 Foundation (SQL/Foundation)                                                               ©ISO/IEC 2003 – All rights reserved
                                                                                             ISO/IEC 9075-2:2003 (E)
                                                                                                8.5 <like predicate>



                      specifier. Each substring with length 1 (one) that is neither the <underscore> octet nor the
                      <percent> octet represents the octet that it contains.
         ii)      If an <escape octet> is not specified, then each <underscore> octet in PBV represents an arbitrary
                  octet specifier, each <percent> octet in PBV represents an arbitrary string specifier, and each
                  octet in PBV that is neither the <underscore> octet nor the <percent> octet represents itself.
    e) The string PBV is a sequence of the minimum number of substring specifiers such that each portion of
       PBV is part of exactly one substring specifier. A substring specifier is an arbitrary octet specifier, and
       arbitrary string specifier, or any sequence of octets other than an arbitrary octet specifier or an arbitrary
       string specifier.
    f) Case:
         i)       If the lengths of both MBV and PBV are 0 (zero), then
                     MB LIKE PB
                  is True.
         ii)      The <predicate>
                     MB LIKE PB
                  is True if there exists a partitioning of MBV into substrings such that:
                  1) A substring of MBV is a sequence of 0 (zero) or more contiguous octets of MBV and each
                     octet of MBV is part of exactly one substring.
                  2) If the i-th substring specifier of PBV is an arbitrary octet specifier, the i-th substring of MBV
                     is any single octet.
                  3) the i-th substring specifier of PBV is an arbitrary string specifier, then the i-th substring of
                     MBV is any sequence of 0 (zero) or more octets.
                  4) If the i-th substring specifier of PBV is an neither an arbitrary character specifier not an
                     arbitrary string specifier, then the i-th substring of MBV has the same length and bit pattern
                     as that of the substring specifier.
                  5) The number of substrings of MBV is equal to the number of substring specifiers of PBV.
         iii)     Otherwise:
                     MB LIKE PB
                  is False.


Conformance Rules
1) Without Feature T042, “Extended LOB data type support”, conforming SQL language shall not contain
   an <octet like predicate>.
2) Without Feature F281, “LIKE enhancements”, conforming SQL language shall not contain a <common
   value expression> simply contained in the <row value predicand> immediately contained in <character
   like predicate> that is not a column reference.


©ISO/IEC 2003 – All rights reserved                                                                  Predicates 389
ISO/IEC 9075-2:2003 (E)
8.5 <like predicate>



3) Without Feature F281, “LIKE enhancements”, conforming SQL language shall not contain a <character
   pattern> that is not a <value specification>.
4) Without Feature F281, “LIKE enhancements”, conforming SQL language shall not contain an <escape
   character> that is not a <value specification>.
5) Without Feature T042, “Extended LOB data type support”, in conforming SQL language, a <character
   value expression> simply contained in a <like predicate> shall not be of declared type CHARACTER
   LARGE OBJECT
6) Without Feature F421, “National character”, and Feature T042, “Extended LOB data type support”, in
   conforming SQL language, a <character value expression> simply contained in a <like predicate> shall
   not be of declared type NATIONAL CHARACTER LARGE OBJECT.




390 Foundation (SQL/Foundation)                                              ©ISO/IEC 2003 – All rights reserved
                                                                          ISO/IEC 9075-2:2003 (E)
                                                                           8.6 <similar predicate>



8.6      <similar predicate>

Function
Specify a character string similarity by means of a regular expression.


Format
<similar predicate> ::=
    <row value predicand> <similar predicate part 2>

<similar predicate part 2> ::=
    [ NOT ] SIMILAR TO <similar pattern> [ ESCAPE <escape character> ]

<similar pattern> ::= <character value expression>

<regular expression> ::=
    <regular term>
  | <regular expression> <vertical bar> <regular term>

<regular term> ::=
    <regular factor>
  | <regular term> <regular factor>

<regular factor> ::=
    <regular primary>
  | <regular primary>           <asterisk>
  | <regular primary>           <plus sign>
  | <regular primary>           <question mark>
  | <regular primary>           <repeat factor>

<repeat factor> ::= <left brace> <low value> [ <upper limit> ] <right brace>

<upper limit> ::= <comma> [ <high value> ]

<low value> ::= <unsigned integer>

<high value> ::= <unsigned integer>

<regular primary> ::=
    <character specifier>
  | <percent>
  | <regular character set>
  | <left paren> <regular expression> <right paren>

<character specifier> ::=
    <non-escaped character>
  | <escaped character>

<non-escaped character> ::= !! See the Syntax Rules

<escaped character> ::= !! See the Syntax Rules

<regular character set> ::=
    <underscore>



©ISO/IEC 2003 – All rights reserved                                                Predicates 391
ISO/IEC 9075-2:2003 (E)
8.6 <similar predicate>



  | <left bracket> <character enumeration>... <right bracket>
  | <left bracket> <circumflex> <character enumeration>... <right bracket>
  | <left bracket> <character enumeration include>...
    <circumflex> <character enumeration exclude>... <right bracket>

<character enumeration include> ::= <character enumeration>

<character enumeration exclude> ::= <character enumeration>

<character enumeration> ::=
    <character specifier>
  | <character specifier> <minus sign> <character specifier>
  | <left bracket> <colon> <regular character set identifier> <colon> <right bracket>

<regular character set identifier> ::= <identifier>


Syntax Rules
1) The <row value predicand> shall be a <row value constructor predicand> that is a <common value
   expression> CVE. The declared types of CVE, <similar pattern>, and <escape character> shall be character
   string. CVE, <similar pattern>, and <escape character> shall be comparable.
2) Let CM be the <character value expression> of CVE and let SP be the <similar pattern>. If <escape character>
   EC is specified, then
      CM NOT SIMILAR TO SP ESCAPE EC
    is equivalent to
      NOT ( CM SIMILAR TO SP ESCAPE EC )
    If <escape character> EC is not specified, then
      CM NOT SIMILAR TO SP
    is equivalent to
      NOT ( CM SIMILAR TO SP )

3) The value of the <identifier> that is a <regular character set identifier> shall be either ALPHA, UPPER,
   LOWER, DIGIT, ALNUM, SPACE, or WHITESPACE.
4) The collation used for <similar predicate> is determined by applying Subclause 9.13, “Collation determi-
   nation”, with operands CVE, PC, and (if specified) EC.
    It is implementation-defined which collations can be used as collations for <similar predicate>.
5) A <non-escaped character> is any single character from the character set of the <similar pattern> that is
   not a <left bracket>, <right bracket>, <left paren>, <right paren>, <vertical bar>, <circumflex>, <minus
   sign>, <plus sign>, <asterisk>, <underscore>, <percent>, <question mark>, <left brace>, or the character
   specified by the result of the <character value expression> of <escape character>. A <character specifier>
   that is a <non-escaped character> represents itself.
6) An <escaped character> is a sequence of two characters: the character specified by the result of the <char-
   acter value expression> of <escape character>, followed by a second character that is a <left bracket>,


392 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                                                      8.6 <similar predicate>



    <right bracket>, <left paren>, <right paren>, <vertical bar>, <circumflex>, <minus sign>, <plus sign>,
    <asterisk>, <underscore>, <percent>, <question mark>, <left brace>, or the character specified by the result
    of the <character value expression> of <escape character>. A <character specifier> that is an <escaped
    character> represents its second character.
7) The value of <low value> shall be a positive integer. The value of <high value> shall be greater than or
   equal to the value of <low value>.


Access Rules
    None.


General Rules
1) Let MCV be the result of the <character value expression> of CVE and let PCV be the result of the <char-
   acter value expression> of the <similar pattern>. If EC is specified, then let ECV be its value.
2) If the result of the <character value expression> of the <similar pattern> is not a zero-length string and
   does not have the format of a <regular expression>, then an exception condition is raised: data exception
   — invalid regular expression.
3) If an <escape character> is specified, then:
    a) If the length in characters of ECV is not equal to 1 (one), then an exception condition is raised: data
       exception — invalid escape character.
    b) If ECV is one of <left bracket>, <right bracket>, <left paren>, <right paren>, <vertical bar>, <circum-
       flex>, <minus sign>, <plus sign>, <asterisk>, <underscore>, <percent>, <question mark>, or <left
       brace> and ECV occurs in the <regular expression> except in an <escaped character>, then an exception
       condition is raised: data exception — invalid use of escape character.
    c) If ECV is a <colon> and the <regular expression> contains a <regular character set identifier>, then
       an exception condition is raised: data exception — escape character conflict.
4) Case:
    a) If ESCAPE is not specified, then if either or both of MCV and PCV are the null value, then the result
       of
             CM SIMILAR TO SP
         is Unknown.
    b) If ESCAPE is specified, then if one or more of MCV, PCV, and ECV are the null value, then the result
       of
             CM SIMILAR TO SP ESCAPE EC
         is Unknown.
    NOTE 188 — If none of MCV, PCV, and ECV (if present) are the null value, then the result is either True or False.

5) The set of characters in a <character enumeration> is defined as



©ISO/IEC 2003 – All rights reserved                                                                             Predicates 393
ISO/IEC 9075-2:2003 (E)
8.6 <similar predicate>



    a) If the enumeration is specified in the form “<character specifier> <minus sign> <character specifier>”,
       then the set of all characters that collate greater than or equal to the character represented by the left
       <character specifier> and less than or equal to the character represented by the right <character specifier>,
       according to the collation of the pattern PCV.
    b) Otherwise, the character that the <character specifier> in the <character enumeration> represents.
6) Let LV be the value of the <low value> contained in a <repeat factor> RF.
    Case:
    a) If RF does not contain an <upper limit>, then let HV be LV.
    b) If RF contains an <upper limit> that contains a <high value>, then let HV be the value of <high value>.
    c) Otherwise, let HV be the length or maximum length of CVE.
7) Let R be the result of the <character value expression> of the <similar pattern>. The regular language L(R)
   of the <similar pattern> is a (possibly infinite) set of strings. It is defined recursively for well-formed
   <regular expression>s Q, Q1, and Q2 by the following rules:
    a) L( Q1 <vertical bar> Q2 )
         is the union of L(Q1) and L(Q2)
    b) L( Q <asterisk> )
         is the set of all strings that can be constructed by concatenating zero or more strings from L(Q).
    c) L( Q <plus sign> )
         is the set of all strings that can be constructed by concatenating one or more strings from L(Q).
    d) L( Q <repeat factor> )

         is the set of all strings that can be constructed by concatenating NS, LV ≤ NS ≤ HV, strings from L(Q).
    e) L( <character specifier> )
         is a set that contains a single string of length 1 (one) with the character that the <character specifier>
         represents
    f) L( <percent> )
         is the set of all strings of any length (zero or more) from the character set of the pattern PCV.
    g) L( <question mark> )
         is the set of all strings that can be constructed by concatenating exactly 0 (zero) or 1 (one) strings from
         L(Q).
    h) L( <left paren> Q <right paren> )
         is equal to L(Q)
    i)   L( <underscore> )
         is the set of all strings of length 1 (one) from the character set of the pattern PCV.


394 Foundation (SQL/Foundation)                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                                                      8.6 <similar predicate>



    j)   L( <left bracket> <character enumeration> <right bracket> )
         is the set of all strings of length 1 (one) from the set of characters in the <character enumeration>s.
    k) L( <left bracket> <circumflex> <character enumeration> <right bracket> )
         is the set of all strings of length 1 (one) with characters from the character set of the pattern PCV that
         are not contained in the set of characters in the <character enumeration>.
    l)   L( <left bracket> <character enumeration include> <circumflex> <character enumeration exclude>
         <right bracket> )
         is the set of all strings of length 1 (one) taken from the set of characters in the <character enumeration
         include>s, except for those strings of length 1 (one) taken from the set of characters in the <character
         enumeration exclude>.
    m) L( <left bracket> <colon> ALPHA <colon> <right bracket> )
         is the set of all character strings of length 1 (one) that are <simple Latin letter>s.
    n) L( <left bracket> <colon> UPPER <colon> <right bracket> )
         is the set of all character strings of length 1 (one) that are <simple Latin upper case letter>s.
    o) L( <left bracket> <colon> LOWER <colon> <right bracket> )
         is the set of all character strings of length 1 (one) that are <simple Latin lower case letter>s.
    p) L( <left bracket> <colon> DIGIT <colon> <right bracket> )
         is the set of all character strings of length 1 (one) that are <digit>s.
    q) L( <left bracket> <colon> SPACE <colon> <right bracket> )
         is the set of all character strings of length 1 (one) that are the <space> character.
    r) L( <left bracket> <colon> WHITESPACE <colon> <right bracket> )
         is the set of all character strings of length 1 (one) that are white space characters.
         NOTE 189 — “white space” is defined in Subclause 3.1.6, “Definitions provided in Part 2”.

    s) L( <left bracket> <colon> ALNUM <colon> <right bracket> )
         is the set of all character strings of length 1 (one) that are <simple Latin letter>s or <digit>s.
    t)   L( Q1 || Q2 )
         is the set of all strings that can be constructed by concatenating one element of L(Q1) and one element
         of L(Q2).
    u) L( Q )
         is the set of the zero-length string, if Q is an empty regular expression.
8) The <similar predicate>
         CM SIMILAR TO SP



©ISO/IEC 2003 – All rights reserved                                                                           Predicates 395
ISO/IEC 9075-2:2003 (E)
8.6 <similar predicate>



   is True, if there exists at least one element X of L(R) that is equal to MCV according to the collation of the
   <similar predicate>; otherwise, it is False.
   NOTE 190 — The <similar predicate> is defined differently from equivalent forms of the LIKE predicate. In particular, blanks at
   the end of a pattern and collation are handled differently.


Conformance Rules
1) Without Feature T141, “SIMILAR predicate”, conforming SQL language shall not contain a <similar
   predicate>.
2) Without Feature T042, “Extended LOB data type support”, in conforming SQL language, a <character
   value expression> simply contained in a <similar predicate> shall not be of declared type CHARACTER
   LARGE OBJECT.




396 Foundation (SQL/Foundation)                                                               ©ISO/IEC 2003 – All rights reserved
                                                                                                  ISO/IEC 9075-2:2003 (E)
                                                                                                     8.7 <null predicate>



8.7       <null predicate>

Function
Specify a test for a null value.


Format
<null predicate> ::= <row value predicand> <null predicate part 2>

<null predicate part 2> ::= IS [ NOT ] NULL


Syntax Rules
      None.


Access Rules
      None.


General Rules
1) Let R be the value of the <row value predicand>.
2) Case:
      a) If R is the null value, then “R IS NULL” is True.
      b) Otherwise:
          i)      The value of “R IS NULL” is
                  Case:
                  1) If the value of every field in R is the null value, then True.
                  2) Otherwise, False.
          ii)     The value of “R IS NOT NULL” is
                  Case:
                  1) If the value of no field in R is the null value, then True.
                  2) Otherwise, False.
      NOTE 191 — For all R, “R IS NOT NULL” has the same result as “NOT R IS NULL” if and only if R is of degree 1. Table 14,
      “<null predicate> semantics”, specifies this behavior.




©ISO/IEC 2003 – All rights reserved                                                                         Predicates 397
ISO/IEC 9075-2:2003 (E)
8.7 <null predicate>




                                     Table 14 — <null predicate> semantics


     Expression              R IS NULL       R IS NOT        NOT R IS         NOT R IS NOT NULL
                                             NULL            NULL

     degree 1: null          True            False           False            True

     degree 1: not null      False           True            True             False

     degree > 1: all null    True            False           False            True

     degree > 1: some null   False           False           True             True

     degree > 1: none null   False           True            True             False



Conformance Rules
   None.




398 Foundation (SQL/Foundation)                                         ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                      8.8 <quantified comparison predicate>



8.8      <quantified comparison predicate>

Function
Specify a quantified comparison.


Format
<quantified comparison predicate> ::=
    <row value predicand> <quantified comparison predicate part 2>

<quantified comparison predicate part 2> ::=
    <comp op> <quantifier> <table subquery>

<quantifier> ::=
    <all>
  | <some>

<all> ::= ALL

<some> ::=
    SOME
  | ANY


Syntax Rules
1) Let RV1 and RV2 be <row value predicand>s whose declared types are respectively that of the <row value
   predicand> and the row type of the <table subquery>. The Syntax Rules of Subclause 8.2, “<comparison
   predicate>”, are applied to:
        RV1 <comp op> RV2



Access Rules
      None.


General Rules
1) Let R be the result of the <row value predicand> and let T be the result of the <table subquery>.
2) The result of “R <comp op> <quantifier> T” is derived by the application of the implied <comparison
   predicate> “R <comp op> RT” to every row RT in T:
      Case:
      a) If T is empty or if the implied <comparison predicate> is True for every row RT in T, then “R <comp
         op> <all> T” is True.




©ISO/IEC 2003 – All rights reserved                                                           Predicates 399
ISO/IEC 9075-2:2003 (E)
8.8 <quantified comparison predicate>



    b) If the implied <comparison predicate> is False for at least one row RT in T, then “R <comp op> <all>
       T” is False.
    c) If the implied <comparison predicate> is True for at least one row RT in T, then “R <comp op> <some>
       T” is True.
    d) If T is empty or if the implied <comparison predicate> is False for every row RT in T, then “R <comp
       op> <some> T” is False.
    e) If “R <comp op> <quantifier> T” is neither True nor False, then it is Unknown.


Conformance Rules
    None.
NOTE 192 — If <equals operator> or <not equals operator> is specified, then the <quantified comparison predicate> is an equality
operator and the Conformance Rules of Subclause 9.9, “Equality operations”, apply. Otherwise, the <quantified comparison predicate>
is an ordering operation, and the Conformance Rules of Subclause 9.12, “Ordering operations”, apply.




400 Foundation (SQL/Foundation)                                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                                           8.9 <exists predicate>



8.9      <exists predicate>

Function
Specify a test for a non-empty set.


Format
<exists predicate> ::= EXISTS <table subquery>


Syntax Rules
      None.


Access Rules
      None.


General Rules
1) Let T be the result of the <table subquery>.
2) If the cardinality of T is greater than 0 (zero), then the result of the <exists predicate> is True; otherwise,
   the result of the <exists predicate> is False.


Conformance Rules
1) Without Feature T501, “Enhanced EXISTS predicate”, conforming SQL language shall not contain an
   <exists predicate> that simply contains a <table subquery> in which the <select list> of a <query specifica-
   tion> directly contained in the <table subquery> does not comprise either an <asterisk> or a single <derived
   column>.




©ISO/IEC 2003 – All rights reserved                                                               Predicates 401
ISO/IEC 9075-2:2003 (E)
8.10 <unique predicate>



8.10 <unique predicate>

Function
Specify a test for the absence of duplicate rows.


Format
<unique predicate> ::= UNIQUE <table subquery>


Syntax Rules
1) Each column of user-defined type in the result of the <table subquery> shall have a comparison type.
2) Each column of the <table subquery> is an operand of a grouping operation. The Syntax Rules of
   Subclause 9.10, “Grouping operations”, apply.


Access Rules
    None.


General Rules
1) Let T be the result of the <table subquery>.
2) If there are no two rows in T such that the value of each column in one row is non-null and is not distinct
   from the value of the corresponding column in the other row, then the result of the <unique predicate> is
   True; otherwise, the result of the <unique predicate> is False.


Conformance Rules
1) Without Feature F291, “UNIQUE predicate”, conforming SQL language shall not contain a <unique
   predicate>.
    NOTE 193 — The Conformance Rules of Subclause 9.10, “Grouping operations”, also apply.




402 Foundation (SQL/Foundation)                                                          ©ISO/IEC 2003 – All rights reserved
                                                                                  ISO/IEC 9075-2:2003 (E)
                                                                              8.11 <normalized predicate>



8.11 <normalized predicate>

Function
Determine whether a character string value is normalized.


Format
<normalized predicate> ::= <row value predicand> <normalized predicate part 2>

<normalized predicate part 2> ::= IS [ NOT ] NORMALIZED


Syntax Rules
1) The <row value predicand> shall be a <row value constructor predicand> that is a <common value
   expression> CVE. The declared type of CVE shal be character string and the character set of CVE shall be
   UTF8, UTF16, or UTF32.
2) The expression
    CVE IS NOT NORMALIZED
    is equivalent to
    NOT ( CVE IS NORMALIZED )


Access Rules
    None.


General Rules
1) The result of CVE IS NORMALIZED is
    Case:
    a) If the value of CVE is the null value, then Unknown.
    b) Otherwise, if the value of CVE is in Normalization Form C, as specified by [Unicode15], then True;
       otherwise, False.


Conformance Rules
1) Without Feature T061, “UCS support”, conforming SQL language shall not contain a <normalized predicate>.




©ISO/IEC 2003 – All rights reserved                                                         Predicates 403
ISO/IEC 9075-2:2003 (E)
8.12 <match predicate>



8.12 <match predicate>

Function
Specify a test for matching rows.


Format
<match predicate> ::= <row value predicand> <match predicate part 2>

<match predicate part 2> ::=
    MATCH [ UNIQUE ] [ SIMPLE | PARTIAL | FULL ] <table subquery>


Syntax Rules
1) The row type of the <row value predicand> and the row type of the <table subquery> shall be comparable.
2) Each field of <row value predicand> and each column of <table subquery> is an operand of an equality
   operation. The Syntax Rules of Subclause 9.9, “Equality operations”, apply.
3) If neither SIMPLE, PARTIAL, nor FULL is specified, then SIMPLE is implicit.


Access Rules
    None.


General Rules
1) Let R be the <row value predicand>.
2) If SIMPLE is specified or implicit, then
    Case:
    a) If R is the null value, then the <match predicate> is True.
    b) Otherwise:
        i)     If the value of some field in R is the null value, then the <match predicate> is True.
        ii)    If the value of no field in R is the null value, then
               Case:
               1) If UNIQUE is not specified and there exists a row RTi of the <table subquery> such that

                       R = RTi

                   then the <match predicate> is True.



404 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                           8.12 <match predicate>



                  2) If UNIQUE is specified and there exists exactly one row RTi in the result of evaluating the
                     <table subquery> such that
                          R = RTi

                      then the <match predicate> is True.
                  3) Otherwise, the <match predicate> is False.
3) If PARTIAL is specified, then
    Case:
    a) If R is the null value, then the <match predicate> is True.
    b) Otherwise,
         Case:
         i)       If the value of every field in R is the null value, then the <match predicate> is True.
         ii)      Otherwise,
                  Case:
                  1) If UNIQUE is not specified and there exists a row RTi of the <table subquery> such that
                     each non-null value of R equals its corresponding value in RTi, then the <match predicate>
                     is True.
                  2) If UNIQUE is specified and there exists exactly one row RTi in the result of evaluating the
                     <table subquery> such that each non-null value of R equals its corresponding value in RTi,
                     then the <match predicate> is True.
                  3) Otherwise, the <match predicate> is False.
4) If FULL is specified, then
    Case:
    a) If R is the null value, then the <match predicate> is True.
    b) Otherwise,
         Case:
         i)       If the value of every field in R is the null value, then the <match predicate> is True.
         ii)      If the value of no field in R is the null value, then
                  Case:
                  1) If UNIQUE is not specified and there exists a row RTi of the <table subquery> such that

                          R = RTi

                      then the <match predicate> is True.



©ISO/IEC 2003 – All rights reserved                                                                 Predicates 405
ISO/IEC 9075-2:2003 (E)
8.12 <match predicate>



               2) If UNIQUE is specified and there exists exactly one row RTi in the result of evaluating the
                  <table subquery> such that
                       R = RTi

                    then the <match predicate> is True.
               3) Otherwise, the <match predicate> is False.
       iii)    Otherwise, the <match predicate> is False.


Conformance Rules
1) Without Feature F741, “Referential MATCH types”, conforming SQL language shall not contain a <match
   predicate>.
   NOTE 194 — The Conformance Rules of Subclause 9.9, “Equality operations”, also apply.




406 Foundation (SQL/Foundation)                                                            ©ISO/IEC 2003 – All rights reserved
                                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                                                   8.13 <overlaps predicate>



8.13 <overlaps predicate>

Function
Specify a test for an overlap between two datetime periods.


Format
<overlaps predicate> ::= <overlaps predicate part 1> <overlaps predicate part 2>

<overlaps predicate part 1> ::= <row value predicand 1>

<overlaps predicate part 2> ::= OVERLAPS <row value predicand 2>

<row value predicand 1> ::= <row value predicand>

<row value predicand 2> ::= <row value predicand>


Syntax Rules
1) The degrees of <row value predicand 1> and <row value predicand 2> shall both be 2.
2) The declared types of the first field of <row value predicand 1> and the first field of <row value predicand
   2> shall both be datetime data types and these data types shall be comparable.
    NOTE 195 — Two datetimes are comparable only if they have the same <primary datetime field>s; see Subclause 4.6.2, “Datetimes”.

3) The declared type of the second field of each <row value predicand> shall be a datetime data type or
   INTERVAL.
    Case:
    a) If the declared type is INTERVAL, then the precision of the declared type shall be such that the interval
       can be added to the datetime data type of the first column of the <row value predicand>.
    b) If the declared type is a datetime data type, then it shall be comparable with the datetime data type of
       the first column of the <row value predicand>.


Access Rules
    None.


General Rules
1) If the value of <row value predicand 1> is the null value or the value of <row value predicand 2> is the
   null value, then the result of the <overlaps predicate> is Unknown and no further General Rules of this
   Subclause are applied.
2) Let D1 be the value of the first field of <row value predicand 1> and D2 be the value of the first field of
   <row value predicand 2>.


©ISO/IEC 2003 – All rights reserved                                                                             Predicates 407
ISO/IEC 9075-2:2003 (E)
8.13 <overlaps predicate>



3) Case:
    a) If the most specific type of the second field of <row value predicand 1> is a datetime data type, then
       let E1 be the value of the second field of <row value predicand 1>.
    b) If the most specific type of the second field of <row value predicand 1> is INTERVAL, then let I1 be
       the value of the second field of <row value predicand 1>. Let E1 = D1 + I1.
4) If D1 is the null value or if E1 < D1, then let S1 = E1 and let T1 = D1. Otherwise, let S1 = D1 and let T1
   = E1.
5) Case:
    a) If the most specific type of the second field of <row value predicand 2> is a datetime data type, then
       let E2 be the value of the second field of <row value predicand 2>.
    b) If the most specific type of the second field of <row value predicand 2> is INTERVAL, then let I2 be
       the value of the second field of <row value predicand 2>. Let E2 = D2 + I2.
6) If D2 is the null value or if E2 < D2, then let S2 = E2 and let T2 = D2. Otherwise, let S2 = D2 and let T2
   = E2.
7) The result of the <overlaps predicate> is the result of the following expression:

    ( S1 > S2 AND NOT ( S1 >= T2 AND T1 >= T2 ) )
         OR
    ( S2 > S1 AND NOT ( S2 >= T1 AND T2 >= T1 ) )
         OR
    ( S1 = S2 AND ( T1 <> T2 OR T1 = T2 ) )


Conformance Rules
1) Without Feature F053, “OVERLAPS predicate”, conforming SQL language shall not contain an <overlaps
   predicate>.




408 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                              ISO/IEC 9075-2:2003 (E)
                                                                                             8.14 <distinct predicate>



8.14 <distinct predicate>

Function
Specify a test of whether two row values are distinct


Format
<distinct predicate> ::=
    <row value predicand 3> <distinct predicate part 2>

<distinct predicate part 2> ::=
    IS [ NOT ] DISTINCT FROM <row value predicand 4>

<row value predicand 3> ::= <row value predicand>

<row value predicand 4> ::= <row value predicand>


Syntax Rules
1) The two <row value predicand>s shall be of the same degree.
2) Let respective values be values with the same ordinal position.
3) The declared types of the respective values of the two <row value predicand>s shall be comparable.
4) Let X be the first <row value predicand> and let Y be the second <row value predicand>.
5) Each field of each <row value predicand> is an operand of an equality operation. The Syntax Rules of
   Subclause 9.9, “Equality operations”, apply.
6) If <distinct predicate part 2> immediately contains NOT, then the <distinct predicate> is equivalent to:

    NOT ( X IS DISTINCT FROM Y )


Access Rules
    None.


General Rules
1) The result of <distinct predicate> is True if the value of <row value predicand 3> is distinct from the value
   of <row value predicand 4>; otherwise, the result is False.
    NOTE 196 — “distinct” is defined in Subclause 3.1.6, “Definitions provided in Part 2”.

2) If two <row value predicand>s are not distinct, then they are said to be duplicates. If a number of <row
   value predicand>s are all duplicates of each other, then all except one are said to be redundant duplicates.




©ISO/IEC 2003 – All rights reserved                                                                   Predicates 409
ISO/IEC 9075-2:2003 (E)
8.14 <distinct predicate>



Conformance Rules
1) Without Feature T151, “DISTINCT predicate”, conforming SQL language shall not contain a <distinct
   predicate>.
    NOTE 197 — The Conformance Rules of Subclause 9.9, “Equality operations”, also apply.

2) Without Feature T152, “DISTINCT predicate with negation”, conforming SQL language shall not contain
   a <distinct predicate part 2> that immediately contains NOT.




410 Foundation (SQL/Foundation)                                                             ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                                   8.15 <member predicate>



8.15 <member predicate>

Function
Specify a test of whether a value is a member of a multiset.


Format
<member predicate> ::=
    <row value predicand> <member predicate part 2>

<member predicate part 2> ::=
    [ NOT ] MEMBER [ OF ] <multiset value expression>


Syntax Rules
1) Let MVE be the <multiset value expression> and let ET be the declared element type of MVE.
2) Case:
    a) If the <row value predicand> is a <row value constructor predicand> that is a single <common value
       expression> or <boolean value expression> CVE, then let X be CVE.
    b) Otherwise, let X be the <row value predicand>.
3) The declared type of X shall be comparable to ET.
4) X is an operand of an equality operation. The Syntax Rules of Subclause 9.9, “Equality operations”, apply.
5) If <member predicate part 2> immediately contains NOT, then the <member predicate> is equivalent to
        NOT ( X MEMBER OF MVE )



Access Rules
    None.


General Rules
1) Let XV be the value of X, and let MV be the value of MVE.
2) Let N be the result of CARDINALITY (MVE).
3) The <member predicate>
        XV MEMBER OF MVE

    is evaluated as follows:
    Case:


©ISO/IEC 2003 – All rights reserved                                                          Predicates 411
ISO/IEC 9075-2:2003 (E)
8.15 <member predicate>



   a) If N is 0 (zero), then the <member predicate> is False.
   b) If either XV or MV is the null value, then the <member predicate> is Unknown.

   c) Otherwise, let MEi for 1 (one) ≤ i ≤ N be an enumeration of the elements of MV.

       Case:
       i)      If CV = MEi for some i, then the <member predicate> is True.

       ii)     If MEi is the null value for some i, then the <member predicate> is Unknown.

       iii)    Otherwise, the <member predicate> is False.


Conformance Rules
1) Without Feature S271, “Basic multiset support”, conforming SQL language shall not contain a <member
   predicate>.
   NOTE 198 — The Conformance Rules of Subclause 9.9, “Equality operations”, also apply.




412 Foundation (SQL/Foundation)                                                            ©ISO/IEC 2003 – All rights reserved
                                                                                 ISO/IEC 9075-2:2003 (E)
                                                                             8.16 <submultiset predicate>



8.16 <submultiset predicate>

Function
Specify a test of whether a multiset is a submultiset of another multiset.


Format
<submultiset predicate> ::=
    <row value predicand> <submultiset predicate part 2>

<submultiset predicate part 2> ::=
    [ NOT ] SUBMULTISET [ OF ] <multiset value expression>


Syntax Rules
1) The <row value predicand> shall be a <row value constructor> that is a single <common value expression>
   CVE. The declared type of CVE shall be a multiset type. Let CVET be the declared element type of CVE.
2) Let MVE be the <multiset value expression>. Let MVET be the declared element type of MVE.
3) CVET shall be comparable to MVET.
4) CVE and MVE are multiset operands of a multiset element grouping operation. The Syntax Rules of
   Subclause 9.11, “Multiset element grouping operations”, apply.
5) If <submultiset predicate part 2> immediately contains NOT, then the <member predicate> is equivalent
   to
        NOT ( CVE SUBMULTISET OF MVE )



Access Rules
    None.


General Rules
1) Let CV be the value of CVE, and let MV be the value of MVE.
2) Let M be the result of CARDINALITY (CV), and let N be the result of CARDINALITY (MV).
3) The <submultiset predicate>
        CVE SUBMULTISET OF MVE

    is evaluated as follows:
    Case:



©ISO/IEC 2003 – All rights reserved                                                        Predicates 413
ISO/IEC 9075-2:2003 (E)
8.16 <submultiset predicate>



   a) If M is 0 (zero), then the <submultiset predicate> is True.
   b) If either CV or MV is the null value, then the <submultiset predicate> is Unknown.
   c) Otherwise,
       Case:
       i)      If M > N, then the <submultiset predicate> is False.

       ii)     If there exist an enumeration CEi for 1 (one) ≤ i ≤ M of the elements of CE and an enumeration
               MEj for 1 (one) ≤ j ≤ N of the elements of MV such that for all i, 1 (one) ≤ i ≤ M, CEi = MEi,
               then the <submultiset predicate> is True.

       iii)    If there exist an enumeration CEi for 1 (one) ≤ i ≤ M of the elements of CE and an enumeration
               MEi for 1 (one) ≤ i ≤ N of the elements of MV such that for all i, 1 (one) ≤ i ≤ M, CEi = MEi is
               either True or Unknown, then the <submultiset predicate> is Unknown.
       iv)     Otherwise, the <submultiset predicate> is False.


Conformance Rules
1) Without Feature S275, “Advanced multiset support”, conforming SQL language shall not contain a <sub-
   multiset predicate>.
   NOTE 199 — The Conformance Rules of Subclause 9.11, “Multiset element grouping operations”, also apply.




414 Foundation (SQL/Foundation)                                                          ©ISO/IEC 2003 – All rights reserved
                                                                                               ISO/IEC 9075-2:2003 (E)
                                                                                                  8.17 <set predicate>



8.17 <set predicate>

Function
Specify a test of whether a multiset is a set (that is, does not contain any duplicates).


Format
<set predicate> ::= <row value predicand> <set predicate part 2>

<set predicate part 2> ::= IS [ NOT ] A SET


Syntax Rules
1) The <row value predicand> shall be a <row value constructor predicand> that is a single <common value
   expression> CVE. The declared type of CVE shall be a multiset type. Let CVET be the element type of
   CVE.
2) CVE is an operand of a multiset element grouping operation. The Syntax Rules of Subclause 9.11, “Multiset
   element grouping operations”, apply.
3) If <set predicate part 2> immediately contains NOT, then the <set predicate> is equivalent to
        NOT ( CVE IS A SET )


4) If <set predicate part 2> does not immediately contain NOT, then the <set predicate> is equivalent to
        CARDINALITY ( CVE ) = CARDINALITY ( SET ( CVE ) )



Access Rules
    None.


General Rules
    None.


Conformance Rules
1) Without Feature S271, “Basic multiset support”, conforming SQL language shall not contain a <set predi-
   cate>.
    NOTE 200 — The Conformance Rules of Subclause 9.11, “Multiset element grouping operations”, also apply.




©ISO/IEC 2003 – All rights reserved                                                                       Predicates 415
ISO/IEC 9075-2:2003 (E)
8.18 <type predicate>



8.18 <type predicate>

Function
Specify a type test.


Format
<type predicate> ::=
    <row value predicand> <type predicate part 2>

<type predicate part 2> ::=
    IS [ NOT ] OF <left paren> <type list> <right paren>

<type list> ::=
    <user-defined type specification>
    [ { <comma> <user-defined type specification> }... ]

<user-defined type specification> ::=
    <inclusive user-defined type specification>
  | <exclusive user-defined type specification>

<inclusive user-defined type specification> ::=
    <path-resolved user-defined type name>

<exclusive user-defined type specification> ::=
    ONLY <path-resolved user-defined type name>


Syntax Rules
1) The <row value predicand> immediately contained in <type predicate> shall be a <row value constructor
   predicand> that is a <common value expression> CVE.
2) The declared type of CVE shall be a user-defined type.
3) For each <user-defined type name> UDTN contained in a <user-defined type specification>, the schema
   identified by the implicit or explicit schema name of UDTN shall include a user-defined type descriptor
   whose name is equivalent to the <qualified identifier> of UDTN.
4) Let the term specified type refer to a user-defined type that is specified by a <user-defined type name>
   contained in a <user-defined type specification>. A type specified by an <inclusive user-defined type
   specification> is inclusively specified; a type specified by an <exclusive user-defined type specification>
   is exclusively specified.
5) Let T be the type specified by <inclusive user-defined type specification> or <exclusive user-defined type
   specification>. T shall be a subtype of the declared type of CVE.
    NOTE 201 — The term “subtype family” is defined in Subclause 4.7.5, “Subtypes and supertypes”. If T1 is a member of the subtype
    family of T2, then it follows that the subtype family of T1 and the subtype family of T2 are the same set of types.

6) Let TL be the <type list>.
7) A <type predicate> of the form


416 Foundation (SQL/Foundation)                                                                ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                        8.18 <type predicate>



        CVE IS NOT OF (TL)
    is equivalent to
        NOT ( CVE IS OF (TL) )


Access Rules
    None.


General Rules
1) Let V be the result of evaluating the <row value predicand>.
2) Let ST be the set consisting of every type that is either some exclusively specified type, or a subtype of
   some inclusively specified type.
3) Let TPR be the result of evaluating the <type predicate>.
    Case:
    a) If V is the null value, then TPR is Unknown.
    b) If the most specific type of V is a member of ST, then TPR is True.
    c) Otherwise, TPR is False.


Conformance Rules
1) Without Feature S151, “Type predicate”, conforming SQL language shall not contain a <type predicate>.




©ISO/IEC 2003 – All rights reserved                                                             Predicates 417
ISO/IEC 9075-2:2003 (E)
8.19 <search condition>



8.19 <search condition>

Function
Specify a condition that is True, False, or Unknown, depending on the value of a <boolean value expression>.


Format
<search condition> ::= <boolean value expression>


Syntax Rules
    None.


Access Rules
    None.


General Rules
1) When a <search condition> S is evaluated against a row of a table, each reference to a column of that table
   by a column reference directly contained in S is a reference to the value of that column in that row.
2) The result of the <search condition> is the result of the <boolean value expression>.


Conformance Rules
    None.




418 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                                                   9.1 Retrieval assignment




9 Additional common rules


9.1       Retrieval assignment

Function
Specify rules for assignments to targets that do not support null values or that support null values with indicator
parameters (e.g., assigning SQL-data to host parameters or host variables).


Syntax Rules
1) Let T and V be the TARGET and VALUE specified in an application of this Subclause. Let the declared
   types of T and V be TD and SD, respectively.
2) If TD is binary string, numeric, boolean, datetime, interval, or a user-defined type, then either SD shall be
   assignable to TD or there shall exist an appropriate user-defined cast function UDCF from SD to TD.
      NOTE 202 — “Appropriate user-defined cast function” is defined in Subclause 4.11, “Data conversions”.

3) If TD is character string, then
      Case:
      a) If T is either a locator parameter of an external routine, a locator variable, or a host parameter that is a
         character large object locator parameter, then SD shall be CHARACTER LARGE OBJECT and SD
         shall be assignable to TD.
      b) Otherwise, either SD shall be assignable to TD or there shall exist an appropriate user-defined cast
         function UDCF from SD to TD.
4) If the declared type of T is a reference type, then the declared type of V shall be a reference type whose
   referenced type is a subtype of the referenced type of T.
5) If the declared type of T is a row type, then:
      a) The declared type of V shall be a row type.
      b) The degree of V shall be the same as the degree of T. Let n be that degree.

      c) Let TTi, 1 (one) ≤ i ≤ n, be the declared type of the i-th field of T, let VTi be the declared type of the
         i-th field of V, let T1i be an arbitrary target whose declared type is TTi, and let V1i be an arbitrary
          expression whose declared type is VTi. For each i, 1 (one) ≤ i ≤ n, the Syntax Rules of this Subclause
          apply to Ti Vi, as TARGET and VALUE, respectively.

6) If the declared type of T is a collection type, then:
      a) If the declared type of T is an array type, then the declared type of V shall be an array type.


©ISO/IEC 2003 – All rights reserved                                                           Additional common rules 419
ISO/IEC 9075-2:2003 (E)
9.1 Retrieval assignment



    b) If the declared type of T is a multiset type, then the declared type of V shall be a multiset type.
    c) Let TT be the element type of the declared type of T, let VT be the element type of the declared type
       of V, let T1 be an arbitrary target whose declared type is TT, and let V1 be an arbitrary expression whose
       declared type is VT. The Syntax Rules of this Subclause apply to T1 and V1, as TARGET and VALUE,
       respectively.


Access Rules
    None.


General Rules
1) If the declared type of V is not assignable to the declared type of T, then for the remaining General Rules
   of this Subclause V is effectively replaced by the result of evaluating the expression UDCF(V).
2) If V is the null value and T is a host parameter, then
    Case:
    a) If an indicator parameter is specified for T, then that indicator parameter is set to –1.
    b) If no indicator parameter is specified for T, then an exception condition is raised: data exception —
       null value, no indicator parameter.
3) If V is the null value and T is a host variable, then
    Case:
    a) If an indicator variable is specified for T, then that indicator variable is set to –1.
    b) If no indicator variable is specified for T, then an exception condition is raised: data exception — null
       value, no indicator parameter.
4) If V is not the null value, T is a host parameter, and T has an indicator parameter, then
    Case:
    a) If the declared type of T is character string or binary string and the length M in characters or octets,
       respectively, of V is greater than the length in characters or octets, respectively, of T, then the indicator
       parameter is set to M. If M exceeds the maximum value that the indicator parameter can contain, then
       an exception condition is raised: data exception — indicator overflow.
    b) Otherwise, the indicator parameter is set to 0 (zero).
5) If V is not the null value, T is a host variable, and T has an indicator variable, then
    Case:
    a) If the declared type of T is character string or binary string and the length in characters or octets,
       respectively, M of V is greater than the length in characters or octets, respectively, of T, then the indi-
       cator parameter is set to M. If M exceeds the maximum value that the indicator parameter can contain,
       then an exception condition is raised: data exception — indicator overflow.



420 Foundation (SQL/Foundation)                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)
                                                                                           9.1 Retrieval assignment



    b) Otherwise, the indicator variable is set to 0 (zero).
6) If V is not the null value, then
    Case:
    a) If the declared type of T is fixed-length character string with length in characters L and the length in
       characters of V is equal to L, then the value of T is set to V.
    b) If the declared type of T is fixed-length character string with length in characters L, and the length in
       characters of V is greater than L, then the value of T is set to the first L characters of V and a completion
       condition is raised: warning — string data, right truncation.
    c) If the declared type of T is fixed-length character string with length in characters L, and the length in
       characters M of V is smaller than L, then the first M characters of T are set to V, and the last L–M
       characters of T are set to <space>s.
    d) If the declared type of T is variable-length character string and the length in characters M of V is not
       greater than the maximum length in characters of T, then the value of T is set to V and the length in
       characters of T is set to M.
    e) If the declared type of T is variable-length character string and the length in characters of V is greater
       than the maximum length in characters L of T, then the value of T is set to the first L characters of V,
       then the length in characters of T becomes L, and a completion condition is raised: warning — string
       data, right truncation.
    f) If the declared type of T is a character large object type and the length in characters M of V is not greater
       than the maximum length in characters of T, then the value of T is set to V and the length in characters
       of T is set to M.
    g) If the declared type of T is a character large object type and the length in characters of V is greater than
       the maximum length in characters L of T, then the value of T is set to the first L characters of V, the
       length in characters of T becomes L, and a completion condition is raised: warning — string data, right
       truncation.
    h) If the declared type of T is binary string and the length in octets M of V is not greater than the maximum
       length in octets of T, then the value of T is set to V and the length in octets of T is set to M.
    i)   If the declared type of T is binary string and the length in octets of V is greater than the maximum
         length in octets L of T, then the value of T is set to the first L octets of V, the length in octets of T
         becomes L, and a completion condition is raised: warning — string data, right truncation.
    j)   If the declared type of T is numeric, then
         Case:
         i)       If V is a member of the declared type of T, then T is set to V.
         ii)      If a member of the declared type of T can be obtained from V by rounding or truncation, then T
                  is set to that value. If the declared type of T is exact numeric, then it is implementation-defined
                  whether the approximation is obtained by rounding or by truncation.
         iii)     Otherwise, an exception condition is raised: data exception — numeric value out of range.
    k) If the declared type of T is boolean, then the value of T is set to V.



©ISO/IEC 2003 – All rights reserved                                                   Additional common rules 421
ISO/IEC 9075-2:2003 (E)
9.1 Retrieval assignment



   l)   If the declared type DT of T is datetime, then:
        i)      If only one of DT and the declared type of V is datetime with time zone, then V is effectively
                replaced by
                  CAST ( V AS DT )

        ii)     Case:
                1) If V is a member of the declared type of T, then T is set to V.
                2) If a member of the declared type of T can be obtained from V by rounding or truncation,
                   then T is set to that value. It is implementation-defined whether the approximation is obtained
                   by rounding or truncation.
                3) Otherwise, an exception condition is raised: data exception — datetime field overflow.
   m) If the declared type of T is interval, then
        Case:
        i)      If V is a member of the declared type of T, then T is set to V.
        ii)     If a member of the declared type of T can be obtained from V by rounding or truncation, then T
                is set to that value. It is implementation-defined whether the approximation is obtained by
                rounding or by truncation.
        iii)    Otherwise, an exception condition is raised: data exception — interval field overflow.
   n) If the declared type of T is a row type, then:
        i)      Let n be the degree of T.
        ii)     For i ranging from 1 (one) to n, the General Rules of this Subclause are applied to the i-th element
                of T and the i-th element of V as TARGET and VALUE, respectively.
   o) If the declared type of T is a user-defined type, then the value of T is set to V.
   p) If the declared type of T is a reference type, then the value of T is set to V.
   q) If the declared type of T is an array type, then
        Case:
        i)      If the maximum cardinality L of T is equal to the cardinality M of V, then the elements of T are
                set to the values of the corresponding elements of V by applying the General Rules of this Sub-
                clause to each pair of elements with the element of T as TARGET and the element of V as VALUE.
        ii)     If the maximum cardinality L of T is smaller than the cardinality M of V, then the elements of
                T are set to the values of the first L corresponding elements of V by applying the General Rules
                of this Subclause to each pair of elements with the element of T as TARGET and the element of
                V as VALUE; a completion condition is raised: warning — array data, right truncation.
        iii)    If the maximum cardinality L of T is greater than the cardinality M of V, then the M first elements
                of T are set to the values of the corresponding elements of V by applying the General Rules of




422 Foundation (SQL/Foundation)                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                        9.1 Retrieval assignment



                  this Subclause to each pair of elements with the element of T as TARGET and the element of V
                  as VALUE. The cardinality of the value of T is M.
                  NOTE 203 — The maximum cardinality L of T is unchanged.

    r) If the declared type of T is a multiset type, then the value of T is set to V.


Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved                                                Additional common rules 423
ISO/IEC 9075-2:2003 (E)
9.2 Store assignment



9.2       Store assignment

Function
Specify rules for assignments where the target permits null without the use of indicator parameters or indicator
variables, such as storing SQL-data or setting the value of SQL parameters.


Syntax Rules
1) Let T and V be the TARGET and VALUE specified in an application of this Subclause. Let the declared
   types of T and V be TD and SD, respectively.
2) If TD is character string, binary string, numeric, boolean, datetime, interval, or a user-defined type, then
   either SD shall be assignable to TD or there shall exist an appropriate user-defined cast function UDCF
   from SD to TD.
      NOTE 204 — “Appropriate user-defined cast function” is defined in Subclause 4.11, “Data conversions”.

3) If the declared type of T is a reference type, then the declared type of V shall be a reference type whose
   referenced type is a subtype of the referenced type of T.
4) If the declared type of T is a row type, then:
      a) The declared type of V shall be a row type.
      b) The degree of V shall be the same as the degree of T. Let n be that degree.

      c) Let TTi, 1 (one) ≤ i ≤ n, be the declared type of the i-th field of T, let VTi be the declared type of the
         i-th field of V, let T1i be an arbitrary target whose declared type is TTi, and let V1i be an arbitrary
          expression whose declared type is VTi. For each i, 1 (one) ≤ i ≤ n, the Syntax Rules of this Subclause
          apply to Ti Vi, as TARGET and VALUE, respectively.

5) If the declared type of T is a collection type, then:
      a) If the declared type of T is an array type, then the declared type of V shall be an array type.
      b) If the declared type of T is a multiset type, then the declared type of V shall be a multiset type.
      c) Let TT be the element type of the declared type of T, let VT be the element type of the declared type
         of V, let T1 be an arbitrary target whose declared type is TT, and let V1 be an arbitrary expression whose
         declared type is VT. The Syntax Rules of this Subclause apply to T1 and V1, as TARGET and VALUE,
         respectively.


Access Rules
      None.




424 Foundation (SQL/Foundation)                                                                ©ISO/IEC 2003 – All rights reserved
                                                                                            ISO/IEC 9075-2:2003 (E)
                                                                                               9.2 Store assignment



General Rules
1) If the declared type of V is not assignable to the declared type of T, then for the remaining General Rules
   of this Subclause V is effectively replaced by the result of evaluating the expression UDCF(V).
2) Case:
    a) If V is the null value, then
         Case:
         i)       If V is specified using NULL, then T is set to the null value.
         ii)      If V is a host parameter and contains an indicator parameter, then
                  Case:
                  1) If the value of the indicator parameter is equal to –1, then T is set to the null value.
                  2) If the value of the indicator parameter is less than –1, then an exception condition is raised:
                     data exception — invalid indicator parameter value.
         iii)     If V is a host variable and contains an indicator variable, then
                  Case:
                  1) If the value of the indicator variable is equal to –1, then T is set to the null value.
                  2) If the value of the indicator variable is less than –1, then an exception condition is raised:
                     data exception — invalid indicator parameter value.
         iv)      Otherwise, T is set to the null value.
    b) Otherwise,
         Case:
         i)       If the declared type of T is fixed-length character string with length in characters L and the length
                  in characters of V is equal to L, then the value of T is set to V.
         ii)      If the declared type of T is fixed-length character string with length in characters L and the length
                  in characters M of V is larger than L, then
                  Case:
                  1) If the rightmost M–L characters of V are all <space>s, then the value of T is set to the first
                     L characters of V.
                  2) If one or more of the rightmost M–L characters of V are not <space>s, then an exception
                     condition is raised: data exception — string data, right truncation.
         iii)     If the declared type of T is fixed-length character string with length in characters L and the length
                  in characters M of V is less than L, then the first M characters of T are set to V and the last L–M
                  characters of T are set to <space>s.




©ISO/IEC 2003 – All rights reserved                                                    Additional common rules 425
ISO/IEC 9075-2:2003 (E)
9.2 Store assignment



       iv)     If the declared type of T is variable-length character string and the length in characters M of V
               is not greater than the maximum length in characters of T, then the value of T is set to V and the
               length in characters of T is set to M.
       v)      If the declared type of T is variable-length character string and the length in characters M of V
               is greater than the maximum length in characters L of T, then
               Case:
               1) If the rightmost M–L characters of V are all <space>s, then the value of T is set to the first
                  L characters of V and the length in characters of T is set to L.
               2) If one or more of the rightmost M–L characters of V are not <space>s, then an exception
                  condition is raised: data exception — string data, right truncation.
       vi)     If the declared type of T is a character large object type and the length in characters M of V is
               not greater than the maximum length in characters of T, then the value of T is set to V and the
               length in characters of T is set to M.
       vii)    If the declared type of T is a character large object type and the length in characters M of V is
               greater than the maximum length in characters L of T, then
               Case:
               1) If the rightmost M–L characters of V are all <space>s, then the value of T is set to the first
                  L characters of V and the length in characters of T is set to L.
               2) If one or more of the rightmost M–L characters of V are not <space>s, then an exception
                  condition is raised: data exception — string data, right truncation.
       viii)   If the declared type of T is binary string and the length in octets M of V is not greater than the
               maximum length in octets of T, then the value of T is set to V and the length in octets of T is set
               to M.
       ix)     If the declared type of T is binary string and the length in octets M of V is greater than the max-
               imum length in octets L of T, then
               Case:
               1) If the rightmost M–L octets of V are all equal to X'00', then the value of T is set to the first
                  L octets of V and the length in octets of T is set to L.
               2) If one or more of the rightmost M–L octets of V are not equal to X'00', then an exception
                  condition is raised: data exception — string data, right truncation.
       x)      If the declared type of T is numeric, then
               Case:
               1) If V is a member of the declared type of T, then T is set to V.
               2) If a member of the declared type of T can be obtained from V by rounding or truncation,
                  then T is set to that value. If the declared type of T is exact numeric, then it is implementation-
                  defined whether the approximation is obtained by rounding or by truncation.
               3) Otherwise, an exception condition is raised: data exception — numeric value out of range.


426 Foundation (SQL/Foundation)                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                            ISO/IEC 9075-2:2003 (E)
                                                                                               9.2 Store assignment



         xi)      If the declared type DT of T is datetime, then
                  1) If only one of DT and the declared type of V is datetime with time zone, then V is effectively
                     replaced by
                          CAST ( V AS DT )

                  2) Case:
                      A) If V is a member of the declared type of T, then T is set to V.
                      B) If a member of the declared type of T can be obtained from V by rounding or truncation,
                         then T is set to that value. It is implementation-defined whether the approximation is
                         obtained by rounding or truncation.
                      C) Otherwise, an exception condition is raised: data exception — datetime field overflow.
         xii)     If the declared type of T is interval, then
                  Case:
                  1) If V is a member of the declared type of T, then T is set to V.
                  2) If a member of the declared type of T can be obtained from V by rounding or truncation,
                     then T is set to that value. It is implementation-defined whether the approximation is obtained
                     by rounding or by truncation.
                  3) Otherwise, an exception condition is raised: data exception — interval field overflow.
         xiii)    If the declared type of T is boolean, then the value of T is set to V.
         xiv)     If the declared type of T is a row type, then:
                  1) Let n be the degree of T.
                  2) For i ranging from 1 (one) to n, the General Rules of this Subclause are applied to the i-th
                     element of T and the i-th element of V as TARGET and VALUE, respectively.
         xv)      If the declared type of T is a user-defined type, then the value of T is set to V.
         xvi)     If the declared type of T is a reference type, then the value of T is set to V.
         xvii) If the declared type of T is an array type, then
                  Case:
                  1) If the maximum cardinality L of T is equal to the cardinality M of V, then the elements of T
                     are set to the values of the corresponding elements of V by applying the General Rules of
                     this Subclause to each pair of elements with the element of T as TARGET and the element
                     of V as VALUE.
                  2) If the maximum cardinality L of T is smaller than the cardinality M of V, then
                      Case:
                      A) If the rightmost M–L elements of V are all null, then the elements of T are set to the
                         values of the first L corresponding elements of V by applying the General Rules of this


©ISO/IEC 2003 – All rights reserved                                                    Additional common rules 427
ISO/IEC 9075-2:2003 (E)
9.2 Store assignment



                       Subclause to each pair of elements with the element of T as TARGET and the element
                       of V as VALUE.
                  B) If one or more of the rightmost M–L elements of V are not null, then an exception con-
                     dition is raised: data exception — array data, right truncation.
              3) If the maximum cardinality L of T is greater than the cardinality M of V, then the M first
                 elements of T are set to the values of the corresponding elements of V by applying the
                 General Rules of this Subclause to each pair of elements with the element of T as TARGET
                 and the element of V as VALUE. The cardinality of the value of T is set to M.
                  NOTE 205 — The maximum cardinality L of T is unchanged.

       xviii) If the declared type of T is a multiset type, then the value of T is set to V.


Conformance Rules
   None.




428 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                                 ISO/IEC 9075-2:2003 (E)
                                                                                  9.3 Data types of results of aggregations



9.3       Data types of results of aggregations

Function
Specify the result data type of the result of an aggregation over values of compatible data types, such as <case
expression>s, <collection value expression>s, or a column in the result of a <query expression>.


Syntax Rules
1) Let IDTS be the set of data types specified in an application of this Subclause. Let DTS be the set of data
   types in IDTS excluding any data types that are undefined. If the cardinality of DTS is 0 (zero), then the
   result data type is undefined and no further Rules of this Subclause are evaluated.
      NOTE 206 — The notion of “undefined data type” is defined in Subclause 19.6, “<prepare statement>”.

2) All of the data types in DTS shall be comparable.
3) Case:
      a) If any of the data types in DTS is character string, then:
          i)      All data types in DTS shall be character string, and all of them shall have the same character
                  repertoire. The character set of the result is the character set of the data type in DTS that has the
                  character encoding form with the higest precedence.
          ii)     The collation derivation and declared type collation of the result are determined as follows.
                  Case:
                  1) If some data type in DTS has an explicit collation derivation and declared type collation
                     EC1, then every data type in DTS that has an explicit collation derivation shall have a declared
                     type collation that is EC1. The collation derivation is explicit and the collation is EC1.
                  2) If every data type in DTS has an implicit collation derivation, then
                       Case:
                       A) If every data type in DTS has the same declared type collation IC1, then the collation
                          derivation is implicit and the declared type collation is IC1.
                       B) Otherwise, the collation derivation is none.
                  3) Otherwise, the collation derivation is none.
          iii)    Case:
                  1) If any of the data types in DTS is a character large object type, then the result data type is a
                     character large object type with maximum length in characters equal to the maximum of the
                     lengths in characters and maximum lengths in characters of the data types in DTS.
                  2) If any of the data types in DTS is variable-length character string, then the result data type
                     is variable-length character string with maximum length in characters equal to the maximum
                     of the lengths in characters and maximum lengths in characters of the data types in DTS.



©ISO/IEC 2003 – All rights reserved                                                          Additional common rules 429
ISO/IEC 9075-2:2003 (E)
9.3 Data types of results of aggregations



                 3) Otherwise, the result data type is fixed-length character string with length in characters equal
                    to the maximum of the lengths in characters of the data types in DTS.
    b) If any of the data types in DTS is binary string, then the result data type is binary string with maximum
       length in octets equal to the maximum of the lengths in octets and maximum lengths in octets of the
       data types in DTS.
    c) If all of the data types in DTS are exact numeric, then the result data type is exact numeric with
       implementation-defined precision and with scale equal to the maximum of the scales of the data types
       in DTS.
    d) If any data type in DTS is approximate numeric, then each data type in DTS shall be numeric and the
       result data type is approximate numeric with implementation-defined precision.
    e) If some data type in DTS is a datetime data type, then every data type in DTS shall be a datetime data
       type having the same datetime fields. The result data type is a datetime data type having the same
       datetime fields, whose fractional seconds precision is the largest of the fractional seconds precisions
       in DTS. If some data type in DTS has a time zone displacement value, then the result has a time zone
       displacement value; otherwise, the result does not have a time zone displacement value.
    f) If any data type in DTS is interval, then each data type in DTS shall be interval. If the precision of any
       data type in DTS specifies YEAR or MONTH, then the precision of each data type shall specify only
       YEAR or MONTH. If the precision of any data type in DTS specifies DAY, HOUR, MINUTE, or
       SECOND(N), then the precision of no data type of DTS shall specify the <primary datetime field>s
       YEAR and MONTH. The result data type is interval with precision “S TO E”, where S and E are the
       most significant of the <start field>s and the least significant of the <end field>s of the data types in
       DTS, respectively.
    g) If any data type in DTS is boolean, then each data type in DTS shall be boolean. The result data type
       is boolean.
    h) If any data type in DTS is a row type, then each data type in DTS shall be a row type with the same
       degree and the data type of each field in the same ordinal position of every row type shall be comparable.
       The result data type is a row type defined by an ordered sequence of (<field name>, data type) pairs
       FDi, where data type is the data type resulting from the application of this Subclause to the set of data
       types of fields in the same ordinal position as FDi in every row type in DTS and <field name> is
       determined as follows:
         Case:
         i)      If the names of fields in the same ordinal position as FDi in every row type in DTS is F, then
                 the <field name> in FDi is F.

         ii)     Otherwise, the <field name> in FDi is implementation-dependent.

    i)   If any data type in DTS is an array type then every data type in DTS shall be an array type. The data
         type of the result is array type with element data type ETR, where ETR is the data type resulting from
         the application of this Subclause to the set of element types of the array types of DTS, and maximum
         cardinality equal to the maximum of the maximum cardinalities of the data types in DTS.
    j)   If any data type in DTS is a multiset type then every data type in DTS shall be a multiset type. The data
         type of the result is multiset type with element data type ETR, where ETR is the data type resulting
         from the application of this Subclause to the set of element types of the multiset types of DTS.


430 Foundation (SQL/Foundation)                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                             ISO/IEC 9075-2:2003 (E)
                                                                              9.3 Data types of results of aggregations



    k) If any data type in DTS is a reference type, then there shall exist a subtype family STF such that each
       data type in DTS is a member of STF. Let RT be the minimal common supertype of each data type in
       DTS.
         Case:
         i)       If the data type descriptor of every data type in DTS includes the name of a referenceable table
                  identifying the scope of the reference type, and every such name is equivalent to some name
                  STN, then result data type is:

                  RT SCOPE ( STN )

         ii)      Otherwise, the result data type is RT.
    l)   Otherwise, there shall exist a subtype family STF such that each data type in DTS is a member of STF.
         The result data type is the minimal common supertype of each data type in DTS.
         NOTE 207 — Minimal common supertype is defined in Subclause 4.7.5, “Subtypes and supertypes”.


Access Rules
    None.


General Rules
    None.


Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved                                                      Additional common rules 431
ISO/IEC 9075-2:2003 (E)
9.4 Subject routine determination



9.4       Subject routine determination

Function
Determine the subject routine of a given routine invocation.


Syntax Rules
1) Let SR and AL be respectively the set of SQL-invoked routines, arbitrarily ordered, and the <SQL argument
   list> specified in an application of this Subclause.

2) Let n be the number of SQL-invoked routines in SR. Let Ri, 1 (one) ≤ i ≤ n, be the i-th SQL-invoked routine
   in SR in the ordering of SR.

3) Let m be the number of SQL arguments in AL. Let Aj, 1 (one) ≤ j ≤ m, be the j-th SQL argument in AL.

4) For Aj, 1 (one) ≤ j ≤ m, then let SDTAj be the declared type of Aj.

5) Let SDTPi,j be the type designator of the declared type of the j-th SQL parameter of Ri.

6) For r varying from 1 (one) to m, if Ar is not a <dynamic parameter specification> and if there is more than
   one SQL-invoked routine in SR, then for each pair of SQL-invoked routines { Rp, Rq } in SR, if SDTPp,r
   ≺ SDTPq,r in the type precedence list of SDTAr, then eliminate Rq from SR.
      NOTE 208 — The “type precedence list” of a given type is determined by Subclause 9.5, “Type precedence list determination”.

7) The set of subject routines is the set of SQL-invoked routines remaining in SR.


Access Rules
      None.


General Rules
      None.


Conformance Rules
      None.




432 Foundation (SQL/Foundation)                                                                ©ISO/IEC 2003 – All rights reserved
                                                                                                  ISO/IEC 9075-2:2003 (E)
                                                                                     9.5 Type precedence list determination



9.5       Type precedence list determination

Function
Determine the type precedence list of a given type.


Syntax Rules
1) Let DT be the data type specified in an application of this Subclause.
2) The type precedence list TPL of DT is a list of type designators as specified in the Syntax Rules of this
   Subclause.
3) Let “A ≺ B” represent “A has precedence over B” and let “A ≃ B” represent “A has the same precedence as
   B”.
4) If DT is a user-defined type, then:
      a) Let ST be the set of supertypes of DT. Let n be the number of data types in ST.
      b) For any two data types TA and TB in ST, TA ≺ TB if and only if TA is a proper subtype of TB.

      c) Let T1 be DT and let Ti+1, 1 (one) ≤ i ≤ n–1, be the direct supertype of Ti.

      d) Let DTNi, 1 (one) ≤ i ≤ n, be the data type designator of Ti.
          NOTE 209 — The type designator of a user-defined type is the type name included in its user-defined type descriptor.

      e) TPL is DTN1, DTN2, ..., DTNn.

5) If DT is fixed-length character string, then TPL is
        CHARACTER, CHARACTER VARYING, CHARACTER LARGE OBJECT

6) If DT is variable-length character string, then TPL is
        CHARACTER VARYING, CHARACTER LARGE OBJECT

7) If DT is binary string, then TPL is
        BINARY LARGE OBJECT

8) If DT is numeric, then:
      a) Let NDT be the following set of numeric types: NUMERIC, DECIMAL, SMALLINT, INTEGER,
         BIGINT, REAL, FLOAT, and DOUBLE PRECISION. For each type T in NDT, the effective binary
         precision is defined as follows.
          Case:
          i)      If T is DECIMAL or NUMERIC, then the effective binary precision is the product of log2(10)
                  and the implementation-defined maximum precision of T.


©ISO/IEC 2003 – All rights reserved                                                            Additional common rules 433
ISO/IEC 9075-2:2003 (E)
9.5 Type precedence list determination



        ii)     If T is FLOAT, then the effective binary precision is the implementation-defined maximum
                precision of T.
        iii)    If the radix of T is decimal, then the effective binary precision is the product of log2(10) and the
                implementation-defined precision of T.
        iv)     Otherwise, the effective binary precision is the implementation-defined precision of T.
    b) Let PTC be the set of all precedence relationships determined as follows: For any two types T1 and
       T2, not necessarily distinct, in NDT,
        Case:
        i)      If T1 is exact numeric and T2 is approximate numeric, then T1 ≺ T2.
        ii)     If T1 is approximate numeric and T2 is exact numeric, then T1 ≻ T2.
        iii)    If the effective binary precision of T1 is greater than the effective binary precision of T2, then
                T2 ≺ T1.
        iv)     If the effective binary precision of T1 equals the effective binary precision of T2, then T2 ≃ T1.
        v)      Otherwise, T1 ≺ T2.
    c) TPL is determined as follows:
        i)      TPL is initially empty.
        ii)     Let ST be the set of types containing DT and every type T in NDT for which the precedence
                relationship DT ≺ T or DT ≃ T is in PTC.
        iii)    Let n be the number of types in ST.
        iv)     For i ranging from 1 (one) to n:
                1) Let NT be the set of types Tk in ST such that there is no other type Tj in ST for which Tj ≺
                   Tk according to PTC.

                2) Case:
                    A) If there is exactly one type Tk in NT, then Tk is placed next in TPL and all relationships
                       of the form Tk ≺ Tr are removed from PTC, where Tr is any type in ST.

                    B) If there is more than one type Tk in NT, then every type Ts in NT is assigned the same
                       position in TPL as Tk and all relationships of the forms Tk ≺ Tr, Tk ≃ Tr, Ts ≺ Tr, and Ts
                       ≃ Tr are removed from PTC, where Tr is any type in ST.

9) If DT specifies a year-month interval type, then TPL is
      INTERVAL YEAR

10) If DT specifies a day-time interval type, then TPL is
      INTERVAL DAY



434 Foundation (SQL/Foundation)                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                                ISO/IEC 9075-2:2003 (E)
                                                                                   9.5 Type precedence list determination



11) If DT specifies DATE, then TPL is
        DATE

12) If DT specifies TIME, then TPL is
        TIME

13) If DT specifies TIMESTAMP, then TPL is
        TIMESTAMP

14) If DT specifies BOOLEAN, then TPL is
        BOOLEAN

15) If DT is a collection type, then let CTC be the kind of collection (either ARRAY or MULTISET) specified
    in DT.
    Let n be the number of elements in the type precedence list for the element type of DT. For i ranging from
    1 (one) to n, let RIOi be the i-th such element. TPL is

        RIO1 CTC, RIO2 CTC, ..., RIOn CTC

16) If DT is a reference type, then let n be the number of elements in the type precedence list for the referenced
    type of DT. For i ranging from 1 (one) to n, let KAWi be the i-th such element. TPL is

        REF(KAW1), REF(KAW2), ..., REF(KAWn)

17) If DT is a row type, then TPL is
        ROW
    NOTE 210 — This rule is placed only to avoid the confusion that might arise if row types were not mentioned in this Subclause.
    As a row type cannot be used as a <parameter type>, the type precedence list of a row type is never referenced.


Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved                                                           Additional common rules 435
ISO/IEC 9075-2:2003 (E)
9.6 Host parameter mode determination



9.6       Host parameter mode determination

Function
Determine the parameter mode for a given host parameter.


Syntax Rules
1) Let PD and SPS be a <host parameter declaration> and an <SQL procedure statement> specified in an
   application of this Subclause.
2) Let P be the host parameter specified by PD and let PN be the <host parameter name> immediately contained
   in PD.
3) Whether P is an input host parameter, an output host parameter, or both an input host parameter and an
   output host parameter is determined as follows:
      Case:
      a) If PD is a <status parameter>, then P is an output host parameter.
      b) Otherwise,
          Case:
          i)      If PN is contained in an <SQL argument> Ai of the <SQL argument list> of a <routine invocation>
                  immediately contained in a <call statement> that is contained in SPS, then:
                  1) Let R be the subject routine of the <routine invocation>.
                  2) Let PRi be the i-th SQL parameter of R.

                  3) Case:
                      A) If PN is contained in a <host parameter specification> that is the <target specification>
                         that is simply contained in Ai and PRi is an output SQL parameter, then P is an output
                         host parameter.
                      B) If PN is contained in a <host parameter specification> that is the <target specification>
                         that is simply contained in Ai and PRi is both an input SQL parameter and an output
                         SQL parameter, then P is both an input host parameter and an output host parameter.
                      C) Otherwise, P is an input host parameter.
          ii)     If PN is contained in a <value specification> or a <simple value specification> that is contained
                  in SPS, and PN is not contained in a <target specification> or a <simple target specification>
                  that is contained in SPS, then P is an input host parameter.
          iii)    If PN is contained in a <target specification> or a <simple target specification> that is contained
                  in SPS, and PN is not contained in a <value specification> or a <simple value specification>
                  that is contained in SPS, then P is an output host parameter.




436 Foundation (SQL/Foundation)                                                       ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                         9.6 Host parameter mode determination



         iv)      If PN is contained in a <value specification> or a <simple value specification> that is contained
                  in SPS, and in a <target specification> or a <simple target specification> that is contained in
                  SPS, then P is both an input host parameter and an output host parameter.
         v)       Otherwise, P is neither an input host parameter nor an output host parameter.


Access Rules
    None.


General Rules
    None.


Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved                                                 Additional common rules 437
ISO/IEC 9075-2:2003 (E)
9.7 Type name determination



9.7        Type name determination

Function
Determine an <identifier> given the name of a predefined data type.


Syntax Rules
1) Let DT be the <predefined type> specified in an application of this Subclause.
2) Let FNSDT be the <identifier> resulting from an application of this Subclause, defined as follows.
      Case:
      a) If DT specifies CHARACTER, then let FNSDT be “CHAR”.
      b) If DT specifies CHARACTER VARYING, then let FNSDT be “VARCHAR”.
      c) If DT specifies CHARACTER LARGE OBJECT, then let FNSDT be “CLOB”.
      d) If DT specifies BINARY LARGE OBJECT, then let FNSDT be “BLOB”.
      e) If DT specifies SMALLINT, then let FNSDT be “SMALLINT”.
      f) If DT specifies INTEGER, then let FNSDT be “INTEGER”.
      g) If DT specifies BIGINT, then let FNSDT be “BIGINT”.
      h) If DT specifies DECIMAL, then let FNSDT be “DECIMAL”.
      i)   If DT specifies NUMERIC, then let FNSDT be “NUMERIC”.
      j)   If DT specifies REAL, then let FNSDT be “REAL”.
      k) If DT specifies FLOAT, then let FNSDT be “FLOAT”.
      l)   If DT specifies DOUBLE PRECISION, then let FNSDT be “DOUBLE”.
      m) If DT specifies DATE, then let FNSDT be “DATE”.
      n) If DT specifies TIME, then let FNSDT be “TIME”.
      o) If DT specifies TIMESTAMP, then let FNSDT be “TIMESTAMP”.
      p) If DT specifies INTERVAL, then let FNSDT be “INTERVAL”.


Access Rules
      None.




438 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                          ISO/IEC 9075-2:2003 (E)
                                      9.7 Type name determination



General Rules
    None.


Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved   Additional common rules 439
ISO/IEC 9075-2:2003 (E)
9.8 Determination of identical values



9.8       Determination of identical values

Function
Determine whether two instances of values are identical, that is to say, are occurrences of the same value.


Syntax Rules
      None.


Access Rules
      None.


General Rules
1) Let V1 and V2 be two values specified in an application of this Subclause.
      NOTE 211 — This Subclause is invoked implicitly wherever the word identical is used of two values.

2) Case:
      a) If V1 and V2 are both null, then V1 is identical to V2.
      b) If V1 is null and V2 is not null, or if V1 is not null and V2 is null, then V1 is not identical to V2.
      c) If V1 and V2 are of comparable predefined types, then
          Case:
          i)      If V1 and V2 are character strings, then let L be CHARACTER_LENGTH(V1).
                  Case:

                  1) If CHARACTER_LENGTH(V2) equals L, and if for all i, 1 (one) ≤ i ≤ L, the i-th character
                     of V1 corresponds to the same character position of ISO/IEC 10646 as the i-th character of
                     V2, then V1 is identical to V2.
                  2) Otherwise, V1 is not identical to V2.
          ii)     If V1 and V2 are TIME WITH TIME ZONE or TIMESTAMP WITH TIME ZONE and are not
                  distinct, and their time zone displacement fields are not distinct, then V1 is identical to V2.
          iii)    Otherwise, V1 is identical to V2 if and only if V1 is not distinct from V2.
      d) If V1 and V2 are of constructed types, then
          Case:
          i)      If V1 and V2 are rows and their respective fields are identical, then V1 is identical to V2.




440 Foundation (SQL/Foundation)                                                                ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                               9.8 Determination of identical values



         ii)      If V1 and V2 are arrays and have the same cardinality and elements in the same ordinal position
                  in the two arrays are identical, then V1 is identical to V2.
         iii)     If V1 and V2 are multisets and have the same cardinality N and there exist enumerations VE1i,
                  1 (one) ≤ i ≤ N, of V1 and VE2i, 1 (one) ≤ i ≤ N, of V2 such that for all i, VE1i is identical to
                  VE2i, then V1 is identical to V2.

         iv)      If V1 and V2 are references and V1 is not distinct from V2, then V1 is identical to V2.
         v)       Otherwise, V1 is not identical to V2.
    e) If V1 and V2 are of the same most specific type MST and MST is a user-defined type, then
         Case:
         i)       If MST is a distinct type whose source type is SDT and the results of SDT(V1) and SDT(V2)
                  are identical, then V1 is identical to V2.
         ii)      If MST is a structured type and, for every observer function O defined for MST, the results of
                  the invocations O(V1) and O(V2) are identical, then V1 is identical to V2.
         iii)     Otherwise, V1 is not identical to V2.
    f) Otherwise, V1 is not identical to V2.


Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved                                                   Additional common rules 441
ISO/IEC 9075-2:2003 (E)
9.9 Equality operations



9.9        Equality operations

Function
Specify the prohibitions and restrictions by data type on operations that involve testing for equality.


Syntax Rules
1) An equality operation is any of the following:
      a) A <comparison predicate> that specifies <equals operator> or <not equals operator>.
      b) A <quantified comparison predicate> that specifies <equals operator> or <not equals operator>.
      c) An <in predicate>.
      d) A <like predicate>.
      e) A <similar predicate>.
      f) A <distinct predicate>.
      g) A <match predicate>.
      h) A <member predicate>.
      i)   A <joined table> that specifies NATURAL or USING.
      j)   A <user-defined ordering definition> that specifies MAP.
      k) A <position expression>.
2) An operand of an equality operation is any of the following:
      a) A field of the declared row type of a <row value predicand> that is simply contained in a <comparison
         predicate> that specifies <equals operator> or <not equals operator>.
      b) A field of the declared row type of a <row value predicand> that is simply contained in a <quantified
         comparison predicate> that specifies <equals operator> or <not equals operator>.
      c) A column of a <table subquery> that is simply contained in a <quantified comparison predicate> that
         specifies <equals operator> or <not equals operator>.
      d) A field of the declared row type of a <row value predicand> or <row value expression> that is simply
         contained in an <in predicate>.
      e) A column of a <table subquery> that is simply contained in an <in predicate>.
      f) A field of the declared row type of a <row value predicand> that is simply contained in a <like predi-
         cate>.
      g) A <character pattern>, <escape character>, <octet pattern> or <escape octet> that is simply contained
         in a <like predicate>.




442 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                         9.9 Equality operations



    h) A field of the declared row type of a <row value predicand> that is simply contained in a <similar
       predicate>.
    i)   A <similar pattern> or <escape character> that is simply contained in a <similar predicate>.
    j)   A field of the declared row type of a <row value predicand> that is simply contained in a <distinct
         predicate>.
    k) A field of the declared row type of a <row value predicand> that is simply contained in a <match
       predicate>.
    l)   A column of a <table subquery> that is simply contained in a <match predicate>.
    m) A field of the declared row type of a <row value predicand> that is simply contained in a <member
       predicate>.
    n) A corresponding join column of a <joined table> that specifies NATURAL or USING.
    o) The <returns data type> of the SQL-invoked function identified by a <map function specification>
       simply contained in a <user-defined ordering definition> that specifies MAP.
    p) A <string value expression> that is simply contained in a <position expression>.
    q) A <blob value expression> that is simply contained in a <position expression>.
3) The declared type of an operand of an equality operation shall not be UDT-NC-ordered.
4) If the declared type of the operands of an equality operation is a character string type, then the Syntax Rules
   of Subclause 9.13, “Collation determination”, apply.
5) If the declared type of an operand OP of an equality operation is a multiset type, then OP is a multiset
   operand of a multiset element grouping operation. The Syntax Rules of Subclause 9.11, “Multiset element
   grouping operations”, apply.


Access Rules
    None.


General Rules
    None.


Conformance Rules
1) Without Feature S024, “Enhanced structured types”, in conforming SQL language, the declared type of an
   operand of an equality operation shall not be ST-ordered.
2) Without Feature T042, “Extended LOB data type support”, in conforming SQL language, the declared type
   of an operand of an equality operation shall not be LOB-ordered.
3) Without Feature S275, “Advanced multiset support”, in conforming SQL language, the declared type of
   an operand of an equality operation shall not be multiset-ordered.



©ISO/IEC 2003 – All rights reserved                                                Additional common rules 443
ISO/IEC 9075-2:2003 (E)
9.9 Equality operations



   NOTE 212 — If the declared type of an operand OP of an equality operation is a multiset type, then OP is a multiset operand of
   a multiset element grouping operation. The Conformance Rules of Subclause 9.11, “Multiset element grouping operations”, apply.




444 Foundation (SQL/Foundation)                                                               ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                                     9.10 Grouping operations



9.10 Grouping operations

Function
Specify the prohibitions and restrictions by data type on operations that involve grouping of data.


Syntax Rules
1) A grouping operation is any of the following:
    a) A <group by clause>.
    b) A <window partition clause>.
    c) An <aggregate function> that specifies DISTINCT.
    d) A <query specification> that immediately contains DISTINCT.
    e) A <query expression body> that simply contains or implies UNION DISTINCT.
    f) A <query expression body> that simply contains EXCEPT.
    g) A <query term> that simply contains INTERSECT.
    h) A <unique predicate>.
    i)   A <unique constraint definition>.
    j)   A <referential constraint definition>.
2) An operand of a grouping operation is any of the following:
    a) A grouping column of a <group by clause>.
    b) A partitioning column of a <window partition clause>.
    c) A <value expression> simply contained in an <aggregate function> that specifies DISTINCT.
    d) A column of the result of a <query specification> that immediately contains DISTINCT.
    e) A column of the result of a <query expression body> that simply contains or implies UNION DISTINCT.
    f) A column of the result of a <query expression body> that simply contains EXCEPT.
    g) A column of the result of a <query term> that simply contains INTERSECT.
    h) A column of the <table subquery> simply contained in a <unique predicate>.
    i)   A column identified by the <unique column list> of a <unique constraint definition>.
    j)   A referencing column of a <referential constraint definition>.
3) The declared type of an operand of a grouping operation shall not be LOB-ordered, array-ordered, multiset-
   ordered, UDT-EC-ordered, or UDT-NC-ordered.




©ISO/IEC 2003 – All rights reserved                                              Additional common rules 445
ISO/IEC 9075-2:2003 (E)
9.10 Grouping operations



4) If the declared type of an operand of a grouping operation is a character string type, then the Syntax Rules
   of Subclause 9.13, “Collation determination”, apply.


Access Rules
    None.


General Rules
    None.


Conformance Rules
1) Without Feature S024, “Enhanced structured types”, in conforming SQL language, the declared type of an
   operand of a grouping operation shall not be ST-ordered.




446 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                    9.11 Multiset element grouping operations



9.11 Multiset element grouping operations

Function
Specify the prohibitions and restrictions by data type on the declared element type of a multiset for operations
that involve grouping the elements of a multiset.


Syntax Rules
1) A multiset element grouping operation is any of the following:
    a) An equality operation such that the declared type of an operand of the equality operation is a multiset
       type.
    b) A <multiset set function>.
    c) A <multiset value expression> that specifies MULTISET UNION DISTINCT.
    d) A <multiset value expression> that specifies MULTISET EXCEPT.
    e) A <multiset term> that specifies MULTISET INTERSECT.
    f) A <submultiset predicate>.
    g) A <set predicate>.
    h) A <general set function> that specifies INTERSECTION.
2) A multiset operand of a multiset element grouping operation is any of the following:
    a) A <multiset value expression> simply contained in a <multiset set function>.
    b) A <multiset value expression> or a <multiset term> that is simply contained in a <multiset value
       expression> that simply contains MULTISET UNION DISTINCT.
    c) A <multiset value expression> or a <multiset term> that is simply contained in a <multiset value
       expression> that simply contains MULTISET EXCEPT.
    d) A <multiset term> or a <multiset primary> that is simply contained in a <multiset term> that simply
       contains MULTISET INTERSECT.
    e) A field of a comparand of a <comparison predicate> such that the <comparison predicate> specifies
       <equals operator> or <not equals operator> and such that the declared type of the field is a multiset
       type.
    f) A <multiset value expression> simply contained in a <member predicate>.
    g) A field of the <row value expression> simply contained in a <submultiset predicate>.
    h) The <multiset value expression> simply contained in a <submultiset predicate>.
    i)   A field of the <row value expression> simply contained in a <set predicate>.
    j)   A value expression> simply contained in a <general set function> that specifies INTERSECTION.


©ISO/IEC 2003 – All rights reserved                                              Additional common rules 447
ISO/IEC 9075-2:2003 (E)
9.11 Multiset element grouping operations



3) The declared element type of a multiset operand of a multiset element grouping operation shall not be LOB-
   ordered, array-ordered, multiset-ordered, UDT-EC-ordered, or UDT-NC-ordered.
4) If the declared element type of a multiset operand of a multiset element grouping operation is a character
   string type, then the Syntax Rules of Subclause 9.13, “Collation determination”, apply.


Access Rules
    None.


General Rules
    None.


Conformance Rules
1) Without Feature S024, “Enhanced structured types”, in conforming SQL language, the declared element
   type of a multiset operand of a multiset element grouping operation shall not be ST-ordered.




448 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                     9.12 Ordering operations



9.12 Ordering operations

Function
Specify the prohibitions and restrictions by data type on operations that involve ordering of data.


Syntax Rules
1) An ordering operation is any of the following:
    a) A <comparison predicate> that does not specify <equals operator> or <not equals operator>.
    b) A <quantified comparison predicate> that does not specify <equals operator> or <not equals operator>.
    c) A <between predicate>.
    d) An <overlaps predicate>.
    e) An <aggregate function> that specifies MAX or MIN.
    f) A <sort specification list>.
    g) A <user-defined ordering definition> that specifies ORDER FULL BY MAP.
2) An operand of an ordering operation is any of the following:
    a) A field of the declared row type of a <row value predicand> that is simply contained in a <comparison
       predicate> that does not specify <equals operator> or <not equals operator>.
    b) A field of the declared row type of a <row value predicand> that is simply contained in a <quantified
       comparison predicate> that does not specify <equals operator> or <not equals operator>.
    c) A column of the <table subquery> that is simply contained in a <quantified comparison predicate> that
       does not specify <equals operator> or <not equals operator>.
    d) A field of the declared row type of a <row value predicand> that is simply contained in a <between
       predicate>.
    e) A field of the declared row type of a <row value predicand> that is simply contained in an <overlaps
       predicate>.
    f) A <value expression> simply contained in an <aggregate function> that specifies MAX or MIN.
    g) A <value expression> simply contained in a <sort key>.
    h) The <returns data type> of the SQL-invoked function identified by a <map function specification>
       simply contained in a <user-defined ordering definition> that specifies ORDER FULL BY MAP.
3) The declared type of an operand of an ordering operation shall not be LOB-ordered, array-ordered, multiset-
   ordered, reference-ordered, UDT-EC-ordered, or UDT-NC-ordered.
4) If the declared type of an operand of an ordering operation is a character string type, then the Syntax Rules
   of Subclause 9.13, “Collation determination”, apply.



©ISO/IEC 2003 – All rights reserved                                              Additional common rules 449
ISO/IEC 9075-2:2003 (E)
9.12 Ordering operations



Access Rules
   None.


General Rules
   None.


Conformance Rules
1) Without Feature S024, “Enhanced structured types”, in conforming SQL language, the declared type of an
   operand of an ordering operation shall not be ST-ordered.




450 Foundation (SQL/Foundation)                                              ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                                   9.13 Collation determination



9.13 Collation determination

Function
Specify rules for determining the collation to be used in the comparison of character strings.


Syntax Rules
1) Let CCS be the character set of the result of applying the rules of Subclause 9.3, “Data types of results of
   aggregations”, to the declared types of all operands of the comparison operation.
2) At least one operand shall have a declared type collation.
3) Case:
    a) If the comparison operation is a <referential constraint definition>, then, for each referencing column,
       the collation to be used is the declared type collation of the corresponding column of the referenced
       table.
    b) If at least one operand has an explicit collation derivation, then every operand whose collation derivation
       is explicit shall have the same declared type collation EDTC and the collation to be used is EDTC.
    c) If the comparison operation is contained in a <preparable statement> that is prepared in the current
       SQL-session by an <execute immediate statement> or a <prepare statement>, or in a <direct SQL
       statement> that is invoked directly, and CCS has an SQL-session collation, then the collation to be
       used is that SQL-session collation.
    d) If CCS has an SQL-client module collation, then the collation to be used is that collation.
    e) Otherwise, every operand whose collation derivation is implicit shall have the same declared type col-
       lation IDTC and the collation to be used is IDTC.


Access Rules
    None.


General Rules
    None.


Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved                                               Additional common rules 451
ISO/IEC 9075-2:2003 (E)
9.14 Execution of array-returning functions



9.14 Execution of array-returning functions

Function
Define the execution of an external function that returns an array value.


Syntax Rules
    None.


Access Rules
    None.


General Rules
1) Let AR, ESPL, and P be the ARRAY, EFFECTIVE SQL PARAMETER LIST, and PROGRAM specified in
   an application of this Subclause.
2) Let ARC be the cardinality of AR.
3) Let EN be the number of entries in ESPL.

4) Let ESPi, 1 (one) ≤ i ≤ EN, be the i-th parameter in ESPL.

5) Let FRN be the number of result data items.
6) Let PN and N be the number of values in the static SQL argument list of P.
7) Let E be 0 (zero).
8) If the call type data item has a value of –1 (indicating “open call”), then P is executed with a list of EN
   parameters PDi whose parameter names are PNi and whose values are set as follows:

    a) Depending on whether the language of R specifies ADA, C, COBOL, FORTRAN, M, PASCAL, or
       PLI, let the operative data type correspondences table be Table 16, “Data type correspondences for
       Ada”, Table 17, “Data type correspondences for C”, Table 18, “Data type correspondences for COBOL”,
       Table 19, “Data type correspondences for Fortran”, Table 20, “Data type correspondences for M”,
       Table 21, “Data type correspondences for Pascal”, or Table 22, “Data type correspondences for PL/I”,
       respectively. Refer to the two columns of the operative data type correspondences table as the “SQL
       data type” column and the “host data type” column.
    b) For i varying from 1 (one) to EN, the data type DTi of PDi is the data type listed in the host data type
       column of the row in the data type correspondences table whose value in the SQL data type column
       corresponds to the data type of ESPi.

    c) The value of PDi is set to the value of ESPi.

9) Case:


452 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                             ISO/IEC 9075-2:2003 (E)
                                                                           9.14 Execution of array-returning functions



    a) If the value of the exception data item is '00000' (corresponding to the completion condition successful
       completion) or the first 2 characters are '01' (corresponding to the completion condition warning with
       any subcondition), then set the call type data item to 0 (zero) (indicating fetch call).
    b) If the exception data item is '02000' (corresponding to the completion condition no data):
         i)       If each PDi, for i ranging from (PN+FRN)+N+1 through (PN+FRN)+N+FRN (that is, the SQL
                  indicator arguments corresponding to the result data items), has the value –1, then set AR to the
                  null value.
         ii)      Set the call type data item to 1 (one) (indicating close call).
    c) Otherwise, set the call type data item to 1 (one) (indicating close call).
10) The following steps are applied as long as the call type data item has a value 0 (zero) (corresponding to
    fetch call):
    a) P is executed with a list of EN parameters PDi whose parameter names are PNi and whose values are
       set as follows:
         i)       For i varying from 1 (one) to EN, the <data type> DTi of PDi is the data type listed in the host
                  data type column of the row in the data type correspondences table whose value in the SQL data
                  type column corresponds to the data type of ESPi.

         ii)      For i ranging from 1 (one) to EN–2, the value of PDi is set to the value of ESPi.

         iii)     For the save area data item, for i equal to EN–1, the value of PDi is set to the value returned in
                  PDi by the prior execution of P.

         iv)      For the call type data item, for i equal to EN, the value of PDi is set to 0 (zero).

    b) Case:
         i)       If the exception data item is '00000' (corresponding to completion condition successful completion)
                  or the first 2 characters are '01' (corresponding to completion condition warning with any sub-
                  condition), then:
                  1) Increment E by 1 (one).
                  2) If E > ARC, then an exception condition is raised: data exception — array element error.
                  3) If the call type data item is 0 (zero), then
                      Case:
                      A) If each PDi, for i ranging from (PN+FRN)+N+1 through (PN+FRN)+N+FRN (that is,
                         the SQL indicator arguments corresponding to the result data items) is negative, then
                         let the E-th element of AR be the null value.
                      B) Otherwise,
                           Case:
                           I)         If FRN is 1 (one), then let the E-th element of AR be the value of the result data
                                      item.


©ISO/IEC 2003 – All rights reserved                                                      Additional common rules 453
ISO/IEC 9075-2:2003 (E)
9.14 Execution of array-returning functions



                        II)    Otherwise:

                               1) Let RDIi, 1 (one) ≤ i ≤ FRN, be the value of the i-th result data item.

                               2) Let the E-th element of AR be the value of the following <row value expres-
                                  sion>:
                                      ROW ( RDI1, ... , RDIFRN )

        ii)    If the exception data item is '02000' (corresponding to completion condition no data), then:
               1) If the value of E is 0 (zero), then set AR to an empty array.
               2) Set the call type data item to 1 (one) (indicating close call).
        iii)   Otherwise, set the value of the call type data item to 1 (one) (indicating close call).
11) If the call type data item has a value of 1 (one) (indicating close call), then P is executed with a list of EN
    parameters PDi whose parameter names are PNi and whose values are set as follows:

    a) For i varying from 1 (one) to EN, the <data type> DTi of PDi is the data type listed in the host data
       type column of the row in the data type correspondences table whose value in the SQL data type column
       corresponds to the data type of ESPi.

    b) For i ranging from 1 (one) to EN–2, the value of PDi is set to the value of ESPi.

    c) For the save area data item, for i equal to EN–1, the value of PDi is set to the value returned in PDi by
       the prior execution of P.
    d) For the call type data item, for i equal to EN, the value of PDi is set to 1 (one).


Conformance Rules
    None.




454 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                 9.15 Execution of multiset-returning functions



9.15 Execution of multiset-returning functions

Function
Define the execution of an external function that returns a multiset value.


Syntax Rules
    None.


Access Rules
    None.


General Rules
1) Let MU, ESPL, and P be the MULTISET, EFFECTIVE SQL PARAMETER LIST, and PROGRAM specified
   in an application of this subclause.
2) Let ET be the element type of MU.
3) Let C be the maximum implementation-defined cardinality of array type with element type ET.
4) Let AT be the array type ET ARRAY[C].
5) Let AR be an array whose declared type is AT.
6) The General Rules of Subclause 9.14, “Execution of array-returning functions”, are applied with AR, ESPL,
   and P as ARRAY, EFFECTIVE SQL PARAMETER LIST, and PROGRAM, respectively.
7) Let MU be the result of casting AR to the multiset type of MU according to the General Rules of
   Subclause 6.12, “<cast specification>”.


Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved                                              Additional common rules 455
ISO/IEC 9075-2:2003 (E)
9.16 Data type identity



9.16 Data type identity

Function
Determine whether two data types are compatible and have the same characteristics.


Syntax Rules
1) Let PM and P be the two data types specified in an application of this Subclause.
2) PM and P shall be compatible.
3) If PM is a character string type, then the length of PM shall be equal to the length of P.
4) If PM is an exact numeric type, then the precision and scale of PM shall be equal to the precision and scale
   of P, respectively.
5) If PM is an approximate numeric type, then the precision of PM shall be equal to the precision of P.
6) If PM is a binary string type, then the maximum length of PM shall be equal to the maximum length of P.
7) If PM is a datetime data type with <time fractional seconds precision>, then the <time fractional seconds
   precision> of PM shall be equal to the <time fractional seconds precision> of P.
8) If PM is an interval type, then the <interval qualifier> of PM shall be equivalent to the <interval qualifier>
   of P.
9) If PM is a collection type, then:
    a) The kind of collection (ARRAY or MULTISET) of PM and the kind of collection of P shall be the
       same.
    b) If PM is an array type, then the maximum cardinality of PM shall be equal to the the maximum cardi-
       nality of P.
    c) The Syntax Rules of this Subclause are applied with the element type of PM and the element type of
       P as the two data types.
10) If PM is a row type, then:
    a) Let N be the degree of PM.

    b) Let DTFPMi and DTFPi, 1 (one) ≤ i ≤ N, be the data type of the i-th field of PM and of P, respectively.
       For i varying from 1 (one) to N, the Syntax Rules of this Subclause are applied with DTFPMi and
       DTFPi the two data types.


Access Rules
    None.




456 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                          ISO/IEC 9075-2:2003 (E)
                                           9.16 Data type identity



General Rules
    None.


Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved   Additional common rules 457
ISO/IEC 9075-2:2003 (E)
9.17 Determination of a from-sql function



9.17 Determination of a from-sql function

Function
Determine the from-sql function of a user-defined type given the name of a user-defined type and the name of
the group.


Syntax Rules
1) Let UDT and GN be a TYPE and a GROUP specified in an application of this Subclause.
2) Let SSUDT be the set of supertypes of UDT.
3) Let SUDT be the data type, if any, in SSUDT such that the transform descriptor included in the data type
   descriptor of SUDT includes a group descriptor GD that includes a group name that is equivalent to GN.
4) The applicable from-sql function is the SQL-invoked function identified by the specific name of the from-
   sql function, if any, in GD.


Access Rules
    None.


General Rules
    None.


Conformance Rules
    None.




458 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                          9.18 Determination of a from-sql function for an overriding method



9.18 Determination of a from-sql function for an overriding method

Function
Determine the from-sql function of a user-defined type given the name of an overriding method and the ordinal
position of an SQL parameter.


Syntax Rules
1) Let R and N be a ROUTINE and a POSITION specified in an application of this Subclause.
2) Let OM be original method of R.
3) The applicable from-sql function is the from-sql function associated with the N-th SQL parameter of OM,
   if any.


Access Rules
    None.


General Rules
    None.


Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved                                            Additional common rules 459
ISO/IEC 9075-2:2003 (E)
9.19 Determination of a to-sql function



9.19 Determination of a to-sql function

Function
Determine the to-sql function of a user-defined type given the name of a user-defined type and the name of a
group.


Syntax Rules
1) Let UDT and GN be a TYPE and a GROUP specified in an application of this Subclause.
2) Let SSUDT be the set of supertypes of UDT.
3) Let SUDT be the data type, if any, in SSUDT such that the transform descriptor included in the data type
   descriptor of SUDT includes a group descriptor GD that includes a group name that is equivalent to GN.
4) The applicable to-sql function is the SQL-invoked function identified by the specific name of the to-sql
   function, if any, in GD.


Access Rules
    None.


General Rules
    None.


Conformance Rules
    None.




460 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                             9.20 Determination of a to-sql function for an overriding method



9.20 Determination of a to-sql function for an overriding method

Function
Determine the to-sql function of a user-defined type given the name of an overriding method.


Syntax Rules
1) Let R be a ROUTINE specified in an application of this Subclause.
2) Let OM be the original method of R
3) The applicable to-sql function is the SQL-invoked function associated with the result of OM, if any.


Access Rules
    None.


General Rules
    None.


Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved                                            Additional common rules 461
ISO/IEC 9075-2:2003 (E)
9.21 Generation of the next value of a sequence generator



9.21 Generation of the next value of a sequence generator

Function
Generate and return the next value of a sequence generator.


Syntax Rules
    None.


Access Rules
    None.


General Rules
1) Let SEQ be the SEQUENCE specified in an application of this Subclause.
2) Let DT, CBV, INC, SMAX, and SMIN be the data type, current base value, increment, maximum value and
   minimum value, respectively, of SEQ.

3) If there exists a non-negative integer N such that SMIN ≤ CBV + N * INC ≤ SMAX and the value (CBV +
   N * INC) has not already been returned in the current cycle, then let V1 be (CBV + N * INC). Otherwise,
    Case:
    a) If the cycle option of SEQ is NO CYCLE, then an exception condition is raised: data exception —
       sequence generator limit exceeded.
    b) Otherwise, a new cycle is initiated.
        Case:
        i)      If SEQ is an ascending sequence generator, then let V1 be SMIN.
        ii)     Otherwise, let V1 be SMAX.
4) Case:
    a) If SEQ is an ascending sequence generator, the current base value of SEQ is set to the value of the
       lowest non-issued value in the cycle.
    b) Otherwise, the current base value of SEQ is set to the highest non-issued value in the cycle.
5) V1 is returned as the RESULT.


Conformance Rules
    None.



462 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                         9.22 Creation of a sequence generator



9.22 Creation of a sequence generator

Function
Complete the definition of an external or internal sequence generator.


Syntax Rules
1) Let OPT and DT be the OPTIONS and DATA TYPE specified in an application of this Subclause. OPT
   shall conform to the Format of <common sequence generator options>. The BNF nonterminal symbols
   used in the remainder of this Subclause refer to the contents of OPT.
2) Each of <sequence generator start with option>, <sequence generator increment by option>, <sequence
   generator maxvalue option>, <sequence generator minvalue option>, and <sequence generator cycle option>
   shall be specified at most once.
3) If <sequence generator increment by option> is specified, then let INC be <sequence generator increment>;
   otherwise, let INC be a <signed numeric literal> whose value is 1 (one).
4) The value of INC shall not be 0 (zero).
5) If the value of INC is negative, then SEQ is a descending sequence generator; otherwise, SEQ is an
   ascending sequence generator.
6) Case:
    a) If <sequence generator maxvalue option> is specified, then
         Case:
         i)       If NO MAXVALUE is specified, then let SMAX be an implementation-defined <signed numeric
                  literal> of declared type DT.
         ii)      Otherwise, let SMAX be <sequence generator max value>.
    b) Otherwise, let SMAX be an implementation-defined <signed numeric literal> of declared type DT.
7) Case:
    a) If <sequence generator minvalue option> is specified, then
         Case:
         i)       If NO MINVALUE is specified, then let SMIN be an implementation-defined <signed numeric
                  literal> of declared type DT.
         ii)      Otherwise, let SMIN be <sequence generator min value>.
    b) Otherwise, let SMIN be an implementation-defined <signed numeric literal> of declared type DT.
8) Case:
    a) If <sequence generator start with option> is specified, then let START be <sequence generator start
       value>.


©ISO/IEC 2003 – All rights reserved                                             Additional common rules 463
ISO/IEC 9075-2:2003 (E)
9.22 Creation of a sequence generator



    b) Otherwise,
        Case:
        i)      If SEQ is an ascending sequence generator, then let START be SMIN.
        ii)     Otherwise, let START be SMAX.
9) The values of INC, START, SMAX, and SMIN shall all be exactly representable with the precision and scale
   of DT.
10) The value of SMAX shall be greater than the value of SMIN.
11) The value of START shall be greater than or equal to the value of SMIN and lesser than or equal to the value
    of SMAX.
12) If <sequence generator cycle option> is specified, then let CYC be <sequence generator cycle option>;
    otherwise, let CYC be NO CYCLE.


Access Rules
    None.


General Rules
1) A sequence generator descriptor SEQDS that describes SEQ is created. SEQDS includes:
    a) The sequence generator name that is a zero-length character string.
        NOTE 213 — The name of an external sequence generator is later set by GR 1) of Subclause 11.62, “<sequence generator
        definition>”; however, internal sequence generators are anonymous.

    b) The data type descriptor of DT.
    c) The increment specified by INC.
    d) The maximum value specified by SMAX.
    e) The minimum value specified by SMIN.
    f) The cycle option specified by CYC.
    g) The current base value, set to START.


Conformance Rules
    None.




464 Foundation (SQL/Foundation)                                                            ©ISO/IEC 2003 – All rights reserved
                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                         9.23 Altering a sequence generator



9.23 Altering a sequence generator

Function
Complete the alteration of an internal or external sequence generator.


Syntax Rules
1) Let OPT and SEQ be the OPTIONS and SEQUENCE specified in an application of this Subclause. OPT
   shall conform to the Format of <alter sequence generator options>. The BNF nonterminal symbols used
   in the remainder of this Subclause refer to the contents of OPT.
2) Let DT be the data type descriptor included in SEQ.
3) Each of <alter sequence generator restart option>, <sequence generator increment by option>, <sequence
   generator maxvalue option>, <sequence generator minvalue option>, and <sequence generator cycle option>
   shall be specified at most once.
4) Case:
    a) If <sequence generator increment> is specified, then:
         i)       Let NEWIV be <sequence generator increment>.
         ii)      The value of NEWIV shall not be 0 (zero).
    b) Otherwise, let NEWIV be the increment of SEQ.
5) Case:
    a) If <sequence generator maxvalue option> is specified, then
         Case:
         i)       If NO MAXVALUE is specified, then let NEWMAX be an implementation-defined <signed
                  numeric literal> of declared type DT.
         ii)      Otherwise, let NEWMAX be <sequence generator max value>.
    b) Otherwise let NEWMAX be the maximum value of SEQ.
6) Case:
    a) If <sequence generator minvalue option> is specified, then
         Case:
         i)       If NO MINVALUE is specified, then let NEWMIN be an implementation-defined <signed
                  numeric literal> of declared type DT.
         ii)      Otherwise, let NEWMIN be <sequence generator min value>.
    b) Otherwise let NEWMIN be the minimum value of SEQ.




©ISO/IEC 2003 – All rights reserved                                          Additional common rules 465
ISO/IEC 9075-2:2003 (E)
9.23 Altering a sequence generator



7) If <sequence generator cycle option> is specified, then let NEWCYCLE be <sequence generator cycle
   option>; otherwise, let NEWCYCLE be the cycle option of SEQ.
8) If <alter sequence generator restart option> is specified, then let NEWVAL be <sequence generator restart
   value>; otherwise, let NEWVAL be the current base value of SEQ.
9) The values of NEWIV, NEWMAX, NEWMIN, and NEWVAL shall all be exactly representable with the
   precision and scale of DT.
10) The value of NEWMIN shall be less than the value of NEWMAX.
11) The value of NEWVAL shall be greater than or equal to the value of NEWMIN and lesser than or equal to
    the value of NEWMAX.


Access Rules
    None.


General Rules
1) SEQ is modified as follows:
    a) The increment is set to NEWIV.
    b) The maximum value is set to NEWMAX.
    c) The minimum value is set to NEWMIN.
    d) The cycle option is set to NEWCYCLE.
    e) The current base value is set to NEWVAL.


Conformance Rules
    None.




466 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                                    10.1 <interval qualifier>




10 Additional common elements


10.1 <interval qualifier>

Function
Specify the precision of an interval data type.


Format
<interval qualifier> ::=
    <start field> TO <end field>
  | <single datetime field>

<start field> ::=
    <non-second primary datetime field>
    [ <left paren> <interval leading field precision> <right paren> ]

<end field> ::=
    <non-second primary datetime field>
  | SECOND [ <left paren> <interval fractional seconds precision> <right paren> ]

<single datetime field> ::=
    <non-second primary datetime field>
    [ <left paren> <interval leading field precision> <right paren> ]
  | SECOND [ <left paren> <interval leading field precision>
    [ <comma> <interval fractional seconds precision> ] <right paren> ]

<primary datetime field> ::=
    <non-second primary datetime field>
  | SECOND

<non-second primary datetime field> ::=
    YEAR
  | MONTH
  | DAY
  | HOUR
  | MINUTE

<interval fractional seconds precision> ::= <unsigned integer>

<interval leading field precision> ::= <unsigned integer>


Syntax Rules
1) There is an ordering of significance of <primary datetime field>s. In order from most significant to least
   significant, the ordering is: YEAR, MONTH, DAY, HOUR, MINUTE, and SECOND. A <start field> or


©ISO/IEC 2003 – All rights reserved                                         Additional common elements 467
ISO/IEC 9075-2:2003 (E)
10.1 <interval qualifier>



    <single datetime field> with an <interval leading field precision> i is more significant than a <start field>
    or <single datetime field> with an <interval leading field precision> j if i>j. An <end field> or <single
    datetime field> with an <interval fractional seconds precision> i is less significant than an <end field> or
    <single datetime field> with an <interval fractional seconds precision> j if i>j.
2) If TO is specified, then <start field> shall be more significant than <end field> and <start field> shall not
   specify MONTH. If <start field> specifies YEAR, then <end field> shall specify MONTH.
3) The maximum value of <interval leading field precision> is implementation-defined, but shall not be less
   than 2.
4) The maximum value of <interval fractional seconds precision> is implementation-defined, but shall not be
   less than 6.
5) An <interval leading field precision>, if specified, shall be greater than 0 (zero) and shall not be greater
   than the implementation-defined maximum. If <interval leading field precision> is not specified, then an
   <interval leading field precision> of 2 is implicit.
6) An <interval fractional seconds precision>, if specified, shall be greater than or equal to 0 (zero) and shall
   not be greater than the implementation-defined maximum. If SECOND is specified and <interval fractional
   seconds precision> is not specified, then an <interval fractional seconds precision> of 6 is implicit.
7) The precision of a field other than the <start field> or <single datetime field> is
    Case:
    a) If the field is not SECOND, then 2.
    b) Otherwise, 2 digits before the decimal point and the explicit or implicit <interval fractional seconds
       precision> after the decimal point.


Access Rules
    None.


General Rules
1) An item qualified by an <interval qualifier> contains the datetime fields identified by the <interval qualifier>.
    Case:
    a) If the <interval qualifier> specifies a <single datetime field>, then the <interval qualifier> identifies a
       single <primary datetime field>. Any reference to the most significant or least significant <primary
       datetime field> of the item refers to that <primary datetime field>.
    b) Otherwise, the <interval qualifier> identifies those datetime fields from <start field> to <end field>,
       inclusive.
2) An <interval leading field precision> specifies
    Case:




468 Foundation (SQL/Foundation)                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                             ISO/IEC 9075-2:2003 (E)
                                                                                             10.1 <interval qualifier>



    a) If the <primary datetime field> is SECOND, then the number of decimal digits of precision before the
       specified or implied decimal point of the seconds <primary datetime field>.
    b) Otherwise, the number of decimal digits of precision of the first <primary datetime field>.
3) An <interval fractional seconds precision> specifies the number of decimal digits of precision following
   the specified or implied decimal point in the <primary datetime field> SECOND.
4) The length in positions of an item of type interval is computed as follows.
    Case:
    a) If the item is a year-month interval, then
         Case:
         i)       If the <interval qualifier> is a <single datetime field>, then the length in positions of the item
                  is the implicit or explicit <interval leading field precision> of the <single datetime field>.
         ii)      Otherwise, the length in positions of the item is the implicit or explicit <interval leading field
                  precision> of the <start field> plus 2 (the length of the <non-second primary datetime field>
                  that is the <end field>) plus 1 (one) (the length of the <minus sign> between the <years value>
                  and the <months value> in a <year-month literal>).
    b) Otherwise,
         Case:
         i)       If the <interval qualifier> is a <single datetime field> that does not specify SECOND, then the
                  length in positions of the item is the implicit or explicit <interval leading field precision> of the
                  <single datetime field>.
         ii)      If the <interval qualifier> is a <single datetime field> that specifies SECOND, then the length
                  in positions of the item is the implicit or explicit <interval leading field precision> of the <single
                  datetime field> plus the implicit or explicit <interval fractional seconds precision>. If <interval
                  fractional seconds precision> is greater than zero, then the length in positions of the item is
                  increased by 1 (one) (the length in positions of the <period> between the <seconds integer value>
                  and the <seconds fraction>).
         iii)     Otherwise, let participating datetime fields mean the datetime fields that are less significant than
                  the <start field> and more significant than the <end field> of the <interval qualifier>. The length
                  in positions of each participating datetime field is 2.
                  Case:
                  1) If <end field> is SECOND, then the length in positions of the item is the implicit or explicit
                     <interval leading field precision>, plus 3 times the number of participating datetime fields
                     (each participating datetime field has length 2 positions, plus the <minus sign>s or <colon>s
                     that precede them have length 1 (one) position), plus the implicit or explicit <interval frac-
                     tional seconds precision>, plus 3 (the length in positions of the <end field> other than any
                     <interval fractional seconds precision> plus the length in positions of its preceding <colon>).
                     If <interval fractional seconds precision> is greater than zero, then the length in positions
                     of the item is increased by 1 (one) (the length in positions of the <period> within the field
                     identified by the <end field>).



©ISO/IEC 2003 – All rights reserved                                                Additional common elements 469
ISO/IEC 9075-2:2003 (E)
10.1 <interval qualifier>



               2) Otherwise, the length in positions of the item is the implicit or explicit <interval leading
                  field precision>, plus 3 times the number of participating datetime fields (each participating
                  datetime field has length 2 positions, plus the <minus sign>s or <colon>s that precede them
                  have length 1 (one) position), plus 2 (the length in positions of the <end field>), plus 1 (one)
                  (the length in positions of the <colon> preceding the <end field>).


Conformance Rules
1) Without Feature F052, “Intervals and datetime arithmetic”, conforming SQL language shall not contain an
   <interval qualifier>.




470 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                 ISO/IEC 9075-2:2003 (E)
                                                                                  10.2 <language clause>



10.2 <language clause>

Function
Specify a standard programming language.


Format
<language clause> ::= LANGUAGE <language name>

<language name> ::=
    ADA
  | C
  | COBOL
  | FORTRAN
  | M | MUMPS
  | PASCAL
  | PLI
  | SQL


Syntax Rules
1) If MUMPS is specified, then M is implicit.


Access Rules
    None.


General Rules
1) The standard programming language specified by the <language clause> is defined in the International
   Standard identified by the <language name> keyword. Table 15, “Standard programming languages”,
   specifies the relationship.

                                      Table 15 — Standard programming languages


      Language            Relevant standard
      keyword

      ADA                 ISO/IEC 8652

      C                   ISO/IEC 9899

      COBOL               ISO 1989

      FORTRAN             ISO 1539



©ISO/IEC 2003 – All rights reserved                                      Additional common elements 471
ISO/IEC 9075-2:2003 (E)
10.2 <language clause>



     Language       Relevant standard
     keyword

     M              ISO/IEC 11756

     PASCAL         ISO/IEC 7185 and ISO/IEC 10206

     PLI            ISO 6160

     SQL            ISO/IEC 9075



Conformance Rules
   None.




472 Foundation (SQL/Foundation)                      ©ISO/IEC 2003 – All rights reserved
                                                                                 ISO/IEC 9075-2:2003 (E)
                                                                                10.3 <path specification>



10.3 <path specification>

Function
Specify an order for searching for an SQL-invoked routine.


Format
<path specification> ::= PATH <schema name list>

<schema name list> ::= <schema name> [ { <comma> <schema name> }... ]


Syntax Rules
1) No two <schema name>s contained in <schema name list> shall be equivalent.


Access Rules
    None.


General Rules
    None.


Conformance Rules
1) Without Feature S071, “SQL paths in function and type name resolution”, conforming SQL language shall
   not contain a <path specification>.




©ISO/IEC 2003 – All rights reserved                                     Additional common elements 473
ISO/IEC 9075-2:2003 (E)
10.4 <routine invocation>



10.4 <routine invocation>

Function
Invoke an SQL-invoked routine.


Format
<routine invocation> ::= <routine name> <SQL argument list>

<routine name> ::= [ <schema name> <period> ] <qualified identifier>

<SQL argument list> ::=
    <left paren> [ <SQL argument> [ { <comma> <SQL argument> }... ] ] <right paren>

<SQL argument> ::=
    <value expression>
  | <generalized expression>
  | <target specification>

<generalized expression> ::=
    <value expression> AS <path-resolved user-defined type name>


Syntax Rules
1) Let RI be the <routine invocation>, let TP be the SQL-path (if any), and let UDTSM be the user-defined
   type of the static SQL-invoked method (if any) specified in an application of this Subclause.
2) Let RN be the <routine name> immediately contained in the <routine invocation> RI.
3) If RI is immediately contained in a <call statement>, then the <SQL argument list> of RI shall not contain
   a <generalized expression> without an intervening <routine invocation>.
4) Case:
    a) If RI is immediately contained in a <call statement>, then an SQL-invoked routine R is a possibly
       candidate routine for RI (henceforth, simply “possibly candidate routine”) if R is an SQL-invoked
       procedure and the <qualified identifier> of the <routine name> of R is equivalent to the <qualified
       identifier> of RN.
    b) If RI is immediately contained in a <method selection>, then an SQL-invoked routine R is a possibly
       candidate routine for RI if R is an instance SQL-invoked method and the <qualified identifier> of the
       <routine name> of R is equivalent to the <qualified identifier> of RN.
    c) If RI is immediately contained in a <constructor method selection>, then an SQL-invoked routine R is
       a possibly candidate routine for RI if R is an SQL-invoked constructor method and the <qualified
       identifier> of the <routine name> of R is equivalent to the <qualified identifier> of RN.
    d) If RI is immediately contained in a <static method selection>, then an SQL-invoked routine R is a
       possibly candidate routine for RI if R is a static SQL-invoked method and the <qualified identifier>
       of the <routine name> of R is equivalent to the <qualified identifier> of RN and the method specification



474 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                                     10.4 <routine invocation>



         descriptor for R is included in a user-defined type descriptor for UDTSM or for some supertype of
         UDTSM.
    e) Otherwise, an SQL-invoked routine R is a possibly candidate routine for RI if R is an SQL-invoked
       regular function and the <qualified identifier> of the <routine name> of R is equivalent to the <qualified
       identifier> of RN.
5) Case:
    a) If RI is contained in an <SQL schema statement>, then an <SQL-invoked routine> R is an executable
       routine if and only if R is a possibly candidate routine and the applicable privileges for the <authorization
       identifier> that owns the containing schema include EXECUTE on R.
    b) Otherwise, an <SQL-invoked routine> R is an executable routine if and only if R is a possibly candidate
       routine and the current privileges include EXECUTE on R.
    NOTE 214 — “applicable privileges” and “current privileges” are defined in Subclause 12.3, “<privileges>”.

6) Case:
    a) If <SQL argument list> does not immediately contain at least one <SQL argument>, then an invocable
       routine is an executable routine that has no SQL parameters.
    b) Otherwise:
         i)       Let NA be the number of <SQL argument>s in the <SQL argument list> AL of RI. Let Ai, 1 (one)
                  ≤ i ≤ NA, be the i-th <SQL argument> in AL.
         ii)      Let the static SQL argument list of RI be AL.
         iii)     Let Pi be the i-th SQL parameter of an executable routine. An invocable routine is an SQL-
                  invoked routine SIR that is an executable routine such that:
                  1) SIR has NA SQL parameters.
                  2) If RI is not immediately contained in a <call statement>, then for each Ai that is not a
                     <dynamic parameter specification>,
                      Case:
                      A) If the declared type of Pi is a user-defined type, then:

                           I)         Let STi be the set of subtypes of the declared type of Ai.

                           II)        The type designator of the declared type of Pi shall be in the type precedence list
                                      of the data type of some type in STi.
                                      NOTE 215 — “type precedence list” is defined in Subclause 9.5, “Type precedence list determina-
                                      tion”.

                      B) Otherwise, the type designator of the declared type of Pi shall be in the type precedence
                         list of the declared type of Ai.
                           NOTE 216 — “type precedence list” is defined in Subclause 9.5, “Type precedence list determination”.

7) If <SQL argument list> does not immediately contain at least one <SQL argument>, then:


©ISO/IEC 2003 – All rights reserved                                                          Additional common elements 475
ISO/IEC 9075-2:2003 (E)
10.4 <routine invocation>



   a) Let AL be an empty list of SQL arguments.
   b) The subject routine of RI is defined as follows:
       i)     If RN does not contain a <schema name>, then:
              1) Case:
                  A) If RI is immediately contained in a <method selection>, <static method selection>, or
                     a <constructor method selection>, then let DP be TP.
                  B) If the routine execution context of the current SQL-session indicates that an SQL-invoked
                     routine is active, then let DP be the routine SQL-path of that routine execution context.
                  C) Otherwise,
                      Case:
                      I)      If RI is contained in a <schema definition>, then let DP be the SQL-path of that
                              <schema definition>.
                      II)     If RI is contained in a <preparable statement> that is prepared in the current SQL-
                              session by an <execute immediate statement> or a <prepare statement> or in a
                              <direct SQL statement> that is invoked directly, then let DP be the SQL-path of
                              the current SQL-session.
                      III)    Otherwise, let DP be the SQL-path of the <SQL-client module definition> that
                              contains RI.
              2) The subject routine of RI is an SQL-invoked routine SIRSR such that:
                  A) SIRSR is an invocable routine.
                  B) The <schema name> of the schema of SIRSR is in DP.
                  C) Case:
                      I)      If the routine descriptor of SIRSR does not include a STATIC indication, then
                              there is no other invocable routine R2 for which the the <schema name> of the
                              schema that includes R2 precedes in DP the <schema name> of the schema that
                              includes SIRSR.
                      II)     If the routine descriptor of SIRSR includes a STATIC indication, then there is no
                              other invocable routine R2 for which the user-defined type described by the
                              descriptor that includes the routine descriptor of R2 is a subtype of the user-
                              defined type described by the user-defined type descriptor that includes the routine
                              descriptor of SIRSR.
       ii)    If RN contains a <schema name> SN, then SN shall be the <schema name> of a schema S. The
              subject routine of RI is the invocable routine (if any) contained in S.
   c) There shall be exactly one subject routine of RI.
   d) If RI is not immediately contained in a <call statement>, then the effective returns data type of RI is
      the result data type of the subject routine of RI.



476 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                              ISO/IEC 9075-2:2003 (E)
                                                                                             10.4 <routine invocation>



    e) Let the static SQL argument list of RI be an empty list of SQL arguments.
8) If <SQL argument list> immediately contains at least one <SQL argument>, then:
    a) The <data type> of each <value expression> immediately contained in a <generalized expression>
       shall be a subtype of the structured type identified by the <user-defined type name> simply contained
       in the <path-resolved user-defined type name> that is immediately contained in <generalized expression>.
    b) The set of candidate routines of RI is defined as follows:
         Case:
         i)       If RN does not contain a <schema name>, then:
                  1) Case:
                      A) If RI is immediately contained in a <method selection>, a <static method selection>, or
                         a <constructor method selection>, then let DP be TP.
                      B) If the routine execution context of the current SQL-session indicates that an SQL-invoked
                         routine is active, then let DP be the routine SQL-path of that routine execution context.
                      C) Otherwise,
                           Case:
                           I)         If RI is contained in a <schema definition>, then let DP be the SQL-path of that
                                      <schema definition>.
                           II)        If RI is contained in a <preparable statement> that is prepared in the current SQL-
                                      session by an <execute immediate statement> or a <prepare statement> or in a
                                      <direct SQL statement> that is invoked directly, then let DP be the SQL-path of
                                      the current SQL-session.
                           III)       Otherwise, let DP be the SQL-path of the <SQL-client module definition> that
                                      contains RI.
                  2) The candidate routines of RI are the set union of invocable routines of all schemas whose
                     <schema name> is in DP.
         ii)      If RN contains a <schema name> SN, then SN shall be the <schema name> of a schema S. The
                  candidate routines of RI are the invocable routines (if any) contained in S.
    c) Case:
         i)       If RI is immediately contained in a <call statement>, then:
                  1) Let XAL be AL.
                  2) The subject routine SR of XAL is the SQL-invoked routine SIRCR1 that is a candidate routine
                     of RI such that there is no other candidate routine R2 for which the <schema name> of the
                     schema that includes R2 precedes in DP the <schema name> of the schema that includes
                     SIRCR1.
                  3) Let PL be the list of SQL parameters Pi of SR.




©ISO/IEC 2003 – All rights reserved                                                   Additional common elements 477
ISO/IEC 9075-2:2003 (E)
10.4 <routine invocation>



              4) For each Pi that is an output SQL parameter or both an input SQL parameter and an output
                 SQL parameter, Ai shall be a <target specification>.

                  A) If RI is contained in a <triggered SQL statement> of an AFTER trigger, then Ai shall
                     not be a <column reference>.
                  B) If Ai is an <embedded variable specification> or a <host parameter specification>, then
                     Pi shall be assignable to Ai, according to the Syntax Rules of Subclause 9.1, “Retrieval
                     assignment”, with Ai and Pi as TARGET and VALUE, respectively.

                  C) If Ai is an <SQL parameter reference>, a <column reference>, or a <target array element
                     specification>, then Pi shall be assignable to Ai, according to the Syntax Rules of
                     Subclause 9.2, “Store assignment”, with Ai and Pi as TARGET and VALUE, respectively.
                      NOTE 217 — The <column reference> can only be a new transition variable column reference.

              5) For each Pi that is an input SQL parameter but not an output SQL parameter, Ai shall be a
                 <value expression>.
              6) For each Pi that is an input SQL parameter or both an input SQL parameter and an output
                 SQL parameter, Ai shall be assignable to Pi, according to the Syntax Rules of Subclause 9.2,
                 “Store assignment”, with Pi and Ai as TARGET and VALUE, respectively.

       ii)    Otherwise:
              1) Ai shall be a <value expression> or <generalized expression>.

              2) Case:
                  A) If Ai is a <generalized expression>, then let TSi be the data type identified by the <user-
                     defined type name> simply contained in the <path-resolved user-defined type name>
                     that is immediately contained in the <generalized expression>.
                  B) Otherwise, let TSi be the data type whose data type name is included in the data type
                     descriptor of the data type of Ai.

              3) The subject routine is defined as follows:
                  A) For each Ai,

                      Case:
                      I)      If Ai is a <dynamic parameter specification>, then let Vi be Ai.

                      II)     Otherwise, let Vi be a value arbitrarily chosen whose declared type is TSi.

                  B) Let XAL be an <SQL argument list> with N <SQL argument>s derived from the Vis
                     ordered according to their ordinal position i in XAL. The Syntax Rules of Subclause 9.4,
                     “Subject routine determination”, are applied to the candidate routines of RI and XAL,
                     yielding a set of candidate subject routines CSR.
                  C) Case:



478 Foundation (SQL/Foundation)                                                        ©ISO/IEC 2003 – All rights reserved
                                                                                               ISO/IEC 9075-2:2003 (E)
                                                                                              10.4 <routine invocation>



                           I)         If RN contains a <schema name>, then there shall be exactly one candidate subject
                                      routine in CSR. The subject routine SR is the candidate subject routine in CSR.
                           II)        Otherwise:
                                      1) There shall be at least one candidate subject routine in CSR.
                                      2) Case:
                                          a) If there is exactly one candidate subject routine in CSR, then the subject
                                             routine SR is the candidate subject routine in CSR.
                                          b) If there is more than one candidate subject routine in CSR, then
                                              Case:
                                              i)      If RI is not immediately contained in a <static method selection>,
                                                      then there shall be an SQL-invoked routine SIRCR2 in CSR such
                                                      that there is no other candidate subject routine R2 in CSR for which
                                                      any of the following is true:
                                                      1) The <schema name> of the schema that includes R2 precedes
                                                         in DP the <schema name> of the schema that includes
                                                         SIRCR2.
                                                      2) The <schema name> of the schema that includes R2 is
                                                         equivalent to the <schema name> of the schema that includes
                                                         SIRCR2.
                                                      The subject routine SR is SIRCR2.
                                              ii)     Otherwise, there shall be an SQL-invoked routine SIRCR3 in CSR
                                                      such that there is no other candidate subject routine R2 in CSR for
                                                      which the user-defined type described by the user-defined type
                                                      descriptor that includes the routine descriptor of R2 is a subtype
                                                      of the user-defined type described by the user-defined type
                                                      descriptor that includes the routine descriptor of SIRCR3. The
                                                      subject routine SR is SIRCR3.
                  4) The subject routine of RI is the subject routine SR.
                  5) Let PL be the list of SQL parameters Pi of SR.

                  6) For each Pi, Ai shall be assignable to Pi according to the Syntax Rules of Subclause 9.2,
                     “Store assignment”, with Pi and Ai as TARGET and VALUE, respectively.

                  7) The effective returns data type of RI is defined as follows:
                      A) Case:
                           I)         If SR is a type-preserving function, then let Pi be the result SQL parameter of
                                      SR. If Ai contains a <generalized expression>, then let RT be the declared type
                                      of the <value expression> contained in the <generalized expression> of Ai; oth-
                                      erwise, let RT be the declared type of Ai.



©ISO/IEC 2003 – All rights reserved                                                   Additional common elements 479
ISO/IEC 9075-2:2003 (E)
10.4 <routine invocation>



                          II)     Otherwise, let RT be the result data type of SR.
                     B) The effective returns data type of RI is RT.
9) If SR is a constructor function, then RI shall be simply contained in a <new invocation>.


Access Rules
    None.


General Rules
1) Let SAL and SR be the static SQL argument list and subject routine of the <routine invocation> as specified
   in an application of this Subclause.
    NOTE 218 — “static SQL argument list” and “subject routine” are defined by the Syntax Rules of this Subclause.

2) Case:
    a) If SAL is empty, then let the dynamic SQL argument list DAL be SAL.
    b) Otherwise:
        i)      Each SQL argument Ai in SAL is evaluated, in an implementation-dependent order, to obtain a
                value Vi.

        ii)     Let the dynamic SQL argument list DAL be the list of values Vi in order.

        iii)    If SR is type preserving and the null value is substituted for the result parameter, then
                Case:
                1) If SR is a mutator function, then an exception condition is raised: data exception — null
                   value substituted for mutator subject parameter.
                2) Otherwise, the value of RI is the null value and the remaining General Rules of this Subclause
                   are not applied.
        iv)     Case:
                1) If SR is an instance SQL-invoked method, then:
                     A) If V1 is the null value, then the value of RI is the null value and the remaining General
                        Rules of this Subclause are not applied.
                     B) Let SM be the set of SQL-invoked methods M that satisfy the following conditions:
                          I)      The <routine name> of SR and the <routine name> of M have equivalent <qual-
                                  ified identifier>s.

                          II)     SR and M have the name number N of SQL parameters. Let PSRi, 1 (one) ≤ i ≤
                                  N, be the i-th SQL parameter of SR and PMi, 1 (one) ≤ i ≤ N, be the i-th SQL
                                  parameter of M.


480 Foundation (SQL/Foundation)                                                              ©ISO/IEC 2003 – All rights reserved
                                                                                             ISO/IEC 9075-2:2003 (E)
                                                                                            10.4 <routine invocation>



                           III)       The declared type of the subject parameter of M is a subtype of the declared type
                                      of the subject parameter of SR.
                           IV)        For j varying from 2 to N, the Syntax Rules of Subclause 9.16, “Data type iden-
                                      tity”, are applied with the declared type of PMj and the declared type of PSRj.
                                      NOTE 219 — SR is an element of the set SM.

                      C) SM is the set of overriding methods of SR and every SQL-invoked method M in SM is
                         an overriding method of SR.
                      D) Case:
                           I)         If the first SQL argument A1 in SAL contains a <generalized expression>, then
                                      let DT1 be the data type identified by the <user-defined type name> contained
                                      in the <generalized expression> of A1.
                           II)        Otherwise, let DT1 be the most specific type of V1.

                      E) Let R be the SQL-invoked method in SM such that there is no other SQL-invoked method
                         M1 in SM for which the type designator of the declared type of the subject parameter
                         of M1 precedes that of the declared type of the subject parameter of R in the type
                         precedence list of DT1.
                  2) Otherwise, let R be SR.
3) Let N and PN be the number of values Vi in DAL. Let Ti be the declared type of the i-th SQL parameter Pi
   of R. For i ranging from 1 (one) to PN,
    Case:
    a) If Pi is an input SQL parameter or both an input SQL parameter and an output SQL parameter, then
       let CPVi be the result of the assignment of Vi to a target of type Ti according to the rules of Subclause 9.2,
       “Store assignment”.
    b) Otherwise,
         Case:
         i)       If R is an SQL routine, then let CPVi be the null value.

         ii)      Otherwise, let CPVi be an implementation-defined value of most specific type Ti.

4) If R is an external routine, then:
    a) Let P be the program identified by the external name of R.
    b) For i ranging from 1 (one) to N, let Pi be the i-th SQL parameter of R and let Ti be the declared type
       of Pi.

         Case:
         i)       If Pi is an input SQL parameter or both an input SQL parameter and an output SQL parameter,
                  then



©ISO/IEC 2003 – All rights reserved                                                 Additional common elements 481
ISO/IEC 9075-2:2003 (E)
10.4 <routine invocation>



              Case:
              1) If Pi is a locator parameter, then CPVi is replaced by the locator value that uniquely identifies
                 the value of CPVi.

              2) If Ti is a user-defined type, and Pi is not a locator parameter, then:

                  A) Let FSFi be the SQL-invoked routine identified by the specific name of the from-sql
                     function associated with Pi in the routine descriptor of R. Let RTi be the result data type
                     of FSFi.

                  B) The General Rules of this Subclause are applied with a static SQL argument list that
                     has a single argument that is CPVi and subject routine FSFi.

                  C) Let RVi be the result of the invocation of FSFi. CPVi is replaced by RVi.

       ii)    Otherwise,
              Case:
              1) If Pi is a locator parameter, then CPVi is replaced with an implementation-dependent value
                 of type INTEGER.
              2) If Ti is a user-defined type and Pi is not a locator parameter, then:

                  A) Let FSFi be the SQL-invoked routine identified by the specific name of the from-sql
                     function associated with Pi in the routine descriptor of R. Let RTi be the result data type
                     of FSFi.

                  B) CPVi is replaced by an implementation-defined value of type RTi.

5) Preserve the current SQL-session context CSC and create a new SQL-session context RSC derived from
   CSC as follows:
   a) Set the current default catalog name, the current default unqualified schema name, the current default
      character set name, the SQL-path of the current SQL-session, the current default time zone displacement
      of the current SQL-session, and the contents of all SQL dynamic descriptor areas to implementation-
      defined values.
   b) Set the values of the current SQL-session identifier, the identities of all instances of global temporary
      tables, the current constraint mode for each integrity constraint, the current transaction access mode,
      the current transaction isolation level, and the current transaction condition area limit to their values
      in CSC.
   c) The diagnostics area stack in CSC is copied to RSC and the General Rules of Subclause 22.2, “Pushing
      and popping the diagnostics area stack”, are applied with “PUSH” as OPERATION and the diagnostics
      area stack in RSC as STACK.
   d) Case:
       i)     If R is an SQL routine, then remove from RSC the identities of all instances of created local
              temporary tables, declared local temporary tables that are defined by <temporary table declara-



482 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                         10.4 <routine invocation>



                  tion>s that are contained in <SQL-client module definition>s, and the cursor position of all open
                  cursors.
         ii)      Otherwise:
                  1) Remove from RSC the identities of all instances of created local temporary tables that are
                     referenced in <SQL-client module definition>s that are not the <SQL-client module defini-
                     tion> of P, declared local temporary tables that are defined by <temporary table declaration>s
                     that are contained in <SQL-client module definition>s that are not the <SQL-client module
                     definition> of P, and the cursor position of all open cursors that are defined by <declare
                     cursor>s that are contained in <SQL-client module definition>s that are not the <SQL-client
                     module definition> of P.
                  2) It is implementation-defined whether the identities of all instances of created local temporary
                     tables that are referenced in the <SQL-client module definition> of P, declared local tempo-
                     rary tables that are defined by <temporary table declaration>s that are contained in the
                     <SQL-client module definition> of P, and the cursor position of all open cursors that are
                     defined by <declare cursor>s that are contained in the <SQL-client module definition> of
                     P are removed from RSC.
    e) Indicate in the routine execution context of RSC that the SQL-invoked routine R is active.
    f) Case:
         i)       If the SQL-data access indication of CSC specifies possibly contains SQL and R possibly reads
                  SQL-data or R possibly modifies SQL-data, then:
                  1) If R is an external routine, then an exception condition is raised: external routine exception
                     — reading SQL-data not permitted.
                  2) Otherwise, an exception condition is raised: SQL routine exception — reading SQL-data
                     not permitted.
         ii)      If the SQL-data access indication of CSC specifies possibly reads SQL and R possibly modifies
                  SQL-data, then:
                  1) If R is an external routine, then an exception condition is raised: external routine exception
                     — modifying SQL-data not permitted.
                  2) Otherwise, an exception condition is raised: SQL routine exception — modifying SQL-data
                     not permitted.
    g) Case:
         i)       If R does not possibly contain SQL, then set the SQL-data access indication in the routine exe-
                  cution context of RSC to does not possibly contain SQL.
         ii)      If R possibly contains SQL, then set the SQL-data access indication in the routine execution
                  context of RSC to possibly contains SQL.
         iii)     If R possibly reads SQL-data, then set the SQL-data access indication in the routine execution
                  context of RSC to possibly reads SQL-data.
         iv)      If R possibly modifies SQL-data, then set the SQL-data access indication in the routine execution
                  context of RSC to possibly modifies SQL-data.


©ISO/IEC 2003 – All rights reserved                                              Additional common elements 483
ISO/IEC 9075-2:2003 (E)
10.4 <routine invocation>



    h) The authorization stack of RSC is set to a copy of the authorization stack of CSC.
    i)   A copy of the top cell is pushed onto the authorization stack of RSC.
    j)   Case:
         i)      If R is an external routine, then:
                 1) Case:
                     A) If the external security characteristic of R is IMPLEMENTATION DEFINED, then the
                        current user identifier and the current role name of RSC are implementation-defined.
                     B) If the external security characteristic of R is DEFINER, then the top cell of the autho-
                        rization stack of RSC is set to contain only the external routine authorization identifier
                        of R.
                 2) Set the routine SQL-path of RSC to be the external routine SQL-path of R.
         ii)     Otherwise:
                 1) If the SQL security characteristic of R is DEFINER, then the current authorization identifier
                    of RSC is set to the routine authorization identifier of R.
                 2) Set the routine SQL-path of RSC to be the routine SQL-path of R.
    k) RSC becomes the current SQL-session context.
6) If the descriptor of R includes an indication that a new savepoint level is to be established when R is invoked,
   then a new savepoint level is established.
7) If R is an SQL routine, then
    Case:
    a) If R is a null-call function and if any of CPVi is the null value, then let RV be the null value.

    b) Otherwise:
         i)      For i ranging from 1 (one) to PN, set the value of Pi to CPVi.

         ii)     The General Rules of Subclause 13.5, “<SQL procedure statement>”, are evaluated with the
                 SQL routine body of R as the executing statement.
         iii)    If, before the completion of the execution of the SQL routine body of R, an attempt is made to
                 execute an SQL-connection statement, then an exception condition is raised: SQL routine
                 exception — prohibited SQL-statement attempted.
         iv)     Case:
                 1) If the SQL-implementation does not support Feature T272, “Enhanced savepoint manage-
                    ment”, and, before the completion of the execution of the SQL routine body of R, an attempt
                    is made to execute an SQL-transaction statement, then an exception condition is raised: SQL
                    routine exception — prohibited SQL-statement attempted.
                 2) If, before the completion of the execution of the SQL routine body of R, an attempt is made
                    to execute an SQL-transaction statement that is not a <savepoint statement> or a <release


484 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                                ISO/IEC 9075-2:2003 (E)
                                                                                               10.4 <routine invocation>



                      savepoint statement>, or is a <rollback statement> that does not specify a <savepoint clause>,
                      then an exception condition is raised: SQL routine exception — prohibited SQL-statement
                      attempted.
         v)       If the SQL implementation does not support Feature T651, “SQL-schema statements in SQL
                  routines”, and, before the completion of the execution of the SQL routine body of R, an attempt
                  is made to execute an SQL-schema statement, an exception condition is raised: SQL routine
                  exception — prohibited SQL-statement attempted.
         vi)      If the SQL implementation does not support Feature T652, “SQL-dynamic statements in SQL
                  routines”, and, before the completion of the execution of the SQL routine body of R, an attempt
                  is made to execute an SQL-dynamic statement, an exception condition is raised: SQL routine
                  exception — prohibited SQL-statement attempted.
         vii)     If the SQL-data access indication of RSC specifies possibly contains SQL and, before the com-
                  pletion of the execution of the SQL routine body of R, an attempt is made to execute an SQL-
                  statement that possibly reads SQL-data, or an attempt is made to execute an SQL-statement that
                  possibly modifies SQL-data, then an exception condition is raised: SQL routine exception —
                  reading SQL-data not permitted.
         viii)    If the SQL-data access indication of RSC specifies possibly reads SQL-data and, before the
                  completion of the execution of the SQL routine body of R, an attempt is made to execute an
                  SQL-statement that possibly modifies SQL-data then an exception condition is raised: SQL
                  routine exception — modifying SQL-data not permitted.
         ix)      If R is an SQL-invoked function, then
                  Case:
                  1) If no <return statement> is executed before completion of the execution of the SQL routine
                     body of R, then an exception condition is raised: SQL routine exception — function executed
                     no return statement.
                  2) Otherwise, let RV be the returned value of the execution of the SQL routine body of R.
                      NOTE 220 — “Returned value” is defined in Subclause 15.2, “<return statement>”.

         x)       If R is an SQL-invoked procedure, then for each SQL parameter of R that is an output SQL
                  parameter or both an input SQL parameter and an output SQL parameter, set the value of CPVi
                  to the value of Pi.

8) If R is an external routine, then:
    a) The method and time of binding of P to the schema or SQL-server module that includes R is implemen-
       tation-defined.
    b) If R specifies PARAMETER STYLE SQL, then
         i)       Case:
                  1) If R is an SQL-invoked function, then the effective SQL parameter list ESPL of R is set as
                     follows:




©ISO/IEC 2003 – All rights reserved                                                    Additional common elements 485
ISO/IEC 9075-2:2003 (E)
10.4 <routine invocation>



                  A) If R is an array-returning external function or a multiset-returning external function with
                     the element type being a row type, then let FRN be the degree of the element type; oth-
                     erwise, let FRN be 1 (one).
                  B) For i ranging from 1 (one) to PN, the i-th entry in ESPL is set to CPVi.

                  C) For i ranging from PN+1 to PN+FRN, the i-th entries in ESPL are the result data items.
                  D) For i ranging from (PN+FRN)+1 to (PN+FRN)+N, the i-th entry in ESPL is the SQL
                     indicator argument corresponding to CPVi-(PN+FRN).

                  E) For i ranging from (PN+FRN)+N+1 to (PN+FRN)+N+FRN, the i-th entries in ESPL are
                     the SQL indicator arguments corresponding to the result data items.
                  F) For i equal to (PN+FRN)+(N+FRN)+1, the i-th entry in ESPL is the exception data item.
                  G) For i equal to (PN+FRN)+(N+FRN)+2, the i-th entry in ESPL is the routine name text
                     item.
                  H) For i equal to (PN+FRN)+(N+FRN)+3, the i-th entry in ESPL is the specific name text
                     item.
                  I) For i equal to (PN+FRN)+(N+FRN)+4, the i-th entry in ESPL is the message text item.
                  J) If R is an array-returning external function or a multiset-returning external function,
                     then for i equal to (PN+FRN)+(N+FRN)+5, the i-th entry in ESPL is the save area data
                     item and for i equal to (PN+FRN)+(N+FRN)+6, the i-th entry in ESPL is the call type
                     data item.
                  K) Set the values of the SQL indicator arguments corresponding to the result data items
                     (that is, SQL argument value list entries from (PN+FRN)+N+1 through
                     (PN+FRN)+N+FRN, inclusive, to 0 (zero).
                  L) For i ranging from 1 (one) to PN, if CPVi is the null value, then set entry (PN+FRN)+i
                     (that is, the i-th SQL indicator argument corresponding to CPVi) to –1; otherwise, set
                     entry (PN+FRN)+i (that is, the i-th SQL indicator argument corresponding to CPVi) to
                     0 (zero).
                  M) If R is an array-returning external function or a multiset-returning external function,
                     then set the value of the save area data item (that is, SQL argument value list entry
                     (PN+FRN)+(N+FRN)+5) to 0 (zero) and set the value of the call type data item (that is,
                     SQL argument value list entry (PN+FRN)+(N+FRN)+6) to –1.
              2) Otherwise, the effective SQL parameter list ESPL of R is set as follows:
                  A) For i ranging from 1 (one) to PN, the i-th entry in ESPL is CPVi.

                  B) For i ranging from PN+1 to PN+N, the i-th entry in ESPL is the SQL indicator argument
                     corresponding to CPVi-PN.

                  C) For i equal to (PN+N)+1, the i-th entry in ESPL is the exception data item.
                  D) For i equal to (PN+N)+2, the i-th entry in ESPL is the routine name text item.




486 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)
                                                                                          10.4 <routine invocation>



                      E) For i equal to (PN+N)+3, the i-th entry in ESPL is the specific name text item.
                      F) For i equal to (PN+N)+4, the i-th entry in ESPL is the message text item.
                      G) For i ranging from 1 (one) to PN, if CPVi is the null value, then set entry PN+i in ESPL
                         (that is, the i-th SQL indicator argument corresponding to CPVi) to –1; otherwise, set
                         entry PN+i in ESPL (that is, the i-th SQL indicator argument corresponding to CPVi)
                         to 0 (zero).
         ii)      The exception data item is set to '00000'.
         iii)     The routine name text item is set to the <schema qualified name> of the routine name of R.
         iv)      The specific name text item is set to the <qualified identifier> of the specific name of R.
         v)       The message text item is set to a zero-length string.
    c) If R specifies PARAMETER STYLE GENERAL, then the effective SQL parameter list ESPL of R is
       set as follows:
         i)       If R is not a null-call function and, for i ranging from 1 (one) to PN, CPVi is the null value, then
                  an exception condition is raised: external routine invocation exception — null value not allowed.
         ii)      For i ranging from 1 (one) to PN, if no CPVi is the null value, then the for j ranging from 1 (one)
                  to PN, if the j-th entry in ESPL is set to CPVj.

    d) If R specifies DETERMINISTIC and if different executions of P with identical SQL argument value
       lists do not produce identical results, then the results are implementation-dependent.
    e) Let EN be the number of entries in ESPL. Let ESPi be the i-th effective SQL parameter in ESPL.

    f) Case:
         i)       If R is a null-call function and if any of CPVi is the null value, then P is assumed to have been
                  executed.
         ii)      Otherwise:
                  1) If R is not an array-returning external function or a multiset-returning external function,
                     then P is executed with a list of EN parameters PDi whose parameter names are PNi and
                     whose values are set as follows:
                      A) Depending on whether the language of R specifies ADA, C, COBOL, FORTRAN, M,
                         PASCAL, or PLI, let the operative data type correspondences table be Table 16, “Data
                         type correspondences for Ada”, Table 17, “Data type correspondences for C”, Table 18,
                         “Data type correspondences for COBOL”, Table 19, “Data type correspondences for
                         Fortran”, Table 20, “Data type correspondences for M”, Table 21, “Data type correspon-
                         dences for Pascal”, or Table 22, “Data type correspondences for PL/I”, respectively.
                         Refer to the two columns of the operative data type correspondences table as the “SQL
                         data type” column and the “host data type” column.




©ISO/IEC 2003 – All rights reserved                                               Additional common elements 487
ISO/IEC 9075-2:2003 (E)
10.4 <routine invocation>



                  B) For i varying from 1 (one) to EN, the data type DTi of PDi is the data type listed in the
                     host data type column of the row in the data type correspondences table whose value in
                     the SQL data type column corresponds to the data type of ESPi.

                  C) The value of PDi is set to the value of ESPi.

              2) If R is an array-returning external function, then:
                  A) Let AR be an array whose declared type is the result data type of R.
                  B) The General Rules of Subclause 9.14, “Execution of array-returning functions”, are
                     applied with AR, ESPL, and P as ARRAY, EFFECTIVE SQL PARAMETER LIST, and
                     PROGRAM, respectively.
              3) If R is a multiset-returning external function, then:
                  A) Let MU be a multiset whose declared type is the result data type of R.
                  B) The General Rules of Subclause 9.15, “Execution of multiset-returning functions”, are
                     applied with MU, ESPL, and P as MULTISET, EFFECTIVE SQL PARAMETER LIST,
                     and PROGRAM, respectively.
              4) If the SQL-data access indication of RSC specifies does not possibly contain SQL and, before
                 the completion of any execution of P, an attempt is made to execute an SQL-statement, then
                 an exception condition is raised: external routine exception — containing SQL not permitted.
              5) If, before the completion of any execution of P, an attempt is made to execute an SQL-
                 connection statement, then an exception condition is raised: external routine exception —
                 prohibited SQL-statement attempted.
              6) Case:
                  A) If the SQL-implementation does not support Feature T272, “Enhanced savepoint man-
                     agement”, and, before the completion of the execution of P, an attempt is made to execute
                     an SQL-transaction statement, then an exception condition is raised: SQL routine
                     exception — prohibited SQL-statement attempted.
                  B) If, before the completion of the execution of P, an attempt is made to execute an SQL-
                     transaction statement that is not <savepoint statement> or <release savepoint statement>,
                     or is a <rollback statement> that does not specify a <savepoint clause>, then an exception
                     condition is raised: external routine exception — prohibited SQL-statement attempted.
              7) If the SQL implementation does not support Feature T653, “SQL-schema statements in
                 external routines”, and, before the completion of any execution of P, an attempt is made to
                 execute an SQL-schema statement, then an exception condition is raised: external routine
                 exception — prohibited SQL-statement attempted.
              8) If the SQL implementation does not support Feature T654, “SQL-dynamic statements in
                 external routines”, and, before the completion of any execution of P, an attempt is made to
                 execute an SQL-dynamic statement, then an exception condition is raised: external routine
                 exception — prohibited SQL-statement attempted.
              9) If the SQL-data access indication of RSC specifies possibly contains SQL and, before the
                 completion of any execution of P, an attempt is made to execute an SQL-statement that


488 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                         10.4 <routine invocation>



                      possibly reads SQL-data, or an attempt is made to execute an SQL-statement that possibly
                      modifies SQL-data, then an exception condition is raised: external routine exception —
                      reading SQL-data not permitted.
                  10) If the SQL-data access indication of RSC specifies possibly reads SQL and, before the
                      completion of any execution of P, an attempt is made to execute an SQL-statement that
                      possibly modifies SQL-data, then an exception condition is raised: external routine exception
                      — modifying SQL-data not permitted.
                  11) If the language specifies ADA (respectively C, COBOL, FORTRAN, M, PASCAL, PLI)
                      and P is not a standard-conforming Ada program (respectively C, COBOL, Fortran, M,
                      Pascal, PL/I program), then the results of any execution of P are implementation-dependent.
    g) After the completion of any execution of P:
         i)       It is implementation-defined whether:
                  1) For every open cursor CR that is associated with RSC and that is defined by a <declare
                     cursor> that is contained in the <SQL-client module definition> of P:
                      A) The following SQL-statement is effectively executed:
                               CLOSE CR

                      B) CR is destroyed.
                  2) Every instance of created local temporary tables and every instance of declared local tempo-
                     rary tables that is associated with RSC is destroyed.
                  3) For every prepared statement PS prepared by P in the current SQL-transaction that has not
                     been deallocated by P:
                      A) Let SSN be the <SQL statement name> that identifies PS.
                      B) The following SQL-statement is effectively executed:
                               DEALLOCATE PREPARE SSN

         ii)      For i varying from 1 (one) to EN, the value of ESPi is set to the value of PDi. If R specifies
                  PARAMETER STYLE SQL, then
                  Case:
                  1) If the exception data item has the value '00000', then the execution of P was successful.
                  2) If the first two characters of the exception data item are equal to the SQLSTATE condition
                     code class value for warning, then a completion condition is raised: warning, using a subclass
                     code equal to the final three characters of the value of the exception data item.
                  3) Otherwise, an exception condition is raised using a class code equal to the first two characters
                     of the value of the exception data item and a subclass code equal to the final three characters
                     of the value of the exception data item.
         iii)     If the exception data item is not '00000' and R specified PARAMETER STYLE SQL, then the
                  message text item is stored in the first diagnostics area.


©ISO/IEC 2003 – All rights reserved                                               Additional common elements 489
ISO/IEC 9075-2:2003 (E)
10.4 <routine invocation>



   h) If R is an SQL-invoked function, then:
       i)     Case:
              1) If R is an SQL-invoked method whose routine descriptor does not include a STATIC indi-
                 cation and if CPV1 is the null value, then let RDI be the null value.

              2) If R is a null-call function, R is not an array-returning external function or a multiset-
                 returning external function, and if any of CPVi is the null value, then let RDI be the null
                 value.
              3) If R is not a null-call function, R specifies PARAMETER STYLE SQL, and entry
                 (PN+1)+N+1 in ESPL (that is, SQL indicator argument N+1 corresponding to the result data
                 item) is negative, then let RDI be the null value.
              4) Otherwise,
                  A) Case:
                      I)      If R is not an array-returning external function or a multiset-returning external
                              function, R specifies PARAMETER STYLE SQL, and entry (PN+1)+N+1 in
                              ESPL (that is, SQL indicator argument N+1 corresponding to the result data item)
                              is not negative, then let ERDI be the value of the result data item.
                      II)     If R is an array-returning external function, and R specifies PARAMETER STYLE
                              SQL, then let ERDI be AR.
                      III)    If R is a multiset-returning function, and R specifies PARAMETER STYLE SQL,
                              then let ERDI be MU.
                      IV)     If R specifies PARAMETER STYLE GENERAL, then let ERDI be the value
                              returned from P.
                              NOTE 221 — The value returned from P is passed to the SQL-implementation in an implementation-
                              dependent manner. An argument value list entry is not used for this purpose.

                  B) Case:
                      I)      If the routine descriptor of R indicates that the return value is a locator, then
                              Case:
                              1) If RT is a binary large object type, then let RDI be the binary large object
                                 value corresponding to ERDI.
                              2) If RT is a character large object type, then let RDI be the large object character
                                 string corresponding to ERDI.
                              3) If RT is an array type, then let RDI be the array value corresponding to ERDI.
                              4) If RT is a multiset type, then let RDI be the multiset value corresponding to
                                 ERDI.
                              5) If RT is a user-defined type, then let RDI be the user-defined type value cor-
                                 responding to ERDI.




490 Foundation (SQL/Foundation)                                                          ©ISO/IEC 2003 – All rights reserved
                                                                                              ISO/IEC 9075-2:2003 (E)
                                                                                             10.4 <routine invocation>



                           II)        Otherwise, if R specifies <result cast>, then let CRT be the <data type> specified
                                      in <result cast>; otherwise, let CRT be the <returns data type> of R.
                                      Case:
                                      1) If R specifies <result cast> and the routine descriptor of R indicates that the
                                         <result cast> has a locator indication, then
                                          Case:
                                          a) If CRT is a binary large object type, then let RDI be the binary large
                                             object value corresponding to ERDI.
                                          b) If CRT is a character large object type, then let RDI be the large object
                                             character string corresponding to ERDI.
                                          c) If CRT is an array type, then let RDI be the array value corresponding to
                                             ERDI.
                                          d) If CRT is a multiset type, then let RDI be the multiset value corresponding
                                             to ERDI.
                                          e) If CRT is a user-defined type, then let RDI be the user-defined type value
                                             corresponding to ERDI.
                                      2) Otherwise,
                                          Case:
                                          a) If CRT is a user-defined type, then:
                                              i)      Let TSF be the SQL-invoked routine identified by the specific
                                                      name of the to-sql function associated with the result of R.
                                              ii)     Case:
                                                      1) If TSF is an SQL-invoked method, then:
                                                          A) If R is a type-preserving function, then let MAT be the
                                                             most specific type of the value of the argument substituted
                                                             for the result SQL parameter of R; otherwise, let MAT be
                                                             CRT.
                                                          B) The General Rules of this Subclause are applied with a
                                                             static SQL argument list whose first element is the value
                                                             returned by the invocation of:
                                                                MAT()
                                                              and whose second element is ERDI, and the subject rou-
                                                              tine TSF.
                                                      2) Otherwise, the General Rules of this Subclause are applied
                                                         with a static SQL argument list that has a single SQL argument
                                                         that is ERDI, and the subject routine TSF.



©ISO/IEC 2003 – All rights reserved                                                  Additional common elements 491
ISO/IEC 9075-2:2003 (E)
10.4 <routine invocation>



                                           iii)    Let RDI be the result of invocation of TSF.
                                      b) Otherwise, let RDI be ERDI.
        ii)     If R specified a <result cast>, then let RT be the <returns data type> of R and let RV be the result
                of:
                   CAST ( RDI AS RT )
                Otherwise, let RV be RDI.

   i)   If R is an SQL-invoked procedure, then for each Pi, 1 (one) ≤ i ≤ PN, that is an output SQL parameter
        or both an input SQL parameter and an output SQL parameter,
        Case:
        i)      If R specifies PARAMETER STYLE SQL and entry (PN+1)+i in ESPL (that is, the i-th SQL
                indicator argument corresponding to CPVi) is negative, then CPVi is set to the null value.

        ii)     If R specifies PARAMETER STYLE SQL, and entry (PN+1)+i in ESPL (that is, the i-th SQL
                indicator argument corresponding to CPVi) is not negative, and a value was not assigned to the
                i-th entry in ESPL, then CPVi is set to an implementation-defined value of type Ti.

        iii)    Otherwise:
                NOTE 222 — In this case, either R specifies PARAMETER STYLE SQL and entry (PN+1)+i in SQPL (that is, the
                i-th SQL indicator argument corresponding to CPVi) is not negative and a value was assigned to the i-th entry in
                ESPL, or else R specifies PARAMETER STYLE GENERAL.

                1) Let EVi be the i-th entry in ESPL. Let Ti be the <data type> of Pi.

                2) Case:
                    A) If Pi is a locator parameter, then

                         Case:
                         I)      If Ti is a binary large object type, then CPVi is set to the binary large object value
                                 corresponding to EVi.

                         II)     If Ti is a character large object type, then CPVi is set to the large object character
                                 string corresponding to EVi.

                         III)    If Ti is an an array type, then CPVi is set to the array value corresponding to EVi.

                         IV)     If Ti is an a multiset type, then CPVi is set to the multiset value corresponding
                                 to EVi.

                         V)      If Ti is a user-defined type, then CPVi is set to the user-defined type value corre-
                                 sponding to EVi.

                    B) If Ti is a user-defined type, then:




492 Foundation (SQL/Foundation)                                                              ©ISO/IEC 2003 – All rights reserved
                                                                                                ISO/IEC 9075-2:2003 (E)
                                                                                               10.4 <routine invocation>



                           I)         Let TSFi be the SQL-invoked function identified by the specific name of the to-
                                      sql function associated with Pi in the routine descriptor of R.

                           II)        Case:
                                      1) If TSF is an SQL-invoked method, then the General Rules of this Subclause
                                         are applied with a static SQL argument list whose first element is the value
                                         returned by the invocation of:
                                              Ti()

                                          and whose second element is EVi, and the subject routine TSFi.

                                      2) Otherwise, the General Rules of this Subclause are applied with a static SQL
                                         argument list that has a single SQL argument that is EVi, and the subject
                                         routine TSFi.

                           III)       CPVi is set to the result of an invocation of TSFi.

                      C) Otherwise, CPVi is set to EVi.

9) Case:
    a) If R is an SQL-invoked function, then:
         i)       If R is a type-preserving function, then:
                  1) Let MAT be the most specific type of the value of the argument substituted for the result
                     SQL parameter of R.
                  2) If RV is not the null value and the most specific type of RV is not compatible with MAT,
                     then an exception condition is raised: data exception — most specific type mismatch.
         ii)      Let ERDT be the effective returns data type of the <routine invocation>.
         iii)     Let the result of the <routine invocation> be the result of assigning RV to a target of declared
                  type ERDT according to the rules of Subclause 9.2, “Store assignment”.
    b) Otherwise, for each SQL parameter Pi of R that is an output SQL parameter or both an input SQL
       parameter and an output SQL parameter, let TSi be the <target specification> of the corresponding
       <SQL argument> Ai.

         Case:
         i)       If TSi is a <host parameter specification> or an <embedded variable specification>, then CPVi
                  is assigned to TSi according to the rules of Subclause 9.1, “Retrieval assignment”.

         ii)      If TSi is an <SQL parameter reference>, a <column reference>, or a <target array element
                  specification>, then
                  NOTE 223 — The <column reference> can only be a new transition variable column reference.

                  Case:
                  1) If <target array element specification> is specified, then


©ISO/IEC 2003 – All rights reserved                                                    Additional common elements 493
ISO/IEC 9075-2:2003 (E)
10.4 <routine invocation>



                  Case:
                  A) If the value of TSi, denoted by C, is null, then an exception condition is raised: data
                     exception — null value in array target.
                  B) Otherwise:
                      I)     Let N be the maximum cardinality of C.
                      II)    Let M be the cardinality of the value of C.
                      III)   Let I be the value of the <simple value specification> immediately contained in
                             TSi.

                      IV)    Let EDT be the element type of C.
                      V)     Case:
                             1) If I is greater than zero and less than or equal to M, then the value of C is
                                replaced by an array A with element type EDT and cardinality M derived as
                                follows:
                                 a) For j varying from 1 (one) to I–1 and from I+1 to M, the j-th element in
                                    A is the value of the j-th element in C.
                                 b) The I-th element of A is set to the value of CPVi , denoted by SV, by
                                    applying the General Rules of Subclause 9.2, “Store assignment”, to the
                                    I-th element of A and SV as TARGET and VALUE, respectively.
                             2) If I is greater than M and less than or equal to N, then the value of C is
                                replaced by an array A with element type EDT and cardinality I derived as
                                follows:
                                 a) For j varying from 1 (one) to M, the j-th element in A is the value of the
                                    j-th element in C.
                                 b) For j varying from M+1 to I, the j-th element in A is the null value.
                                 c) The I-th element of A is set to the value of CPVi, denoted by SV, by
                                    applying the General Rules of Subclause 9.2, “Store assignment”, to the
                                    I-th element of A and SV as TARGET and VALUE, respectively.
                             3) Otherwise, an exception condition is raised: data exception — array element
                                error.
              2) Otherwise, CPVi is assigned to TSi according to the rules of Subclause 9.2, “Store assign-
                 ment”.
10) If the subject routine is a procedure whose descriptor PR includes a maximum number of dynamic result
    sets that is greater than zero, then a sequence of result sets RRS is returned to INV.
   a) Let MAX be maximum number of dynamic result sets included in PR.
   b) Let OPN be the actual number of result set cursors declared in the body of the subject routine that
      remain open when control is returned to INV.


494 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                                        10.4 <routine invocation>



    c) Case:
         i)       If OPN is greater than MAX, then:
                  1) Let RTN be MAX.
                  2) A completion condition is raised: warning — attempt to return too many result sets.
         ii)      Otherwise, let RTN be OPN.
    d) Let FRC be the ordered set of result set cursors that remain open when PR returns to INV. Let FRCi,
         1 (one) ≤ i ≤ RTN, be the i-th cursor in FRC, let FRCNi be the <cursor name> that identifies FRCi, and
         let RSi be the result set of FRCi.

    e) Case:

         i)       If FRCNi, 1 (one) ≤ i ≤ RTN, is a scrollable cursor, then let NXTi be 1 (one).

         ii)      Otherwise, let NXTi, 1 (one) ≤ i ≤ RTN, be the ordinal number of the row of RSi that would be
                  retrieved if the following SQL-statement were executed:
                  FETCH NEXT FROM FRCNi
                  INTO...

    f) Let TOTi, 1 (one) ≤ i ≤ RTN, be the original cardinality of RSi when established by the opening of FRCi.

    g) Let RRS be the ordered set of returned result sets RRSi, 1 (one) ≤ i ≤ RTN, comprising the rows of RSi
         at ordinal positions ROWi,j, NXTi ≤ j ≤ TOTi.

    h) A completion condition is raised: warning — dynamic result sets returned.

    i)   RSi, 1 (one) ≤ i ≤ RTN, is returned to INV.

11) Prepare CSC to become the current SQL-session context:
    a) Set the value of the current constraint mode for each integrity constraint in CSC to the value of the
       current constraint mode for each integrity constraint in RSC.
    b) Set the value of the current transaction access mode in CSC to the value of the current transaction
       access mode in RSC.
    c) Set the value of the current transaction isolation level in CSC to the value of the current transaction
       isolation level in RSC.
    d) Set the value of the current transaction condition area limit in CSC to the value of the current transaction
       condition area limit CAL in RSC.
    e) For each occupied condition area CA in the first diagnostics area of RSC, if the value of
       RETURNED_SQLSTATE in CA does not represent successful completion, then
         Case:




©ISO/IEC 2003 – All rights reserved                                             Additional common elements 495
ISO/IEC 9075-2:2003 (E)
10.4 <routine invocation>



        i)      If the number of occupied condition areas in the first diagnostics area DA1 in CSC is less than
                CAL, then CA is copied to the first vacant condition area in DA1.
                NOTE 224 — This causes the first vacant condition area in DA1 to become occupied.

        ii)     Otherwise, the value of MORE in the statement information area of DA1 is set to 'Y'.
    f) Replace the identities of all instances of global temporary tables in CSC with the identities of the
       instances of global temporary tables in RSC.
    g) Remove the top cell from the authorization stack of RSC and set the authorization stack of CSC to a
       copy of the authorization stack of RSC.
        NOTE 225 — The copying of RSC's authorization stack into CSC is necessary in order to carry back any change in the SQL-
        session user identifier.

12) If R is an SQL-invoked function or if R is an SQL-invoked procedure and the descriptor of R includes an
    indication that a new savepoint level is to be established when R is invoked, then the current savepoint
    level is destroyed.
13) CSC becomes the current SQL-session context.


Conformance Rules
1) Without Feature S023, “Basic structured types”, conforming SQL language shall not contain a <generalized
   expression>.
2) Without Feature S201, “SQL-invoked routines on arrays”, conforming SQL language shall not contain an
   <SQL argument> whose declared type is an array type.
3) Without Feature S202, “SQL-invoked routines on multisets”, conforming SQL language shall not contain
   an <SQL argument> whose declared type is a multiset type.
4) Without Feature B033, “Untyped SQL-invoked function arguments”, conforming SQL language shall not
   contain a <routine invocation> that is not simply contained in a <call statement> that simply contains an
   <SQL argument> that is a <dynamic parameter specification>.




496 Foundation (SQL/Foundation)                                                             ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                             10.5 <character set specification>



10.5 <character set specification>

Function
Identify a character set.


Format
<character set specification> ::=
    <standard character set name>
  | <implementation-defined character set name>
  | <user-defined character set name>

<standard character set name> ::= <character set name>

<implementation-defined character set name> ::= <character set name>

<user-defined character set name> ::= <character set name>


Syntax Rules
1) The <standard character set name>s and <implementation-defined character set name>s that are supported
   are implementation-defined.
2) A character set identified by a <standard character set name>, or by an <implementation-defined character
   set name> has associated with it a privilege descriptor that was effectively defined by the <grant statement>
        GRANT USAGE ON CHARACTER SET CS TO PUBLIC
    where CS is the <character set name> contained in the <character set specification>. The grantor of the
    privilege descriptor is set to the special grantor value “_SYSTEM”.
3) The <standard character set name>s shall include SQL_CHARACTER and those character sets specified
   in Subclause 4.2.7, “Character sets”, as defined by this and other standards.
4) The <implementation-defined character set name>s shall include SQL_TEXT and SQL_IDENTIFIER.
5) Let C be the <character set name> contained in the <character set specification>. The schema identified
   by the explicit or implicit qualifier of the <character set name> shall include the descriptor of C.
6) If a <character set specification> is not contained in a <schema definition>, then the <character set name>
   immediately contained in the <character set definition> shall contain an explicit <schema name> that is
   not equivalent to INFORMATION_SCHEMA.


Access Rules
1) Case:
    a) If <character set specification> is contained, without an intervening <SQL routine spec> that specifies
       SQL SECURITY INVOKER, in an <SQL schema statement>, then the applicable privileges of the
       <authorization identifier> that owns the containing schema shall include USAGE on C.


©ISO/IEC 2003 – All rights reserved                                          Additional common elements 497
ISO/IEC 9075-2:2003 (E)
10.5 <character set specification>



    b) Otherwise, the current privileges shall include USAGE on C.
    NOTE 226 — “applicable privileges” and “current privileges” are defined in Subclause 12.3, “<privileges>”.


General Rules
1) A <character set specification> identifies a character set. Let the identified character set be CS.
2) A <standard character set name> specifies the name of a character set that is defined by a national or
   international standard. The character repertoire of CS is defined by the standard defining the character set
   identified by that <standard character set name>. The default collation of the character set is defined by
   the order of the characters in the standard and has the PAD SPACE characteristic.
3) An <implementation-defined character set name> specifies the name of a character set that is implementation-
   defined. The character repertoire of CS is implementation-defined. The default collation of the character
   set and whether the collation has the NO PAD characteristic or the PAD SPACE characteristic is implemen-
   tation-defined.
4) A <user-defined character set name> identifies a character set whose descriptor is included in some schema
   whose <schema name> is not equivalent to INFORMATION_SCHEMA.
    NOTE 227 — The default collation of the character set is defined as in Subclause 11.31, “<character set definition>”.

5) There is a character set descriptor for every character set that can be specified by a <character set specifi-
   cation>.


Conformance Rules
1) Without Feature F461, “Named character sets”, conforming SQL language shall not contain a <character
   set specification>.




498 Foundation (SQL/Foundation)                                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                              10.6 <specific routine designator>



10.6 <specific routine designator>

Function
Specify an SQL-invoked routine.


Format
<specific routine designator> ::=
    SPECIFIC <routine type> <specific name>
  | <routine type> <member name> [ FOR <schema-resolved user-defined type name> ]

<routine type> ::=
    ROUTINE
  | FUNCTION
  | PROCEDURE
  | [ INSTANCE | STATIC | CONSTRUCTOR ] METHOD

<member name> ::= <member name alternatives> [ <data type list> ]

<member name alternatives> ::=
    <schema qualified routine name>
  | <method name>

<data type list> ::=
    <left paren> [ <data type> [ { <comma> <data type> }... ] ] <right paren>


Syntax Rules
1) If a <specific name> SN is specified, then the <specific routine designator> shall identify an SQL-invoked
   routine whose <specific name> is SN.
2) If <routine type> specifies METHOD and none of INSTANCE, STATIC, or CONSTRUCTOR is specified,
   then INSTANCE is implicit.
3) If a <member name> MN is specified, then:
    a) If <schema-resolved user-defined type name> is specified, then <routine type> shall specify METHOD.
       If METHOD is specified, then <schema-resolved user-defined type name> shall be specified.
    b) Case:
         i)       If <routine type> specifies METHOD, then <method name> shall be specified. Let SCN be the
                  implicit or explicit <schema name> of <schema-resolved user-defined type name>, let METH
                  be the <method name>, and let RN be SCN.METH.
         ii)      Otherwise, <schema qualified routine name> shall be specified. Let RN be the <schema qualified
                  routine name> of MN and let SCN be the <schema name> of MN.
    c) Case:
         i)       If MN contains a <data type list>, then:



©ISO/IEC 2003 – All rights reserved                                           Additional common elements 499
ISO/IEC 9075-2:2003 (E)
10.6 <specific routine designator>



               1) If <routine type> specifies FUNCTION, then there shall be exactly one SQL-invoked regular
                  function in the schema identified by SCN whose <schema qualified routine name> is RN
                  such that for all i the Syntax Rules of Subclause 9.16, “Data type identity”, when applied
                  with the declared type of its i-th SQL parameter and the i-th <data type> in the <data type
                  list> of MN, are satisfied. The <specific routine designator> identifies that SQL-invoked
                  function.
               2) If <routine type> specifies PROCEDURE, then there shall be exactly one SQL-invoked
                  procedure in the schema identified by SCN whose <schema qualified routine name> is RN
                  such that for all i the Syntax Rules of Subclause 9.16, “Data type identity”, when applied
                  with the declared type of its i-th SQL parameter and the i-th <data type> in the <data type
                  list> of MN, are satisfied. The <specific routine designator> identifies that SQL-invoked
                  procedure.
               3) If <routine type> specifies METHOD, then
                   Case:
                   A) If STATIC is specified, then there shall be exactly one static SQL-invoked method of
                      the type identified by <schema-resolved user-defined type name> whose <method name>
                      is METH, such that for all i the Syntax Rules of Subclause 9.16, “Data type identity”,
                      when applied with the declared data type of its i-th SQL parameter and the i-th <data
                      type> in the <data type list> of MN, are satisfied. The <specific routine designator>
                      identifies that static SQL-invoked method.
                   B) If CONSTRUCTOR is specified, then there shall be exactly one SQL-invoked constructor
                      method of the type identified by <schema-resolved user-defined type name> whose
                      <method name> is METH, such that for all i the Syntax Rules of Subclause 9.16, “Data
                      type identity”, when applied with the declared data type of its i-th SQL parameter in
                      the unaugmented <SQL parameter declaration list> amd the i-th <data type> in the <data
                      type list> of MN, are satisfied. The <specific routine designator> identifies that SQL-
                      invoked constructor method.
                   C) Otherwise, there shall be exactly one instance SQL-invoked method of the type identified
                      by <schema-resolved user-defined type name> whose <method name> is METH, such
                      that for all i the Syntax Rules of Subclause 9.16, “Data type identity”, when applied
                      with the declared data type of its i-th SQL parameter in the unaugmented <SQL
                      parameter declaration list> and the i-th <data type> in the <data type list> of MN, are
                      satisfied. The <specific routine designator> identifies that instance SQL-invoked method.
               4) If <routine type> specifies ROUTINE, then there shall be exactly one SQL-invoked routine
                  in the schema identified by SCN whose <schema qualified routine name> is RN such that
                  for all i the Syntax Rules of Subclause 9.16, “Data type identity”, when applied with the
                  declared type of its i-th SQL parameter and the i-th <data type> in the <data type list> of
                  MN, are satisfied. The <specific routine designator> identifies that SQL-invoked routine.
        ii)    Otherwise:
               1) If <routine type> specifies FUNCTION, then there shall be exactly one SQL-invoked
                  function in the schema identified by SCN whose <schema qualified routine name> is RN.
                  The <specific routine designator> identifies that SQL-invoked function.




500 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                              10.6 <specific routine designator>



                  2) If <routine type> specifies PROCEDURE, then there shall be exactly one SQL-invoked
                     procedure in the schema identified by SCN whose <schema qualified routine name> is RN.
                     The <specific routine designator> identifies that SQL-invoked procedure.
                  3) If <routine type> specifies METHOD, then
                      Case:
                      A) If STATIC is specified, then there shall be exactly one static SQL-invoked method of
                         the user-defined type identified by <schema-resolved user-defined type name> whose
                         <method name> is METH. The <specific routine designator> identifies that static SQL-
                         invoked method.
                      B) If CONSTRUCTOR is specified, then there shall be exactly one SQL-invoked constructor
                         method of the user-defined type identified by <schema-resolved user-defined type name>
                         whose <method name> is METH. The <specific routine designator> identifies that SQL-
                         invoked constructor method.
                      C) Otherwise, there shall be exactly one instance SQL-invoked method of the user-defined
                         type identified by <schema-resolved user-defined type name> whose <method name>
                         is METH. The <specific routine designator> identifies that instance SQL-invoked method.
                  4) If <routine type> specifies ROUTINE, then there shall be exactly one SQL-invoked routine
                     in the schema identified by SCN whose <schema qualified routine name> is RN. The <specific
                     routine designator> identifies that SQL-invoked routine.
4) If FUNCTION is specified, then the SQL-invoked routine that is identified shall be an SQL-invoked regular
   function. If PROCEDURE is specified, then the SQL-invoked routine that is identified shall be an SQL-
   invoked procedure. If STATIC METHOD is specified, then the SQL-invoked routine that is identified shall
   be a static SQL-invoked method. If CONSTRUCTOR METHOD is specified, then the SQL-invoked routine
   shall be an SQL-invoked constructor method. If INSTANCE METHOD is specified or implicit, then the
   SQL-invoked routine shall be an instance SQL-invoked method. If ROUTINE is specified, then the SQL-
   invoked routine that is identified is either an SQL-invoked function or an SQL-invoked procedure.


Access Rules
    None.


General Rules
    None.


Conformance Rules
1) Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain a <specific
   routine designator> that contains a <routine type> that immediately contains METHOD.




©ISO/IEC 2003 – All rights reserved                                           Additional common elements 501
ISO/IEC 9075-2:2003 (E)
10.7 <collate clause>



10.7 <collate clause>

Function
Specify a default collation.


Format
<collate clause> ::= COLLATE <collation name>


Syntax Rules
1) Let C be the <collation name> contained in the <collate clause>. The schema identified by the explicit or
   implicit qualifier of the <collation name> shall include the descriptor of C.


Access Rules
1) Case:
    a) If <collate clause> is contained, without an intervening <SQL routine spec> that specifies SQL
       SECURITY INVOKER, in an <SQL schema statement>, then the applicable privileges of the
       <authorization identifier> that owns the containing schema shall include USAGE on C.
    b) Otherwise, the current privileges shall include USAGE on C.
    NOTE 228 — “applicable privileges” and “current privileges” are defined in Subclause 12.3, “<privileges>”.


General Rules
    None.


Conformance Rules
1) Without Feature F690, “Collation support”, conforming SQL language shall not contain a <collate clause>.




502 Foundation (SQL/Foundation)                                                               ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                             10.8 <constraint name definition> and <constraint characteristics>



10.8 <constraint name definition> and <constraint characteristics>

Function
Specify the name of a constraint and its characteristics.


Format
<constraint name definition> ::= CONSTRAINT <constraint name>

<constraint characteristics> ::=
    <constraint check time> [ [ NOT ] DEFERRABLE ]
  | [ NOT ] DEFERRABLE [ <constraint check time> ]

<constraint check time> ::=
    INITIALLY DEFERRED
  | INITIALLY IMMEDIATE


Syntax Rules
1) If a <constraint name definition> is contained in a <schema definition>, and if the <constraint name>
   contains a <schema name>, then that <schema name> shall be equivalent to the specified or implicit <schema
   name> of the containing <schema definition>.
2) The <qualified identifier> of <constraint name> shall not be equivalent to the <qualified identifier> of the
   <constraint name> of any other constraint defined in the same schema.
3) If <constraint check time> is not specified, then INITIALLY IMMEDIATE is implicit.
4) Case:
    a) If INITIALLY DEFERRED is specified, then:
         i)       NOT DEFERRABLE shall not be specified.
         ii)      If DEFERRABLE is not specified, then DEFERRABLE is implicit.
    b) If INITIALLY IMMEDIATE is specified or implicit and neither DEFERRABLE nor NOT
       DEFERRABLE is specified, then NOT DEFERRABLE is implicit.


Access Rules
    None.


General Rules
1) A <constraint name> identifies a constraint. Let the identified constraint be C.
2) If NOT DEFERRABLE is specified, then C is not deferrable; otherwise it is deferrable.



©ISO/IEC 2003 – All rights reserved                                          Additional common elements 503
ISO/IEC 9075-2:2003 (E)
10.8 <constraint name definition> and <constraint characteristics>



3) If <constraint check time> is INITIALLY DEFERRED, then the initial constraint mode for C is deferred;
   otherwise, the initial constraint mode for C is immediate.
4) If, on completion of any SQL-statement, the constraint mode of any constraint is immediate, then that
   constraint is effectively checked.
    NOTE 229 — This includes the cases where SQL-statement is a <set constraints mode statement>, a <commit statement>, or the
    statement that causes a constraint with a constraint mode of initially immediate to be created.

5) When a constraint is effectively checked, if the constraint is not satisfied, then an exception condition is
   raised: integrity constraint violation. If this exception condition is raised as a result of executing a <commit
   statement>, then SQLSTATE is not set to integrity constraint violation, but is set to transaction rollback
   — integrity constraint violation (see the General Rules of Subclause 16.6, “<commit statement>”).


Conformance Rules
1) Without Feature F721, “Deferrable constraints”, conforming SQL language shall not contain a <constraint
   characteristics>.
    NOTE 230 — This means that INITIALLY IMMEDIATE NOT DEFERRABLE is implicit.

2) Without Feature F491, “Constraint management”, conforming SQL language shall not contain a <constraint
   name definition>.




504 Foundation (SQL/Foundation)                                                             ©ISO/IEC 2003 – All rights reserved
                                                                         ISO/IEC 9075-2:2003 (E)
                                                                       10.9 <aggregate function>



10.9 <aggregate function>

Function
Specify a value computed from a collection of rows.


Format
<aggregate function> ::=
    COUNT <left paren> <asterisk> <right paren> [ <filter clause> ]
  | <general set function> [ <filter clause> ]
  | <binary set function> [ <filter clause> ]
  | <ordered set function> [ <filter clause> ]

<general set function> ::=
    <set function type> <left paren> [ <set quantifier> ]
    <value expression> <right paren>

<set function type> ::= <computational operation>

<computational operation> ::=
    AVG
  | MAX
  | MIN
  | SUM
  | EVERY
  | ANY
  | SOME
  | COUNT
  | STDDEV_POP
  | STDDEV_SAMP
  | VAR_SAMP
  | VAR_POP
  | COLLECT
  | FUSION
  | INTERSECTION

<set quantifier> ::=
    DISTINCT
  | ALL

<filter clause> ::=
    FILTER <left paren> WHERE <search condition> <right paren>

<binary set function> ::=
    <binary set function type> <left paren> <dependent variable expression> <comma>
    <independent variable expression> <right paren>

<binary set function type> ::=
    COVAR_POP
  | COVAR_SAMP
  | CORR
  | REGR_SLOPE
  | REGR_INTERCEPT



©ISO/IEC 2003 – All rights reserved                              Additional common elements 505
ISO/IEC 9075-2:2003 (E)
10.9 <aggregate function>



  |   REGR_COUNT
  |   REGR_R2
  |   REGR_AVGX
  |   REGR_AVGY
  |   REGR_SXX
  |   REGR_SYY
  |   REGR_SXY

<dependent variable expression> ::= <numeric value expression>

<independent variable expression> ::= <numeric value expression>

<ordered set function> ::=
    <hypothetical set function>
  | <inverse distribution function>

<hypothetical set function> ::=
    <rank function type> <left paren>
    <hypothetical set function value expression list> <right paren>
    <within group specification>

<within group specification> ::=
    WITHIN GROUP <left paren> ORDER BY <sort specification list> <right paren>

<hypothetical set function value expression list> ::=
    <value expression> [ { <comma> <value expression> }... ]

<inverse distribution function> ::=
    <inverse distribution function type> <left paren>
    <inverse distribution function argument> <right paren>
    <within group specification>

<inverse distribution function argument> ::= <numeric value expression>

<inverse distribution function type> ::=
    PERCENTILE_CONT
  | PERCENTILE_DISC


Syntax Rules
1) Let AF be the <aggregate function>.
2) If STDDEV_POP, STDDEV_SAMP, VAR_POP, or VAR_SAMP is specified, then <set quantifier> shall
   not be specified.
3) If <general set function> is specified and <set quantifier> is not specified, then ALL is implicit.
4) The argument source of an <aggregate function> is
      Case:
      a) If AF is immediately contained in a <set function specification>, then a table or group of a grouped
         table as specified in Subclause 7.10, “<having clause>”, and Subclause 7.12, “<query specification>”.




506 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)
                                                                                         10.9 <aggregate function>



    b) Otherwise, the collection of rows in the current row's window frame defined by the window structure
       descriptor identified by the <window function> that simply contains AF, as defined in Subclause 7.11,
       “<window clause>”.
5) Let T be the argument source of AF.
6) If COUNT is specified, then the declared type of the result is an implementation-defined exact numeric
   type scale of 0 (zero).
7) If <general set function> is specified, then:
    a) The <value expression> VE shall not contain a <window function>.
    b) Let DT be the declared type of the <value expression>.
    c) If AF specifies a <general set function> whose <set quantifier> is DISTINCT, then VE is an operand
       of a grouping operation. The Syntax Rules of Subclause 9.10, “Grouping operations”, apply.
    d) If AF specifies a <set function type> that is MAX or MIN, then VE is an operand of an ordering oper-
       ation. The Syntax Rules of Subclause 9.12, “Ordering operations”, apply.
    e) If EVERY, ANY, or SOME is specified, then DT shall be boolean and the declared type of the result
       is boolean.
    f) If MAX or MIN is specified, then the declared type of the result is DT.
    g) If SUM or AVG is specified, then:
         i)       DT shall be a numeric type or an interval type.
         ii)      If SUM is specified and DT is exact numeric with scale S, then the declared type of the result
                  is an implementation-defined exact numeric type with scale S.
         iii)     If AVG is specified and DT is exact numeric, then the declared type of the result is an implemen-
                  tation-defined exact numeric type with precision not less than the precision of DT and scale not
                  less than the scale of DT.
         iv)      If DT is approximate numeric, then the declared type of the result is an implementation-defined
                  approximate numeric with precision not less than the precision of DT.
         v)       If DT is interval, then the declared type of the result is interval with the same precision as DT.
    h) If VAR_POP or VAR_SAMP is specified, then the declared type of the result is an implementation-
       defined approximate numeric type. If DT is an approximate numeric type, then the precision of the
       result is not less than the precision of DT.
    i)   STDDEV_POP(X) is equivalent to SQRT(VAR_POP(X)).
    j)   STDDEV_SAMP(X) is equivalent to SQRT(VAR_SAMP(X)).
    k) If COLLECT is specified, then the declared type of the result is DT MULTISET.
    l)   COLLECT (X) is equivalent to FUSION (MULTISET [X]).
    m) If FUSION is specified, then DT shall be a multiset type, and DISTINCT shall not be specified. The
       declared type of the result is DT.



©ISO/IEC 2003 – All rights reserved                                              Additional common elements 507
ISO/IEC 9075-2:2003 (E)
10.9 <aggregate function>



    n) If INTERSECTION is specified, then DT shall be a multiset type, and DISTINCT shall not be specified.
       VE is a multiset operand of a multiset element grouping operation, and the Syntax Rules of
       Subclause 9.11, “Multiset element grouping operations”, apply. The declared type of the result is DT.
8) A <filter clause> shall not contain a <subquery>, a <window function>, or an outer reference.
9) If <binary set function> is specified, then:
    a) The <dependent variable expression> DVE and the <independent variable expression> IVE shall not
       contain a <window function>.
    b) Let DTDVE be the declared type of DVE and let DTIVE be the declared type of IVE.
    c) Case:
        i)      The declared type of REGR_COUNT is an implementation-defined exact numeric type with
                scale of 0 (zero).
        ii)     Otherwise, the declared type of the result is an implementation-defined approximate numeric
                type. If DTDVE is an approximate numeric type, then the precision of the result is not less than
                the precision of DTDVE. If DTIVE is an approximate numeric type, then the precision of the
                result is not less than the precision of DTIVE.
10) If <hypothetical set function> is specified, then:
    a) The <hypothetical set function> shall not contain a <window function>, a <set function specification>,
       or a <subquery>.
    b) The number of <value expression>s simply contained in <hypothetical set function value expression
       list> shall be the same as the number of <sort key>s simply contained in the <sort specification list>.
    c) For each <value expression> HSFVE simply contained in the <hypothetical set function value expression
       list>, let SK be the corresponding <sort key> simply contained in the <sort specification list>.
        Case:
        i)      If the declared type of HSFVE is a character string type, then the declared type of SK shall be a
                character string type with the same character repertoire as that of HSFVE. The collation is
                determined by applying Subclause 9.13, “Collation determination”, with operands HSFVE and
                SK.
        ii)     Otherwise the declared types of HSFVE and SK shall be compatible.
    d) Case:
        i)      If RANK or DENSE_RANK is specified, then the declared type of the result is exact numeric
                with implementation-defined precision and with scale 0 (zero).
        ii)     Otherwise, the declared type of the result is approximate numeric with implemenation-defined
                precision.
11) If <inverse distribution function> is specified, then:
    a) The <within group specification> shall contain a single <sort specification>.




508 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                                     10.9 <aggregate function>



    b) The <inverse distribution function> shall not contain a <window function>, a <set function specifica-
       tion>, or a <subquery>.
    c) Let DT be the declared type of the <value expression> simply contained in the <sort specification>.
    d) If PERCENTILE_CONT is specified, then DT shall be numeric or interval.
    e) The declared type of the result is
         Case:
         i)       If DT is numeric, then approximate numeric with implementation-defined precision.
         ii)      If DT is interval, then DT.


Access Rules
    None.


General Rules
1) If, during the computation of the result of AF, an intermediate result is not representable in the declared
   type of the site that contains that intermediate result, then
    Case:
    a) If the most specific type of the result of AF is an interval type, then an exception condition is raised:
       data exception — interval value out of range.
    b) If the most specific type of the result of AF is a multiset type, then an exception condition is raised:
       data exception — multiset value overflow.
    c) Otherwise, an exception condition is raised: data exception — numeric value out of range.
2) Case:
    a) If <filter clause> is specified, then the <search condition> is applied to each row of T. Let T1 be the
       collection of rows of T for which the result of the <search condition> is True.
    b) Otherwise, let T1 be T.
3) If COUNT(*) is specified, then the result is the cardinality of T1.
4) If <general set function> is specified, then:
    a) Let TX be the single-column table that is the result of applying the <value expression> to each row of
       T1 and eliminating null values. If one or more null values are eliminated, then a completion condition
       is raised: warning — null value eliminated in set function.
    b) Case:
         i)       If DISTINCT is specified, then let TXA be the result of eliminating redundant duplicate values
                  from TX, using the comparison rules specified in Subclause 8.2, “<comparison predicate>”, to
                  identify the redundant duplicate values.



©ISO/IEC 2003 – All rights reserved                                           Additional common elements 509
ISO/IEC 9075-2:2003 (E)
10.9 <aggregate function>



       ii)     Otherwise, let TXA be TX.
   c) Let N be the cardinality of TXA.
   d) Case:
       i)      If COUNT is specified, then the result is N.
       ii)     If TXA is empty, then the result is the null value.
       iii)    If AVG is specified, then the result is the average of the values in TXA.
       iv)     If MAX or MIN is specified, then the result is respectively the maximum or minimum value in
               TXA. These results are determined using the comparison rules specified in Subclause 8.2,
               “<comparison predicate>”. If DT is a user-defined type and the comparison of two values in
               TXA results in Unknown, then the maximum or minimum of TXA is implementation-dependent.
       v)      If SUM is specified, then the result is the sum of the values in TXA. If the sum is not within the
               range of the declared type of the result, then an exception condition is raised: data exception —
               numeric value out of range.
       vi)     If EVERY is specified, then
               Case:
               1) If the value of some element of TXA is False, then the result is False.
               2) Otherwise, the result is True.
       vii)    If ANY or SOME is specified, then
               Case:
               1) If the value of some element of TXA is True, then the result is True.
               2) Otherwise, the result is False.
       viii)   If VAR_POP or VAR_SAMP is specified, then let S1 be the sum of values in the column of
               TXA, and S2 be the sum of the squares of the values in the column of TXA.
               1) If VAR_POP is specified, then the result is (S2-S1*S1/N)/N.
               2) If VAR_SAMP is specified, then
                   Case:
                   A) If N is 1 (one), then the result is the null value.
                   B) Otherwise, the result is (S2-S1*S1/N)/(N-1)
       ix)     If FUSION is specified, then the result is the multiset M such that for each value V in the element
               type of DT, including the null value, the number of elements of M that are identical to V is the
               sum of the number of identical copies of V in the multisets that are the values of the column in
               each row of TXA.
       x)      If INTERSECTION is specified, then the result is a multiset M such that for each value V in the
               element type of DT, including the null value, the number of duplicates of V in M is the minimum



510 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                                                       10.9 <aggregate function>



                  of the number of duplicates of V in the multisets that are the values of the column in each row
                  of TXA.
                  NOTE 231 — This rule says “the result is a multiset” rather than “the result is the multiset” because the precise
                  duplicate values are not specified. Thus this calculation is non-deterministic for certain element types, namely those
                  based on character string, datetime with time zone and user-defined types.

5) If <binary set function type> is specified, then:
    a) Let TXA be the two-column table that is the result of applying the <dependent variable expression>
       and the <independent variable expression> to each row of T1 and eliminating each row in which either
       <dependent variable expression> or <independent variable expression> is the null value. If one or more
       null values are eliminated, then a completion condition is raised: warning — null value eliminated in
       set function.
    b) Let N be the cardinality of TXA, let SUMX be the sum of the column of values of <independent variable
       expression>, let SUMY be the sum of the column of values of <dependent variable expression>, let
       SUMX2 be the sum of the squares of values in the <independent variable expression> column, let
       SUMY2 be the sum of the squares of values in the <dependent variable expression> column, and let
       SUMXY be the sum of the row-wise products of the value in the <independent variable expression>
       column times the value in the <dependent variable expression> column.
    c) Case:
         i)       If REGR_COUNT is specified, then the result is N.
         ii)      If N is 0 (zero), then the result is the null value.
         iii)     If REGR_SXX is specified, then the result is (SUMX2-SUMX*SUMX/N).
         iv)      If REGR_SYY is specified, then the result is (SUMY2-SUMY*SUMY/N).
         v)       If REGR_SXY is specified, then the result is (SUMXY-SUMX*SUMY/N).
         vi)      If REGR_AVGX is specified, then the result is SUMX/N.
         vii)     If REGR_AVGY is specified, then the result is SUMY/N.
         viii)    If COVAR_POP is specified, then the result is (SUMXY-SUMX*SUMY/N)/N.
         ix)      If COVAR_SAMP is specified, then
                  Case:
                  1) If N is 1 (one), then the result is the null value.
                  2) Otherwise, the result is (SUMXY-SUMX*SUMY/N)/(N-1)
         x)       If CORR is specified, then
                  Case:
                  1) If N*SUMX2 equals SUMX*SUMX, then the result is the null value.
                       NOTE 232 — In this case, all remaining values of <independent variable expression> are equal, and consequently
                       the <independent variable expression> does not correlate with the <dependent variable expression>.

                  2) If N*SUMY2 equals SUMY*SUMY, then the result is the null value.



©ISO/IEC 2003 – All rights reserved                                                           Additional common elements 511
ISO/IEC 9075-2:2003 (E)
10.9 <aggregate function>



                    NOTE 233 — In this case, all remaining values of <dependent variable expression> are equal, and consequently
                    the <dependent variable expression> does not correlate with the <independent variable expression>.

                3) Otherwise, the result is SQRT(POWER(N*SUMXY-SUMX*SUMY,2) /
                   ((N*SUMX2-SUMX*SUMX)*(N*SUMY2-SUMY*SUMY))). If the exponent of the
                   approximate mathematical result of the operation is not within the implementation-defined
                   exponent range for the result data type, then the result is the null value.
        xi)     If REGR_R2 is specified, then
                Case:
                1) If N*SUMX2 equals SUMX*SUMX, then the result is the null value.
                    NOTE 234 — In this case, all remaining values of <independent variable expression> are equal, and consequently
                    the least-squares fit line would be vertical, or, if N = 1 (one), there is no uniquely determined least-squares-fit
                    line.

                2) If N*SUMY2 equals SUMY*SUMY, then the result is 1 (one).
                    NOTE 235 — In this case, all remaining values of <dependent variable expression> are equal, and consequently
                    the least-squares fit line is horizontal.

                3) Otherwise, the result is POWER(N*SUMXY-SUMX*SUMY,2) /
                   ((N*SUMX2-SUMX*SUMX) * (N*SUMY2-SUMY*SUMY)). If the exponent of the
                   approximate mathematical result of the operation is not within the implementation-defined
                   exponent range for the result data type, then the result is the null value.
        xii)    If REGR_SLOPE(Y, X) is specified, then
                Case:
                1) If N*SUMX2 equals SUMX*SUMX, then the result is the null value.
                    NOTE 236 — In this case, all remaining values of <independent variable expression> are equal, and consequently
                    the least-squares fit line would be vertical, or, if N = 1 (one), then there is no uniquely determined least-squares-
                    fit line.

                2) Otherwise, the result is (N*SUMXY-SUMX*SUMY) / (N*SUMX2-SUMX*SUMX). If
                   the exponent of the approximate mathematical result of the operation is not within the
                   implementation-defined exponent range for the result data type, then the result is the null
                   value.
        xiii)   If REGR_INTERCEPT is specified, then
                Case:
                1) If N*SUMX2 equals SUMX*SUMX, then the result is the null value.
                    NOTE 237 — In this caes, all remaining values of <independent variable expression> are equal, and consequently
                    the least-squares fit line would be vertical, or, if N = 1 (one), then there is no uniquely determined least-squares-
                    fit line.

                2) Otherwise, the result is (SUMY*SUMX2-SUMX*SUMXY) / (N*SUMX2-SUMX*SUMX).
                   If the exponent of the approximate mathematical result of the operation is not within the
                   implementation-defined exponent range for the result data type, then the result is the null
                   value.
6) If <hypothetical set function> is specified, then


512 Foundation (SQL/Foundation)                                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                      10.9 <aggregate function>



    a) Let WIFT be the <rank function type>.
    b) Let TNAME be an implementation-dependent name for T1.
    c) Let K be the number of <value expression>s simply contained in <hypothetical set function value
       expression list>.
    d) Let VE1, ..., VEK be the <value expression>s simply contained in the <hypothetical set function value
       expression list>.
    e) Let WIFTVAL, MARKER and CN1, ..., CNK be distinct implementation-dependent column names.

    f) Let SP1, ..., SPK be the <sort specification>s simply contained in the <sort specification list>. For each
       i, let WSPi be the <sort specification> obtained from SPi by replacing the <sort key> with CNi.

    g) The result is the result of the <scalar subquery>
              ( SELECT WIFTVAL
               FROM ( SELECT MARKER, WIFT() OVER
                         ( ORDER BY WSP1, ..., WSPK )
                      FROM ( SELECT 0, SK1, ..., SKK
                             FROM TNAME
                               UNION ALL
                                  VALUES (1, VE1, ..., VEK) )
                               AS TXNAME (MARKER, CN1, ..., CNK )
                    ) AS TEMPTABLE (MARKER, WIFTVAL)
               WHERE MARKER = 1 )


7) If <inverse distribution function> is specified, then
    a) Let NVE be the value of the <inverse distribution function argument>.
    b) If NVE is the null value, then the result is the null value.
    c) If NVE is less than 0 (zero) or greater than 1 (one), then an exception condition is raised: data exception
       — numeric value out of range.
    d) Let TXA be the single-column table that is the result of applying the <value expression> simply contained
       in the <sort specification> to each row of T1 and eliminating null values. If one or more null values
       are eliminated, then a completion condition is raised: warning — null value eliminated in set function.
       TXA is ordered by the <sort specification> as specified in the General Rules of Subclause 10.10, “<sort
       specification list>”.
    e) Let TXANAME be an implementation-dependent name for TXA.
    f) Let TXCOLNAME be an implementation-dependent column name for the column of TXA.
    g) Let WSP be obtained from the <sort specification> by replacing the <sort key> with TXCOLNAME.
    h) Case:
         i)       If PERCENTILE_CONT is specified, then:
                  1) Let ROW0 be the greatest exact numeric value with scale 0 (zero) that is less than or equal
                     to NVE*(N–1). Let ROWLIT0 be a <literal> representing ROW0.


©ISO/IEC 2003 – All rights reserved                                            Additional common elements 513
ISO/IEC 9075-2:2003 (E)
10.9 <aggregate function>



              2) Let ROW1 be the least exact numeric value with scale 0 (zero) that is greater than or equal
                 to NVE*(N–1). Let ROWLIT1 be a <literal> representing ROW1.
              3) Let FACTOR be an <approximate numeric literal> representing NVE*(N–1)–ROW0.
              4) The result is the result of the <scalar subquery>
                      ( WITH TEMPTABLE(X, Y) AS
                            ( SELECT ROW_NUMBER()
                                       OVER (ORDER BY WSP) - 1,
                                     TXCOLNAME
                              FROM TXANAME )
                     SELECT CAST ( T0.Y + FACTOR * (T1.Y - T0.Y) AS DT )
                     FROM TEMPTABLE T0, TEMPTABLE T1
                     WHERE T0.ROWNUMBER = ROWLIT0
                       AND T1.ROWNUMBER = ROWLIT1 )

                  NOTE 238 — Although ROW_NUMBER is nondeterministic, the values of T0.Y and T1.Y are determined by
                  this expression. Note that the only column of TXA is completely ordered by WSP. If NVE*(N–1) is a whole
                  number, then the rows selected from T0 and T1 are the same and the result is just T0.Y. Otherwise, the subquery
                  performs a linear interpolation between the two consecutive values whose row numbers in the ordered set, seen
                  as proportions of the whole, bound the argument of the PERCENTILE_CONT operator.

        ii)   If PERCENTILE_DISC is specified, then
              1) If the <ordering specification> simply contained in WSP is DESC, then let MAXORMIN be
                 MAX; otherwise let MAXORMIN be MIN.
              2) Let NVELIT be a <literal> representing the value of NVE.
              3) The result is the result of the <scalar subquery>
                      ( SELECT MAXORMIN (TXCOLNAME)
                       FROM ( SELECT TXCOLNAME,
                                     CUME_DIST() OVER (ORDER BY WSP)
                       FROM TXANAME ) AS TEMPTABLE (TXCOLNAME, CUMEDIST)
                       WHERE CUMEDIST >= NVELIT )



Conformance Rules
1) Without Feature T031, “BOOLEAN data type”, conforming SQL language shall not contain a <computational
   operation> that immediately contains EVERY, ANY, or SOME.
2) Without Feature F561, “Full value expressions”, or Feature F801, “Full set function”, conforming SQL
   language shall not contain a <general set function> that immediately contains DISTINCT and contains a
   <value expression> that is not a column reference.
3) Without Feature F441, “Extended set function support”, conforming SQL language shall not contain a
   <general set function> that contains a <computational operation> that immediately contains COUNT and
   does not contain a <set quantifier> that immediately contains DISTINCT.
4) Without Feature F441, “Extended set function support”, conforming SQL language shall not contain a
   <general set function> that does not contain a <set quantifier> that immediately contains DISTINCT and
   that contains a <value expression> that contains a column reference that does not reference a column of T.



514 Foundation (SQL/Foundation)                                                              ©ISO/IEC 2003 – All rights reserved
                                                                                                 ISO/IEC 9075-2:2003 (E)
                                                                                               10.9 <aggregate function>



5) Without Feature F441, “Extended set function support”, conforming SQL language shall not contain a
   <binary set function> that does not contain either a <dependent variable expression> or an <independent
   variable expression> that contains a column reference that references a column of T.
6) Without Feature F441, “Extended set function support”, conforming SQL language shall not contain a
   <value expression> simply contained in a <general set function> that contains a column reference that is
   an outer reference where the <value expression> is not a column reference.
7) Without Feature F441, “Extended set function support”, conforming SQL language shall not contain a
   <numeric value expression> simply contained in a <dependent variable expression> or an <independent
   variable expression> that contains a column reference that is an outer reference and in which the <numeric
   value expression> is not a column reference.
8) Without Feature F441, “Extended set function support”, conforming SQL language shall not contain a
   column reference contained in an <aggregate function> that contains a reference to a column derived from
   a <value expression> that generally contains an <aggregate function> SFS2 without an intervening <routine
   invocation>.
9) Without Feature T621, “Enhanced numeric functions”, conforming SQL language shall not contain a
   <computational operation> that immediately contains STDDEV_POP, STDDEV_SAMP, VAR_POP, or
   VAR_SAMP.
10) Without Feature T621, “Enhanced numeric functions”, conforming SQL language shall not contain a
    <binary set function type>.
11) Without Feature T612, “Advanced OLAP operations”, conforming SQL language shall not contain a
    <hypothetical set function> or an <inverse distribution function>.
12) Without Feature T612, “Advanced OLAP operations”, conforming SQL language shall not contain a <filter
    clause>.
13) Without Feature S271, “Basic multiset support”, conforming SQL language shall not contain a <computa-
    tional operation> that immediately contains COLLECT.
14) Without Feature S275, “Advanced multiset support”, conforming SQL language shall not contain a
    <computational operation> that immediately contains FUSION or INTERSECTION.
    NOTE 239 — If INTERSECTION is specified, then the Conformance Rules of Subclause 9.11, “Multiset element grouping
    operations”, also apply.

15) Without Feature T052, “MAX and MIN for row types”, conforming SQL language shall not contain a
    <computational operation> that immediately contains MAX or MIN in which the declared type of the
    <value expression> is a row type.
    NOTE 240 — If DISTINCT is specified, then the Conformance Rules of Subclause 9.10, “Grouping operations”, also apply. If
    MAX or MIN is specified, then the Conformance Rules of Subclause 9.12, “Ordering operations”, also apply.

16) Without Feature F442, “Mixed column references in set functions”, conforming SQL language shall not
    contain a <hypothetical set function value expression list> or a <sort specification list> that simply contains
    a <value expression> that contains more than one column reference, one of which is an outer reference.
17) Without Feature F442, “Mixed column references in set functions”, conforming SQL language shall not
    contain an <inverse distribution function> that contains an <inverse distribution function argument> or a
    <sort specification> that contains more than one column reference, one of which is an outer reference.




©ISO/IEC 2003 – All rights reserved                                                    Additional common elements 515
ISO/IEC 9075-2:2003 (E)
10.9 <aggregate function>



18) Without Feature F442, “Mixed column references in set functions”, conforming SQL language shall not
    contain an <aggregate function> that contains a <general set function> whose simply contained <value
    expression> contains more than one column reference, one of which is an outer reference.
19) Without Feature F442, “Mixed column references in set functions”, conforming SQL language shall not
    contain an <aggregate function> that contains a <binary set function> whose simply contained <dependent
    variable expression> or <independent variable expression> contains more than one column reference, one
    of which is an outer reference.




516 Foundation (SQL/Foundation)                                               ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                 10.10 <sort specification list>



10.10 <sort specification list>

Function
Specify a sort order.


Format
<sort specification list> ::=
    <sort specification> [ { <comma> <sort specification> }... ]

<sort specification> ::=
    <sort key> [ <ordering specification> ] [ <null ordering> ]

<sort key> ::= <value expression>

<ordering specification> ::=
    ASC
  | DESC

<null ordering> ::=
    NULLS FIRST
  | NULLS LAST


Syntax Rules
1) Let DT be the declared type of the <value expression> simply contained in the <sort key> contained in a
   <sort specification>.
2) Each <value expression> simply contained in the <sort key> contained in a <sort specification> is an
   operand of an ordering operation. The Syntax Rules of Subclause 9.12, “Ordering operations”, apply.
3) If <null ordering> is not specified, then an implementation-defined <null ordering> is implicit. The
   implementation-defined default for <null ordering> shall not depend on the context outside of <sort speci-
   fication list>.


Access Rules
    None.


General Rules
1) A <sort specification list> defines an ordering of rows, as follows:
    a) Let N be the number of <sort specification>s.

    b) Let Ki, 1 (one) ≤ i ≤ N, be the <sort key> contained in the i-th <sort specification>.




©ISO/IEC 2003 – All rights reserved                                          Additional common elements 517
ISO/IEC 9075-2:2003 (E)
10.10 <sort specification list>



    c) Each <sort specification> specifies the sort direction for the corresponding sort key Ki. If DESC is not
       specified in the i-th <sort specification>, then the sort direction for Ki is ascending and the applicable
       <comp op> is the <less than operator>. Otherwise, the sort direction for Ki is descending and the
       applicable <comp op> is the <greater than operator>.
    d) Let P be any row of the collection of rows to be ordered, and let Q be any other row of the same collec-
       tion of rows.
    e) Let PVi and QVi be the values of Ki in P and Q, respectively. The relative position of rows P and Q in
       the result is determined by comparing PVi and QVi according to the rules of Subclause 8.2, “<compar-
       ison predicate>” where the <comp op> is the applicable <comp op> for Ki, with the following special
       treatment of null values.
         Case:
         i)      If PVi and QVi are both null, then they are considered equal to each other.

         ii)     If PVi is null and QVi is not null, then

                 Case:
                 1) If NULLS FIRST is specified or implied, then PVi <comp op> QVi is considered to be True.

                 2) If NULLS LAST is specified or implied, then PVi <comp op> QVi is considered to be False.

         iii)    If PVi is not null and QVi is null, then

                 Case:
                 1) If NULLS FIRST is specified or implied, then PVi <comp op> QVi is considered to be False.

                 2) If NULLS LAST is specified or implied, then PVi <comp op> QVi is considered to be True.

    f) PVi is said to precede QVi if the value of the <comparison predicate> “PVi <comp op> QVi” is
       True for the applicable <comp op>.
    g) If PVi and QVi are not null and the result of “PVi <comp op> QVi” is Unknown, then the relative
       ordering of PVi and QVi is implementation-dependent.

    h) The relative position of row P is before row Q if PVn precedes QVn for some n, 1 (one) ≤ n ≤ N, and
       PVi is not distinct from QVi for all i < n.

    i)   Two rows that are not distinct with respect to the <sort specification>s are said to be peers of each
         other. The relative ordering of peers is implementation-dependent.


Conformance Rules
1) Without Feature T611, “Elementary OLAP operations”, conforming SQL language shall not contain a
   <null ordering>.
    NOTE 241 — The Conformance Rules of Subclause 9.12, “Ordering operations”, also apply.




518 Foundation (SQL/Foundation)                                                          ©ISO/IEC 2003 – All rights reserved
                                                                         ISO/IEC 9075-2:2003 (E)
                                                                        11.1 <schema definition>




11 Schema definition and manipulation


11.1 <schema definition>

Function
Define a schema.


Format
<schema definition> ::=
    CREATE SCHEMA <schema name clause>
    [ <schema character set or path> ]
    [ <schema element>... ]

<schema character set or path> ::=
    <schema character set specification>
  | <schema path specification>
  | <schema character set specification> <schema path specification>
  | <schema path specification> <schema character set specification>

<schema name clause> ::=
    <schema name>
  | AUTHORIZATION <schema authorization identifier>
  | <schema name> AUTHORIZATION <schema authorization identifier>

<schema authorization identifier> ::= <authorization identifier>

<schema character set specification> ::=
    DEFAULT CHARACTER SET <character set specification>

<schema path specification> ::= <path specification>

<schema element> ::=
    <table definition>
  | <view definition>
  | <domain definition>
  | <character set definition>
  | <collation definition>
  | <transliteration definition>
  | <assertion definition>
  | <trigger definition>
  | <user-defined type definition>
  | <user-defined cast definition>
  | <user-defined ordering definition>
  | <transform definition>
  | <schema routine>
  | <sequence generator definition>




©ISO/IEC 2003 – All rights reserved                       Schema definition and manipulation 519
ISO/IEC 9075-2:2003 (E)
11.1 <schema definition>



  | <grant statement>
  | <role definition>


Syntax Rules
1) If <schema name> is not specified, then a <schema name> equal to <schema authorization identifier> is
   implicit.
2) If AUTHORIZATION <schema authorization identifier> is not specified, then
    Case:
    a) If the <schema definition> is contained in an SQL-client module that has a <module authorization
       identifier> specified, then an <authorization identifier> equal to that <module authorization identifier>
       is implicit for the <schema definition>.
    b) Otherwise, an <authorization identifier> equal to the SQL-session user identifier is implicit.
3) The <unqualified schema name> of the explicit or implicit <schema name> shall not be equivalent to the
   <unqualified schema name> of the <schema name> of any other schema in the catalog identified by the
   <catalog name> of <schema name>.
4) If a <schema definition> is contained in an <externally-invoked procedure> in an <SQL-client module
   definition>, then the effective <schema authorization identifier> and <schema name> during processing
   of the <schema definition> are, respectively, the <schema authorization identifier> and <schema name>
   specified or implicit in the <schema definition>.
    NOTE 242 — Other SQL-statements executed in <externally-invoked procedure>s in the SQL-client module have the <module
    authorization identifier> and <schema name> specified or implicit for the SQL-client module.

5) If <schema character set specification> is not specified, then a <schema character set specification> that
   specifies an implementation-defined character set that contains at least every character that is in <SQL
   language character> is implicit.
6) If <schema path specification> is not specified, then a <schema path specification> containing an imple-
   mentation-defined <schema name list> that contains the <schema name> contained in <schema name
   clause> is implicit.
7) The explicit or implicit <catalog name> of each <schema name> contained in the <schema name list> of
   the <schema path specification> shall be equivalent to the <catalog name> of the <schema name> contained
   in the <schema name clause>.
8) The <schema name list> of the explicit or implicit <schema path specification> is used as the SQL-path
   of the schema. The SQL-path is used to effectively qualify unqualified <routine name>s that are immediately
   contained in <routine invocation>s that are contained in the <schema definition>.
    NOTE 243 — <routine name> is defined in Subclause 5.4, “Names and identifiers”.


Access Rules
1) The privileges necessary to execute the <schema definition> are implementation-defined.




520 Foundation (SQL/Foundation)                                                          ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                                        11.1 <schema definition>



General Rules
1) A <schema definition> creates an SQL-schema S in a catalog. S includes:
    a) A schema name that is equivalent to the explicit or implicit <schema name>.
    b) A schema authorization identifier that is equivalent to the explicit or implicit <authorization identifier>.
    c) A schema character set name that is equivalent to the explicit or implicit <schema character set speci-
       fication>.
    d) A schema SQL-path that is equivalent to the explicit or implicit <schema path specification>.
    e) The descriptor created by every <schema element> of the <schema definition>.
2) The owner of S is schema authorization identifier.
3) The explicit or implicit <character set specification> is used as the default character set used for all <column
   definition>s and <domain definition>s that do not specify an explicit character set.


Conformance Rules
1) Without Feature S071, “SQL paths in function and type name resolution”, conforming SQL language shall
   not contain a <schema path specification>.
2) Without Feature F461, “Named character sets”, conforming SQL language shall not contain a <schema
   character set specification>.
3) Without Feature F171, “Multiple schemas per user”, conforming SQL language shall not contain a <schema
   name clause> that contains a <schema name>.




©ISO/IEC 2003 – All rights reserved                                     Schema definition and manipulation 521
ISO/IEC 9075-2:2003 (E)
11.2 <drop schema statement>



11.2 <drop schema statement>

Function
Destroy a schema.


Format
<drop schema statement> ::= DROP SCHEMA <schema name> <drop behavior>

<drop behavior> ::=
    CASCADE
  | RESTRICT


Syntax Rules
1) Let S be the schema identified by <schema name>.
2) S shall identify a schema in the catalog identified by the explicit or implicit <catalog name>.
3) If RESTRICT is specified, then S shall not contain any persistent base tables, global temporary tables,
   created local temporary tables, views, domains, assertions, character sets, collations, transliterations, triggers,
   user-defined types, SQL-invoked routines, sequence generators, or roles, and the <schema name> of S shall
   not be generally contained in the SQL routine body of any routine descriptor.
    NOTE 244 — If CASCADE is specified, then such objects will be dropped by the effective execution of the SQL schema manip-
    ulation statements specified in the General Rules of this Subclause.


Access Rules
1) The enabled authorization identifiers shall include the <authorization identifier> that owns the schema
   identified by the <schema name>.


General Rules
1) Let T be the <table name> included in the descriptor of any base table or temporary table included in S.
   The following <drop table statement> is effectively executed:
       DROP TABLE T CASCADE

2) Let V be the <table name> included in the descriptor of any view included in S. The following <drop view
   statement> is effectively executed:
       DROP VIEW V CASCADE

3) Let D be the <domain name> included in the descriptor of any domain included in S. The following <drop
   domain statement> is effectively executed:
       DROP DOMAIN D CASCADE


522 Foundation (SQL/Foundation)                                                            ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                                11.2 <drop schema statement>



4) Let A be the <constraint name> included in the descriptor of any assertion included in S. The following
   <drop assertion statement> is effectively executed:
        DROP ASSERTION A CASCADE

5) Let CD be the <collation name> included in the descriptor of any collation included in S. The following
   <drop collation statement> is effectively executed:
        DROP COLLATION CD CASCADE

6) Let TD be the <transliteration name> included in the descriptor of any transliteration included in S. The
   following <drop transliteration statement> is effectively executed:
        DROP TRANSLATION TD

7) Let RD be the <character set name> included in the descriptor of any character set included in S. The fol-
   lowing <drop character set statement> is effectively executed:
        DROP CHARACTER SET RD

8) Let DT be the <user-defined type name> included in the descriptor of any user-defined type included in S.
   The following <drop data type statement> is effectively executed:
        DROP TYPE DT CASCADE

9) Let TT be the <trigger name> included in the descriptor of any trigger included in S. The following <drop
   trigger statement> is effectively executed:
        DROP TRIGGER TT

10) For every SQL-invoked routine R whose descriptor is included in S, let SN be the <specific name> of R.
    The following <drop routine statement> is effectively executed for every R:
        DROP SPECIFIC ROUTINE SN CASCADE

11) Let R be any SQL-invoked routine whose routine descriptor includes an SQL routine body that contains
    the <schema name> of S. Let SN be the <specific name> of R. The following <drop routine statement> is
    effectively executed without further Access Rule checking:
        DROP SPECIFIC ROUTINE SN CASCADE

12) Let RO be the name included in the descriptor of any role included in S. The following <drop role statement>
    is effectively executed:
        DROP ROLE RO CASCADE

13) Let SEQN be the sequence generator name included in the descriptor of any sequence generator included
    in S. The following <drop sequence generator statement> is effectively executed:
    DROP SEQUENCE SEQN CASCADE

14) S is destroyed.



©ISO/IEC 2003 – All rights reserved                                   Schema definition and manipulation 523
ISO/IEC 9075-2:2003 (E)
11.2 <drop schema statement>



Conformance Rules
1) Without Feature F381, “Extended schema manipulation”, conforming SQL language shall not contain a
   <drop schema statement>.




524 Foundation (SQL/Foundation)                                           ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                                        11.3 <table definition>



11.3 <table definition>

Function
Define a persistent base table, a created local temporary table, or a global temporary table.


Format
<table definition> ::=
    CREATE [ <table scope> ] TABLE <table name> <table contents source>
    [ ON COMMIT <table commit action> ROWS ]

<table contents source> ::=
    <table element list>
  | <typed table clause>
  | <as subquery clause>

<table scope> ::= <global or local> TEMPORARY

<global or local> ::=
    GLOBAL
  | LOCAL

<table commit action> ::=
    PRESERVE
  | DELETE

<table element list> ::=
    <left paren> <table element> [ { <comma> <table element> }... ] <right paren>

<table element> ::=
    <column definition>
  | <table constraint definition>
  | <like clause>

<typed table clause> ::=
    OF <path-resolved user-defined type name> [ <subtable clause> ]
    [ <typed table element list> ]

<typed table element list> ::=
    <left paren> <typed table element>
    [ { <comma> <typed table element> }... ] <right paren>

<typed table element> ::=
    <column options>
  | <table constraint definition>
  | <self-referencing column specification>

<self-referencing column specification> ::=
    REF IS <self-referencing column name> [ <reference generation> ]

<reference generation> ::=
    SYSTEM GENERATED
  | USER GENERATED




©ISO/IEC 2003 – All rights reserved                                    Schema definition and manipulation 525
ISO/IEC 9075-2:2003 (E)
11.3 <table definition>



  | DERIVED

<self-referencing column name> ::= <column name>

<column options> ::= <column name> WITH OPTIONS <column option list>

<column option list> ::=
    [ <scope clause> ] [ <default clause> ] [ <column constraint definition>... ]

<subtable clause> ::= UNDER <supertable clause>

<supertable clause> ::= <supertable name>

<supertable name> ::= <table name>

<like clause> ::= LIKE <table name> [ <like options> ]

<like options> ::= <like option>...

<like option> ::=
    <identity option>
  | <column default option>
  | <generation option>

<identity option> ::=
    INCLUDING IDENTITY
  | EXCLUDING IDENTITY

<column default option> ::=
    INCLUDING DEFAULTS
  | EXCLUDING DEFAULTS

<generation option> ::=
    INCLUDING GENERATED
  | EXCLUDING GENERATED

<as subquery clause> ::=
    [ <left paren> <column name list> <right paren> ] AS <subquery>
    <with or without data>

<with or without data> ::=
    WITH NO DATA
  | WITH DATA


Syntax Rules
1) Let T be the table defined by the <table definition> TD. Let TN be the <table name> simply contained in
   TD.
2) If a <table definition> is contained in a <schema definition> SD and TN contains a <local or schema qual-
   ifier>, then that <local or schema qualifier> shall be equivalent to the implicit or explicit <schema name>
   of SD.
3) The schema identified by the explicit or implicit schema name of TN shall not include a table descriptor
   whose table name is TN.




526 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                                          11.3 <table definition>



4) If the <table definition> is contained in a <schema definition>, then let A be the explicit or implicit
   <authorization identifier> of the <schema definition>. Otherwise, let A be the <authorization identifier>
   that owns the schema identified by the implicit or explicit <schema name> of TN.
5) If <table element> TEL is specified, then:
    a) TEL shall contain at least one <column definition> or <like clause>.
    b) For each <like clause> LC that is directly contained in TEL:
         i)       Let LT be the table identified by the <table name> contained in LC.
         ii)      If LT is a viewed table, then <like options> shall not be specified.

         iii)     Let D be the degree of LT. For i, 1 (one) ≤ i ≤ D:
                  1) Let LCDi, be the column descriptor of the i-th column of LT.

                  2) Let LCNi be the column name included in LCDi.

                  3) Let LDTi be the data type included in LCDi.

                  4) If the nullability characteristic included in LCDi is known not nullable, then let LNCi be
                     NOT NULL; otherwise, let LNCi be the zero-length string.

                  5) Let CDi be the <column definition>

                      LCNi LDTi LNCi

         iv)      If <like options> is specified, then:
                  1) <identity option> shall not be specified more than once, <column default option> shall not
                     be specified more than once, and <generation option> shall not be specified more than once.
                  2) If <identity option> is not specified, then EXCLUDING IDENTITY is implicit.
                  3) If <column default option> is not specified, then EXCLUDING DEFAULTS is implicit.
                  4) If <generation option> is not specified, then EXCLUDING GENERATED is implicit.
                  5) If INCLUDING IDENTITY is specified and LT includes an identity column, then let ICD
                     be the column descriptor of that column included in the table descriptor of LT. Let SGD be
                     the sequence generator descriptor included in ICD.
                      A) Let SV be the start value included in ICD.
                      B) Let IV be the increment included in SGD.
                      C) Let MAX be the maximum value included in SGD.
                      D) Let MIN be the minimum value included in SGD.
                      E) Let CYC be the cycle option included in SGD.
                      F) Let k be the ordinal position in which the column described by ICD appears in the table
                         identified by LT.


©ISO/IEC 2003 – All rights reserved                                       Schema definition and manipulation 527
ISO/IEC 9075-2:2003 (E)
11.3 <table definition>



                   G) Case:
                       I)      If ICD indicates that values are always generated, then let G be GENERATED
                               ALWAYS.
                       II)     If ICD indicates that values are generated by default, then let G be GENERATED
                               BY DEFAULT.
                   H) The value of CDk is replaced by:

                       LCNk LDTk
                         G AS IDENTITY ( START WITH SV, INCREMENT BY IV,
                                         MAXVALUE MAX, MINVALUE MIN, CYC ) LNCk


              6) If INCLUDING GENERATED is specified, then let GCDj, 1 (one) ≤ j ≤ D, be the column
                 descriptors included in the descriptor of LT, with j being the ordinal position of the column
                 described by GCDj. For each GCDj that indicates that the column it describes is a generated
                 column:
                   A) Let GEj be the <generation expression> included in GCDj, where the <table name>
                      contained in any contained <column reference> is replaced by TN.
                   B) The value of CDj is replaced by

                       LCNj LDTj GENERATED ALWAYS AS GEj LCNj


              7) If INCLUDING DEFAULTS is specified, then let DCDm, 1 (one) ≤ m ≤ D, be the column
                 descriptors included in the descriptor of LT, with m being the ordinal position of the column
                 described by DCDm.

                   For each DCDm, if DCDm includes a <default option> DOm, then the value of CDm is
                   replaced by

                   LCNm LDTm DEFAULT         DOm LCNm

        v)    LC is effectively replaced by:

              CD1, ..., CDD

              NOTE 245 — <column constraint>s, except for NOT NULL, are not included in CDi; <column constraint definition>s
              are effectively transformed to <table constraint definition>s and are thereby also excluded.

6) If <as subquery clause> is specified, then:
    a) Let QT be the table specified by the <subquery>.
    b) If any two columns in QT have equivalent <column name>s, or if any column of QT has an implemen-
       tation-dependent name, then <column name list> shall be specified.
    c) Let D be the degree of QT.
    d) <column name list> shall not contain two or more equivalent <column name>s.



528 Foundation (SQL/Foundation)                                                           ©ISO/IEC 2003 – All rights reserved
                                                                                            ISO/IEC 9075-2:2003 (E)
                                                                                             11.3 <table definition>



    e) The number of <column name>s in <column name list> shall be D.

    f) For i, 1 (one) ≤ i ≤ D:
         i)       Case:
                  1) If <column name list> is specified, then let QCNi be the i-th <column name> in that <column
                     name list>.
                  2) Otherwise, let QCNi be the <column name> of the i-th column of QT.

         ii)      Let QDTi be the declared type of the i-th column of QT.

         iii)     If the nullability characteristic of the i-th column of QT is known not nullable, then let QNCi be
                  NOT NULL; otherwise, let QNCi be the zero-length string.

         iv)      Let CDi be the <column definition>

                  QCNi QDTi QNCi

    g) <as subquery clause> is effectively replaced by a <table element list> TEL of the form:

         CD1, ..., CDD

7) If <typed table clause> TTC is specified, then:
    a) The <user-defined type name> simply contained in <path-resolved user-defined type name> shall
       identify a structured type ST.
    b) If <subtable clause> is specified, then <self-referencing column specification> shall not be specified.
       Otherwise, <self-referencing column specification> shall be specified exactly once.
    c) If <self-referencing column specification> SRCS is specified, then let RST be the reference type REF(ST).
         i)       <subtable clause> shall not be specified.
         ii)      <table scope> shall not be specified.
         iii)     If SYSTEM GENERATED is specified, then RST shall have a system-defined representation.
         iv)      If USER GENERATED is specified, then RST shall have a user-defined representation.
         v)       If DERIVED is specified, then RST shall have a derived representation.
         vi)      If RST has a derived representation, then let m be the number of attributes included in the list
                  of attributes of the derived representation of RST and let Ai, 1 (one) ≤ i ≤ m, be those attributes.

                  1) TD shall contain a <table constraint definition> that specifies a <unique constraint definition>
                     UCD whose <unique column list> contains the attribute names of A1, A2, ..., Am in that
                     order.




©ISO/IEC 2003 – All rights reserved                                        Schema definition and manipulation 529
ISO/IEC 9075-2:2003 (E)
11.3 <table definition>



              2) If UCD does not specify PRIMARY KEY, then for every attribute Ai, 1 (one) ≤ i ≤ m, TD
                 shall contain a <column options> COi with a <column name> that is equivalent to the
                 <attribute name> of Ai and with a <column constraint definition> that specifies NOT NULL.

       vii)   Let CD0 be the <column definition>:

              CN0 RST SCOPE(TN) UNIQUE NOT NULL

              where CN0 denotes the <self-referencing column name> simply contained in SRCS.

   d) If <subtable clause> is specified, then:
       i)     The <table name> contained in the <subtable clause> identifies the direct supertable of T, which
              shall be a base table. T is called a direct subtable of the direct supertable of T.
       ii)    ST shall be a direct subtype of the structured type of the direct supertable of T.
       iii)   The SQL-schema identified by the explicit or implicit <schema name> of the <table name> of
              T shall include the descriptor of the direct supertable of T.
       iv)    The subtable family of T shall not include a member, other than T itself, whose associated
              structured type is ST.
       v)     TD shall not contain a <table constraint definition> that specifies PRIMARY KEY.
       vi)    Let the term inherited column of T refer to a column of T that corresponds to an inherited attribute
              of ST. For every such inherited attribute IA, there is a column CA of the direct supertable of T
              such that the <column name> of CA is equivalent to the <attribute name> of IA. CA is called
              the direct supercolumn of IA in the direct supertable of T.
       vii)   Let CD0 be the <column definition>:

              CN0 RST SCOPE(TN) UNIQUE NOT NULL

              where CN0 denotes the <self-referencing column name> simply contained in SRCS.

   e) Let the term originally-defined column of T refer to a column of T that corresponds to an originally-
      defined attribute of ST.

   f) Let n be the number of attributes of ST. Let ADi, 1 (one) ≤ i ≤ n, be the attribute descriptors included
      in the data type descriptor of ST and let CDi be the <column definition> CNi DTi DCi, where:

       i)     CNi is the attribute name included in ADi.

       ii)    DTi is some <data type> that, under the General Rules of Subclause 6.1, “<data type>”, would
              result in the creation of the data type descriptor included in ADi.

       iii)   If ADi describes an inherited attribute IA, then

              Case:
              1) If the column descriptor of the direct supercolumn of IA includes a default value, then DCi
                 is some <default clause> whose <default option> denotes this default value.


530 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                                                          11.3 <table definition>



                  2) Otherwise, DCi is the zero-length string.

         iv)      If ADi describes an originally-defined attribute OA, then

                  Case:
                  1) If ADi includes a default value, then DCi is some <default clause> whose <default option>
                     denotes this default value.
                  2) Otherwise, DCi is the zero-length string.

    g) If <typed table element list> TTEL is specified and <column options> CO is specified, then:
         i)       The <column name> CN simply contained in CO shall be equivalent to the <column name> CNj
                  specified in some <column definition> CDj and shall refer to an originally-defined column of
                  T.
         ii)      CN shall not be equivalent to the <column name> simply contained in any other <column
                  options> contained in TTEL.
         iii)     A <column option list> shall immediately contain either a <scope clause> or a <default clause>,
                  or at least one <column constraint definition>.
         iv)      If CO specifies a <scope clause> SC, then DTj shall be a <reference type> RT. If RT contains a
                  <scope clause>, then that <scope clause> is replaced by SC; otherwise, RT is replaced by RT
                  SC.
                  NOTE 246 — Changes to the scope of a column of a typed table do not affect the scope defined for the underlying
                  attribute. Such an attribute scope serves as a kind of default for the column's scope, at the time the typed table is
                  defined, and is not restored if a column's scope is dropped.

         v)       If CO specifies a <default clause> DC, then DCj is replaced by DC in CDj.

         vi)      If CO specifies a non-empty list CCDL of <column constraint definition>s, then CDj is replaced
                  by CDj CCDL.

         vii)     CO is deleted from TTEL.
    h) T is a referenceable table.
    i)   If TTEL is empty, then let TEL be a <table element list> of the form

         CD0, ..., CDn

         Otherwise, then let TEL be a <table element list> of the form

         CD0, ..., CDn TTEL

8) If ON COMMIT is specified, then TEMPORARY shall be specified.
9) If TEMPORARY is specified and ON COMMIT is not specified, then ON COMMIT DELETE ROWS is
   implicit.
10) Every referenceable table referenced by a <scope clause> contained in a <column definition> or <column
    options> contained in TD shall be


©ISO/IEC 2003 – All rights reserved                                                  Schema definition and manipulation 531
ISO/IEC 9075-2:2003 (E)
11.3 <table definition>



    Case:
    a) If TD specifies no <table scope>, then a persistent base table.
    b) If TD specifies GLOBAL TEMPORARY, then a global temporary table.
    c) If TD specifies LOCAL TEMPORARY, then a created local temporary table.
11) At most one <table element> shall be a <column definition> that contains an <identity column specification>.
12) The scope of the <table name> is the <table definition>, excluding the <as subquery clause>.


Access Rules
1) If a <table definition> is contained in an <SQL-client module definition>, then the enabled authorization
   identifiers shall include A.
2) If a <like clause> is contained in a <table definition>, then the applicable privileges for A shall include
   SELECT privilege on the table identified in the <like clause>.
3) A shall have in its applicable privileges the UNDER privilege on the <supertable name> specified in
   <subtable clause>.
4) If “OF <path-resolved user-defined type name>” is specified, then the applicable privileges for A shall
   include USAGE on ST.


General Rules
1) A <table definition> defines either a persistent base table, a global temporary table or a created local tem-
   porary table. If GLOBAL is specified, then a global temporary table is defined. If LOCAL is specified,
   then a created local temporary table is defined. Otherwise, a persistent base table is defined.
2) The degree of T is initially set to 0 (zero); the General Rules of Subclause 11.4, “<column definition>”,
   specify the degree of T during the definition of the columns of T.
3) If <path-resolved user-defined type name> is specified, then:
    a) Let R be the structured type identified by the <user-defined type name> simply contained in <path-
       resolved user-defined type name>.
    b) R is the structured type associated with T.
4) A table descriptor TDS is created that describes T. TDS includes:
    a) The table name TN.
    b) The column descriptors of every column of T, according to the Syntax Rules and General Rules of
       Subclause 11.4, “<column definition>”, applied to the <column definition>s contained in TEL, in the
       order in which they were specified.
    c) If <typed table clause> is specified, then:
        i)     An indication that the table is a referenceable table.



532 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                            ISO/IEC 9075-2:2003 (E)
                                                                                             11.3 <table definition>



         ii)      An indication that the column at ordinal position 1 (one) is the self-referencing column of T.
                  The column descriptor included in TDS that describes that column is marked as identifying a
                  self-referencing column.
         iii)     If RST has a system-defined representation, then an indication that the self-referencing column
                  is a system-generated self-referencing column.
         iv)      If RST has a derived representation, then an indication that the self-referencing column is a
                  derived self-referencing column.
         v)       If RST has a user-defined representation, then an indication that the self-referencing column is
                  a user-generated self-referencing column.
    d) The table constraint descriptors specified by each <table constraint definition> contained in TEL.
    e) If a <path-resolved user-defined type name> is specified, then the user-defined type name of R.
    f) If <subtable clause> is specified, then the table name of the direct supertable of T contained in the
       <subtable clause>.
    g) A non-empty set of functional dependencies, according to the rules given in Subclause 4.18, “Functional
       dependencies”.
    h) A non-empty set of candidate keys.
    i)   A preferred candidate key, which may or may not be additionally designated the primary key, according
         to the Rules in Subclause 4.18, “Functional dependencies”.
    j)   An indication of whether the table is a persistent base table, a global temporary table, a created local
         temporary table, or a declared local temporary table.
    k) If TEMPORARY is specified, then
         Case:
         i)       If ON COMMIT PRESERVE ROWS is specified, then the table descriptor includes an indication
                  that ON COMMIT PRESERVE ROWS is specified.
         ii)      Otherwise, the table descriptor includes an indication that ON COMMIT DELETE ROWS is
                  specified or implied.
    l)   Case:
         i)       If <typed table clause> is not specified, then an indication that T is insertable-into.
         ii)      Otherwise,
                  Case:
                  1) If the data type descriptor of R indicates that R is instantiable, then an indication that T is
                     insertable-into.
                  2) Otherwise, an indication that T is not insertable-into.
5) In the descriptor of each direct supertable of T, TN is added to the end of the list of direct subtables.




©ISO/IEC 2003 – All rights reserved                                        Schema definition and manipulation 533
ISO/IEC 9075-2:2003 (E)
11.3 <table definition>



6) If <subtable clause> is specified, then a set of privilege descriptors is created that defines the privileges
   SELECT, UPDATE, and REFERENCES for every inherited column of this table to the <authorization
   identifier> that owns the schema identified by the implicit or explicit <schema name> of the <table name>
   of the direct supertable from which that column was inherited. These privileges are grantable. The grantor
   for each of these privilege descriptors is set to the special grantor value “_SYSTEM”.
7) A set of privilege descriptors is created that define the privileges INSERT, SELECT, UPDATE, DELETE,
   TRIGGER, and REFERENCES on this table and SELECT, INSERT, UPDATE, and REFERENCES for
   every <column definition> in the table definition. If OF <path-resolved user-defined type name> is specified,
   then a table/method privilege descriptor is created on this table for every method of the structured type
   identified by the <path-resolved user-defined type name> and the table SELECT privilege has the WITH
   HIERARCHY OPTION. These privileges are grantable.
    The grantor for each of these privilege descriptors is set to the special grantor value “_SYSTEM”. The
    grantee is <authorization identifier> A.
8) If <subtable clause> is specified, then let ST be the set of supertables of T. Let PDS be the set of privilege
   descriptors that defined SELECT WITH HIERARCHY OPTION privilege on a table in ST. For every
   privilege descriptor in PDS, with grantee G, grantor A,
    Case:
    a) If the privilege is grantable, then let WGO be “WITH GRANT OPTION”.
    b) Otherwise, let WGO be a zero-length string.
    The following <grant statement> is effectively executed without further Access Rule checking:
       GRANT SELECT ON T TO G WGO FROM A


9) The row type RT of the table T defined by the <table definition> is the set of pairs (<field name>, <data
   type>) where <field name> is the name of a column C of T and <data type> is the declared type of C. This
   set of pairs contains one pair for each column of T, in the order of their ordinal position in T.
10) If <as subquery clause> is specified and WITH DATA is specified, then let QE be the <query expression>
    immediately contained in the <subquery>. The following <insert statement> is effectively executed without
    further Access Rule checking:
       INSERT INTO TN QE


Conformance Rules
1) Without Feature T171, “LIKE clause in table definition”, conforming SQL language shall not contain a
   <like clause>.
2) Without Feature F531, “Temporary tables”, conforming SQL language shall not contain a <table scope>
   and shall not reference any global or local temporary table.
3) Without Feature S051, “Create table of type”, conforming SQL language shall not contain “OF <path-
   resolved user-defined type name>”.




534 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                                    11.3 <table definition>



4) Without Feature S043, “Enhanced reference types”, conforming SQL language shall not contain a <column
   option list> that contains a <scope clause>.
5) Without Feature S043, “Enhanced reference types”, conforming SQL language shall not contain <reference
   generation> that does not contain SYSTEM GENERATED.
6) Without Feature S081, “Subtables”, conforming SQL language shall not contain a <subtable clause>.
7) Without Feature T172, “AS subquery clause in table definition”, conforming SQL language shall not contain
   an <as subquery clause>.
8) Without Feature T173, “Extended LIKE clause in table definition”, a <like clause> shall not contain <like
   options>.




©ISO/IEC 2003 – All rights reserved                                 Schema definition and manipulation 535
ISO/IEC 9075-2:2003 (E)
11.4 <column definition>



11.4 <column definition>

Function
Define a column of a base table.


Format
<column definition> ::=
    <column name> [ <data type or domain name> ]
    [ <default clause> | <identity column specification> | <generation clause> ]
    [ <column constraint definition>... ]
    [ <collate clause> ]

<data type or domain name> ::=
    <data type>
  | <domain name>

<column constraint definition> ::=
    [ <constraint name definition> ] <column constraint> [ <constraint characteristics> ]

<column constraint> ::=
    NOT NULL
  | <unique specification>
  | <references specification>
  | <check constraint definition>

<identity column specification> ::=
    GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY
    [ <left paren> <common sequence generator options> <right paren> ]

<generation clause> ::= <generation rule> AS <generation expression>

<generation rule> ::= GENERATED ALWAYS

<generation expression> ::= <left paren> <value expression> <right paren>


Syntax Rules
1) Case:
    a) If the <column definition> is contained in a <table definition>, then let T be the table defined by that
       <table definition>.
    b) If the <column definition> is contained in a <temporary table declaration>, then let T be the table
       declared by that <temporary table declaration>.
    c) If the <column definition> is contained in an <alter table statement>, then let T be the table identified
       in the containing <alter table statement>.
    The <column name> in the <column definition> shall not be equivalent to the <column name> of any other
    column of T.



536 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                         11.4 <column definition>



2) Let A be the <authorization identifier> that owns T.
3) Let C be the <column name> of the <column definition>.
4) <data type or domain name> shall unambiguously reference either a <data type> or a <domain name>.
5) If <domain name> is specified, then let D be the domain identified by the <domain name>.
6) If <generation clause> GC is specified, then:
    a) Let GE be the <generation expression> contained in GC.
    b) C is a generated column.
    c) Every <column reference> contained in GE shall reference a base column of T.
    d) GE shall be deterministic.
    e) GE shall not contain a <routine invocation> whose subject routine possibly reads SQL-data.
    f) GE shall not contain a <subquery>.
7) If <generation clause> is omitted, then either <data type> or <domain name> shall be specified.
8) Case:
    a) If <column definition> immediately contains <domain name>, then it shall not also immediately contain
       <collate clause>.
    b) Otherwise, <collate clause> shall not be both specified in <data type> and immediately contained in
       <column definition>. If <collate clause> is immediately contained in <column definition>, then it is
       equivalent to specifying an equivalent <collate clause> in <data type>.
9) The declared type of the column is
    Case:
    a) If <data type> is specified, then that data type. If <generation clause> is also specified, then the declared
       type of <generation expression> shall be assignable to the declared type of the column.
    b) If <domain name> is specified, then the declared type of D. If <generation clause> is also specified,
       then the declared type of <generation expression> shall be assignable to the declared type of the column.
    c) If <generation clause> is specified, then the declared type of GE.
10) If a <data type> is specified, then:
    a) Let DT be the <data type>.
    b) If DT specifies CHARACTER, CHARACTER VARYING, or CHARACTER LARGE OBJECT and
       does not specify a <character set specification>, then the <character set specification> specified or
       implicit in the <schema character set specification> of the <schema definition> that created the schema
       identified by the <schema name> immediately contained in the <table name> of the containing <table
       definition> or <alter table statement> is implicit.
11) If <identity column specification> ICS is specified, then:
    a) Case:


©ISO/IEC 2003 – All rights reserved                                      Schema definition and manipulation 537
ISO/IEC 9075-2:2003 (E)
11.4 <column definition>



        i)      If the declared type of the column being defined is a distinct type DIST, then the source type of
                DIST shall be exact numeric with scale 0 (zero). Let ICT be the source type of DIST.
        ii)     Otherwise, the declared type of the column being defined shall be exact numeric with scale 0
                (zero). Let ICT be the declared type of the column being defined.
    b) Let SGO be the <common sequence generator options>.
    c) The Syntax Rules of Subclause 9.22, “Creation of a sequence generator”, are applied with SGO as
       OPTIONS and ICT as DATA TYPE.
    d) The <column constraint definition> NOT NULL NOT DEFERRABLE is implicit.
12) If a <column constraint definition> is specified, then let CND be the <constraint name definition> if one
    is specified and let CND be a zero-length string otherwise; let CA be the <constraint characteristics> if
    specified and let CA be a zero-length string otherwise. The <column constraint definition> is equivalent
    to a <table constraint definition> as follows:
    Case:
    a) If a <column constraint definition> is specified that contains the <column constraint> NOT NULL,
       then it is equivalent to the following <table constraint definition>:
              CND CHECK ( C IS NOT NULL ) CA

    b) If a <column constraint definition> is specified that contains a <unique specification> US, then it is
       equivalent to the following <table constraint definition>:
              CND US (C) CA
        NOTE 247 — The <unique specification> is defined in Subclause 11.7, “<unique constraint definition>”.

    c) If a <column constraint definition> is specified that contains a <references specification> RS, then it
       is equivalent to the following <table constraint definition>:
              CND FOREIGN KEY (C) RS CA
        NOTE 248 — The <references specification> is defined in Subclause 11.8, “<referential constraint definition>”.

    d) If a <column constraint definition> is specified that contains a <check constraint definition> CCD,
       then it is equivalent to the following <table constraint definition>:
              CND CCD CA
        Each column reference directly contained in the <search condition> shall reference column C.
13) The schema identified by the explicit or implicit qualifier of the <domain name> shall include the
    descriptor of D.


Access Rules
1) If <domain name> is specified, then the applicable privileges for A shall include USAGE on D.




538 Foundation (SQL/Foundation)                                                               ©ISO/IEC 2003 – All rights reserved
                                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                                                  11.4 <column definition>



General Rules
1) A <column definition> defines a column in a table.
2) If the <column definition> specifies <data type>, then a data type descriptor is created that describes the
   declared type of the column being defined.
3) The degree of the table T being defined in the containing <table definition> or <temporary table declaration>,
   or being altered by the containing <alter table statement> is increased by 1 (one).
4) A column descriptor is created that describes the column being defined. The column descriptor includes:
    a) C, the name of the column.
    b) Case:
         i)       If the <column definition> specifies a <data type> or a <generation clause>, then the data type
                  descriptor of the declared type of the column.
         ii)      Otherwise, the domain of the column.
    c) The ordinal position of the column, which is equal to the degree of T.
    d) The nullability characteristic of the column, determined according to the rules in Subclause 4.13,
       “Columns, fields, and attributes”.
         NOTE 249 — Both <column constraint definition>s and <table constraint definition>s shall be analyzed to determine the
         nullability characteristics of all columns.

    e) If <default clause> is specified, then the <default option>.
    f) If <identity column specification> is specified, then:
         i)       An indication that the column is an identity column.
         ii)      If ALWAYS is specified, then an indication that values are always generated.
         iii)     If BY DEFAULT is specified, then an indication that values are generated by default.
         iv)      The descriptor of the sequence generator descriptor SG resulting from application of the General
                  Rules of Subclause 9.22, “Creation of a sequence generator”, with SGO as OPTIONS and ICT
                  as DATA TYPE.
         v)       The next available value of SG as the start value.
    g) If <generation clause> is specified, then GE.
    h) An indication that the column is updatable.


Conformance Rules
1) Without Feature F692, “Extended collation support”, conforming SQL language shall not contain a <column
   definition> that immediately contains a <collate clause>.
2) Without Feature T174, “Identity columns”, conforming SQL language shall not contain an <identity column
   specification>.


©ISO/IEC 2003 – All rights reserved                                             Schema definition and manipulation 539
ISO/IEC 9075-2:2003 (E)
11.4 <column definition>



3) Without Feature T175, “Generated columns”, conforming SQL language shall not contain a <generation
   clause>.




540 Foundation (SQL/Foundation)                                           ©ISO/IEC 2003 – All rights reserved
                                                                                              ISO/IEC 9075-2:2003 (E)
                                                                                                11.5 <default clause>



11.5 <default clause>

Function
Specify the default for a column, domain, or attribute.


Format
<default clause> ::= DEFAULT <default option>

<default option> ::=
    <literal>
  | <datetime value function>
  | USER
  | CURRENT_USER
  | CURRENT_ROLE
  | SESSION_USER
  | SYSTEM_USER
  | CURRENT_PATH
  | <implicitly typed value specification>


Syntax Rules
1) The subject data type of a <default clause> is the data type specified in the descriptor identified by the
   containing <column definition>, <domain definition>, <attribute definition>, <alter column definition>,
   or <alter domain statement>.
2) If USER is specified, then CURRENT_USER is implicit.
3) Case:
    a) If the subject data type of the <default clause> is a user-defined type, a reference type, or a row type,
       then <default option> shall specify <null specification>.
    b) If the subject data type of the <default clause> is a collection type, then <default option> shall specify
       <implicitly typed value specification>. If the <default option> specifies an <empty specification> that
       specifies ARRAY, then the subject data type shall be an array type. If the <default option> specifies
       an <empty specification> that specifies MULTISET, then the subject data type shall be a multiset type.
4) Case:
    a) If a <literal> is specified, then
         Case:
         i)       If the subject data type is character string, then the <literal> shall be a <character string literal>.
                  If the length of the subject data type is fixed, then the length in characters of the <character
                  string literal> shall not be greater than the length of the subject data type. If the length of the
                  subject data type is variable, then the length in characters of the <character string literal> shall
                  not be greater than the maximum length of the subject data type. The <literal> shall have the
                  same character repertoire as the subject data type.


©ISO/IEC 2003 – All rights reserved                                         Schema definition and manipulation 541
ISO/IEC 9075-2:2003 (E)
11.5 <default clause>



        ii)     If the subject data type is binary string, then the <literal> shall be a <binary string literal> that
                has an even number of <hexit>s. The length in octets of the <binary string literal> shall not be
                greater than the maximum length of the subject data type.
        iii)    If the subject data type is exact numeric, then the <literal> shall be a <signed numeric literal>
                that simply contains an <exact numeric literal>. There shall be a representation of the value of
                the <literal> in the subject data type that does not lose any significant digits.
        iv)     If the subject data type is approximate numeric, then the <literal> shall be a <signed numeric
                literal>.
        v)      If the subject data type is datetime, then the <literal> shall be a <datetime literal> with the same
                primary datetime fields and the same time zone datetime fields as the subject data type. If
                SECOND is one of these fields, then the fractional seconds precision of the <datetime literal>
                shall be less than or equal to the fractional seconds precision of the subject data type.
        vi)     If the subject data type is interval, then the <literal> shall be an <interval literal> and shall contain
                the same <interval qualifier> as the subject data type.
        vii)    If the subject data type is boolean, then the <literal> shall be a <boolean literal>.
    b) If CURRENT_USER, CURRENT_ROLE, SESSION_USER, or SYSTEM_USER is specified, then
       the subject data type shall be character string with character set SQL_IDENTIFIER. If the length of
       the subject data type is fixed, then its length shall not be less than 128 characters. If the length of the
       subject data type is variable, then its maximum length shall not be less than 128 characters.
    c) If CURRENT_PATH is specified, then the subject data type shall be character string with character
       set SQL_IDENTIFIER. If the length of the subject data type is fixed, then its length shall not be less
       than 1031 characters. If the length of the subject data type is variable, then its maximum length shall
       not be less than 1031 characters.
    d) If <datetime value function> is specified, then the subject data type shall be datetime with the same
       declared datetime data type of the <datetime value function>.
    e) If <empty specification> is specified, then the subject data type shall be a collection type.


Access Rules
    None.


General Rules
1) The default value inserted in the column descriptor, if the <default clause> is to apply to a column, or in
   the domain descriptor, if the <default clause> is to apply to a domain, or in the attribute descriptor, if the
   <default clause> is to apply to an attribute, is the <default option>.
2) The value specified by a <default option> is
    Case:
    a) If the <default option> contains a <literal>, then
        Case:


542 Foundation (SQL/Foundation)                                                         ©ISO/IEC 2003 – All rights reserved
                                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                                            11.5 <default clause>



         i)       If the subject data type is numeric, then the numeric value of the <literal>.
         ii)      If the subject data type is character string with variable length, then the value of the <literal>.
         iii)     If the subject data type is character string with fixed length, then the value of the <literal>,
                  extended as necessary on the right with <space>s to the length in characters of the subject data
                  type.
         iv)      If the subject data type is binary string, then the value of the <literal>.
         v)       If the subject data type is datetime or interval, then the value of the <literal>.
         vi)      If the subject data type is boolean, then the value of the <literal>.
    b) If the <default option> specifies CURRENT_USER, CURRENT_ROLE, SESSION_USER, SYS-
       TEM_USER, or CURRENT_PATH, then
         Case:
         i)       If the subject data type is character string with variable length, then the value obtained by an
                  evaluation of CURRENT_USER, SESSION_USER, SYSTEM_USER, or CURRENT_PATH
                  at the time that the default value is required.
         ii)      If the subject data type is character string with fixed length, then the value obtained by an eval-
                  uation of CURRENT_USER, SESSION_USER, CURRENT_PATH, or SYSTEM_USER at
                  the time that the default value is required, extended as necessary on the right with <space>s to
                  the length in characters of the subject data type.
    c) If the <default option> contains a <datetime value function>, then the value of an evaluation of the
       <datetime value function> at the time that the default value is required.
    d) If the <default option> specifies <empty specification>, then an empty collection.
3) When a site S is set to its default value,
    Case:
    a) If the descriptor of S indicates that it represents a column of which some underlying column is an
       identity column or a generated column, then S is marked as unassigned.
         NOTE 250 — The notion of a site being unassigned is only for definitional purposes in this International Standard. It is not
         a state that can persist so as to be visible in SQL-data. The treatment of unassigned sites is given in Subclause 14.19, “Effect
         of inserting tables into base tables”, and Subclause 14.22, “Effect of replacing rows in base tables”.

    b) If the data descriptor for the site includes a <default option>, then S is set to the value specified by that
       <default option>.
    c) If the data descriptor for the site includes a <domain name> that identifies a domain descriptor that
       includes a <default option>, then S is set to the value specified by that <default option>.
    d) If the default value is for a column C of a candidate row for insertion into or update of a derived table
       DT and C has a single counterpart column CC in a leaf generally underlying table of DT, then S is set
       to the default value of CC, which is obtained by applying the General Rules of this Subclause.
    e) Otherwise, S is set to the null value.




©ISO/IEC 2003 – All rights reserved                                                  Schema definition and manipulation 543
ISO/IEC 9075-2:2003 (E)
11.5 <default clause>



   NOTE 251 — If <default option> specifies CURRENT_USER, SESSION_USER, SYSTEM_USER, CURRENT_ROLE or
   CURRENT_PATH, then the “value in the column descriptor” will effectively be the text of the <default option>, whose evaluation
   occurs at the time that the default value is required.

4) If the <default clause> is contained in an <SQL schema statement> and character representation of the
   <default option> cannot be represented in the Information Schema without truncation, then a completion
   condition is raised: warning — default value too long for information schema.
   NOTE 252 — The Information Schema is defined in ISO/IEC 9075-11.


Conformance Rules
1) Without Feature S071, “SQL paths in function and type name resolution”, conforming SQL language shall
   not contain a <default option> that contains CURRENT_PATH.
2) Without Feature F321, “User authorization”, conforming SQL language shall not contain a <default option>
   that contains CURRENT_USER, SESSION_USER, or SYSTEM_USER.
   NOTE 253 — Although CURRENT_USER and USER are semantically the same, without Feature F321, “User authorization”,
   CURRENT_USER shall be specified as USER.

3) Without Feature T332, “Extended roles”, conforming SQL language shall not contain a <default option>
   that contains CURRENT_ROLE.




544 Foundation (SQL/Foundation)                                                               ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                11.6 <table constraint definition>



11.6 <table constraint definition>

Function
Specify an integrity constraint.


Format
<table constraint definition> ::=
    [ <constraint name definition> ] <table constraint>
    [ <constraint characteristics> ]

<table constraint> ::=
    <unique constraint definition>
  | <referential constraint definition>
  | <check constraint definition>


Syntax Rules
1) If <constraint characteristics> is not specified, then INITIALLY IMMEDIATE NOT DEFERRABLE is
   implicit.
2) If <constraint name definition> is specified and its <constraint name> contains a <schema name>, then
   that <schema name> shall be equivalent to the explicit or implicit <schema name> of the <table name> of
   the table identified by the containing <table definition> or <alter table statement>.
3) If <constraint name definition> is not specified, then a <constraint name definition> that contains an
   implementation-dependent <constraint name> is implicit. The assigned <constraint name> shall obey the
   Syntax Rules of an explicit <constraint name>.


Access Rules
    None.


General Rules
1) A <table constraint definition> defines a table constraint.
2) A table constraint descriptor is created that describes the table constraint being defined. The table constraint
   descriptor includes the <constraint name> contained in the explicit or implicit <constraint name definition>.
    The table constraint descriptor includes an indication of whether the constraint is deferrable or not deferrable
    and whether the initial constraint mode of the constraint is deferred or immediate.
    Case:
    a) If <unique constraint definition> is specified, then the table constraint descriptor is a unique constraint
       descriptor that includes an indication of whether it was defined with PRIMARY KEY or UNIQUE,
       and the names of the unique columns specified in the <unique column list>.


©ISO/IEC 2003 – All rights reserved                                      Schema definition and manipulation 545
ISO/IEC 9075-2:2003 (E)
11.6 <table constraint definition>



    b) If <referential constraint definition> is specified, then the table constraint descriptor is a referential
       constraint descriptor that includes a list of the names of the referencing columns specified in the <ref-
       erencing columns>, the name of the referenced table specified in the <referenced table and columns>
       and a list of the names of the referenced columns specified in the <referenced table and columns>, the
       value of the <match type>, if specified, and the <referential triggered action>s, if specified. The
       ordering of the lists of referencing column names and referenced column names is implementation-
       defined, but shall be such that corresponding column names occupy corresponding positions in each
       list.
    c) If <check constraint definition> is specified, then the table constraint descriptor is a table check constraint
       descriptor that includes the <search condition>.
3) If the <table constraint> is a <check constraint definition>, then let SC be the <search condition> immediately
   contained in the <check constraint definition> and let T be the table name included in the corresponding
   table constraint descriptor; the table constraint is not satisfied if and only if
       EXISTS ( SELECT * FROM T WHERE NOT ( SC ) )
    is True.


Conformance Rules
    None.




546 Foundation (SQL/Foundation)                                                       ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                           11.7 <unique constraint definition>



11.7 <unique constraint definition>

Function
Specify a uniqueness constraint for a table.


Format
<unique constraint definition> ::=
    <unique specification> <left paren> <unique column list> <right paren>
  | UNIQUE ( VALUE )

<unique specification> ::=
    UNIQUE
  | PRIMARY KEY

<unique column list> ::= <column name list>


Syntax Rules
1) Each column identified by a <column name> in the <unique column list> is an operand of a grouping
   operation. The Syntax Rules of Subclause 9.10, “Grouping operations”, apply.
2) Let T be the table identified by the containing <table definition> or <alter table statement>. Let TN be the
   <table name> of T.
3) If <unique column list> UCL is specified, then
    a) Each <column name> in the <unique column list> shall identify a column of T, and the same column
       shall not be identified more than once.
    b) The set of columns in the <unique column list> shall be distinct from the unique columns of any other
       unique constraint descriptor that is included in the base table descriptor of T.
    c) Case:
         i)       If the <unique specification> specifies PRIMARY KEY, then let SC be the <search condition>:
                  UNIQUE ( SELECT UCL FROM TN )
                      AND
                  ( UCL ) IS NOT NULL

         ii)      Otherwise, let SC be the <search condition>:
                  UNIQUE ( SELECT UCL FROM TN )

4) If UNIQUE (VALUE) is specified, then let SC be the <search condition>:
        UNIQUE ( SELECT TN.* FROM TN )

5) If the <unique specification> specifies PRIMARY KEY, then for each <column name> in the explicit or
   implicit <unique column list> for which NOT NULL is not specified, NOT NULL is implicit in the <column
   definition>.


©ISO/IEC 2003 – All rights reserved                                   Schema definition and manipulation 547
ISO/IEC 9075-2:2003 (E)
11.7 <unique constraint definition>



6) A <table definition> shall specify at most one implicit or explicit <unique constraint definition> that
   specifies PRIMARY KEY.
7) If a <unique constraint definition> that specifies PRIMARY KEY is contained in an <add table constraint
   definition>, then the table identified by the <table name> immediately contained in the containing <alter
   table statement> shall not have a unique constraint that was defined by a <unique constraint definition>
   that specified PRIMARY KEY.


Access Rules
    None.


General Rules
1) A <unique constraint definition> defines a unique constraint.
    NOTE 254 — Subclause 10.8, “<constraint name definition> and <constraint characteristics>”, specifies when a constraint is
    effectively checked.

2) The unique constraint is not satisfied if and only if
       EXISTS ( SELECT * FROM TN WHERE NOT ( SC ) )
    is True.


Conformance Rules
1) Without Feature S291, “Unique constraint on entire row”, conforming SQL language shall not contain
   UNIQUE(VALUE).
2) Without Feature T591, “UNIQUE constraints of possibly null columns”, in conforming SQL language, if
   UNIQUE is specified, then the <column definition> for each column whose <column name> is contained
   in the <unique column list> shall contain NOT NULL.
    NOTE 255 — The Conformance Rules of Subclause 9.10, “Grouping operations”, also apply.




548 Foundation (SQL/Foundation)                                                               ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                        11.8 <referential constraint definition>



11.8 <referential constraint definition>

Function
Specify a referential constraint.


Format
<referential constraint definition> ::=
    FOREIGN KEY <left paren> <referencing columns> <right paren>
    <references specification>

<references specification> ::=
    REFERENCES <referenced table and columns>
    [ MATCH <match type> ] [ <referential triggered action> ]

<match type> ::=
    FULL
  | PARTIAL
  | SIMPLE

<referencing columns> ::= <reference column list>

<referenced table and columns> ::=
    <table name> [ <left paren> <reference column list> <right paren> ]

<reference column list> ::= <column name list>

<referential triggered action> ::=
    <update rule> [ <delete rule> ]
  | <delete rule> [ <update rule> ]

<update rule> ::= ON UPDATE <referential action>

<delete rule> ::= ON DELETE <referential action>

<referential action> ::=
    CASCADE
  | SET NULL
  | SET DEFAULT
  | RESTRICT
  | NO ACTION


Syntax Rules
1) If <match type> is not specified, then SIMPLE is implicit.
2) Let referencing table be the table identified by the containing <table definition> or <alter table statement>.
   Let referenced table be the table identified by the <table name> in the <referenced table and columns>.
   Let referencing columns be the column or columns identified by the <reference column list> in the <refer-
   encing columns> and let referencing column be one such column.
3) Case:


©ISO/IEC 2003 – All rights reserved                                    Schema definition and manipulation 549
ISO/IEC 9075-2:2003 (E)
11.8 <referential constraint definition>



    a) If the <referenced table and columns> specifies a <reference column list>, then there shall be a one-
       to-one correspondence between the set of <column name>s contained in that <reference column list>
       and the set of <column name>s contained in the <unique column list> of a unique constraint of the
       referenced table such that corresponding <column name>s are equivalent. Let referenced columns be
       the column or columns identified by that <reference column list> and let referenced column be one
       such column. Each referenced column shall identify a column of the referenced table and the same
       column shall not be identified more than once.
    b) If the <referenced table and columns> does not specify a <reference column list>, then the table
       descriptor of the referenced table shall include a unique constraint that specifies PRIMARY KEY. Let
       referenced columns be the column or columns identified by the unique columns in that unique constraint
       and let referenced column be one such column. The <referenced table and columns> shall be considered
       to implicitly specify a <reference column list> that is identical to that <unique column list>.
4) The table constraint descriptor describing the <unique constraint definition> whose <unique column list>
   identifies the referenced columns shall indicate that the unique constraint is not deferrable.
5) The referenced table shall be a base table.
    Case:
    a) If the referencing table is a persistent base table, then the referenced table shall be a persistent base
       table.
    b) If the referencing table is a global temporary table, then the referenced table shall be a global temporary
       table.
    c) If the referencing table is a created local temporary table, then the referenced table shall be either a
       global temporary table or a created local temporary table.
    d) If the referencing table is a declared local temporary table, then the referenced table shall be either a
       global temporary table, a created local temporary table or a declared local temporary table.
6) If the referenced table is a temporary table with ON COMMIT DELETE ROWS specified, then the refer-
   encing table shall specify ON COMMIT DELETE ROWS.
7) Each referencing column shall identify a column of the referencing table, and the same column shall not
   be identified more than once.
8) Each referencing column is an operand of a grouping operation. The Syntax Rules of Subclause 9.10,
   “Grouping operations”, apply.
9) The <referencing columns> shall contain the same number of <column name>s as the <referenced table
   and columns>. The i-th column identified in the <referencing columns> corresponds to the i-th column
   identified in the <referenced table and columns>. The declared type of each referencing column shall be
   comparable to the declared type of the corresponding referenced column. There shall not be corresponding
   constituents of the declared type of a referencing column and the declared type of the corresponding refer-
   enced column such that one constituent is datetime with time zone and the other is datetime without time
   zone.
10) If a <referential constraint definition> does not specify any <update rule>, then an <update rule> with a
    <referential action> of NO ACTION is implicit.




550 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                                ISO/IEC 9075-2:2003 (E)
                                                                                   11.8 <referential constraint definition>



11) If a <referential constraint definition> does not specify any <delete rule>, then a <delete rule> with a
    <referential action> of NO ACTION is implicit.
12) If any referencing column is a generated column, then:
    a) <referential action> shall not specify SET NULL or SET DEFAULT.
    b) <update rule> shall not specify ON UPDATE CASCADE.
13) Let T be the referenced table. The schema identified by the explicit or implicit qualifier of the <table name>
    shall include the descriptor of T.


Access Rules
1) The applicable privileges for the owner of T shall include REFERENCES for each referenced column.


General Rules
1) A <referential constraint definition> defines a referential constraint.
    NOTE 256 — Subclause 10.8, “<constraint name definition> and <constraint characteristics>”, specifies when a constraint is
    effectively checked.

2) Let Rf be the referencing columns and let Rt be the referenced columns in the referenced table T. The refer-
   encing table and the referenced table satisfy the referential constraint if and only if:
    Case:
    a) SIMPLE is specified or implicit and for each row of the referencing table, the <match predicate>

         Rf MATCH SIMPLE ( SELECT Rt FROM T )

         is True.
    b) PARTIAL is specified and for each row of the referencing table, the <match predicate>

         Rf MATCH PARTIAL ( SELECT Rt FROM T )

         is True.
    c) FULL is specified and for each row of the referencing table, the <match predicate>

         Rf MATCH FULL ( SELECT Rt FROM T )

         is True.
3) Case:
    a) If SIMPLE is specified or implicit, or if FULL is specified, then for a given row in the referenced table,
       every row that is a subrow or a superrow of a row R in the referencing table such that the referencing
       column values equal the corresponding referenced column values in R for the referential constraint is
       a matching row.
    b) If PARTIAL is specified, then:


©ISO/IEC 2003 – All rights reserved                                              Schema definition and manipulation 551
ISO/IEC 9075-2:2003 (E)
11.8 <referential constraint definition>



        i)      For a given row in the referenced table, every row that is a subrow or a superrow of a row R in
                the referencing table such that R has at least one non-null referencing column value and the non-
                null referencing column values of R equal the corresponding referenced column values for the
                referential constraint is a matching row.
        ii)     For a given row in the referenced table, every matching row for that given row that is a matching
                row only to the given row in the referenced table for the referential constraint is a unique
                matching row. For a given row in the referenced table, a matching row for that given row that
                is not a unique matching row for that given row for the referential constraint is a non-unique
                matching row.
4) For each row of the referenced table, its matching rows, unique matching rows, and non-unique matching
   rows are determined immediately prior to the execution of any <SQL procedure statement>. No new
   matching rows are added during the execution of that <SQL procedure statement>.
    The association between a referenced row and a non-unique matching row is dropped during the execution
    of that SQL-statement if the referenced row is either marked for deletion or updated to a distinct value on
    any referenced column that corresponds to a non-null referencing column. This occurs immediately after
    such a mark for deletion or update of the referenced row. Unique matching rows and non-unique matching
    rows for a referenced row are evaluated immediately after dropping the association between that referenced
    row and a non-unique matching row.
5) Let CTEC be the current trigger execution context. Let SSC be the set of state changes in CTEC. Let SCi
   be a state change in SSC.
6) Let F be a subtable or supertable of the referencing table.
    a) Let FL be the set of all columns of F. Let SRC be the set of referencing columns in F. Let SS be the
       set whose elements are the empty set and each subset of FL that contains at least one column in SRC.
       Let NSS be the number of sets in SS.
    b) Let PMC be the set of referencing columns in F that correspond with the referenced columns. Let PSS
       be the set whose elements are the empty set and each subset of FL that contains at least one column in
       PMC. Let PNSS be the number of sets in PSS.
    c) Let UMC be the set of referencing columns that correspond with updated referenced columns. Let USS
       be the set whose elements are the empty set and each subset of FL that contains at least one column in
       UMC. Let UNSS be the number of sets in USS.
7) For every row of the referenced table that is marked for deletion and has not previously been marked for
   deletion,
    Case:
    a) If SIMPLE is specified or implicit, or if FULL is specified, then
        Case:
        i)      If the <delete rule> specifies CASCADE, then for every F:
                1) Every matching row in F is marked for deletion.
                2) If no SCi has subject table F, trigger event DELETE, and an empty column list, then a state
                   change SCj is added to SSC as follows:



552 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                                ISO/IEC 9075-2:2003 (E)
                                                                                   11.8 <referential constraint definition>



                      A) The trigger event of SCj is DELETE.

                      B) The subject table of SCj is F.

                      C) The column list of SCj is empty.

                      D) The set of transitions of SCj is empty.
                           NOTE 257 — The set of transitions will have been replaced by a nonempty set by the time any triggers
                           activated by this state change are executed.

                      E) The set of statement-level triggers for which SCj is considered as executed is empty.

                      F) The set of row-level triggers consists of each row-level trigger that is activated by SCj,
                         paired with the empty set (of rows considered as executed).
         ii)      If the <delete rule> specifies SET NULL, then:
                  1) For every F, for each matching row MR in F, a transition is formed by pairing MR with the
                     value formed by copying MR and setting each referencing column in the copy to the null
                     value.
                  2) For every F, for every generated column GC in F that depends on some referencing column,
                     for every site GCS corresponding to GC in the new row NR of a transition for F, let GCR
                     be the result of evaluating, for NR, the generation expression included in the column
                     descriptor of GC. The General Rules of Subclause 9.2, “Store assignment”, are applied with
                     GCS as TARGET and GCR as VALUE.
                  3) The General Rules of Subclause 14.25, “Execution of BEFORE triggers”, are applied with
                     the following set of state changes BTSS:
                      A) For every F, for k ranging from 1 (one) to NSS, let SSk be the k-th set of SS.

                      B) BTSS contains a state change SCk as follows:

                           I)         The trigger event of SCk is UPDATE.

                           II)        The subject table of SCk is F.

                           III)       The column list of SCk is SSk.

                           IV)        The set of transitions of SCk is the set of transitions for F.

                           V)         The set of statement-level triggers for which SCk is considered as executed is
                                      empty.
                           VI)        The set of row-level triggers consists of each row-level trigger that is activated
                                      by SCk , paired with the empty set (of rows considered as executed).

                  4) For every matching row MR in every F, F is identified for replacement processing and MR
                     is identified for replacement in F. The General Rules of Subclause 14.22, “Effect of
                     replacing rows in base tables”, are applied.
                  5) For every F, for k ranging from 1 (one) to NSS, let SSk be the k-th set of SS.



©ISO/IEC 2003 – All rights reserved                                              Schema definition and manipulation 553
ISO/IEC 9075-2:2003 (E)
11.8 <referential constraint definition>



                   Case:
                   A) If no SCi has subject table F, trigger event UPDATE, and column list that is SSk, then
                      a state change SCj is added to SSC as follows:

                       I)     The trigger event of SCj is UPDATE.

                       II)    The subject table of SCj is F.

                       III)   The column list of SCj is SSk.

                       IV)    The set of transitions of SCj is the set of transitions for F.

                       V)     The set of statement-level triggers for which SCj is considered as executed is
                              empty.
                       VI)    The set of row-level triggers consists of each row-level trigger that is activated
                              by SCj, paired with the empty set (of rows considered as executed).

                   B) Otherwise, let SCj be the state change in SSC that has subject table F, trigger event
                      UPDATE, and a column list that is SSk. The set of transitions of SCj is the set of transi-
                      tions for F.
        iii)   If the <delete rule> specifies SET DEFAULT, then:
               1) For every F, for each matching row MR in F, a transition is formed by pairing MR with the
                  value formed by copying MR and setting each referencing column in the copy to the default
                  value specified in the General Rules of Subclause 11.5, “<default clause>”.
               2) For every F, for every generated column GC in F that depends on some referencing column,
                  for every site GCS corresponding to GC in the new row NR of a transition for F, let GCR
                  be the result of evaluating, for NR, the generation expression included in the column
                  descriptor of GC. The General Rules of Subclause 9.2, “Store assignment”, are applied with
                  GCS as TARGET and GCR as VALUE.
               3) The General Rules of Subclause 14.25, “Execution of BEFORE triggers”, are applied with
                  the following set of state changes BTSS:
                   A) For every F, for k ranging from 1 (one) to NSS, let SSk be the k-th set of SS.

                   B) BTSS contains a state change SCk as follows:

                       I)     The trigger event of SCk is UPDATE.

                       II)    The subject table of SCk is F.

                       III)   The column list of SCk is SSk.

                       IV)    The set of transitions of SCk is the set of transitions for F.

                       V)     The set of statement-level triggers for which SCk is considered as executed is
                              empty.



554 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                               ISO/IEC 9075-2:2003 (E)
                                                                                  11.8 <referential constraint definition>



                           VI)        The set of row-level triggers consists of each row-level trigger that is activated
                                      by SCk , paired with the empty set (of rows considered as executed).

                  4) For every matching row MR in every F, F is identified for replacement processing and MR
                     is identified for replacement in F. The General Rules of Subclause Subclause 14.22, “Effect
                     of replacing rows in base tables”, are applied.
                  5) For every F, for k ranging from 1 (one) to NSS, let SSk be the k-th set of SS.

                      Case:
                      A) If no SCi has subject table F, trigger event UPDATE, and a column list that is SSk, then
                         a state change SCj is added to SSC as follows:

                           I)         The trigger event of SCj is UPDATE.

                           II)        The subject table of SCj is F.

                           III)       The column list of SCj is SSk.

                           IV)        The set of transitions of SCj is a the set of transitions for F.

                           V)         The set of statement-level triggers for which SCj is considered as executed is
                                      empty.
                           VI)        The set of row-level triggers consists of each row-level trigger that is activated
                                      by SCj, paired with the empty set (of rows considered as executed).

                      B) Otherwise, let SCj be the state change in SSC that has subject table F, event UPDATE,
                         and column list that is SSk. The set of transitions of SCj is the set of transitions for F.

         iv)      If the <delete rule> specifies RESTRICT and there exists some matching row, then an exception
                  condition is raised: integrity constraint violation — restrict violation.
    b) If PARTIAL is specified, then
         Case:
         i)       If the <delete rule> specifies CASCADE, then for every F:
                  1) Every unique matching row in F is marked for deletion.
                  2) If no SCi has subject table F, event DELETE, and an empty column list, then a state change
                     SCj is added to SSC as follows:

                      A) The trigger event of SCj is DELETE.

                      B) The subject table of SCj is F.

                      C) The column list of SCj is empty.

                      D) The set of transitions of SCj is empty.




©ISO/IEC 2003 – All rights reserved                                             Schema definition and manipulation 555
ISO/IEC 9075-2:2003 (E)
11.8 <referential constraint definition>



                       NOTE 258 — The set of transitions will have been replaced by a nonempty set by the time any triggers
                       activated by this state change are executed.

                   E) The set of statement-level triggers for which SCj is considered as executed is empty.

                   F) The set of row-level triggers consists of each row-level trigger that is activated by SCj,
                      paired with the empty set (of rows considered as executed).
        ii)    If the <delete rule> specifies SET NULL, then:
               1) For every F, for each unique matching row UMR in F, a transition is formed by pairing
                  UMR with the value formed by copying UMR and setting each referencing column in the
                  copy to the null value.
               2) For every F, for every generated column GC in F that depends on some referencing column,
                  for every site GCS corresponding to GC in the new row NR of a transition for F, let GCR
                  be the result of evaluating, for NR, the generation expression included in the column
                  descriptor of GC. The General Rules of Subclause 9.2, “Store assignment”, are applied with
                  GCS as TARGET and GCR as VALUE.
               3) The General Rules of Subclause 14.25, “Execution of BEFORE triggers”, are applied with
                  the following set of state changes BTSS:
                   A) For every F, for k ranging from 1 (one) to NSS, let SSk be the k-th set of SS.

                   B) BTSS contains a state change SCk as follows:

                       I)      The trigger event of SCk is UPDATE.

                       II)     The subject table of SCk is F.

                       III)    The column list of SCk is SSk.

                       IV)     The set of transitions of SCk is the set of transitions for F.

                       V)      The set of statement-level triggers for which SCk is considered as executed is
                               empty.
                       VI)     The set of row-level triggers consists of each row-level trigger that is activated
                               by SCk, paired with the empty set (of rows considered as executed).

               4) For every unique matching row UMR in every F, F is identified for replacement processing
                  and UMR is identified for replacement in F. The General Rules of Subclause 14.22, “Effect
                  of replacing rows in base tables”, are applied.
               5) For every F, for k ranging from 1 (one) to NSS, let SSk be the k-th set of SS.

                   Case:
                   A) If no SCi has subject table F, trigger event UPDATE, and a column list that is SSk, then
                      a state change SCj is added to SSC as follows:

                       I)      The trigger event of SCj is UPDATE.




556 Foundation (SQL/Foundation)                                                           ©ISO/IEC 2003 – All rights reserved
                                                                                               ISO/IEC 9075-2:2003 (E)
                                                                                  11.8 <referential constraint definition>



                           II)        The subject table of SCj is F.

                           III)       The column list of SCj is SSk.

                           IV)        The set of transitions of SCj is a the set of transitions for F.

                           V)         The set of statement-level triggers for which SCj is considered as executed is
                                      empty.
                           VI)        The set of row-level triggers consists of each row-level trigger that is activated
                                      by SCj, paired with the empty set (of rows considered as executed).

                      B) Otherwise, let SCj be the state change in SSC that has subject table F, trigger event
                         UPDATE, and column list that is SSk. The set of transitions of SCj is the set of transitions
                         of F.
         iii)     If the <delete rule> specifies SET DEFAULT, then:
                  1) For every F, for each unique matching row UMR in F, a transition is formed pairing UMR
                     with the value formed by copying UMR and setting each referencing column in the copy to
                     the default value specified in the General Rules of Subclause 11.5, “<default clause>”.
                  2) For every F, for every generated column GC in F that depends on some referencing column,
                     for every site GCS corresponding to GC in the new row NR of a transition for F, let GCR
                     be the result of evaluating, for NR, the generation expression included in the column
                     descriptor of GC. The General Rules of Subclause 9.2, “Store assignment”, are applied with
                     GCS as TARGET and GCR as VALUE.
                  3) The General Rules of Subclause 14.25, “Execution of BEFORE triggers”, are applied with
                     the following set of state changes BTSS:
                      A) For every F, for k ranging from 1 (one) to NSS, let SSk be the k-th set of SS.

                      B) BTSS contains a state change SCk as follows:

                           I)         The trigger event of SCk is UPDATE.

                           II)        The subject table of SCk is F.

                           III)       The column list of SCk is SSk.

                           IV)        The set of transitions of SCk is the set of transitions for F.

                           V)         The set of statement-level triggers for which SCk is considered as executed is
                                      empty.
                           VI)        The set of row-level triggers consists of each row-level trigger that is activated
                                      by SCk, paired with the empty set (of rows considered as executed).

                  4) For every unique matching row UMR in every F, F is identified for replacement processing
                     and UMR is identified for replacement in F. The General Rules of Subclause 14.22, “Effect
                     of replacing rows in base tables”, are applied.



©ISO/IEC 2003 – All rights reserved                                             Schema definition and manipulation 557
ISO/IEC 9075-2:2003 (E)
11.8 <referential constraint definition>



                5) For every F, for k ranging from 1 (one) to NSS, let SSk be the k-th set of SS.

                    Case:
                    A) If no SCi has subject table F, trigger event UPDATE, and a column list that is SSk, then
                       a new state change SCj is added to SSC as follows:

                         I)      The trigger event of SCj is UPDATE.

                         II)     The subject table of SCj is F.

                         III)    The column list of SCj is SSk.

                         IV)     The set of transitions of SCj is the set of transitions for F.

                         V)      The set of statement-level triggers for which SCk is considered as executed is
                                 empty.
                         VI)     The set of row-level triggers consists of each row-level trigger that is activated
                                 by SCk, paired with the empty set (of rows considered as executed).

                    B) Otherwise, let SCj be the state change in SSC that has subject table F, trigger event
                       UPDATE, and a column list that is SSk. The set of transitions of SCj is the set of transi-
                       tions for F.
        iv)     If the <delete rule> specifies RESTRICT and there exists some unique matching row, then an
                exception condition is raised: integrity constraint violation — restrict violation.
                NOTE 259 — Otherwise, the <referential action> is not performed.

8) If a non-null value of a referenced column RC in the referenced table is updated to a value that is distinct
   from the current value of RC, then for every member F of the subtable family of the referencing table:
    Case:
    a) If SIMPLE is specified or implicit, or if FULL is specified, then
        Case:
        i)      If the <update rule> specifies CASCADE, then:
                1) For every F, for each matching row MR in F, a transition is formed by pairing MR with the
                   value formed by copying MR and setting each referencing column in the copy that corre-
                   sponds with a referenced column to the new value of that referenced column.
                2) For every F, for every generated column GC in F that depends on some referencing column,
                   for every site GCS corresponding to GC in the new row NR of a transition for F, let GCR
                   be the result of evaluating, for NR, the generation expression included in the column
                   descriptor of GC. The General Rules of Subclause 9.2, “Store assignment”, are applied with
                   GCS as TARGET and GCR as VALUE.
                3) The General Rules of Subclause 14.25, “Execution of BEFORE triggers”, are applied with
                   the following set of state changes BTSS:
                    A) For every F, for k ranging from 1 (one) to PNSS, let SSk be the k-th set of PSS.


558 Foundation (SQL/Foundation)                                                        ©ISO/IEC 2003 – All rights reserved
                                                                                               ISO/IEC 9075-2:2003 (E)
                                                                                  11.8 <referential constraint definition>



                      B) BTSS contains a state change SCk as follows:

                           I)         The trigger event of SCk is UPDATE.

                           II)        The subject table of SCk is F.

                           III)       The column list of SCk is SSk.

                           IV)        The set of transitions of SCk is the set of transitions for F.

                           V)         The set of statement-level triggers for which SCk is considered as executed is
                                      empty.
                           VI)        The set of row-level triggers consists of each row-level trigger that is activated
                                      by SCk, paired with the empty set (of rows considered as executed).

                  4) For every matching row MR in every F, F is identified for replacement processing and MR
                     is identified for replacement in F.
                  5) For every F, for k ranging from 1 (one) to PNSS, let SSk be the k-th set of PSS.

                      Case:
                      A) If no SCi has subject table F, trigger event UPDATE, and a column list that is SSk, then
                         a state change SCj is added to SSC as follows:

                           I)         The trigger event of SCj is UPDATE.

                           II)        The subject table of SCj is F.

                           III)       The column list of SCj is SSk.

                           IV)        The set of transitions of SCj is the set of transitions for F.

                           V)         The set of statement-level triggers for which SCj is considered as executed is
                                      empty.
                           VI)        The set of row-level triggers consists of each row-level trigger that is activated
                                      by SCj, paired with the empty set (of rows considered as executed).

                      B) Otherwise, let SCj be the state change in SSC that has subject table F, trigger event
                         UPDATE, and a column list that is SSk. The set of transitions of SCj is the set of transi-
                         tions for F.
         ii)      If the <update rule> specifies SET NULL, then
                  Case:
                  1) If SIMPLE is specified or implicit, then:
                      A) For every F, for each matching row MR in F, a transition is formed by pairing MR with
                         the value formed by copying MR and setting each referencing column in the copy to the
                         null value.



©ISO/IEC 2003 – All rights reserved                                             Schema definition and manipulation 559
ISO/IEC 9075-2:2003 (E)
11.8 <referential constraint definition>



                   B) For every F, for every generated column GC in F that depends on some referencing
                      column, for every site GCS corresponding to GC in the new row NR of a transition for
                      F, let GCR be the result of evaluating, for NR, the generation expression included in the
                      column descriptor of GC. The General Rules of Subclause 9.2, “Store assignment”, are
                      applied with GCS as TARGET and GCR as VALUE.
                   C) The General Rules of Subclause 14.25, “Execution of BEFORE triggers”, are applied
                      with the following set of state changes BTSS:
                       I)      For every F, for k ranging from 1 (one) to PNSS, let SSk be the k-th set of PSS.

                       II)     BTSS contains a state change SCk as follows:

                               1) The trigger event of SCk is UPDATE.

                               2) The subject table of SCk is F.

                               3) The column list of SCk is SSk.

                               4) The set of transitions of SCk is the set of transitions for F.

                               5) The set of statement-level triggers for which SCk is considered as executed
                                  is empty.
                               6) The set of row-level triggers consists of each row-level trigger that is activated
                                  by SCk, paired with the empty set (of rows considered as executed).

                   D) For every matching row MR in every F, F is identified for replacement processing and
                      MR is identified for replacement in F.
                   E) For every F, for k ranging from 1 (one) to NSS, let SSk be the k-th set of SS.

                       Case:
                       I)      If no SCi has subject table F, trigger event UPDATE, and a column list that is
                               SSk, then a state change SCj is added to SSC as follows:

                               1) The trigger event of SCj is UPDATE.

                               2) The subject table of SCj is F.

                               3) The column list of SCj is SSk.

                               4) The set of transitions of SCj is the set of transitions for F.

                               5) The set of statement-level triggers for which SCj is considered as executed
                                  is empty.
                               6) The set of row-level triggers consists of each row-level trigger that is activated
                                  by SCj, paired with the empty set (of rows considered as executed).




560 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                              ISO/IEC 9075-2:2003 (E)
                                                                                 11.8 <referential constraint definition>



                           II)        Otherwise, let SCj be the state change in SSC that has subject table F, trigger
                                      event UPDATE, and a column list that is SSk. The set of transitions of SCj is the
                                      set of transitions of F.
                  2) If <match type> specifies FULL, then:
                      A) For every F, for each matching row MR in F, a transition is formed by pairing MR with
                         the value formed by copying MR and setting each referencing column in the copy that
                         corresponds with a referenced column to the null value.
                      B) For every F, for every generated column GC in F that depends on some referencing
                         column, for every site GCS corresponding to GC in the new row NR of a transition for
                         F, let GCR be the result of evaluating, for NR, the generation expression included in the
                         column descriptor of GC. The General Rules of Subclause 9.2, “Store assignment”, are
                         applied with GCS as TARGET and GCR as VALUE.
                      C) The General Rules of Subclause 14.25, “Execution of BEFORE triggers”, are applied
                         with the following set of state changes BTSS:
                           I)         For every F, for k ranging from 1 (one) to NSS, let SSk be the k-th set of SS.

                           II)        BTSS contains a state change SCk as follows:

                                      1) The trigger event of SCk is UPDATE.

                                      2) The subject table of SCk is F.

                                      3) The column list of SCk is SSk.

                                      4) The set of transitions of SCk is the set of transitions for F.

                                      5) The set of statement-level triggers for which SCk is considered as executed
                                         is empty.
                                      6) The set of row-level triggers consists of each row-level trigger that is activated
                                         by SCk, paired with the empty set (of rows considered as executed).

                      D) For every matching row MR in every F, F is identified for replacement processing and
                         MR is identified for replacement in F.
                      E) For every F, for k ranging from 1 (one) to NSS, let SSk be the k-th set of SS.

                           Case:
                           I)         If no SCi has subject table F, trigger event UPDATE, and a column list that is
                                      SSk, then a state change SCj is added to SSC as follows:

                                      1) The trigger event of SCj is UPDATE.

                                      2) The subject table of SCj is F.

                                      3) The column list of SCj is SSk.




©ISO/IEC 2003 – All rights reserved                                            Schema definition and manipulation 561
ISO/IEC 9075-2:2003 (E)
11.8 <referential constraint definition>



                              4) The set of transitions of SCj is the set of transitions for F.

                              5) The set of statement-level triggers for which SCj is considered as executed
                                 is empty.
                              6) The set of row-level triggers consists of each row-level trigger that is activated
                                 by SCj, paired with the empty set (of rows considered as executed).

                       II)    Otherwise, let SCj be the state change in SSC that has subject table F, trigger
                              event UPDATE, and a column list that is SSk. The set of transitions of SCj is the
                              set of transitions for F.
        iii)   If the <update rule> specifies SET DEFAULT, then:
               1) For every F, for each matching row MR in F, a transition is formed by pairing MR with the
                  value formed by copying MR and setting each referencing column in the copy that corre-
                  sponds with a referenced column to the default value specified in the General Rules of
                  Subclause 11.5, “<default clause>”.
               2) For every F, for every generated column GC in F that depends on some referencing column,
                  for every site GCS corresponding to GC in the new row NR of a transition for F, let GCR
                  be the result of evaluating, for NR, the generation expression included in the column
                  descriptor of GC. The General Rules of Subclause 9.2, “Store assignment”, are applied with
                  GCS as TARGET and GCR as VALUE.
               3) The General Rules of Subclause 14.25, “Execution of BEFORE triggers”, are applied with
                  the following set of state changes BTSS:
                   A) For every F, for k ranging from 1 (one) to PNSS, let SSk be the k-th set of PSS.

                   B) BTSS contains a state change SCk as follows:

                       I)     The trigger event of SCk is UPDATE.

                       II)    The subject table of SCk is F.

                       III)   The column list of SCk is SSk.

                       IV)    The set of transitions of SCk is the set of transitions for F.

                       V)     The set of statement-level triggers for which SCk is considered as executed is
                              empty.
                       VI)    The set of row-level triggers consists of each row-level trigger that is activated
                              by SCk, paired with the empty set (of rows considered as executed).

               4) For every matching row MR in every F, F is identified for replacement processing and MR
                  is identified for replacement in F.
               5) For every F, for k ranging from 1 (one) to PNSS, let SSk be the k-th set of PSS.

                   Case:




562 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                                       11.8 <referential constraint definition>



                      A) If no SCi has subject table F, trigger event UPDATE, and a column list that is SSk, then
                         a state change SCj is added to SSC as follows:

                           I)         The trigger event of SCj is UPDATE.

                           II)        The subject table of SCj is F.

                           III)       The column list of SCj is SSk.

                           IV)        The set of transitions of SCj is the set of transitions for F.

                           V)         The set of statement-level triggers for which SCj is considered as executed is
                                      empty.
                           VI)        The set of row-level triggers consists of each row-level trigger that is activated
                                      by SCj, paired with the empty set (of rows considered as executed).

                      B) Otherwise, let SCj be the state change in SSC that has subject table F, event UPDATE,
                         and a column list that is SSk. The set of transitions of SCj is the set of transitions for F.

         iv)      If the <update rule> specifies RESTRICT and there exists some matching row, then an exception
                  condition is raised: integrity constraint violation — restrict violation.
    b) If PARTIAL is specified, then
         Case:
         i)       If the <update rule> specifies CASCADE, then:
                  1) For every F, for each unique matching row UMR in F that contains a non-null value in the
                     referencing column C1 in F that corresponds to the updated referenced column C2, a transition
                     is formed by pairing UMR with the value formed by copying UMR and setting C1 in the
                     copy to the new value V of C2, provided that, in all updated rows in the referenced table
                     that formerly had, during the same execution of the same innermost SQL-statement, that
                     unique matching row as a matching row, the values in C2 have all been updated to a value
                     that is not distinct from V. If this last condition is not satisfied, then an exception condition
                     is raised: triggered data change violation.
                      NOTE 260 — Because of the Rules of Subclause 8.2, “<comparison predicate>”, on which the definition of
                      “distinct” relies, the values in C2 may have been updated to values that are not distinct, yet are not identical.
                      Which of these non-distinct values is used for the cascade operation is implementation-dependent.

                  2) For every F, for every generated column GC in F that depends on some referencing column,
                     for every site GCS corresponding to GC in the new row NR of a transition for F, let GCR
                     be the result of evaluating, for NR, the generation expression included in the column
                     descriptor of GC. The General Rules of Subclause 9.2, “Store assignment”, are applied with
                     GCS as TARGET and GCR as VALUE.
                  3) The General Rules of Subclause 14.25, “Execution of BEFORE triggers”, are applied with
                     the following set of state changes BTSS:
                      A) For every F, for k ranging from 1 (one) to UNSS, let SSk be the k-th set of USS.

                      B) BTSS contains a state change SCk as follows:


©ISO/IEC 2003 – All rights reserved                                                  Schema definition and manipulation 563
ISO/IEC 9075-2:2003 (E)
11.8 <referential constraint definition>



                       I)     The trigger event of SCk is UPDATE.

                       II)    The subject table of SCk is F.

                       III)   The column list of SCk is SSk.

                       IV)    The set of transitions of SCk is the set of transitions for F.

                       V)     The set of statement-level triggers for which SCk is considered as executed is
                              empty.
                       VI)    The set of row-level triggers consists of each row-level trigger that is activated
                              by SCk, paired with the empty set (of rows considered as executed).

               4) For every unique matching row UMR in every F, F is identified for replacement processing
                  and UMR is identified for replacement in F.
               5) For every F, for k ranging from 1 (one) to UNSS, let SSk be the k-th set of USS.

                   Case:
                   A) If no SCi has subject table F, trigger event UPDATE, and a column list that is SSk, then
                      a state change SCj is added to SSC as follows:

                       I)     The trigger event of SCj is UPDATE.

                       II)    The subject table of SCj is F.

                       III)   The column list of SCj is SSk.

                       IV)    The set of transitions of SCj is the set of transitions for F.

                       V)     The set of statement-level triggers for which SCj is considered as executed is
                              empty.
                       VI)    The set of row-level triggers consists of each row-level trigger that is activated
                              by SCj, paired with the empty set (of rows considered as executed).

                   B) Otherwise, let SCj be the state change in SSC that has subject table F, trigger event
                      UPDATE, and a column list that is SSk. The set of transitions of SCj is the set of transi-
                      tions for F.
        ii)    If the <update rule> specifies SET NULL, then:
               1) For every F, for each unique matching row UMR in F that contains a non-null value in the
                  referencing column in F that corresponds with the updated referenced column, a transition
                  is formed by pairing UMR with the value formed by copying UMR and setting that referencing
                  column in the copy to the null value.
               2) For every F, for every generated column GC in F that depends on some referencing column,
                  for every site GCS corresponding to GC in the new row NR of a transition for F, let GCR
                  be the result of evaluating, for NR, the generation expression included in the column



564 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                               ISO/IEC 9075-2:2003 (E)
                                                                                  11.8 <referential constraint definition>



                      descriptor of GC. The General Rules of Subclause 9.2, “Store assignment”, are applied with
                      GCS as TARGET and GCR as VALUE.
                  3) The General Rules of Subclause 14.25, “Execution of BEFORE triggers”, are applied with
                     the following set of state changes BTSS:
                      A) For every F, for k ranging from 1 (one) to UNSS, let SSk be the k-th set of USS.

                      B) BTSS contains a state change SCk as follows:

                           I)         The trigger event of SCk is UPDATE.

                           II)        The subject table of SCk is F.

                           III)       The column list of SCk is SSk.

                           IV)        The set of transitions of SCk is the set of transitions for F.

                           V)         The set of statement-level triggers for which SCk is considered as executed is
                                      empty.
                           VI)        The set of row-level triggers consists of each row-level trigger that is activated
                                      by SCk, paired with the empty set (of rows considered as executed).

                  4) For every unique matching row UMR in every F, F is identified for replacement processing
                     and UMR is identified for replacement in F.
                  5) For every F, for k ranging from 1 (one) to NSS, let SSk be the k-th set of SS.

                      Case:
                      A) If no SCi has subject table F, trigger event UPDATE, and a column list that is SSk, then
                         a state change SCj is added to SSC as follows:

                           I)         The trigger event of SCj is UPDATE.

                           II)        The subject table of SCj is F.

                           III)       The column list of SCj is SSk.

                           IV)        The set of transitions of SCj is the set of transitions for F.

                           V)         The set of statement-level triggers for which SCj is considered as executed is
                                      empty.
                           VI)        The set of row-level triggers consists of each row-level trigger that is activated
                                      by SCj, paired with the empty set (of rows considered as executed).

                      B) Otherwise, let SCj be the state change in SSC that has subject table F, trigger event
                         UPDATE, and a column list that is SSk. The set of transitions of SCj is the set of transi-
                         tions for F.
         iii)     If the <update rule> specifies SET DEFAULT, then:



©ISO/IEC 2003 – All rights reserved                                             Schema definition and manipulation 565
ISO/IEC 9075-2:2003 (E)
11.8 <referential constraint definition>



               1) For every F, for each unique matching row UMR in F that contains a non-null value in the
                  referencing column in F that corresponds with the updated referenced column, a transition
                  is formed by pairing UMR with the value formed by copying UMR and setting that referencing
                  column in the copy to the default value specified in the General Rules of Subclause 11.5,
                  “<default clause>”.
               2) For every F, for every generated column GC in F that depends on some referencing column,
                  for every site GCS corresponding to GC in the new row NR of a transition for F, let GCR
                  be the result of evaluating, for NR, the generation expression included in the column
                  descriptor of GC. The General Rules of Subclause 9.2, “Store assignment”, are applied with
                  GCS as TARGET and GCR as VALUE.
               3) The General Rules of Subclause 14.25, “Execution of BEFORE triggers”, are applied with
                  the following set of state changes BTSS:
                   A) For every F, for k ranging from 1 (one) to UNSS, let SSk be the k-th set of USS.

                   B) BTSS contains a state change SCk as follows:

                       I)     The trigger event of SCk is UPDATE.

                       II)    The subject table of SCk is F.

                       III)   The column list of SCk is SSk.

                       IV)    The set of transitions of SCk is the set of transitions for F.

                       V)     The set of statement-level triggers for which SCk is considered as executed is
                              empty.
                       VI)    The set of row-level triggers consists of each row-level trigger that is activated
                              by SCk, paired with the empty set (of rows considered as executed).

               4) For every unique matching row UMR in every F, F is identified for replacement processing
                  and UMR is identified for replacement in F.
               5) For every F, for k ranging from 1 (one) to UNSS, let SSk be the k-th set of USS.

                   Case:
                   A) If no SCi has subject table F, trigger event UPDATE, and a column list that is SSk, then
                      a state change SCj is added to SSC as follows:

                       I)     The trigger event of SCj is UPDATE.

                       II)    The subject table of SCj is F.

                       III)   The column list of SCj is SSk.

                       IV)    The set of transitions of SCj is the set of transitions for F.

                       V)     The set of statement-level triggers for which SCj is considered as executed is
                              empty.



566 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                                 ISO/IEC 9075-2:2003 (E)
                                                                                    11.8 <referential constraint definition>



                           VI)        The set of row-level triggers consists of each row-level trigger that is activated
                                      by SCj, paired with the empty set (of rows considered as executed).

                      B) Otherwise, let SCj be the state change in SSC that has subject table F, trigger event
                         UPDATE, and a column list that is SSk. The set of transitions of SCj is the set of transi-
                         tions for F.
         iv)      If the <update rule> specifies RESTRICT and there exists some unique matching row, then an
                  exception condition is raised: integrity constraint violation — restrict violation.
         NOTE 261 — Otherwise, the <referential action> is not performed.

9) Let ISS be the innermost SQL-statement being executed.
10) If evaluation of these General Rules during the execution of ISS would cause an update of some site to a
    value that is distinct from the value to which that site was previously updated during the execution of ISS,
    then an exception condition is raised: triggered data change violation.
11) If evaluation of these General Rules during the execution of ISS would cause deletion of a row containing
    a site that is identified for replacement in that row, then an exception condition is raised: triggered data
    change violation.
12) If evaluation of these General Rules during the execution of ISS would cause either an attempt to update a
    row that has been deleted by any <delete statement: positioned> or <dynamic delete statement: positioned>
    that identifies some cursor CR that is still open or has been updated by any <update statement: positioned>
    or <dynamic delete statement: positioned> that identifies some cursor CR that is still open, or an attempt
    to mark for deletion such a row, then a completion condition is raised: warning — cursor operation conflict.
13) For every row RMD that is marked for deletion, every subrow of RMD and every superrow of RMD is
    marked for deletion.
14) If any table T is the subject table of a state change in SSC that has been created or modified during evaluation
    of the preceding General Rules of this subclause, then, for every referential constraint descriptor, the pre-
    ceding General Rules of this subclause are applied.
    NOTE 262 — Thus these rules are repeatedly evaluated until no further transitions are generated.

15) The General Rules of Subclause 14.25, “Execution of BEFORE triggers”, are applied with the following
    set of state changes BTSS.
    For each table Fi that contains a row that is marked for deletion, BTSS contains a state change SCi as follows:

    a) The trigger event of SCi is DELETE.

    b) The subject table of SCi is Fi.

    c) The column list of SCi is empty.

    d) The set of transitions of SCi is a copy of the set of rows in Fi that are marked for deletion.

    e) The set of statement-level triggers for which SCi is considered as executed is empty.

    f) The set of row-level triggers consists of each row-level trigger that is activated by SCi, paired with the
       empty set (of rows considered as executed).



©ISO/IEC 2003 – All rights reserved                                               Schema definition and manipulation 567
ISO/IEC 9075-2:2003 (E)
11.8 <referential constraint definition>



16) For each table Fi that contains a row that is marked for deletion, let SCj be the state change in SSC that has
    subject table Fi, trigger event DELETE, and an empty column list. A copy of the rows in Fi that are marked
    for deletion constitutes the set of transitions of SCj.


Conformance Rules
1) Without Feature T191, “Referential action RESTRICT”, conforming SQL language shall not contain a
   <referential action> that contains RESTRICT.
2) Without Feature F741, “Referential MATCH types”, conforming SQL language shall not contain a <refer-
   ences specification> that contains MATCH.
3) Without Feature F191, “Referential delete actions”, conforming SQL language shall not contain a <delete
   rule>.
4) Without Feature F701, “Referential update actions”, conforming SQL language shall not contain an <update
   rule>.
5) Without Feature T201, “Comparable data types for referential constraints”, conforming SQL language shall
   not contain a <referencing columns> in which the data type of each referencing column is not the same as
   the data type of the corresponding referenced column.
    NOTE 263 — The Conformance Rules of Subclause 9.10, “Grouping operations”, also apply.




568 Foundation (SQL/Foundation)                                                          ©ISO/IEC 2003 – All rights reserved
                                                                                               ISO/IEC 9075-2:2003 (E)
                                                                                       11.9 <check constraint definition>



11.9 <check constraint definition>

Function
Specify a condition for the SQL-data.


Format
<check constraint definition> ::= CHECK <left paren> <search condition> <right paren>


Syntax Rules
1) The <search condition> shall not contain a <target specification>.
2) The <search condition> shall not contain a <set function specification> that is not contained in a <subquery>.
3) If <check constraint definition> is contained in a <table definition> or <alter table statement>, then let T
   be the table identified by the containing <table definition> or <alter table statement>.
    Case:
    a) If T is a persistent base table, or if the <check constraint definition> is contained in a <domain definition>
       or <alter domain statement>, then no <table reference> generally contained in the <search condition>
       shall reference a temporary table.
    b) If T is a global temporary table, then no <table reference> generally contained in the <search condition>
       shall reference a table other than a global temporary table.
    c) If T is a created local temporary table, then no <table reference> generally contained in the <search
       condition> shall reference a table other than either a global temporary table or a created local temporary
       table.
    d) If T is a declared local temporary table, then no <table reference> generally contained in the <search
       condition> shall reference a persistent base table.
4) If the <check constraint definition> is contained in a <table definition> that defines a temporary table and
   specifies ON COMMIT PRESERVE ROWS or a <temporary table declaration> that specifies ON COMMIT
   PRESERVE ROWS, then no <subquery> in the <search condition> shall reference a temporary table
   defined by a <table definition> or a <temporary table declaration> that specifies ON COMMIT DELETE
   ROWS.
5) The <search condition> shall simply contain a <boolean value expression> that is retrospectively determin-
   istic.
    NOTE 264 — “retrospectively deterministic” is defined in Subclause 6.34, “<boolean value expression>”.

6) The <search condition> shall not generally contain a <routine invocation> whose subject routine is an SQL-
   invoked routine that possibly modifies SQL-data.
7) Let A be the <authorization identifier> that owns T.




©ISO/IEC 2003 – All rights reserved                                             Schema definition and manipulation 569
ISO/IEC 9075-2:2003 (E)
11.9 <check constraint definition>



Access Rules
    None.


General Rules
1) A <check constraint definition> defines a check constraint.
    NOTE 265 — Subclause 10.8, “<constraint name definition> and <constraint characteristics>”, specifies when a constraint is
    effectively checked. The General Rules that control the evaluation of a check constraint can be found in either Subclause 11.6,
    “<table constraint definition>”, or Subclause 11.24, “<domain definition>”, depending on whether it forms part of a table constraint
    or a domain constraint.

2) If the character representation of the <search condition> cannot be represented in the Information Schema
   without truncation, then a completion condition is raised: warning — search condition too long for infor-
   mation schema.
    NOTE 266 — The Information Schema is defined in ISO/IEC 9075-11.


Conformance Rules
1) Without Feature F671, “Subqueries in CHECK constraints”, conforming SQL language shall not contain
   a <search condition> contained in a <check constraint definition> that contains a <subquery>.
2) Without Feature F672, “Retrospective check constraints”, conforming SQL language shall not contain a
   <check constraint definition> that generally contains CURRENT_DATE, CURRENT_TIMESTAMP, or
   LOCALTIMESTAMP.




570 Foundation (SQL/Foundation)                                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                 11.10 <alter table statement>



11.10 <alter table statement>

Function
Change the definition of a table.


Format
<alter table statement> ::= ALTER TABLE <table name> <alter table action>

<alter table action> ::=
    <add column definition>
  | <alter column definition>
  | <drop column definition>
  | <add table constraint definition>
  | <drop table constraint definition>


Syntax Rules
1) Let T be the table identified by the <table name>.
2) The schema identified by the explicit or implicit schema name of the <table name> shall include the
   descriptor of T.
3) The scope of the <table name> is the entire <alter table statement>.
4) T shall be a base table.
5) T shall not be a declared local temporary table.


Access Rules
1) The enabled authorization identifiers shall include the <authorization identifier> that owns the schema
   identified by the <schema name> of the table identified by <table name>.


General Rules
1) The base table descriptor of T is modified as specified by <alter table action>.
2) If <add column definition> or <drop column definition> is specified, then the row type RT of T is the set
   of pairs (<field name>, <data type>) where <field name> is the name of a column C of T and <data type>
   is the declared type of C. This set of pairs contains one pair for each column of T in the order of their
   ordinal position in T.


Conformance Rules
    None.



©ISO/IEC 2003 – All rights reserved                                  Schema definition and manipulation 571
ISO/IEC 9075-2:2003 (E)
11.11 <add column definition>



11.11 <add column definition>

Function
Add a column to a table.


Format
<add column definition> ::= ADD [ COLUMN ] <column definition>


Syntax Rules
1) Let T be the table identified by the <table name> immediately contained in the containing <alter table
   statement>.
2) T shall not be a referenceable table.
3) If <column definition> contains <identity column specification>, then the table descriptor of T shall not
   include a column descriptor of an identity column.


Access Rules
    None.


General Rules
1) The column defined by the <column definition> is added to T.
2) Let C be the column added to T.
    Case:
    a) If C is a generated column, then let TN be the <table name> immediately contained in the containing
       <alter table statement>, let CN be the <column name> immediately contained in <column definition>,
       and let GE be the generation expression included in the column descriptor of C. The following <update
       statement: searched> is executed without further Syntax Rule or Access Rule checking:
             UPDATE TN SET CN = GE

    b) Otherwise, C is a base column.
        Case:
        i)      If C is an identity column, then for each row in T let CS be the site corresponding to C and let
                NV be the result of applying the General Rules of Subclause 9.21, “Generation of the next value
                of a sequence generator”, with the sequence descriptor included in the column descriptor of C
                as SEQUENCE.
                Case:


572 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                                11.11 <add column definition>



                  1) If the declared type of C is a distinct type DIST, then let CNV be DIST(NV).
                  2) Otherwise, let CNV be NV.
                  The General Rules of Subclause 9.2, “Store assignment”, are applied with CS as TARGET and
                  CNV as VALUE.
         ii)      Otherwise, every value in C is the default value for C.
    NOTE 267 — The default value of a column is defined in Subclause 11.5, “<default clause>”.
    NOTE 268 — The addition of a column to a table has no effect on any existing <query expression> included in a view descriptor,
    <triggered action> included in a trigger descriptor, or <search condition> included in a constraint descriptor because any implicit
    column references in these descriptor elements are syntactically substituted by explicit column references under the Syntax Rules
    of Subclause 7.12, “<query specification>”. Furthermore, by implication (from the lack of any General Rules to the contrary), the
    meaning of a column reference is never retroactively changed by the addition of a column subsequent to the invocation of the
    <SQL schema statement> containing that column reference.

3) For every table privilege descriptor that specifies T and a privilege of SELECT, UPDATE, INSERT or
   REFERENCES, a new column privilege descriptor is created that specifies T, the same action, grantor, and
   grantee, and the same grantability, and specifies the <column name> of the <column definition>.
4) In all other respects, the specification of a <column definition> in an <alter table statement> has the same
   effect as specification of the <column definition> in the <table definition> for T would have had. In partic-
   ular, the degree of T is increased by 1 (one) and the ordinal position of that column is equal to the new
   degree of T as specified in the General Rules of Subclause 11.4, “<column definition>”.


Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved                                                 Schema definition and manipulation 573
ISO/IEC 9075-2:2003 (E)
11.12 <alter column definition>



11.12 <alter column definition>

Function
Change a column and its definition.


Format
<alter column definition> ::=
    ALTER [ COLUMN ] <column name> <alter column action>

<alter column action> ::=
    <set column default clause>
  | <drop column default clause>
  | <add column scope clause>
  | <drop column scope clause>
  | <alter identity column specification>


Syntax Rules
1) Let T be the table identified in the containing <alter table statement>.
2) Let C be the column identified by the <column name>.
3) C shall be a column of T.
4) If C is the self-referencing column of T or C is a generated column of T, then <alter column action> shall
   not contain <add column scope clause> or <drop column scope clause>.
5) If C is an identity column, then <alter column action> shall contain <alter identity column specification>.
6) If <alter identity column specification> is specified, then C shall be an identity column.


Access Rules
    None.


General Rules
1) The column descriptor of C is modified as specified by <alter column action>.


Conformance Rules
1) Without Feature F381, “Extended schema manipulation”, conforming SQL language shall not contain an
   <alter column definition>.




574 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                           11.13 <set column default clause>



11.13 <set column default clause>

Function
Set the default clause for a column.


Format
<set column default clause> ::= SET <default clause>


Syntax Rules
    None.


Access Rules
    None.


General Rules
1) Let C be the column identified by the <column name> in the containing <alter column definition>.
2) The default value specified by the <default clause> is placed in the column descriptor of C.


Conformance Rules
1) Without Feature F381, “Extended schema manipulation”, conforming SQL language shall not contain a
   <set column default clause>.




©ISO/IEC 2003 – All rights reserved                                 Schema definition and manipulation 575
ISO/IEC 9075-2:2003 (E)
11.14 <drop column default clause>



11.14 <drop column default clause>

Function
Drop the default clause from a column.


Format
<drop column default clause> ::= DROP DEFAULT


Syntax Rules
1) Let C be the column identified by the <column name> in the containing <alter column definition>.
2) The descriptor of C shall include a default value.


Access Rules
    None.


General Rules
1) The default value is removed from the column descriptor of C.


Conformance Rules
1) Without Feature F381, “Extended schema manipulation”, conforming SQL language shall not contain a
   <drop column default clause>.




576 Foundation (SQL/Foundation)                                              ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                              11.15 <add column scope clause>



11.15 <add column scope clause>

Function
Add a non-empty scope for an existing column of data type REF in a base table.


Format
<add column scope clause> ::= ADD <scope clause>


Syntax Rules
1) Let C be the column identified by the <column name> in the containing <alter column definition>. The
   declared type of C shall be some reference type. Let RTD be the reference type descriptor included in the
   descriptor of C.
2) Let T be the table identified by the <table name> in the containing <alter table statement>. If T is a refer-
   enceable table, then C shall be an originally-defined column of T.
3) RTD shall not include a scope.
4) Let UDTN be the name of the referenced type included in RTD.
5) The <table name> STN contained in the <scope clause> shall identify a referenceable table whose structured
   type is UDTN.


Access Rules
    None.


General Rules
1) STN is included as the scope in the reference type descriptor included in the column descriptor of C.
2) For any proper subtable PST of T, let PSC be the column whose corresponding column in T is C. STN is
   included as the scope in the reference type descriptor included in the column descriptor of PSC.


Conformance Rules
1) Without Feature F381, “Extended schema manipulation”, conforming SQL language shall not contain an
   <add column scope clause>.
2) Without Feature S043, “Enhanced reference types”, conforming SQL language shall not contain an <add
   column scope clause>.




©ISO/IEC 2003 – All rights reserved                                   Schema definition and manipulation 577
ISO/IEC 9075-2:2003 (E)
11.16 <drop column scope clause>



11.16 <drop column scope clause>

Function
Drop the scope from an existing column of data type REF in a base table.


Format
<drop column scope clause> ::= DROP SCOPE <drop behavior>


Syntax Rules
1) Let C be the column identified by the <column name> in the containing <alter column definition>. The
   declared type of C shall be some reference type whose reference type descriptor includes a scope.
2) Let T be the table identified by the <table name> in the containing <alter table statement>. If T is a refer-
   enceable table, then C shall be an originally-defined column of T.
3) Let SC be the set of columns consisting of C and, for every proper subtable of T, the column whose super-
   column is C.
4) An impacted dereference operation is a <dereference operation> whose <reference value expression> is a
   column reference that identifies a column in SC, a <method reference> whose <value expression primary>
   is a column reference that identifies a column in SC, or a <reference resolution> whose <reference value
   expression> is a column reference that identifies a column in SC.
5) If RESTRICT is specified, then no impacted dereference operation shall be contained in any of the following:
    a) The SQL routine body of any routine descriptor.
    b) The <query expression> of any view descriptor.
    c) The <search condition> of any constraint descriptor.
    d) The triggered action of any trigger descriptor.
    NOTE 269 — If CASCADE is specified, then such referencing objects will be dropped by the execution of the <SQL procedure
    statement>s specified in the General Rules of this Subclause.


Access Rules
    None.


General Rules
1) For every SQL-invoked routine R whose routine descriptor includes an SQL routine body that contains an
   impacted dereference operation, let SN be the <specific name> of R. The following <drop routine statement>
   is effectively executed for every R without further Access Rule checking:




578 Foundation (SQL/Foundation)                                                            ©ISO/IEC 2003 – All rights reserved
                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                           11.16 <drop column scope clause>




    DROP SPECIFIC ROUTINE SN CASCADE

2) For every view V whose view descriptor includes a <query expression> that contains an impacted dereference
   operation, let VN be the <table name> of V. The following <drop view statement> is effectively executed
   for every V without further Access Rule checking:

    DROP VIEW VN CASCADE

3) For every assertion A whose assertion descriptor includes a <search condition> that contains an impacted
   dereference operation, let AN be the <constraint name> of A. The following <drop assertion statement> is
   effectively executed for every A without further Access Rule checking:

    DROP ASSERTION AN CASCADE

4) For every table check constraint CC whose table check constraint descriptor includes a <search condition>
   that contains an impacted dereference operation, let CN be the <constraint name> of CC and let TN be the
   <table name> of the table whose descriptor includes descriptor of CC. The following <alter table statement>
   is effectively executed for every CC without further Access Rule checking:

    ALTER TABLE TN DROP CONSTRAINT CN CASCADE

5) The scope included in the reference type descriptor included in the column descriptor of every column in
   SC is made empty.


Conformance Rules
1) Without Feature F381, “Extended schema manipulation”, conforming SQL language shall not contain a
   <drop column scope clause>.
2) Without Feature S043, “Enhanced reference types”, conforming SQL language shall not contain a <drop
   column scope clause>.




©ISO/IEC 2003 – All rights reserved                                  Schema definition and manipulation 579
ISO/IEC 9075-2:2003 (E)
11.17 <alter identity column specification>



11.17 <alter identity column specification>

Function
Change the options specified for an identity column.


Format
<alter identity column specification> ::= <alter identity column option>...

<alter identity column option> ::=
    <alter sequence generator restart option>
  | SET <basic sequence generator option>


Syntax Rules
1) Let SEQ be the sequence generator descriptor included in the column descriptor identified by the <column
   name> in the containing <alter column definition>.
2) Let OPT be the character string formulated from <alter identity column specification> that conforms to the
   Format of <alter sequence generator options>.
    NOTE 270 — OPT is formulated by removing all instances of the keyword SET from the string corresponding to from <alter
    identity column specification>.

3) The Syntax Rules of Subclause 9.23, “Altering a sequence generator”, are applied with OPT as OPTIONS
   and SEQ as SEQUENCE.


Access Rules
    None.


General Rules
1) The General Rules of Subclause 9.23, “Altering a sequence generator”, are applied with OPT as OPTIONS
   and SEQ as SEQUENCE.


Conformance Rules
1) Without Feature T174, “Identity columns”, an <alter column definition> shall not contain an <alter identity
   column specification>.




580 Foundation (SQL/Foundation)                                                            ©ISO/IEC 2003 – All rights reserved
                                                                                                 ISO/IEC 9075-2:2003 (E)
                                                                                           11.18 <drop column definition>



11.18 <drop column definition>

Function
Destroy a column of a base table.


Format
<drop column definition> ::= DROP [ COLUMN ] <column name> <drop behavior>


Syntax Rules
1) Let T be the table identified by the <table name> in the containing <alter table statement> and let TN be
   the name of T.
2) Let C be the column identified by the <column name> CN.
3) T shall not be a referenceable table.
4) C shall be a column of T and C shall not be the only column of T.
5) If RESTRICT is specified, then C shall not be referenced in any of the following:
    a) The <query expression> of any view descriptor.
    b) The <search condition> of any constraint descriptor other than a table constraint descriptor that contains
       references to no other column and that is included in the table descriptor of T.
    c) The SQL routine body of any routine descriptor.
    d) Either an explicit trigger column list or a triggered action column set of any trigger descriptor.
    e) The generation expression of any column descriptor.
    NOTE 271 — A <drop column definition> that does not specify CASCADE will fail if there are any references to that column
    resulting from the use of CORRESPONDING, NATURAL, SELECT * (except where contained in an exists predicate>), or
    REFERENCES without a <reference column list> in its <referenced table and columns>.
    NOTE 272 — If CASCADE is specified, then any such dependent object will be dropped by the execution of the <revoke statement>
    specified in the General Rules of this Subclause.


Access Rules
    None.


General Rules
1) Let TR be the trigger name of any trigger descriptor having an explicit trigger column list or a triggered
   action column set that contains CN. The following <drop trigger statement> is effectively executed without
   further Access Rule checking:



©ISO/IEC 2003 – All rights reserved                                              Schema definition and manipulation 581
ISO/IEC 9075-2:2003 (E)
11.18 <drop column definition>



      DROP TRIGGER TR

2) Let A be the <authorization identifier> that owns T. The following <revoke statement> is effectively executed
   with a current authorization identifier of “_SYSTEM” and without further Access Rule checking:
      REVOKE INSERT(CN), UPDATE(CN), SELECT(CN), REFERENCES(CN) ON TABLE TN
      FROM A CASCADE

3) Let GC be any generated column of T in whose descriptor the generation expression contains a <column
   reference> that references C. The following <alter table statement> is effectively executed without further
   Access Rule checking:
      ALTER TABLE T DROP COLUMN GC CASCADE

4) If the column is not based on a domain, then its data type descriptor is destroyed.
5) The data associated with C is destroyed.
6) The descriptor of C is removed from the descriptor of T.
7) The descriptor of C is destroyed.
8) The degree of T is reduced by 1 (one). The ordinal position of all columns having an ordinal position greater
   than the ordinal position of C is reduced by 1 (one).


Conformance Rules
1) Without Feature F033, “ALTER TABLE statement: DROP COLUMN clause”, conforming SQL language
   shall not contain a <drop column definition>.




582 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                                 ISO/IEC 9075-2:2003 (E)
                                                                                    11.19 <add table constraint definition>



11.19 <add table constraint definition>

Function
Add a constraint to a table.


Format
<add table constraint definition> ::= ADD <table constraint definition>


Syntax Rules
1) If PRIMARY KEY is specified, then T shall not have any proper supertable.


Access Rules
    None.


General Rules
1) Let T be the table identified by the <table name> in the containing <alter table statement>.
2) The table constraint descriptor for the <table constraint definition> is included in the table descriptor for
   T.
3) Let TC be the table constraint added to T. If TC causes some column CN to be known not nullable and no
   other constraint causes CN to be known not nullable, then the nullability characteristic of the column
   descriptor of CN is changed to known not nullable.
    NOTE 273 — The nullability characteristic of a column is defined in Subclause 4.13, “Columns, fields, and attributes”.


Conformance Rules
1) Without Feature F381, “Extended schema manipulation”, conforming SQL language shall not contain an
   <add table constraint definition>.




©ISO/IEC 2003 – All rights reserved                                               Schema definition and manipulation 583
ISO/IEC 9075-2:2003 (E)
11.20 <drop table constraint definition>



11.20 <drop table constraint definition>

Function
Destroy a constraint on a table.


Format
<drop table constraint definition> ::= DROP CONSTRAINT <constraint name> <drop behavior>


Syntax Rules
1) Let T be the table identified by the <table name> in the containing <alter table statement>.
2) The <constraint name> shall identify a table constraint TC of T.
3) If TC is a unique constraint and RC is a referential constraint whose referenced table is T and whose refer-
   enced columns are the unique columns of TC, then RC is said to be dependent on TC.
4) If QS is a <query specification> that contains an implicit or explicit <group by clause> and that contains
   a column reference to a column C in its <select list> that is not contained in an aggregated argument of a
   <set function specification>, and if G is the set of grouping columns of QS, and if the table constraint TC
   is needed to conclude that G ↦ C is a known functional dependency in QS, then QS is said to be dependent
   on TC.
5) If V is a view that contains a <query specification> that is dependent on a table constraint TC, then V is
   said to be dependent on TC.
6) If R is an SQL routine whose <SQL routine body> contains a <query specification> that is dependent on
   a table constraint TC, then R is said to be dependent on TC.
7) If C is a constraint or assertion whose <search condition> contains a <query specification> that is dependent
   on a table constraint TC, then C is said to be dependent on TC.
8) If T is a trigger whose triggered action contains a <query specification> that is dependent on a table constraint
   TC, then T is said to be dependent on TC.
9) If T is a referenceable table with a derived self-referencing column, then:
    a) TC shall not be a unique constraint whose unique columns correspond to the attributes in the list of
       attributes of the derived representation of the reference type whose referenced type is the structured
       type of T.
    b) TC shall not be a unique constraint whose unique column is the self-referencing column of T.
10) If RESTRICT is specified, then:
    a) No table constraint shall be dependent on TC.
    b) The <constraint name> of TC shall not be generally contained in the SQL routine body of any routine
       descriptor.



584 Foundation (SQL/Foundation)                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                               ISO/IEC 9075-2:2003 (E)
                                                                                 11.20 <drop table constraint definition>



    c) No view shall be dependent on TC.
    d) No SQL routine shall be dependent on TC.
    e) No constraint or assertion shall be dependent on TC.
    f) No trigger shall be dependent on TC.
    NOTE 274 — If CASCADE is specified, then any such dependent object will be dropped by the effective execution of the General
    Rules of this Subclause.


Access Rules
    None.


General Rules
1) Let TCN2 be the <constraint name> of any table constraint that is dependent on TC and let T2 be the <table
   name> of the table descriptor that includes TCN2. The following <alter table statement> is effectively
   executed without further Access Rule checking:
        ALTER TABLE T2 DROP CONSTRAINT TCN2 CASCADE

2) Let R be any SQL-invoked routine whose routine descriptor contains the <constraint name> of TC in the
   SQL routine body. Let SN be the <specific name> of R. The following <drop routine statement> is effectively
   executed without further Access Rule checking:
        DROP SPECIFIC ROUTINE SN CASCADE

3) Let VN be the table name of any view V that is dependent on TC. The following <drop view statement> is
   effectively executed for every V:
        DROP VIEW VN CASCADE

4) Let SN be the specific name of any SQL routine R that is dependent on TC. The following <drop routine
   statement> is effectively executed for every SR:
        DROP SPECIFIC ROUTINE SN CASCADE

5) Let CN be the constraint name of any constraint C that is dependent on TC. Let TN be the name of the table
   constrainted by C. The following <alter table statement> is effectively executed for every C:
        ALTER TABLE TN DROP CONSTRAINT CN CASCADE

6) Let AN be the assertion name of any assertion A that is dependent on TC. The following <drop assertion
   statement> is effectively executed for every A:
        DROP ASSERTION AN CASCADE

7) Let TN be the trigger name of any trigger T that is dependent on TC. The following <drop trigger statement>
   is effectively executed for every T:


©ISO/IEC 2003 – All rights reserved                                             Schema definition and manipulation 585
ISO/IEC 9075-2:2003 (E)
11.20 <drop table constraint definition>



       DROP TRIGGER T CASCADE

8) The descriptor of TC is removed from the descriptor of T.
9) If TC causes some column CN to be known not nullable and no other constraint causes CN to be known
   not nullable, then the nullability characteristic of the column descriptor of CN is changed to possibly nullable.
    NOTE 275 — The nullability characteristic of a column is defined in Subclause 4.13, “Columns, fields, and attributes”.

10) The descriptor of TC is destroyed.


Conformance Rules
1) Without Feature F381, “Extended schema manipulation”, conforming SQL language shall not contain a
   <drop table constraint definition>.




586 Foundation (SQL/Foundation)                                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                                ISO/IEC 9075-2:2003 (E)
                                                                                           11.21 <drop table statement>



11.21 <drop table statement>

Function
Destroy a table.


Format
<drop table statement> ::= DROP TABLE <table name> <drop behavior>


Syntax Rules
1) Let T be the table identified by the <table name> and let TN be that <table name>.
2) The schema identified by the explicit or implicit schema name of the <table name> shall include the
   descriptor of T.
3) T shall be a base table.
4) T shall not be a declared local temporary table.
5) An impacted dereference operation is any of the following:
    a) A <dereference operation> DO, where T is the scope of the reference type of the <reference value
       expression> immediately contained in DO.
    b) A <method reference> MR, where T is the scope of the reference type of the <value expression primary>
       immediately contained in MR.
    c) A <reference resolution> RR, where T is the scope of the reference type of the <reference value
       expression> immediately contained in RR.
6) If RESTRICT is specified, then T shall not have any proper subtables.
7) If RESTRICT is specified, then T shall not be referenced and no impacted dereference operation shall be
   contained in any of the following:
    a) The <query expression> of any view descriptor.
    b) The <search condition> of any constraint descriptor that is not a table check constraint descriptor
       included in the base table descriptor of T.
    c) The <search condition> of any assertion descriptor.
    d) The table descriptor of the referenced table of any referential constraint descriptor of any table other
       than T.
    e) The SQL routine body of any routine descriptor.
    f) The <triggered action> of any trigger descriptor.
    NOTE 276 — If CASCADE is specified, then such objects will be dropped by the execution of the <revoke statement> specified
    in the General Rules of this Subclause.



©ISO/IEC 2003 – All rights reserved                                            Schema definition and manipulation 587
ISO/IEC 9075-2:2003 (E)
11.21 <drop table statement>



8) If RESTRICT is specified and T is a referenceable table, then TN shall not be the scope included in a refer-
   ence type descriptor generally included in any of the following:
    a) The attribute descriptor of an attribute of a user-defined type.
    b) The column descriptor of a column of a table other than T.
    c) The descriptor of an SQL parameter or the result type included in the routine descriptor of any <SQL-
       invoked routine>.
    d) The descriptor of an SQL parameter or the result type included in a method specification descriptor
       included in the user-defined type descriptor of any user-defined type.
    e) The descriptor of any user-defined cast.
    NOTE 277 — A descriptor that “generally includes” another descriptor is defined in Subclause 6.3.4, “Descriptors”, in ISO/IEC
    9075-1.

9) Let A be the <authorization identifier> that owns the schema identified by the <schema name> of the table
   identified by TN.


Access Rules
1) The enabled authorization identifiers shall include A.


General Rules
1) Let STN be the <table name> of any direct subtable of T. The following <drop table statement> is effectively
   executed without further Access Rule checking:

    DROP TABLE STN CASCADE

2) For every proper supertable of T, every superrow of every row of T is effectively deleted at the end of the
   SQL-statement, prior to the checking of any integrity constraints.
    NOTE 278 — This deletion creates neither a new trigger execution context nor the definition of a new state change in the current
    trigger execution context.

3) The following <revoke statement> is effectively executed with a current authorization identifier of
   “_SYSTEM” and without further Access Rule checking:

    REVOKE ALL PRIVILEGES ON TN FROM A CASCADE

4) If T is a referenceable table, then:
    a) For every reference type descriptor RTD that includes a scope of TN and is generally included in any
       of the following:
        i)       The attribute descriptor of an attribute of a user-defined type.
        ii)      The column descriptor of a column of a table other than T.
        iii)     The descriptor of an SQL parameter or the result type included in the routine descriptor of any
                 <SQL-invoked routine>.


588 Foundation (SQL/Foundation)                                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                                  ISO/IEC 9075-2:2003 (E)
                                                                                             11.21 <drop table statement>



         iv)      The descriptor of an SQL parameter or the result type in a method specification descriptor
                  included in the user-defined type descriptor of any user-defined type.
         v)       The descriptor of any user-defined cast.
         the scope of RTD is made empty.
    b) Let SOD be the descriptor of a schema object dependent on the table descriptor of T.
         Case:
         i)       If SOD is a view descriptor, then let SON be the name of the view included in SOD. The following
                  <drop view statement> is effectively executed without further Access Rule checking:

                  DROP VIEW SON CASCADE

         ii)      If SOD is an assertion descriptor, then let SON be the name of the assertion included in SOD.
                  The following <drop assertion statement> is effectively executed without further Access Rule
                  checking:

                  DROP ASSERTION SON CASCADE

         iii)     If SOD is a table constraint descriptor, then let SON be the name of the constraint included in
                  SOD. Let CTN be the <table name> included in the table descriptor that includes SOD. The
                  following <alter table statement> is effectively executed without further Access Rule checking:

                  ALTER TABLE CTN DROP CONSTRAINT SON CASCADE

         iv)      If SOD is a routine descriptor, then let SON be the specific name included in SOD. The following
                  <drop routine statement> is effectively executed without further Access Rule checking:

                  DROP SPECIFIC ROUTINE SON CASCADE

         v)       If SOD is a trigger descriptor, then let SON be the trigger name included in SOD. The following
                  <drop trigger statement> is effectively executed without further Access Rule checking:

                  DROP TRIGGER SON CASCADE

         NOTE 279 — A descriptor that “depends on” another descriptor is defined in Subclause 6.3.4, “Descriptors”, in ISO/IEC
         9075-1.

5) For each direct supertable DST of T, the table name of T is removed from the list of table names of direct
   subtables of DST that is included in the table descriptor of DST.
6) The descriptor of T is destroyed.


Conformance Rules
1) Without Feature F032, “CASCADE drop behavior”, conforming SQL language shall not contain a <drop
   table statement> that contains <drop behavior> that contains CASCADE.




©ISO/IEC 2003 – All rights reserved                                             Schema definition and manipulation 589
ISO/IEC 9075-2:2003 (E)
11.22 <view definition>



11.22 <view definition>

Function
Define a viewed table.


Format
<view definition> ::=
    CREATE [ RECURSIVE ] VIEW <table name> <view specification>
    AS <query expression> [ WITH [ <levels clause> ] CHECK OPTION ]

<view specification> ::=
    <regular view specification>
  | <referenceable view specification>

<regular view specification> ::=
    [ <left paren> <view column list> <right paren> ]

<referenceable view specification> ::=
    OF <path-resolved user-defined type name> [ <subview clause> ]
    [ <view element list> ]

<subview clause> ::= UNDER <table name>

<view element list> ::=
    <left paren> <view element> [ { <comma> <view element> }... ] <right paren>

<view element> ::=
    <self-referencing column specification>
  | <view column option>

<view column option> ::= <column name> WITH OPTIONS <scope clause>

<levels clause> ::=
    CASCADED
  | LOCAL

<view column list> ::= <column name list>


Syntax Rules
1) The <query expression> shall have an element type that is a row type.
2) The <query expression> shall not contain a <target specification>.
3) The <view definition> shall not contain an <embedded variable specification> or a <dynamic parameter
   specification>.
4) If a <view definition> is contained in a <schema definition> and the <table name> contains a <schema
   name>, then that <schema name> shall be equivalent to the specified or implicit <schema name> of the
   containing <schema definition>.



590 Foundation (SQL/Foundation)                                             ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                         11.22 <view definition>



5) The schema identified by the explicit or implicit schema name of the <table name> shall not include a table
   descriptor whose table name is <table name>.
6) No <table reference> generally contained in the <query expression> shall identify any declared local tem-
   porary table.
7) If a <table reference> generally contained in the <query expression> identifies the viewed table VT defined
   by <view definition> VD, then VD and VT are said to be recursive.
8) If VD is recursive, then:
    a) <view column list> shall be specified.
    b) RECURSIVE shall be specified.
    c) CHECK OPTION shall not be specified.
    d) <referenceable view specification> shall not be specified.
    e) VD is equivalent to

         CREATE VIEW <table name> AS
             WITH RECURSIVE <table name> (<view column list>)
               AS (<query expression>)
             SELECT <view column list> FROM <table name>

9) The viewed table is updatable if the <query expression> is updatable.
10) The viewed table is simply updatable if the <query expression> is simply updatable.
11) The viewed table is effectively updatable if it is simply updatable, or if the SQL implementation supports
    Feature T111, “Updatable joins, unions, and columns”, and the viewed table is updatable.
12) The viewed table is insertable-into if the <query expression> is insertable-into.
13) If the <query expression> is a <query specification> that contains a <group by clause> or a <having clause>
    that is not contained in a <subquery>, then the viewed table defined by the <view definition> is a grouped
    view.
14) If any two columns in the table specified by the <query expression> have equivalent <column name>s, or
    if any column of that table has an implementation-dependent name, then a <view column list> shall be
    specified.
15) Equivalent <column name>s shall not be specified more than once in the <view column list>.
16) The number of <column name>s in the <view column list> shall be the same as the degree of the table
    specified by the <query expression>.
17) Every column in the table specified by <query expression> whose declared type is a character string type
    shall have a declared type collation.
18) If WITH CHECK OPTION is specified, then the viewed table shall be updatable.
19) If WITH CHECK OPTION is specified and <levels clause> is not specified, then a <levels clause> of
    CASCADED is implicit.




©ISO/IEC 2003 – All rights reserved                                   Schema definition and manipulation 591
ISO/IEC 9075-2:2003 (E)
11.22 <view definition>



20) If WITH LOCAL CHECK OPTION is specified, then the <query expression> shall not generally contain
    a <query expression> QE or a <query specification> QS that is possibly non-deterministic unless QE or
    QS is generally contained in a viewed table that is a leaf underlying table of the <query expression>.
    If WITH CASCADED CHECK OPTION is specified, then the <query expression> shall not generally
    contain a <query expression> or <query specification> that is possibly non-deterministic.
21) Let V be the view defined by the <view definition>. The underlying columns of every i-th column of V are
    the underlying columns of the i-th column of the <query expression> and the underlying columns of V are
    the underlying columns of the <query expression>.
22) <subview clause>, if present, identifies the direct superview SV of V and V is said to be a direct subview
    of SV. View V1 is a superview of view V2 if and only if one of the following is true:
    a) V1 and V2 are the same view.
    b) V1 is a direct superview of V2.
    c) There exists a view V3 such that V1 is a direct superview of V3 and V3 is a superview of V2. If V1 is
       a superview of V2, then V2 is a subview of V1.
    If V1 is a superview of V2 and V1 and V2 are not the same view, then V2 is a proper subview of V1 and V1
    is a proper superview of V2.
    If V2 is a direct subview of V1, then V2 is a direct subtable of V1.
    NOTE 280 — It follows that the subviews of the superviews of V together constitute the subtable family of V, every implication
    of which applies.

23) If <referenceable view specification> is specified, then:
    a) V is a referenceable view.
    b) RECURSIVE shall not be specified.
    c) The <user-defined type name> simply contained in <path-resolved user-defined type name> shall
       identify a structured type ST.
    d) The subtable family of V shall not include a member, other than V itself, whose associated structured
       type is ST.
    e) If <subview clause> is not specified, then <self-referencing column specification> shall be specified.
    f) Let QE be the <query expression>.

    g) Let n be the number of attributes of ST. Let Ai, 1 (one) ≤ i ≤ n be the attributes of ST.

    h) Let RT be the row type of QE.
    i)   If <self-referencing column specification> is specified, then:
         i)      Exactly one <self-referencing column specification> shall be specified.
         ii)     <subview clause> shall not be specified.
         iii)    SYSTEM GENERATED shall not be specified.



592 Foundation (SQL/Foundation)                                                                ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)
                                                                                            11.22 <view definition>



         iv)      Let RST be the reference type REF(ST).
                  Case:
                  1) If USER GENERATED is specified, then:
                      A) RST shall have a user-defined representation.
                      B) Let m be 1 (one).
                  2) If DERIVED is specified, then:
                      A) RST shall have a derived representation.
                      B) Let m be 0 (zero).
    j)   If <subview clause> is specified, then:
         i)       The <table name> contained in the <subview clause> shall identify a referenceable table SV that
                  is a view.
         ii)      ST shall be a direct subtype of the structured type of the direct supertable of V.
         iii)     The SQL-schema identified by the explicit or implicit <schema name> of the <table name> of
                  V shall include the descriptor of SV.
         iv)      Let MSV be the maximum superview of the subtable family of V. Let RMSV be the reference
                  type REF(MSV).
                  Case:
                  1) If RMSV has a user-defined representation, then let m be 1 (one).
                  2) Otherwise, RMSV has a derived representation. Let m be 0 (zero).
    k) The degree of RT shall be n+m.

    l)   Let Fi, 1 (one) ≤ i ≤ n, be the fields of RT.

    m) For i varying from 1 (one) to n:
         i)       The declared data type DDTFi+m of Fi+m shall be compatible with the declared data type DDTAi
                  of Ai.

         ii)      The Syntax Rules of Subclause 9.16, “Data type identity”, are applied with DDTFi+m and DDTAi.

    n) QE shall consist of a single <query specification> QS.
    o) The <from clause> of QS shall simply contain a single <table reference> TR.
    p) TR shall immediately contain a <table or query name>. Let TQN be the table identified by the <table
       or query name>. TQN is the basis table of V.
    q) If TQN is a referenceable base table or a referenceable view, then TR shall simply contain ONLY.
    r) QS shall not simply contain a <group by clause> or a <having clause>.



©ISO/IEC 2003 – All rights reserved                                       Schema definition and manipulation 593
ISO/IEC 9075-2:2003 (E)
11.22 <view definition>



    s) If <self-referencing column specification> is specified, then
         Case:
         i)      If RST has a user-defined representation, then:
                 1) TQN shall have a candidate key consisting of a single column RC.
                 2) Let SS be the first <select sublist> in the <select list> of QS.
                 3) SS shall consist of a single <cast specification> CS whose leaf column is RC.
                     NOTE 281 — “Leaf column of a <cast specification>” is defined in Subclause 6.12, “<cast specification>”.

                 4) The declared type of F1 shall be REF(ST).

         ii)     Otherwise, RST has a derived representation.

                 1) Let Ci, 1 (one) ≤ i ≤ n, be the columns of V that correspond to the attributes of the derived
                    representation of RST.
                 2) TQN shall have a candidate key consisting of some subset of the underlying columns of Ci,
                     1 (one) ≤ i ≤ n.
    t)   If <subview clause> is specified, then TQN shall be a proper subtable or proper subview of the basis
         table of SV.
    u) Let <view element list>, if specified, be TEL1.

    v) Let r be the number of <view column option>s. For every <view column option> VCOj, 1 (one) ≤ j ≤
       r, <column name> shall be equivalent to the <attribute name> of some attribute of ST.
    w) Distinct <view column option>s contained in TEL1 shall specify distinct <column name>s.

    x) Let CNj, 1 (one) ≤ j ≤ r, be the <column name> contained in VCOj and let SCLj be the <scope clause>
       contained in VCOj.

         i)      CNj shall be equivalent to some <attribute name> of ST, whose declared type is some reference
                 type CORTj.

         ii)     The <table name> contained in SCLj shall identify a referenceable table SRT.

         iii)    SRT shall be based on the referenced type of CORTj.

24) Let the originally-defined columns of V be the columns of the table defined by QE.
25) A column of V is called an updatable column of V if its underlying column is updatable.
26) If the <view definition> is contained in a <schema definition>, then let A be the explicit or implicit
    <authorization identifier> of the <schema definition>; otherwise, let A be the <authorization identifier>
    that owns the schema identified by the explicit or implicit <schema name> of the <table name>.




594 Foundation (SQL/Foundation)                                                              ©ISO/IEC 2003 – All rights reserved
                                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                                                    11.22 <view definition>



Access Rules
1) If a <view definition> is contained in an <SQL-client module definition>, then the enabled authorization
   identifiers shall include the <authorization identifier> that owns the schema identified by the implicit or
   explicit <schema name> of the <table name>.
2) If <referenceable view specification> is specified, then the applicable privileges for A shall include USAGE
   on ST.
3) If <subview clause> is specified, then
    Case:
    a) If <view definition> is contained, without an intervening <SQL routine spec> that specifies SQL
       SECURITY INVOKER, in an <SQL schema statement>, then the applicable privileges of the
       <authorization identifier> that owns the schema shall include UNDER for SV.
    b) Otherwise, the current privileges shall include UNDER for SV.
    NOTE 282 — “current privileges” and “applicable privileges” are defined in Subclause 12.3, “<privileges>”.


General Rules
1) A view descriptor VD is created that describes V. VD includes:
    a) The <table name> TN.
    b) QE, as both the <query expression> of the descriptor and the original <query expression> of the
       descriptor.
    c) Case:
         i)       If <regular view specification> is specified, then the column descriptors taken from the table
                  specified by the <query expression>.
                  Case:
                  1) If a <view column list> is specified, then the <column name> of the i-th column of the view
                     is the i-th <column name> in that <view column list>.
                  2) Otherwise, the <column name>s of the view are the <column name>s of the table specified
                     by the <query expression>.
         ii)      Otherwise:
                  1) A column descriptor in which:
                      A) The name of the column is <self-referencing column name>.
                      B) The data type descriptor is that generated by the <data type> “REF(ST) SCOPE(TN)”.
                      C) The nullability characteristic is known not nullable.
                      D) The ordinal position is 1 (one).
                      E) The column is indicated to be self-referencing.


©ISO/IEC 2003 – All rights reserved                                              Schema definition and manipulation 595
ISO/IEC 9075-2:2003 (E)
11.22 <view definition>



               2) The column descriptor ODCD of each originally-defined column ODC of V in which:
                   A) The <column name> included in ODCD is replaced by the <attribute name> of its cor-
                      responding attribute of ST.
                   B) If the declared type of the column is a reference type and some VCOi contains the
                      <attribute name> of ST that corresponds to the column, then the (possibly empty) scope
                      contained in the reference type descriptor immediately included in the column descriptor
                      is replaced by SCOi.

               3) If DERIVED is specified, then an indication that the self-referencing column is a derived
                  self-referencing column.
               4) If USER GENERATED is specified, then an indication that the self-referencing column is
                  a user-generated self-referencing column.
    d) In each column descriptor, an indication that the column is updatable if V is effectively updatable, and
       the corresponding column of QE is updatable.
    e) An indication as to whether WITH CHECK OPTION was omitted, specified with LOCAL, or specified
       with CASCADED.
2) Let VN be the <table name>. Let QE be the <query expression> included in the view descriptor VD of the
   view identified by VN. Let OQE be the original <query expression> included in VD. If a <view column
   list> is specified, then let VCL be the <view column list> preceded by a <left paren> and followed by a
   <right paren>; otherwise, let VCL be the zero-length string.
    Case:
    a) If VN is immediately contained in some SQL-schema statement, then VN identifies the view descriptor
       VD.
    b) If VN is immediately contained in a <table reference> that specifies ONLY, then VN references the
       same table as the <table reference>:
             ( OQE ) AS VN VCL

    c) Otherwise, VN references the same table as the <table reference>:
             ( QE ) AS VN VCL

3) For i ranging from 1 (one) to the number of distinct leaf underlying tables of the <query expression> QE
   of V, let RTi be the <table name>s of those tables. For every column CV of V:

    a) Let CRTi,j, for j ranging from 1 (one) to the number of columns of RTi that are underlying columns of
       CV, be the <column name>s of those columns.
    b) A set of privilege descriptors with the grantor for each set to the special grantor value “_SYSTEM” is
       created as follows:
        i)     For every column CV of V, a privilege descriptor is created that defines the privilege SELECT(CV)
               on V to A. That privilege is grantable if and only if all the following are true:




596 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                           11.22 <view definition>



                  1) The applicable privileges for A include grantable SELECT privileges on all of the columns
                     CRTi,j.

                  2) The applicable privileges for A include grantable EXECUTE privileges on all SQL-invoked
                     routines that are subject routines of <routine invocation>s contained in QE.
                  3) The applicable privileges for A include grantable SELECT privilege on every table T1 and
                     every method M such that there is a <method reference> MR contained in QE such that T1
                     is in the scope of the <value expression primary> of MR and M is the method identified by
                     the <method name> of MR.
                  4) The applicable privileges for A include grantable SELECT privilege WITH HIERARCHY
                     OPTION on at least one supertable of the scoped table of every <reference resolution> that
                     is contained in QE.
         ii)      For every column CV of V, if the applicable privileges for A include REFERENCES(CRTi,j) for
                  all i and for all j, and the applicable privileges for A include REFERENCES on some column
                  of RTi for all i, then a privilege descriptor is created that defines the privilege REFERENCES(CV)
                  on V to A. That privilege is grantable if and only if all the following are true:
                  1) The applicable privileges for A include grantable REFERENCES privileges on all of the
                     columns CRTi,j.

                  2) The applicable privileges for A include grantable EXECUTE privileges on all SQL-invoked
                     routines that are subject routines of <routine invocation>s contained in QE.
                  3) The applicable privileges for A include grantable SELECT privilege on every table T1 and
                     every method M such that there is a <method reference> MR contained in QE such that T1
                     is in the scope of the <value expression primary> of MR and M is the method identified by
                     the <method name> of MR.
                  4) The applicable privileges for A include grantable SELECT privilege WITH HIERARCHY
                     OPTION on at least one supertable of the scoped table of every <reference resolution> that
                     is contained in QE.
4) A privilege descriptor is created that defines the privilege SELECT on V to A. That privilege is grantable
   if and only if the applicable privileges for A include grantable SELECT privilege on every column of V.
   The grantor of that privilege descriptor is set to the special grantor value “_SYSTEM”.
5) If the applicable privileges for A include REFERENCES privilege on every column of V, then a privilege
   descriptor is created that defines the privilege REFERENCES on V to A. That privilege is grantable if and
   only if the applicable privileges for A include grantable REFERENCES privilege on every column of V.
   The grantor of that privilege descriptor is set to the special grantor value “_SYSTEM”.
6) If V is effectively updatable, then a set of privilege descriptors with the grantor for each set to the special
   grantor value “_SYSTEM” is created as follows:
    a) For each leaf underlying table LUT of QE, if QE is one-to-one with respect to LUT, and the applicable
       privileges for A include INSERT privilege on LUT, then a privilege descriptor is created that defines
       the INSERT privilege on V. That privilege is grantable if and only if the applicable privileges for A
       include grantable INSERT privilege on LUT.




©ISO/IEC 2003 – All rights reserved                                       Schema definition and manipulation 597
ISO/IEC 9075-2:2003 (E)
11.22 <view definition>



    b) For each leaf underlying table LUT of QE, if QE is one-to-one with respect to LUT, and the applicable
       privileges for A include UPDATE privilege on LUT, then a privilege descriptor is created that defines
       the UPDATE privilege on V. That privilege is grantable if and only if the applicable privileges for A
       include grantable UPDATE privilege on LUT.
    c) For each leaf underlying table LUT of QE, if QE is one-to-one with respect to LUT, and the applicable
       privileges for A include DELETE privilege on LUT, then a privilege descriptor is created that defines
       the DELETE privilege on V. That privilege is grantable if and only if the applicable privileges for A
       include grantable DELETE privilege on LUT.
    d) For each column CV of V that has a counterpart CLUT in LUT, if QE is one-to-one with respect to LUT,
       and the applicable privileges for A include INSERT(CLUT) privilege on LUT, then a privilege
       descriptor is created that defines the INSERT(CV) privilege on V. That privilege is grantable if and
       only if the applicable privileges for A include grantable INSERT(CLUT) privilege on LUT.
    e) For each column CV of V that has a counterpart CLUT in LUT, if QE is one-to-one with respect to LUT,
       and the applicable privileges for A include UPDATE(CLUT) privilege on LUT, then a privilege
       descriptor is created that defines the UPDATE(CV) privilege on V. That privilege is grantable if and
       only if the applicable privileges for A include grantable UPDATE(CLUT) privilege on LUT.
7) If V is a referenceable view, then a set of privilege descriptors with the grantor for each set to the special
   grantor value “_SYSTEM” are created as follows:
    a) A privilege descriptor is created that defines the SELECT privilege WITH HIERARCHY OPTION on
       V to A. That privilege is grantable.
    b) For every method M of the structured type identified by <path-resolved user-defined type name>, a
       privilege descriptor is created that defines the privilege SELECT(M) on V to A. That privilege is
       grantable.
    c) Case:
        i)     If <subview clause> is not specified, then a privilege descriptor is created that defines the UNDER
               privilege on V to A. That privilege is grantable.
        ii)    Otherwise, a privilege descriptor is created that defines the UNDER privilege on V to A. That
               privilege is grantable if and only if the applicable privileges for A include grantable UNDER
               privilege on the direct supertable of V.
8) If <subview clause> is specified, then let ST be the set of supertables of V. Let PDS be the set of privilege
   descriptors that define SELECT WITH HIERARCHY OPTION privilege on a table in ST.
9) For every privilege descriptor in PDS, with grantee G and grantor A,
    Case:
    a) If the privilege is grantable, then let WGO be “WITH GRANT OPTION”.
    b) Otherwise, let WGO be a zero-length string.
    The following <grant statement> is effectively executed without further Access Rule checking:
       GRANT SELECT ON V
       TO G WGO FROM A




598 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                       11.22 <view definition>



10) If <subview clause> is specified, then let SVQE be the <query expression> included in the view descriptor
    of SV.
    a) The <query expression> included in the descriptor of SV is replaced by the following <query expression>:
             ( SVQE ) UNION ALL CORRESPONDING SELECT * FROM TN

    b) The General Rules of this subclause are reevaluated for SV in the light of the new <query expression>
       in its descriptor.
11) If the character representation of the <query expression> cannot be represented in the Information Schema
    without truncation, then a completion condition is raised: warning — query expression too long for infor-
    mation schema.
    NOTE 283 — The Information Schema is defined in ISO/IEC 9075-11.


Conformance Rules
1) Without Feature T131, “Recursive query”, conforming SQL language shall not contain a <view definition>
   that immediately contains RECURSIVE.
2) Without Feature F751, “View CHECK enhancements”, conforming SQL language shall not contain a
   <levels clause>.
3) Without Feature S043, “Enhanced reference types”, conforming SQL language shall not contain a <refer-
   enceable view specification>.
4) Without Feature F751, “View CHECK enhancements”, conforming SQL language shall not contain <view
   definition> that contains a <subquery> and contains CHECK OPTION.
5) Without Feature T111, “Updatable joins, unions and columns”, in conforming SQL language, if WITH
   CHECK OPTION is specified, then the viewed table shall be simply updatable.




©ISO/IEC 2003 – All rights reserved                                    Schema definition and manipulation 599
ISO/IEC 9075-2:2003 (E)
11.23 <drop view statement>



11.23 <drop view statement>

Function
Destroy a view.


Format
<drop view statement> ::= DROP VIEW <table name> <drop behavior>


Syntax Rules
1) Let V be the table identified by the <table name> and let VN be that <table name>. The schema identified
   by the explicit or implicit schema name of VN shall include the descriptor of V.
2) V shall be a viewed table.
3) An impacted dereference operation is any of the following:
    a) A <dereference operation> DO, where V is the scope of the reference type of the <reference value
       expression> immediately contained in DO.
    b) A <method reference> MR, where V is the scope of the reference type of the <value expression primary>
       immediately contained in MR.
    c) A <reference resolution> RR, where V is the scope of the reference type of the <reference value
       expression> immediately contained in RR.
4) If RESTRICT is specified, then V shall not have any proper subtables.
5) If RESTRICT is specified, then V shall not be referenced and no impacted dereference operation shall be
   contained in any of the following:
    a) The <query expression> of the view descriptor of any view other than V.
    b) The <search condition> of any constraint descriptor or assertion descriptor.
    c) The <triggered action> of any trigger descriptor.
    d) The SQL routine body of any routine descriptor.
    NOTE 284 — If CASCADE is specified, then any such dependent object will be dropped by the execution of the <revoke statement>
    specified in the General Rules of this Subclause.

6) If RESTRICT is specified and V is a referenceable view, then VN shall not be the scope included in a ref-
   erence type descriptor generally included in any of the following:
    a) The attribute descriptor of an attribute of a user-defined type.
    b) The column descriptor of a column of a table other than V.
    c) The descriptor of an SQL parameter or the result type included in the routine descriptor of any <SQL-
       invoked routine>.


600 Foundation (SQL/Foundation)                                                               ©ISO/IEC 2003 – All rights reserved
                                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                                              11.23 <drop view statement>



    d) The descriptor of an SQL parameter or the result type included in a method specification descriptor
       included in the user-defined type descriptor of any user-defined type.
    e) The descriptor of any user-defined cast.
    NOTE 285 — A descriptor that “generally includes” another descriptor is defined in Subclause 6.3.4, “Descriptors”, in ISO/IEC
    9075-1.

7) Let A be the <authorization identifier> that owns the schema identified by the <schema name> of the table
   identified by VN.


Access Rules
1) The enabled authorization identifier shall include A.


General Rules
1) Let SVN be the <table name> of any direct subview of V. The following <drop view statement> is effectively
   executed without further Access Rule checking:

    DROP VIEW SVN CASCADE

2) The following <revoke statement> is effectively executed with a current authorization identifier of
   “_SYSTEM” and without further Access Rule checking:

    REVOKE ALL PRIVILEGES ON VN FROM A CASCADE

3) If V is a referenceable view, then:
    a) For every reference type descriptor RTD that includes a scope of VN and is generally included in any
       of the following:
         i)       The attribute descriptor of an attribute of a user-defined type.
         ii)      The column descriptor of a column of a table other than V.
         iii)     The descriptor of an SQL parameter or the result type included in the routine descriptor of any
                  <SQL-invoked routine>.
         iv)      The descriptor of an SQL parameter or the result type included in a method specification
                  descriptor included in the user-defined type descriptor of any user-defined type.
         v)       The descriptor of any user-defined cast.
         the scope of RTD is made empty.
    b) Let SOD be the descriptor of a schema object dependent on the view descriptor of V.
         Case:
         i)       If SOD is a view descriptor, then let SON be the name of the view included in SOD. The following
                  <drop view statement> is effectively executed without further Access Rule checking:

                  DROP VIEW SON CASCADE



©ISO/IEC 2003 – All rights reserved                                              Schema definition and manipulation 601
ISO/IEC 9075-2:2003 (E)
11.23 <drop view statement>




        ii)     If SOD is an assertion descriptor, then let SON be the name of the assertion included in SOD.
                The following <drop assertion statement> is effectively executed without further Access Rule
                checking:

                DROP ASSERTION SON CASCADE

        iii)    If SOD is a table constraint descriptor, then let SON be the name of the constraint included in
                SOD. Let CTN be the <table name> included in the table descriptor that includes SOD. The
                following <alter table statement> is effectively executed without further Access Rule checking:

                ALTER TABLE CTN DROP CONSTRAINT SON CASCADE

        iv)     If SOD is a routine descriptor, then let SON be the specific name included in SOD. The following
                <drop routine statement> is effectively executed without further Access Rule checking:

                DROP SPECIFIC ROUTINE SON CASCADE

        v)      If SOD is a trigger descriptor, then let SON be the trigger name included in SOD. The following
                <drop trigger statement> is effectively executed without further Access Rule checking:

                DROP TRIGGER SON

        NOTE 286 — A descriptor that “depends on” another descriptor is defined in Subclause 6.3.4, “Descriptors”, in ISO/IEC
        9075-1.

4) For each direct supertable DST of V, the table name of V is removed from the list of table names of direct
   subtables of DST that is included in the table descriptor of DST.
5) The descriptor of V is destroyed.


Conformance Rules
1) Without Feature F032, “CASCADE drop behavior”, conforming SQL language shall not contain a <drop
   view statement> that contains a <drop behavior> that contains CASCADE.




602 Foundation (SQL/Foundation)                                                              ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                    11.24 <domain definition>



11.24 <domain definition>

Function
Define a domain.


Format
<domain definition> ::=
    CREATE DOMAIN <domain name> [ AS ] <predefined type>
    [ <default clause> ]
    [ <domain constraint>... ]
    [ <collate clause> ]

<domain constraint> ::=
    [ <constraint name definition> ] <check constraint definition> [
    <constraint characteristics> ]


Syntax Rules
1) If a <domain definition> is contained in a <schema definition>, and if the <domain name> contains a
   <schema name>, then that <schema name> shall be equivalent to the specified or implicit <schema name>
   of the containing <schema definition>.
2) If <constraint name definition> is specified and its <constraint name> contains a <schema name>, then
   that <schema name> shall be equivalent to the explicit or implicit <schema name> of the <domain name>
   of the domain identified by the containing <domain definition> or <alter domain statement>.
3) The schema identified by the explicit or implicit schema name of the <domain name> shall not include a
   domain descriptor whose domain name is equivalent to <domain name> nor a user-defined type descriptor
   whose user-defined type name is equivalent to <domain name>.
4) If <predefined type> specifies a <character string type> and does not specify <character set specification>,
   then the character set name of the default character set of the schema identified by the implicit or explicit
   <schema name> of <domain name> is implicit.
5) <collate clause> shall not be both specified in <predefined type> and immediately contained in <domain
   definition>. If <collate clause> is immediately contained in <domain definition>, then it is equivalent to
   specifying an equivalent <collate clause> in <predefined type>.
6) Let D1 be some domain. D1 is in usage by a domain constraint DC if and only if the <search condition>
   of DC generally contains the <domain name> either of D1 or of some domain D2 such that D1 is in usage
   by some domain constraint of D2. No domain shall be in usage by any of its own constraints.
7) If <collate clause> is specified, then <predefined type> shall be a character string type.
8) For every <domain constraint> specified:
    a) If <constraint characteristics> is not specified, then INITIALLY IMMEDIATE NOT DEFERRABLE
       is implicit.



©ISO/IEC 2003 – All rights reserved                                   Schema definition and manipulation 603
ISO/IEC 9075-2:2003 (E)
11.24 <domain definition>



    b) If <constraint name definition> is not specified, then a <constraint name definition> that contains an
       implementation-dependent <constraint name> is implicit. The assigned <constraint name> shall obey
       the Syntax Rules of an explicit <constraint name>.


Access Rules
1) If a <domain definition> is contained in an <SQL-client module definition>, then the enabled authorization
   identifiers shall include the <authorization identifier> that owns the schema identified by the implicit or
   explicit <schema name> of the <domain name>.


General Rules
1) A <domain definition> defines a domain.
2) A data type descriptor is created that describes the declared type of the domain being created.
3) A domain descriptor is created that describes the domain being created. The domain descriptor contains
   the name of the domain, the data type descriptor of the declared type, the value of the <default clause> if
   the <domain definition> immediately contains <default clause>, and a domain constraint descriptor for
   every immediately contained <domain constraint>.
4) A privilege descriptor is created that defines the USAGE privilege on this domain to the <authorization
   identifier> A of the schema or SQL-client module in which the <domain definition> appears. This privilege
   is grantable if and only if the applicable privileges for A include a grantable REFERENCES privilege for
   each column reference included in the domain descriptor and a grantable USAGE privilege for each <domain
   name>, <collation name>, <character set name>, and <transliteration name> contained in the <search
   condition> of any domain constraint descriptor included in the domain descriptor. The grantor of the priv-
   ilege descriptor is set to the special grantor value “_SYSTEM”.
5) Let DSC be the <search condition> included in some domain constraint descriptor DCD. Let D be the name
   of the domain whose descriptor includes DCD. Let T be the name of some table whose descriptor includes
   some column descriptor with column name C whose domain name is D. Let CSC be a copy of DSC in
   which every instance of the <general value specification> VALUE is replaced by C.
6) The domain constraint specified by DCD for C is not satisfied if and only if
       EXISTS ( SELECT * FROM T WHERE NOT ( CSC ) )
    is True.
    NOTE 287 — Subclause 10.8, “<constraint name definition> and <constraint characteristics>”, specifies when a constraint is
    effectively checked.


Conformance Rules
1) Without Feature F251, “Domain support”, conforming SQL language shall not contain a <domain definition>.
2) Without Feature F692, “Extended collation support”, conforming SQL language shall not contain a <domain
   definition> that immediately contains a <collate clause>.




604 Foundation (SQL/Foundation)                                                               ©ISO/IEC 2003 – All rights reserved
                                                                                              ISO/IEC 9075-2:2003 (E)
                                                                                        11.25 <alter domain statement>



11.25 <alter domain statement>

Function
Change a domain and its definition.


Format
<alter domain statement> ::= ALTER DOMAIN <domain name> <alter domain action>

<alter domain action> ::=
    <set domain default clause>
  | <drop domain default clause>
  | <add domain constraint definition>
  | <drop domain constraint definition>


Syntax Rules
1) Let D be the domain identified by <domain name>. The schema identified by the explicit or implicit schema
   name of the <domain name> shall include the descriptor of D.


Access Rules
1) The enabled authorization identifiers shall include the <authorization identifier> that owns the schema
   identified by the implicit or explicit <schema name> of <domain name>.


General Rules
1) The domain descriptor of D is modified as specified by <alter domain action>.
    NOTE 288 — The changed domain descriptor of D is applicable to every column that is dependent on D.


Conformance Rules
1) Without Feature F711, “ALTER domain”, conforming SQL language shall not contain an <alter domain
   statement>.




©ISO/IEC 2003 – All rights reserved                                           Schema definition and manipulation 605
ISO/IEC 9075-2:2003 (E)
11.26 <set domain default clause>



11.26 <set domain default clause>

Function
Set the default value in a domain.


Format
<set domain default clause> ::= SET <default clause>


Syntax Rules
    None.


Access Rules
    None.


General Rules
1) Let D be the domain identified by the <domain name> in the containing <alter domain statement>.
2) The default value specified by the <default clause> is placed in the domain descriptor of D.


Conformance Rules
1) Without Feature F711, “ALTER domain”, conforming SQL language shall not contain a <set domain
   default clause>.




606 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                  ISO/IEC 9075-2:2003 (E)
                                                                        11.27 <drop domain default clause>



11.27 <drop domain default clause>

Function
Remove the default clause of a domain.


Format
<drop domain default clause> ::= DROP DEFAULT


Syntax Rules
1) Let D be the domain identified by the <domain name> in the containing <alter domain statement>.
2) The descriptor of D shall contain a default value.


Access Rules
    None.


General Rules
1) Let C be the set of columns whose column descriptors contain the domain descriptor of D.
2) For every column belonging to C, if the column descriptor does not already contain a default value, then
   the default value from the domain descriptor of D is placed in that column descriptor.
3) The default value is removed from the domain descriptor of D.


Conformance Rules
1) Without Feature F711, “ALTER domain”, conforming SQL language shall not contain a <drop domain
   default clause>.




©ISO/IEC 2003 – All rights reserved                                 Schema definition and manipulation 607
ISO/IEC 9075-2:2003 (E)
11.28 <add domain constraint definition>



11.28 <add domain constraint definition>

Function
Add a constraint to a domain.


Format
<add domain constraint definition> ::= ADD <domain constraint>


Syntax Rules
1) Let D be the domain identified by the <domain name> in the <alter domain statement>.
2) Let D1 be some domain. D1 is in usage by a domain constraint DC if and only if the <search condition>
   of DC generally contains the <domain name> either of D1 or of some domain D2 such that D1 is in usage
   by some domain constraint of D2. No domain shall be in usage by any of its own constraints.


Access Rules
    None.


General Rules
1) The constraint descriptor of the <domain constraint> is added to the domain descriptor of D.
2) If DC causes some column CN to be known not nullable and no other constraint causes CN to be known
   not nullable, then the nullability characteristic of the column descriptor of CN is changed to known not
   nullable.
    NOTE 289 — The nullability characteristic of a column is defined in Subclause 4.13, “Columns, fields, and attributes”.


Conformance Rules
1) Without Feature F711, “ALTER domain”, conforming SQL language shall not contain an <add domain
   constraint definition>.




608 Foundation (SQL/Foundation)                                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                               ISO/IEC 9075-2:2003 (E)
                                                                                11.29 <drop domain constraint definition>



11.29 <drop domain constraint definition>

Function
Destroy a constraint on a domain.


Format
<drop domain constraint definition> ::= DROP CONSTRAINT <constraint name>


Syntax Rules
1) Let D be the domain identified by the <domain name> DN in the containing <alter domain statement>.
2) Let CD be any column descriptor that includes DN, let T be the table described by the table descriptor that
   includes CD, and let TN be the <table name> of T.
3) Let DC be the descriptor of the constraint identified by <constraint name>.
4) DC shall be included in the domain descriptor of D.


Access Rules
    None.


General Rules
1) The constraint descriptor DC is removed from the domain descriptor of D.
2) If DC causes some column CN to be known not nullable and no other constraint causes CN to be known
   not nullable, then the nullability characteristic of the column descriptor of CN is changed to possibly nullable.
    NOTE 290 — The nullability characteristic of a column is defined in Subclause 4.13, “Columns, fields, and attributes”.

3) The descriptor of DC is destroyed.


Conformance Rules
1) Without Feature F711, “ALTER domain”, conforming SQL language shall not contain a <drop domain
   constraint definition>.
2) Without Feature F491, “Constraint management”, conforming SQL language shall not contain a <drop
   domain constraint definition>.




©ISO/IEC 2003 – All rights reserved                                               Schema definition and manipulation 609
ISO/IEC 9075-2:2003 (E)
11.30 <drop domain statement>



11.30 <drop domain statement>

Function
Destroy a domain.


Format
<drop domain statement> ::= DROP DOMAIN <domain name> <drop behavior>


Syntax Rules
1) Let D be the domain identified by <domain name> and let DN be that <domain name>. The schema iden-
   tified by the explicit or implicit schema name of DN shall include the descriptor of D.
2) If RESTRICT is specified, then D shall not be referenced in any of the following:
    a) A column descriptor.
    b) The <query expression> of any view descriptor.
    c) The <search condition> of any constraint descriptor.
    d) The SQL routine body of any routine descriptor.
3) Let UA be the <authorization identifier> that owns the schema identified by the <schema name> of the
   domain identified by DN.


Access Rules
1) The enabled authorization identifiers shall include UA.


General Rules
1) Let C be any column descriptor that includes DN, let T be the table described by the table descriptor that
   includes C, and let TN be the table name of T. C is modified as follows:
    a) DN is removed from C. A copy of the data type descriptor of D is included in C.
    b) If C does not include a <default clause> and the domain descriptor of D includes a <default clause>,
       then a copy of the <default clause> of D is included in C.
    c) Let the excluded constraint list be the <constraint name> of each domain constraint descriptor included
       in the domain descriptor of D that does not occur in the implicit or explicit <constraint name list>.
    d) For every domain constraint descriptor included in the domain descriptor of D whose <constraint name>
       is not contained in the excluded constraint list:




610 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)
                                                                                    11.30 <drop domain statement>



         i)       Let TCD be a <table constraint definition> consisting of a <constraint name definition> whose
                  <constraint name> is implementation-dependent, whose <table constraint> is derived from the
                  <check constraint definition> of the domain constraint descriptor by replacing every instance
                  of VALUE by the <column name> of C, and whose <constraint characteristics> are the <con-
                  straint characteristics> of the domain constraint descriptor.
         ii)      If the applicable privileges for UA include all of the privileges necessary for UA to successfully
                  execute the <add table constraint definition>
                     ALTER TABLE TN ADD TCD
                  then the following <table constraint definition> is effectively executed with a current authorization
                  identifier of UA:
                     ALTER TABLE TN ADD TCD

2) The following <revoke statement> is effectively executed with a current authorization identifier of
   “_SYSTEM” and without further Access Rule checking:
        REVOKE USAGE ON DOMAIN DN FROM UA CASCADE

3) The descriptor of D is destroyed.


Conformance Rules
1) Without Feature F251, “Domain support”, conforming SQL language shall not contain a <drop domain
   statement>.




©ISO/IEC 2003 – All rights reserved                                        Schema definition and manipulation 611
ISO/IEC 9075-2:2003 (E)
11.31 <character set definition>



11.31 <character set definition>

Function
Define a character set.


Format
<character set definition> ::=
    CREATE CHARACTER SET <character set name> [ AS ]
    <character set source> [ <collate clause> ]

<character set source> ::= GET <character set specification>


Syntax Rules
1) If a <character set definition> is contained in a <schema definition> and if the <character set name>
   immediately contained in the <character set definition> contains a <schema name>, then that <schema
   name> shall be equivalent to the specified or implicit <schema name> of the <schema definition>.
2) The schema identified by the explicit or implicit schema name of the <character set name> shall not include
   a character set descriptor whose character set name is <character set name>.
3) The character set CS identified by the <character set specification> contained in <character set source>
   shall have associated with it a privilege descriptor that was effectively defined by the <grant statement>
       GRANT USAGE ON CHARACTER SET CSN TO PUBLIC
    where CSN is a <character set name> that identifies CS.
4) If <collate clause> is specified, then the <collation name> contained in <collate clause> shall identify a
   collation descriptor CD included in the schema identified by the explicit or implicit <schema name> contained
   in the <collation name>. The collation shall be applicable to the character repertoire of the character set
   identified by <character set source>. The list of applicable character set names included in CD shall include
   one that identifies CS.
5) Let A be the <authorization identifier> that owns the schema identified by the implicit or explicit <schema
   name> of <character set name>.


Access Rules
1) If a <character set definition> is contained in an <SQL-client module definition>, then the enabled autho-
   rization identifiers shall include A.
2) The applicable privileges for A shall include USAGE on the character set identified by the <character set
   specification>.




612 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                  11.31 <character set definition>



General Rules
1) A <character set definition> defines a character set.
2) A character set descriptor is created for the defined character set.
3) The descriptor created for the character set being defined is identical to the descriptor for the character set
   identified by <character set specification>, except that the included character set name is <character set
   name> and, if <collate clause> is specified, then the included name of the default collation is the <collation
   name> contained in <collate clause>.
4) A privilege descriptor is created that defines the USAGE privilege on this character set to be the <autho-
   rization identifier> of the <schema definition> or <SQL-client module definition> in which the <character
   set definition> appears. The grantor of the privilege descriptor is set to the special grantor value “_SYSTEM”.
   This privilege is grantable.


Conformance Rules
1) Without Feature F451, “Character set definition”, conforming SQL language shall not contain a <character
   set definition>.




©ISO/IEC 2003 – All rights reserved                                       Schema definition and manipulation 613
ISO/IEC 9075-2:2003 (E)
11.32 <drop character set statement>



11.32 <drop character set statement>

Function
Destroy a character set.


Format
<drop character set statement> ::= DROP CHARACTER SET <character set name>


Syntax Rules
1) Let C be the character set identified by the <character set name> and let CN be the name of C.
2) The schema identified by the explicit or implicit schema name of CN shall include the descriptor of C.
3) The explicit or implicit <schema name> contained in CN shall not be equivalent to INFORMA-
   TION_SCHEMA.
4) C shall not be referenced in any of the following:
    a) The data type descriptor included in any column descriptor.
    b) The data type descriptor included in any domain descriptor.
    c) The data type descriptor generally included in any user-defined type descriptor.
    d) The data type descriptor included in any field descriptor.
    e) The <query expression> of any view descriptor.
    f) The <search condition> of any constraint descriptor.
    g) The collation descriptor of any collation.
    h) The transliteration descriptor of any transliteration.
    i)   The SQL routine body, the <SQL parameter declaration>s, or the <returns data type> of any routine
         descriptor.
    j)   The <SQL parameter declaration>s or <returns data type> of any method specification descriptor.
5) Let the containing schema be the schema identified by the <schema name> explicitly or implicitly contained
   in <character set name>.


Access Rules
1) Let A be the <authorization identifier> that owns the schema identified by the <schema name> of the
   character set identified by C. The enabled authorization identifiers shall include A.




614 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                  ISO/IEC 9075-2:2003 (E)
                                                                       11.32 <drop character set statement>



General Rules
1) The following <revoke statement> is effectively executed with a current authorization identifier of
   “_SYSTEM” and without further Access Rule checking:
        REVOKE USAGE ON CHARACTER SET CN FROM A CASCADE

2) The descriptor of C is destroyed.


Conformance Rules
1) Without Feature F451, “Character set definition”, conforming SQL language shall not contain a <drop
   character set statement>.




©ISO/IEC 2003 – All rights reserved                                 Schema definition and manipulation 615
ISO/IEC 9075-2:2003 (E)
11.33 <collation definition>



11.33 <collation definition>

Function
Define a collation.


Format
<collation definition> ::=
    CREATE COLLATION <collation name> FOR <character set specification>
    FROM <existing collation name> [ <pad characteristic> ]

<existing collation name> ::= <collation name>

<pad characteristic> ::=
    NO PAD
  | PAD SPACE


Syntax Rules
1) Let A be the <authorization identifier> that owns the schema identified by the implicit or explicit <schema
   name> of the <collation name>.
2) If a <collation definition> is contained in a <schema definition> and if the <collation name> immediately
   contained in the <collation definition> contains a <schema name>, then that <schema name> shall be
   equivalent to the specified or implicit <schema name> of the <schema definition>.
3) The schema identified by the explicit or implicit schema name of the <collation name> CN immediately
   contained in <collation definition> shall not include a collation descriptor whose collation name is CN.
4) The schema identified by the explicit or implicit schema name of the <collation name> ECN immediately
   contained in <existing collation name> shall include a collation descriptor whose collation name is ECN.
5) The collation identified by ECN shall be a collation whose descriptor includes a character repertoire name
   that is equivalent to that included in the descriptor of the character set identified by <character set specifi-
   cation>.
6) If <pad characteristic> is not specified, then the <pad characteristic> of the collation identified by ECN is
   implicit.
7) If NO PAD is specified, then the collation is said to have the NO PAD characteristic. If PAD SPACE is
   specified, then the collation is said to have the PAD SPACE characteristic.


Access Rules
1) If a <collation definition> is contained in an <SQL-client module definition>, then the enabled authorization
   identifiers shall include A.
2) The applicable privileges for A shall include USAGE on ECN.



616 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                     11.33 <collation definition>



General Rules
1) A <collation definition> defines a collation.
2) A privilege descriptor is created that defines the USAGE privilege on this collation for A. The grantor of
   the privilege descriptor is set to the special grantor value “_SYSTEM”.
3) This privilege descriptor is grantable if and only if the USAGE privilege for A on the collation identified
   by ECN is grantable.
4) A collation descriptor is created for the defined collation.
5) The collation descriptor CD created is identical to the collation descriptor for ECN, except that the collation
   name included in CD is CN and, if <pad characteristic> is specified, then the pad characteristic included
   in CD is <pad characteristic>.


Conformance Rules
1) Without Feature F690, “Collation support”, conforming SQL language shall not contain a <collation defi-
   nition>.




©ISO/IEC 2003 – All rights reserved                                    Schema definition and manipulation 617
ISO/IEC 9075-2:2003 (E)
11.34 <drop collation statement>



11.34 <drop collation statement>

Function
Destroy a collation.


Format
<drop collation statement> ::= DROP COLLATION <collation name> <drop behavior>


Syntax Rules
1) Let C be the collation identified by the <collation name> and let CN be the name of C.
2) The schema identified by the explicit or implicit schema name of CN shall include the descriptor of C.
3) The explicit or implicit <schema name> contained in CN shall not be equivalent to INFORMA-
   TION_SCHEMA.
4) If RESTRICT is specified, then C shall not be referenced in any of the following:
    a) Any character set descriptor.
    b) The triggered action of any trigger descriptor.
    c) The <query expression> of any view descriptor.
    d) The <search condition> of any constraint descriptor.
    e) The SQL routine body, the <SQL parameter declaration>s, or the <returns data type> of any routine
       descriptor.
    f) The <SQL parameter declaration>s or the <returns data type> of any method specification descriptor.
5) Let A be the <authorization identifier> that owns the schema identified by the <schema name> of the col-
   lation identified by C.
6) Let the containing schema be the schema identified by the <schema name> explicitly or implicitly contained
   in <collation name>.


Access Rules
1) The enabled authorization identifiers shall include A.


General Rules
1) For every character set descriptor CSD that includes CN, CSD is modified such that it does not include CN.
   If CSD does not include any collation name, then CSD is modified to indicate that it utilizes the default
   collation for its character repertoire.



618 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                                             11.34 <drop collation statement>



2) For every data type descriptor DD that includes CN, DD is modified such that it includes the collation name
   of the character set collation of the character set of DD.
    NOTE 291 — This causes the column, domain, attribute, or field described by DD to revert to the default collation for its character
    set.

3) The following <revoke statement> is effectively executed with a current authorization identifier of
   “_SYSTEM” and without further Access Rule checking:
        REVOKE USAGE ON COLLATION CN FROM A CASCADE

4) The descriptor of C is destroyed.


Conformance Rules
1) Without Feature F690, “Collation support”, conforming SQL language shall not contain a <drop collation
   statement>.




©ISO/IEC 2003 – All rights reserved                                                 Schema definition and manipulation 619
ISO/IEC 9075-2:2003 (E)
11.35 <transliteration definition>



11.35 <transliteration definition>

Function
Define a character transliteration.


Format
<transliteration definition> ::=
    CREATE TRANSLATION <transliteration name> FOR <source character set specification>
    TO <target character set specification> FROM <transliteration source>

<source character set specification> ::= <character set specification>

<target character set specification> ::= <character set specification>

<transliteration source> ::=
    <existing transliteration name>
  | <transliteration routine>

<existing transliteration name> ::= <transliteration name>

<transliteration routine> ::= <specific routine designator>


Syntax Rules
1) If a <transliteration definition> is contained in a <schema definition> and if the <transliteration name>
   immediately contained in the <transliteration definition> contains a <schema name>, then that <schema
   name> shall be equivalent to the specified or implicit <schema name> of the <schema definition>.
2) The schema identified by the explicit or implicit schema name of the <transliteration name> TN immediately
   contained in <transliteration definition> shall not include a transliteration descriptor whose transliteration
   name is TN.
3) The schema identified by the explicit or implicit schema name of the <character set name> SCSN contained
   in the <character set specification> contained in <source character set specification> shall include a char-
   acter set descriptor whose character set name is SCSN.
4) The schema identified by the explicit or implicit schema name of the <character set name> TCSN contained
   in the <character set specification> contained in <source character set specification> shall include a char-
   acter set descriptor whose character set name is TCSN.
5) If <existing transliteration name> is specified, then:
    a) The schema identified by the explicit or implicit schema name of the <transliteration name> TN contained
       in <transliteration source> shall include a transliteration descriptor whose transliteration name is TN.
    b) The character set identified by SCSN shall have the same character repertoire and character encoding
       form as the source character set of the transliteration identified by TN.
    c) The character set identified by TCSN shall have the same character repertoire and character encoding
       form as the target character set of the transliteration identified by TN.


620 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                              11.35 <transliteration definition>



6) If <transliteration routine> is specified, then:
    a) The schema identified by the explicit or implicit schema name of the <specific routine designator>
       SRD contained in <transliteration routine> shall include a routine descriptor that identifies a routine
       having a <specific routine designator> SRD.
    b) The routine identified by SRD shall be an SQL-invoked function that has one parameter whose data
       type is character string and whose character set is the character set specified by SCSN; the <returns
       type> of the routine shall be character string whose character set is the character set specified by TCSN.


Access Rules
1) Let A be the <authorization identifier> that owns the schema identified by the implicit or explicit <schema
   name> of <transliteration name>. If a <transliteration definition> is contained in an <SQL-client module
   definition>, then the enabled authorization identifiers shall include A.
2) If <transliteration source> is specified, then the applicable privileges for A shall include USAGE on the
   transliteration identified by TN.
3) If <transliteration routine> is specified, then the applicable privileges for A shall include EXECUTE on
   the routine identified by RN.


General Rules
1) A <transliteration definition> defines a transliteration.
2) If <transliteration source> contains <existing transliteration name>, then let SRDN be the specific name
   included in the transliteration descriptor whose transliteration name is TN; otherwise, let SRDN be the
   specific name of the SQL-invoked routine identified by <transliteration routine>.
3) A transliteration descriptor is created that includes:
    a) The name of the transliteration TN.
    b) The name of the character set SCSN from which it translates.
    c) The name of the character set TCSN to which it translates.
    d) SRDN, the specific name of the SQL-invoked routine that performs the transliteration.
4) A privilege descriptor PD is created that defines the USAGE privilege on this transliteration to the
   <authorization identifier> of the <schema definition> or <SQL-client module definition> in which the
   <transliteration definition> appears. The grantor of the privilege descriptor is set to the special grantor
   value “_SYSTEM”.
5) PD is grantable if and only if the USAGE privilege for the <authorization identifier> of the <schema defi-
   nition> or <SQL-client module definition> in which the <transliteration definition> appears is also grantable
   on every character set identified by a <character set name> contained in the <transliteration definition>.




©ISO/IEC 2003 – All rights reserved                                    Schema definition and manipulation 621
ISO/IEC 9075-2:2003 (E)
11.35 <transliteration definition>



Conformance Rules
1) Without Feature F695, “Translation support”, conforming SQL language shall not contain a <transliteration
   definition>.




622 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                       11.36 <drop transliteration statement>



11.36 <drop transliteration statement>

Function
Destroy a character transliteration.


Format
<drop transliteration statement> ::= DROP TRANSLATION <transliteration name>


Syntax Rules
1) Let T be the transliteration identified by the <transliteration name> and let TN be the name of T.
2) Let A be the <authorization identifier> that owns the schema identified by the <schema name> of the
   transliteration identified by T.
3) The schema identified by the explicit or implicit schema name of TN shall include the descriptor of T.
4) T shall not be referenced in any of the following:
    a) The triggered action of any trigger descriptor.
    b) The <query expression> of any view descriptor.
    c) The <search condition> of any constraint descriptor.
    d) The collation descriptor of any collation.
    e) The transliteration descriptor of any translation.
    f) The SQL routine body of any routine descriptor.


Access Rules
1) The enabled authorization identifiers shall include A.


General Rules
1) The following <revoke statement> is effectively executed with a current authorization identifier of
   “_SYSTEM” and without further Access Rule checking:
        REVOKE USAGE ON TRANSLATION TN FROM A CASCADE

2) The descriptor of T is destroyed.




©ISO/IEC 2003 – All rights reserved                                  Schema definition and manipulation 623
ISO/IEC 9075-2:2003 (E)
11.36 <drop transliteration statement>



Conformance Rules
1) Without Feature F695, “Translation support”, conforming SQL language shall not contain a <drop
   transliteration statement>.




624 Foundation (SQL/Foundation)                                             ©ISO/IEC 2003 – All rights reserved
                                                                                                  ISO/IEC 9075-2:2003 (E)
                                                                                              11.37 <assertion definition>



11.37 <assertion definition>

Function
Specify an integrity constraint.


Format
<assertion definition> ::=
    CREATE ASSERTION <constraint name>
    CHECK <left paren> <search condition> <right paren>
    [ <constraint characteristics> ]


Syntax Rules
1) If an <assertion definition> is contained in a <schema definition> and if the <constraint name> contains a
   <schema name>, then that <schema name> shall be equivalent to the explicit or implicit <schema name>
   of the containing <schema definition>.
2) The schema identified by the explicit or implicit schema name of the <constraint name> shall not include
   a constraint descriptor whose constraint name is <constraint name>.
3) If <constraint characteristics> is not specified, then INITIALLY IMMEDIATE NOT DEFERRABLE is
   implicit.
4) The <search condition> shall not contain a <host parameter name>, an <SQL parameter name>, an
   <embedded variable specification> or a <dynamic parameter specification>.
    NOTE 292 — <SQL parameter name> is excluded because of the scoping rules for <SQL parameter name>.

5) No <query expression> in the <search condition> shall reference a temporary table.
6) The <search condition> shall simply contain a <boolean value expression> that is retrospectively determin-
   istic.
    NOTE 293 — “retrospectively deterministic” is defined in Subclause 6.34, “<boolean value expression>”.

7) The <search condition> shall not generally contain a <routine invocation> whose subject routine is an SQL-
   invoked routine that possibly modifies SQL-data.
8) The <qualified identifier> of <constraint name> shall not be equivalent to the <qualified identifier> of the
   <constraint name> of any other constraint defined in the same schema.


Access Rules
1) Let A be the <authorization identifier> that owns the schema identified by the <schema name> of the
   <assertion definition>. If an <assertion definition> is contained in an <SQL-client module definition>, then
   the enabled authorization identifier shall include A.




©ISO/IEC 2003 – All rights reserved                                             Schema definition and manipulation 625
ISO/IEC 9075-2:2003 (E)
11.37 <assertion definition>



General Rules
1) An <assertion definition> defines an assertion. An assertion is a constraint.
    NOTE 294 — Subclause 10.8, “<constraint name definition> and <constraint characteristics>”, specifies when a constraint is
    effectively checked.

2) Let SC be the <search condition> simply contained in the <assertion definition>.
3) The assertion is not satisfied if and only if the result of evaluating SC is False.
4) An assertion descriptor is created that describes the assertion being defined. The name included in the
   assertion descriptor is <constraint name>.
    The assertion descriptor includes an indication of whether the constraint is deferrable or not deferrable and
    whether the initial constraint mode is deferred or immediate.
    The assertion descriptor includes SC.
5) If the character representation of SC cannot be represented in the Information Schema without truncation,
   then a completion condition is raised: warning — search condition too long for information schema.
    NOTE 295 — The Information Schema is defined in ISO/IEC 9075-11.

6) If SC causes some column CN be to known not nullable and no other constraint causes CN to be known
   not nullable, then the nullability characteristic of CN is changed to known not nullable.
    NOTE 296 — The nullability characteristic of a column is defined in Subclause 4.13, “Columns, fields, and attributes”.


Conformance Rules
1) Without Feature F521, “Assertions”, conforming SQL language shall not contain an <assertion definition>.
2) Without Feature F672, “Retrospective check constraints”, conforming SQL language shall not contain an
   <assertion definition> that generally contains CURRENT_DATE, CURRENT_TIMESTAMP, or
   LOCALTIMESTAMP.




626 Foundation (SQL/Foundation)                                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                                 ISO/IEC 9075-2:2003 (E)
                                                                                         11.38 <drop assertion statement>



11.38 <drop assertion statement>

Function
Destroy an assertion.


Format
<drop assertion statement> ::= DROP ASSERTION <constraint name> [ <drop behavior> ]


Syntax Rules
1) Let A be the assertion identified by <constraint name> and let AN be the name of A.
2) The schema identified by the explicit or implicit schema name of AN shall include the descriptor of A.
3) If <drop behavior> is not specified, then RESTRICT is implicit.
4) If RESTRICT is specified or implied, then AN shall not be referenced in the SQL routine body of any
   routine descriptor.
5) If QS is a <query specification> that contains a column reference to a column C in its <select list> that is
   not contained in a <set function specification>, and if G is the set of columns defined by the <grouping
   column reference list> of QS, and if the assertion A is needed to conclude that G ↦ C is a known functional
   dependency in QS, then QS is said to be dependent on A.
6) If V is a view that contains a <query specification> that is dependent on A, then V is said to be dependent
   on A.
7) If R is an SQL routine whose <SQL routine body> contains a <query specification> that is dependent on
   A, then R is said to be dependent on A.
8) If C is a constraint or assertion whose <search condition> contains a <query specification> that is dependent
   on A, then C is said to be dependent on A.
9) If T is a trigger whose triggered action contains a <query specification> that is dependent on A, then T is
   said to be dependent on A.
10) If RESTRICT is specified or implicit, or <drop behavior> is not specified, then:
    a) No table constraint shall be dependent on A.
    b) No view shall be dependent on TC.
    c) No SQL routine shall be dependent on TC.
    d) No constraint or assertion shall be dependent on TC.
    e) No trigger shall be dependent on TC.
    NOTE 297 — If CASCADE is specified, then any such dependent object will be dropped by the execution of the <revoke statement>
    specified in the General Rules of this Subclause.




©ISO/IEC 2003 – All rights reserved                                              Schema definition and manipulation 627
ISO/IEC 9075-2:2003 (E)
11.38 <drop assertion statement>



Access Rules
1) The enabled authorization identifiers shall include the <authorization identifier> that owns the schema
   identified by the <schema name> of the assertion identified by AN.


General Rules
1) Let R be any SQL-invoked routine whose routine descriptor contains the <constraint name> of A in the
   SQL routine body. Let SN be the <specific name> of R. The following <drop routine statement> is effectively
   executed without further Access Rule checking:
       DROP SPECIFIC ROUTINE SN CASCADE

2) Let VN be the table name of any view V that is dependent on A. The following <drop view statement> is
   effectively executed for every V:
       DROP VIEW VN CASCADE

3) Let SN be the specific name of any SQL routine SR that is dependent on A, or that contains a reference to
   A. The following <drop routine statement> is effectively executed for every SR:
       DROP SPECIFIC ROUTINE SN CASCADE

4) Let CN be the constraint name of any constraint C that is dependent on A. Let TN be the name of the table
   constrained by C. The following <alter table statement> is effectively executed for every C:
       ALTER TABLE TN DROP CONSTRAINT CN CASCADE

5) Let AN2 be the assertion name of any assertion A that is dependent on A. The following <drop assertion
   statement> is effectively executed for every A:
       DROP ASSERTION AN2 CASCADE

6) Let TN be the trigger name of any trigger T that is dependent on A. The following <drop trigger statement>
   is effectively executed for every T:
       DROP TRIGGER TN

7) Let SC be the <search condition> included in the descriptor of A. If SC causes some column CN be to
   known not nullable and no other constraint causes CN to be known not nullable, then the nullability char-
   acteristic of CN is changed to possibly nullable.
    NOTE 298 — The nullability characteristic of a column is defined in Subclause 4.13, “Columns, fields, and attributes”.

8) The descriptor of A is destroyed.


Conformance Rules
1) Without Feature F521, “Assertions”, conforming SQL language shall not contain a <drop assertion state-
   ment>.


628 Foundation (SQL/Foundation)                                                                 ©ISO/IEC 2003 – All rights reserved
                                                                               ISO/IEC 9075-2:2003 (E)
                                                                       11.38 <drop assertion statement>



11.39 <trigger definition>

Function
Define triggered SQL-statements.


Format
<trigger definition> ::=
    CREATE TRIGGER <trigger name> <trigger action time> <trigger event>
    ON <table name> [ REFERENCING <transition table or variable list> ]
    <triggered action>

<trigger action time> ::=
    BEFORE
  | AFTER

<trigger event> ::=
    INSERT
  | DELETE
  | UPDATE [ OF <trigger column list> ]

<trigger column list> ::= <column name list>

<triggered action> ::=
    [ FOR EACH { ROW | STATEMENT } ]
    [ WHEN <left paren> <search condition> <right paren> ]
    <triggered SQL statement>

<triggered SQL statement> ::=
    <SQL procedure statement>
  | BEGIN ATOMIC { <SQL procedure statement> <semicolon> }... END

<transition table or variable list> ::= <transition table or variable>...

<transition table or          variable> ::=
    OLD [ ROW ] [ AS          ] <old transition variable name>
  | NEW [ ROW ] [ AS          ] <new transition variable name>
  | OLD TABLE [ AS ]          <old transition table name>
  | NEW TABLE [ AS ]          <new transition table name>

<old transition table name> ::= <transition table name>

<new transition table name> ::= <transition table name>

<transition table name> ::= <identifier>

<old transition variable name> ::= <correlation name>

<new transition variable name> ::= <correlation name>




©ISO/IEC 2003 – All rights reserved                              Schema definition and manipulation 629
ISO/IEC 9075-2:2003 (E)
11.39 <trigger definition>



Syntax Rules
1) Case:
    a) If a <trigger definition> is contained in a <schema definition> and if the <trigger name> contains a
       <schema name>, then that <schema name> shall be equivalent to the specified or implicit <schema
       name> of the containing <schema definition>.
    b) If a <trigger definition> is contained in an <SQL-client module definition> and if the <trigger name>
       contains a <schema name>, then that <schema name> shall be equivalent to the specified or implicit
       <schema name> of the <SQL-client module definition>.
2) Let TN be the <table name> of a <trigger definition>. The table T identified by TN is the subject table of
   the <trigger definition>.
3) The schema identified by the explicit or implicit <schema name> of TN shall include the descriptor of T.
4) The schema identified by the explicit or implicit <schema name> of a <trigger name> TRN shall not include
   a trigger descriptor whose trigger name is TRN.
5) T shall be a base table that is not a declared local temporary table.
6) If a <trigger column list> is specified, then:
    a) No <column name> shall appear more than once in the <trigger column list>.
    b) The <column name>s of the <trigger column list> shall identify columns of T.
7) If REFERENCING is specified, then:
    a) Let OR, OT, NR, and NT be the <old transition variable name>, <old transition table name>, <new
       transition variable name>, and <new transition table name>, respectively.
    b) OLD or OLD ROW, NEW or NEW ROW, OLD TABLE, and NEW TABLE shall be specified at most
       once each within the <transition table or variable list>.
    c) Case:
        i)      If <trigger event> specifies INSERT, then neither OLD ROW nor OLD TABLE shall be specified.
        ii)     If <trigger event> specifies DELETE, then neither NEW ROW nor NEW TABLE shall be
                specified.
    d) No two of OR, OT, NR, and NT shall be equivalent.
    e) Both OR and NR are range variables.
        NOTE 299 — “range variable” is defined in Subclause 4.14.6, “Operations involving tables”.

    f) The scope of OR, OT, NR, and NT is the <triggered action>, excluding any <SQL schema statement>s
       that are contained in the <triggered action>.
8) If neither FOR EACH ROW nor FOR EACH STATEMENT is specified, then FOR EACH STATEMENT
   is implicit.
9) If OR or NR is specified, then FOR EACH ROW shall be specified.



630 Foundation (SQL/Foundation)                                                             ©ISO/IEC 2003 – All rights reserved
                                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                                     11.39 <trigger definition>



10) The <triggered action> shall not contain an <SQL parameter reference>, a <host parameter name>, a
    <dynamic parameter specification>, or an <embedded variable name>.
11) It is implementation-defined whether the <triggered SQL statement> shall not generally contain an <SQL
    transaction statement>, an <SQL connection statement>, an <SQL schema statement>, an <SQL dynamic
    statement>, or an <SQL session statement>.
12) If BEFORE is specified, then:
    a) It is implementation-defined whether the <triggered action> shall not generally contain an <SQL data
       change statement> or a <routine invocation> whose subject routine is an SQL-invoked routine that
       possibly modifies SQL-data.
    b) Neither OLD TABLE nor NEW TABLE shall be specified.
    c) The <triggered action> shall not contain a <field reference> that references a field in the new transition
       variable corresponding to a generated column of T.


Access Rules
1) Let A be the <authorization identifier> that owns the schema identified by the implicit or explicit <schema
   name> of the <trigger name> of the <trigger definition>. If a <trigger definition> is contained in an <SQL-
   client module definition>, then the enabled authorization identifiers shall include A.
2) The applicable privileges for A for T shall include TRIGGER.
3) If the <triggered action> TA of a <trigger definition> contains an <old transition table name> OTTN, an
   <old transition variable name> OTVN, a <new transition table name> NTTN, or a <new transition variable
   name> NTVN, and TA contains OTTN, OTVN, or NTTN, or if TA contains NTVN, then the applicable priv-
   ileges for TA shall include SELECT.


General Rules
1) A <trigger definition> defines a trigger.
2) OT identifies the old transition table. NT identifies the new transition table. OR identifies the old transition
   variable. NR identifies the new transition variable.
    NOTE 300 — “old transition table”, “new transition table”, “old transition variable”, and “new transition variable” are defined in
    Subclause 4.38.1, “General description of triggers”.

3) The transition table identified by OT is the table associated with OR. The transition table identified by NT
   is the table associated with NR.
4) If the character representation of the <triggered SQL statement> cannot be represented in the Information
   Schema without truncation, then a completion condition is raised: warning — statement too long for
   information schema.
    NOTE 301 — The Information Schema is defined in ISO/IEC 9075-11.

5) A trigger descriptor is created for <trigger definition>s as follows:
    a) The trigger name included in the trigger descriptor is <trigger name>.



©ISO/IEC 2003 – All rights reserved                                                 Schema definition and manipulation 631
ISO/IEC 9075-2:2003 (E)
11.39 <trigger definition>



    b) The subject table included in the trigger descriptor is <table name>.
    c) The trigger action time included in the trigger descriptor is <trigger action time>.
    d) If FOR EACH STATEMENT is specified or implicit, then an indication that the trigger is a statement-
       level trigger; otherwise, an indication that the trigger is a row-level trigger.
    e) The trigger event included in the trigger descriptor is <trigger event>.
    f) Any <old transition variable name>, <new transition variable name>, <old transition table name>, or
       <new transition table name> specified in the <trigger definition> is included in the trigger descriptor
       as the old transition variable name, new transition variable name, old transition table name, or new
       transition table name, respectively.
    g) The trigger action included in the trigger descriptor is the specified <triggered action>.
    h) If a <trigger column list> TCL is specified, then TCL is the trigger column list included in the trigger
       descriptor; otherwise, that trigger column list is empty.
    i)   The triggered action column set included in the trigger descriptor is the set of all distinct, fully qualified
         names of columns contained in the <triggered action>.
    j)   The timestamp of creation included in the trigger descriptor is the timestamp of creation of the trigger.


Conformance Rules
1) Without Feature T211, “Basic trigger capability”, conforming SQL language shall not contain a <trigger
   definition>.
2) Without Feature T212, “Enhanced trigger capability”, in conforming SQL language, a <triggered action>
   shall contain FOR EACH ROW.




632 Foundation (SQL/Foundation)                                                        ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                              11.40 <drop trigger statement>



11.40 <drop trigger statement>

Function
Destroy a trigger.


Format
<drop trigger statement> ::= DROP TRIGGER <trigger name>


Syntax Rules
    None.


Access Rules
1) Let TR be the trigger identified by the <trigger name>. The enabled authorization identifiers shall include
   the <authorization identifier> that owns the schema identified by the <schema name> of TR.


General Rules
1) The descriptor of TR is destroyed.


Conformance Rules
1) Without Feature T211, “Basic trigger capability”, conforming SQL language shall not contain a <drop
   trigger statement>.




©ISO/IEC 2003 – All rights reserved                                  Schema definition and manipulation 633
ISO/IEC 9075-2:2003 (E)
11.41 <user-defined type definition>



11.41 <user-defined type definition>

Function
Define a user-defined type.


Format
<user-defined type definition> ::= CREATE TYPE <user-defined type body>

<user-defined type body> ::=
    <schema-resolved user-defined type name>
    [ <subtype clause> ]
    [ AS <representation> ]
    [ <user-defined type option list> ]
    [ <method specification list> ]

<user-defined type option list> ::=
    <user-defined type option> [ <user-defined type option>... ]

<user-defined type option> ::=
    <instantiable clause>
  | <finality>
  | <reference type specification>
  | <cast to ref>
  | <cast to type>
  | <cast to distinct>
  | <cast to source>

<subtype clause> ::= UNDER <supertype name>

<supertype name> ::= <path-resolved user-defined type name>

<representation> ::=
    <predefined type>
  | <member list>

<member list> ::= <left paren> <member> [ { <comma> <member> }... ] <right paren>

<member> ::= <attribute definition>

<instantiable clause> ::=
    INSTANTIABLE
  | NOT INSTANTIABLE

<finality> ::=
    FINAL
  | NOT FINAL

<reference type specification> ::=
    <user-defined representation>
  | <derived representation>
  | <system-generated representation>

<user-defined representation> ::= REF USING <predefined type>



634 Foundation (SQL/Foundation)                                    ©ISO/IEC 2003 – All rights reserved
                                                                       ISO/IEC 9075-2:2003 (E)
                                                             11.41 <user-defined type definition>



<derived representation> ::= REF FROM <list of attributes>

<system-generated representation> ::= REF IS SYSTEM GENERATED

<cast to ref> ::=
    CAST <left paren> SOURCE AS REF <right paren> WITH <cast to ref identifier>

<cast to ref identifier> ::= <identifier>

<cast to type> ::=
    CAST <left paren> REF AS SOURCE <right paren> WITH <cast to type identifier>

<cast to type identifier> ::= <identifier>

<list of attributes> ::=
    <left paren> <attribute name> [ { <comma> <attribute name> }... ] <right paren>

<cast to distinct> ::=
    CAST <left paren> SOURCE AS DISTINCT <right paren>
    WITH <cast to distinct identifier>

<cast to distinct identifier> ::= <identifier>

<cast to source> ::=
    CAST <left paren> DISTINCT AS SOURCE <right paren>
    WITH <cast to source identifier>

<cast to source identifier> ::= <identifier>

<method specification list> ::=
    <method specification> [ { <comma> <method specification> }... ]

<method specification> ::=
    <original method specification>
  | <overriding method specification>

<original method specification> ::=
    <partial method specification> [ SELF AS RESULT ] [ SELF AS LOCATOR ]
    [ <method characteristics> ]

<overriding method specification> ::= OVERRIDING <partial method specification>

<partial method specification> ::=
    [ INSTANCE | STATIC | CONSTRUCTOR ]
    METHOD <method name> <SQL parameter declaration list>
    <returns clause>
    [ SPECIFIC <specific method name> ]

<specific method name> ::= [ <schema name> <period> ]<qualified identifier>

<method characteristics> ::= <method characteristic>...

<method characteristic> ::=
    <language clause>
  | <parameter style clause>
  | <deterministic characteristic>
  | <SQL-data access indication>
  | <null-call clause>




©ISO/IEC 2003 – All rights reserved                       Schema definition and manipulation 635
ISO/IEC 9075-2:2003 (E)
11.41 <user-defined type definition>



Syntax Rules
1) Let UDTD be the <user-defined type definition>, let UDTB be the <user-defined type body> immediately
   contained in UDTD, let UDTN be the <schema-resolved user-defined type name> immediately contained
   in UDTB, let SN be the specified or implicit <schema name> of UDTN, let SS be the SQL-schema identified
   by SN, and let UDT be the data type defined by UDTD.
2) If UDTD is contained in a <schema definition> and UDTN contains a <schema name>, then that <schema
   name> shall be equivalent to the specified or implicit <schema name> of the containing <schema definition>.
3) SS shall not include a user-defined type descriptor or a domain descriptor whose name is equivalent to
   UDTN.
4) None of <instantiable clause>, <finality>, <reference type specification>, <cast to ref>, <cast to type>,
   <cast to distinct>, or <cast to source> shall be specified more than once.
5) Case:
    a) If <representation> specifies <predefined type>, then UDTD defines a distinct type.
    b) Otherwise, UDTD defines a structured type.
6) If <finality> specifies FINAL, then <instantiable clause> shall not specify NOT INSTANTIABLE.
7) If UDTD defines a distinct type, then:
    a) Let PSDT be the data type identified by <predefined type>.
        Case:
        i)      If PSDT is an exact numeric type, then let SDT be an implementation-defined exact numeric
                type whose precision is equal to the precision of PSDT and whose scale is equal to the scale of
                PSDT.
        ii)     If PSDT is an approximate numeric type, then let SDT be an implementation-defined approximate
                numeric type whose precision is equal to the precision of PSDT.
        iii)    Otherwise, let SDT be PSDT.
    b) <instantiable clause> shall not be specified.
    c) If <finality> is not specified, then FINAL is implicit; otherwise, FINAL shall be specified.
    d) <subtype clause> shall not be specified.
    e) <reference type specification> shall not be specified.
    f) <cast to distinct> and <cast to source> shall not be specified.
    g) If <cast to distinct> is specified, then let FNUDT be <cast to distinct identifier>; otherwise, let FNUDT
       be the <qualified identifier> of UDTN.
    h) If <cast to source> is specified, then let FNSDT be <cast to source identifier>; otherwise, the Syntax
       Rules of Subclause 9.7, “Type name determination”, are applied to SDT, yielding an <identifier>
       FNSDT.




636 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                11.41 <user-defined type definition>



8) If UDTD specifies a structured type, then:
    a) <cast to distinct> and <cast to type> shall not be specified.
    b) If <subtype clause> is specified, then <reference type specification> shall not be specified.
    c) If <subtype clause> and <reference type specification> are not specified, then <system-generated rep-
       resentation> is implicit.
    d) If <instantiable clause> is not specified, then INSTANTIABLE is implicit.
    e) <finality> shall be specified.
    f) The originally-defined attributes of UDT are those defined by <attribute definition>s contained in
       <member list>. No two originally-defined attributes of UDT shall have equivalent <attribute name>s.
    g) For each <attribute definition> ATD contained in <member list>, let AN be the <attribute name> con-
       tained in ATD and let DT be the <data type> contained in ATD. The following <original method spec-
       ification>s are implicit:
               METHOD AN ( )
                   RETURNS DT
                   LANGUAGE SQL
                   DETERMINISTIC
                   CONTAINS SQL
                 RETURNS NULL ON NULL INPUT

               This is the original method specification of the observer function of attribute AN.
               METHOD AN ( ATTR DT )
                   RETURNS UDTN
                   SELF AS RESULT
                   LANGUAGE SQL
                   DETERMINISTIC
                   CONTAINS SQL
                 CALLED ON NULL INPUT

               This is the original method specification of the mutator function of attribute AN.

    h) If <user-defined representation> is specified, then:
         i)        Let BT be <predefined type>. BT is the representation type of the referencing type of UDT.
         ii)       BT shall be exact numeric or a character string type that is not a large object string type.
         iii)      If <cast to ref> is specified, then let FNREF be <cast to ref identifier>; otherwise, let FNREF
                   be the <qualified identifier> of UDTN.
         iv)       Case:
                   1) If <cast to type> is specified, then let FNTYP be <cast to type identifier>.
                   2) Otherwise, the Syntax Rules of Subclause 9.7, “Type name determination”, are applied to
                      BT, yielding an <identifier> FNTYP.
    i)   If <derived representation> is specified, then no two <attribute name>s in <list of attributes> shall be
         equivalent.


©ISO/IEC 2003 – All rights reserved                                        Schema definition and manipulation 637
ISO/IEC 9075-2:2003 (E)
11.41 <user-defined type definition>



    j)   If <subtype clause> is specified, then:
         i)     <supertype name> shall not be equivalent to UDTN.
         ii)    The <supertype name> immediately contained in the <subtype clause> shall identify the
                descriptor of some structured type SST. UDT is a direct subtype of SST, and SST is a direct
                supertype of UDT.
         iii)   The descriptor of SST shall not include an indication that SST is final.
         iv)    The inherited attributes of UDT are the attributes described by the attribute descriptors included
                in the descriptor of SST.
         v)     If <member list> is specified, then no <attribute name> contained in <member list> shall have
                an attribute name that is equivalent to the attribute name of an inherited attribute.
         vi)    If the user-defined type descriptor of SST indicates that the referencing type of SST has a user-
                defined representation, then let BT be the data type described by the data type descriptor of the
                representation type of the referencing type of SST included in the user-defined type descriptor
                of SST.
                1) If <cast to ref> is specified, then let FNREF be <cast to ref identifier>; otherwise, let FNREF
                   be the <qualified identifier> of UDTN.
                2) Case:
                    A) If <cast to type> is specified, then let FNTYP be <cast to type identifier>.
                    B) Otherwise, the Syntax Rules of Subclause 9.7, “Type name determination”, are applied
                       to BT, yielding an <identifier> FNTYP.
    k) If <cast to distinct> or <cast to source> is specified, then exactly one of the following shall be true:
         i)     <user-defined representation> is specified.
         ii)    <subtype clause> is specified and the user-defined type descriptor of the direct supertype of
                UDT indicates that the referencing type of the direct supertype of UDT has a user-defined repre-
                sentation.
9) If <method specification list> is specified, then:

    a) Let M be the number of <method specification>s MSi, 1 (one) ≤ i ≤ M, contained in <method specifi-
       cation list>. Let MNi be the <method name> of MSi.

    b) For i ranging from 1 (one) to M:
         i)     If MSi does not specify INSTANCE, CONSTRUCTOR, or STATIC, then INSTANCE is implicit.

         ii)    If MSi specifies STATIC, then:

                1) None of SELF AS RESULT, SELF AS LOCATOR, and OVERRIDING shall be specified.
                2) MSi specifies a static method.

         iii)   If MSi specifies CONSTRUCTOR, then:



638 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                               11.41 <user-defined type definition>



                  1) SELF AS RESULT shall be specified.
                  2) OVERRIDING shall not be specified.
                  3) MNi shall be equivalent to the <qualified identifier> of UDTN.

                  4) The <returns data type> shall specify UDTN.
                  5) UDTD shall define a structured type.
                  6) MSi specifies an SQL-invoked constructor method.

         iv)      Let RNi be SN.MNi.

         v)       If <specific method name> is not specified, then an implementation-dependent <specific method
                  name> whose <schema name> is equivalent to SN is implicit.
         vi)      If <specific method name> contains a <schema name>, then that <schema name> shall be
                  equivalent to SN. If <specific method name> does not contain a <schema name>, then the
                  <schema name> of SN is implicit.
         vii)     The schema identified by the explicit or implicit <schema name> of the <specific method name>
                  shall not include a routine descriptor whose specific name is equivalent to <specific method
                  name> or a user-defined type descriptor that includes a method specification descriptor whose
                  specific method name is equivalent to <specific method name>.
         viii)    Let PDLi be the <SQL parameter declaration list> contained in MSi.

                  1) No two <SQL parameter name>s contained in PDLi shall be equivalent.

                  2) No <SQL parameter name> contained in PDLi shall be equivalent to SELF.

         ix)      Let Ni be the number of <SQL parameter declaration>s contained in MSi. For every <SQL
                  parameter declaration> PDi,j, 1 (one) ≤ j ≤ Ni:

                  1) PDi,j shall not contain <parameter mode>. A <parameter mode> of IN is implicit.

                  2) PDi,j shall not specify RESULT.

                  3) <parameter type> PTi,j immediately contained in PDi,j shall not specify ROW.

                  4) If PTi,j simply contains <locator indication>, then:

                      A) MSi shall not specify or imply LANGUAGE SQL.

                      B) PTi,j shall specify either binary large object type, character large object type, array type,
                         multiset type, or user-defined type.
         x)       If <returns data type> RT simply contains <locator indication>, then:
                  1) LANGUAGE SQL shall not be specified or implied.
                  2) RT shall be either binary large object type, character large object type, array type, multiset
                     type, or user-defined type.



©ISO/IEC 2003 – All rights reserved                                        Schema definition and manipulation 639
ISO/IEC 9075-2:2003 (E)
11.41 <user-defined type definition>



                3) <result cast> shall not be specified.
        xi)     If SELF AS RESULT is specified, then the <returns data type> shall specify UDTN.
        xii)    For k ranging from (i+1) to M, at least one of the following conditions shall be false:
                1) MNi and the <method name> of MSk are equivalent.

                2) Both MSi and MSk either specify CONSTRUCTOR or neither specifies CONSTRUCTOR.

                3) MSk has Ni <SQL parameter declaration>s.

                4) The data type of PTi,j, 1 (one) ≤ j ≤ Ni, is compatible with PTk,j.

        xiii)   The unaugmented SQL parameter declaration list of MSi is the <SQL parameter declaration
                list> contained in MSi.

        xiv)    If MSi specifies <original method specification>, then:

                1) The <method characteristics> of MSi shall contain at most one <language clause>, at most
                   one <parameter style clause>, at most one <deterministic characteristic>, at most one <SQL-
                   data access indication>, and at most one <null-call clause>.
                2) If <language clause> is not specified, then LANGUAGE SQL is implicit.
                3) If <deterministic characteristic> is not specified, then NOT DETERMINISTIC is implicit.
                4) <SQL-data access indication> shall be specified.
                5) If <null-call clause> is not specified, then CALLED ON NULL INPUT is implicit.
                6) Case:
                    A) If LANGUAGE SQL is specified or implied, then:
                        I)     The <returns clause> shall not specify a <result cast>.
                        II)    <SQL-data access indication> shall not specify NO SQL.
                        III)   <parameter style clause> shall not be specified.
                        IV)    Every <SQL parameter declaration> contained in <SQL parameter declaration
                               list> shall contain an <SQL parameter name>.
                    B) Otherwise:
                        I)     If <parameter style> is not specified, then PARAMETER STYLE SQL is implicit.
                        II)    If a <result cast> is specified, then let V be some value of the <data type> specified
                               in the <result cast> and let RT be the <returns data type>. The following shall be
                               valid according to the Syntax Rules of Subclause 6.12, “<cast specification>”:
                                  CAST ( V AS RT )




640 Foundation (SQL/Foundation)                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                             ISO/IEC 9075-2:2003 (E)
                                                                                   11.41 <user-defined type definition>



                           III)       If <result cast from type> RCT simply contains <locator indication>, then RCT
                                      shall be either binary large object type, character large object type, array type,
                                      multiset type, or user-defined type.
                  7) Let a conflicting method specification CMS be a method specification that is included in the
                     descriptor of a proper supertype of UDT, such that the following are all true:
                      A) The method names of CMS and MNi are equivalent.

                      B) CMS and MSi have the same number of SQL parameters Ni.

                      C) Let PCMSj, 1 (one) ≤ j ≤ Ni, be the j-th SQL parameter in the unaugmented SQL
                           parameter declaration list of CMS. Let PMSi,j, 1 (one) ≤ j ≤ Ni, be the j-th SQL parameter
                           in the unaugmented SQL parameter declaration list of MSi.

                      D) For j varying from 1 (one) to Ni, the declared type of PCMSj and the declared type of
                         PMSi,j are compatible.

                      E) MSi does not specify CONSTRUCTOR.

                      F) CMS and MSi either both are not static methods or one of CMS and MSi is a static method
                         and the other is not a static method.
                  8) There shall be no conflicting method specification.
                  9) The augmented SQL parameter declaration list NPLi of MSi is defined as follows:

                      Case:
                      A) If MSi specifies STATIC, then let NPLi be:
                                  ( PDi,1 , ..., PDi,Ni )


                      B) If MSi specifies SELF AS RESULT and SELF AS LOCATOR, then let NPLi be:
                                  ( SELF UDTN RESULT AS LOCATOR, PDi,1 , ..., PDi,Ni )


                      C) If MSi specifies SELF AS LOCATOR, then let NPLi be:
                                  ( SELF UDTN AS LOCATOR, PDi,1 , ..., PDi,Ni )


                      D) If MSi specifies SELF AS RESULT, then let NPLi be:
                                  ( SELF UDTN RESULT, PDi,1 , ..., PDi,Ni )


                      E) Otherwise, let NPLi be:
                                  ( SELF UDTN, PDi,1 , ..., PDi,Ni )




©ISO/IEC 2003 – All rights reserved                                           Schema definition and manipulation 641
ISO/IEC 9075-2:2003 (E)
11.41 <user-defined type definition>



                  F) Let ANi be the number of <SQL parameter declaration>s in NPLi.

              10) If MSi does not specify STATIC or CONSTRUCTOR, then there shall be no SQL-invoked
                  function F that satisfies all the following conditions:
                  A) The routine name of F and RNi have equivalent <qualified identifier>s.

                  B) If F is not a static method, then F has ANi SQL parameters; otherwise, F has (ANi-1)
                     SQL parameters.
                  C) The data type being defined is a proper subtype of
                       Case:
                       I)      If F is not a static method, then the declared type of the first SQL parameter of
                               F.
                       II)     Otherwise, the user-defined type whose user-defined type descriptor includes the
                               routine descriptor of F.

                  D) The declared type of the i-th SQL parameter in NPLi, 2 ≤ i ≤ ANi is compatible with

                       Case:
                       I)      If F is not a static method, then the declared type of i-th SQL parameter of F.
                       II)     Otherwise, the declared type of the (i-1)-th SQL parameter of F.
              11) If MSi specifies STATIC, then there shall be no SQL-invoked function F that is not a static
                  method that satisfies all the following conditions:
                  A) The routine name of F and RNi have equivalent <qualified identifier>s.

                  B) F has (ANi+1) SQL parameters.

                  C) The data type being defined is a subtype of the declared type of the first SQL parameter
                     of F.

                  D) The declared type of the i-th SQL parameter in F, 2 ≤ i ≤ (ANi+1), is compatible with
                     the declared type of the (i-1)-th SQL parameter of NPLi.

        xv)   If MSi specifies <overriding method specification>, then:

              1) MSi shall not specify STATIC or CONSTRUCTOR.

              2) A <returns clause> contained in MSi shall not specify a <result cast> or <locator indication>.

              3) Let the candidate original method specification COMS be an original method specification
                 whose descriptor is included in the descriptor of a proper supertype of the user-defined type
                 being defined, such that the following are all true:
                  A) The <method name> of COMS and MNi are equivalent.

                  B) COMS and MSi have the same number of SQL parameters Ni.


642 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                             ISO/IEC 9075-2:2003 (E)
                                                                                   11.41 <user-defined type definition>



                      C) Let PCOMSi, 1 (one) ≤ i ≤ Ni, be the i-th SQL parameter in the unaugmented SQL
                           parameter declaration list of COMS. Let POVMSi, 1 (one) ≤ i ≤ Ni, be the i-th SQL
                           parameter in the unaugmented SQL parameter declaration list of MSi.

                      D) For i varying from 1 (one) to Ni, the Syntax Rules of Subclause 9.16, “Data type identity”,
                         are applied with the declared type of PCOMSi and the declared type of POVMSi.

                      E) The descriptor of COMS shall not include an indication that STATIC or CONSTRUC-
                         TOR was specified.
                  4) There shall exist exactly one COMS.
                  5) COMS shall not be the corresponding method specification of a mutator or observer function.
                      NOTE 302 — “Corresponding method specification” is defined in Subclause 11.50, “<SQL-invoked routine>”.

                  6) For j ranging from 1 (one) to Ni, all of the following shall be true:

                      A) If POVMSj contains an <SQL parameter name> PNM1, then PCOMSj contains an <SQL
                         parameter name> that is equivalent to PNM1.
                      B) If PCOMSj contains an <SQL parameter name> PNM2, then POVMSj contains an <SQL
                         parameter name> that is equivalent to PNM2.
                      C) If POVMSj contains a <locator indication>, then PCOMSj contains a <locator indication>.

                      D) If PCOMSj contains a <locator indication>, then POVMSj contains a <locator indication>.

                  7) Let ROVMS be the <returns data type> of MSi. Let RCOMS be the <returns data type> of
                     COMS.
                      Case:
                      A) If RCOMS is a user-defined type, then:
                           I)         Let a candidate overriding method specification COVRMS be a method specifi-
                                      cation that is included in the descriptor of a proper supertype of UDT, such that
                                      all of the following are true:
                                      1) The <method name> of COVRMS and MNi are equivalent.

                                      2) COVRMS and MSi have the same number of SQL parameters Ni.

                                      3) Let PCOVRMSi, 1 (one) ≤ i ≤ Ni, be the i-th SQL parameter in the unaug-
                                         mented SQL parameter declaration list of COVRMS. Let POVMSi, 1 (one)
                                          ≤ i ≤ Ni, be the i-th SQL parameter in the unaugmented SQL parameter dec-
                                          laration list of MSi.

                                      4) For i varying from 1 (one) to Ni, the Syntax Rules of Subclause 9.16, “Data
                                         type identity”, are applied with the declared type of PCOVRMSi and the
                                         declared type of POVMSi.



©ISO/IEC 2003 – All rights reserved                                           Schema definition and manipulation 643
ISO/IEC 9075-2:2003 (E)
11.41 <user-defined type definition>



                       II)    Let NOVMS be the number of candidate overriding method specifications. For i
                              varying from 1 (one) to NOVMS, ROVMS shall be a subtype of the <returns data
                              type> of the i-th candidate overriding method specification.
                   B) Otherwise, the Syntax Rules of Subclause 9.16, “Data type identity”, are applied with
                      RCOMS and ROVMS.
               8) The augmented SQL parameter declaration list ASPDL of MSi is formed from the augmented
                  SQL parameter declaration list of COMS by replacing the <data type> of the first parameter
                  (named SELF) with UDTN.
               9) There shall be no SQL-invoked function F that satisfies all the following conditions:
                   A) The routine name of F and the RNi have equivalent <qualified identifier>s.

                   B) F and ASPDL have the same number N of SQL parameters.
                   C) The data type being defined is a proper subtype of the declared type of the first SQL
                      parameter of F.

                   D) The declared type of POVMSi, 1 (one) ≤ i ≤ N, is compatible with the declared type of
                      SQL parameter Pi+1 of F.

                   E) F is not an SQL-invoked method.


Access Rules
1) Let A be the <authorization identifier> that owns SS. If a <user-defined type definition> is contained in an
   <SQL-client module definition>, then the enabled authorization identifiers shall include A.
2) The applicable privileges for A shall include UNDER on the <user-defined type name> specified in <subtype
   clause>.


General Rules
1) A user-defined type descriptor UDTDS that describes UDT is created. UDTDS includes:
    a) The user-defined type name UDTN.
    b) If UDT is a distinct type or INSTANTIABLE is specified or implicit, then an indication that UDT is
       instantiable; otherwise, an indication that UDT is not instantiable.
    c) An indication of whether the user-defined type is final or not final.
    d) An indication of whether UDT is a distinct type or a structured type.
    e) If UDT is a distinct type, then the data type descriptor of SDT.
    f) If UDT is a structured type, then:
        i)     For each inherited attribute IA of UDT, the attribute descriptor of IA and an indication that IA
               is an inherited attribute.



644 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                             11.41 <user-defined type definition>



         ii)      For each originally-defined attribute ODA of UDT, the attribute descriptor of ODA and an indi-
                  cation that ODA is an originally-defined attribute.
         iii)     The name of the direct supertype of UDT.
         iv)      A transform descriptor with an empty list of groups.
         v)       Case:
                  1) If <user-defined representation> is specified, then an indication that the referencing type of
                     UDT has a user-defined representation, along with the data type descriptor of the represen-
                     tation type of the referencing type of UDT.
                  2) If <derived representation> is specified, then an indication that the referencing type of UDT
                     has a derived representation, along with the attributes specified by <list of attributes>.
                  3) Otherwise, an indication that the referencing type of UDT has a system-defined representation.
         vi)      If <subtype clause> is specified, then let SUDT be the direct supertype of UDT and let DSUDT
                  be the user-defined type descriptor of SUDT. Let RUDT be the referencing type of UDT and let
                  RSUDT be the referencing type of SUDT.
                  Case:
                  1) If DSUDT indicates that RSUDT has a user-defined representation, then an indication that
                     RUDT has a user-defined representation and the data type descriptor of the representation
                     type of RSUDT included in DSUDT.
                  2) If DSUDT indicates that RSUDT has a derived representation, then an indication that RUDT
                     has a derived representation and the list of attributes included in DSUDT.
                  3) If DSUDT indicates that RSUDT has a system-defined representation, then an indication
                     that RUDT has a system-defined representation.
         vii)     The ordering form NONE.
         viii)    The ordering category STATE.
    g) If <method specification list> is specified, then for every <original method specification> ORMS con-
       tained in <method specification list>, a method specification descriptor that includes:
         i)       An indication that the method specification is original.
         ii)      An indication of whether STATIC or CONSTRUCTOR is specified.
         iii)     The <method name> of ORMS.
         iv)      The <specific method name> of ORMS.
         v)       The <SQL parameter declaration list> contained in ORMS (augmented, if STATIC is not specified
                  in ORMS, to include the implicit first parameter with parameter name SELF).
         vi)      The <language name> contained in the explicit or implicit <language clause>.
         vii)     The explicit or implicit <parameter style> if the <language name> is SQL.
         viii)    The <returns data type>.


©ISO/IEC 2003 – All rights reserved                                      Schema definition and manipulation 645
ISO/IEC 9075-2:2003 (E)
11.41 <user-defined type definition>



        ix)     The <result cast from type>, if any.
        x)      An indication of whether the method is deterministic.
        xi)     An indication of whether the method possibly modifies SQL-data, possibly reads SQL-data,
                possibly contains SQL, or does not possibly contain SQL.
        xii)    An indication of whether the method should not be invoked if any argument is the null value.
    h) If <method specification list> is specified, then for every <overriding method specification> OVMS
       contained in <method specification list>, let DCMS be the descriptor of the corresponding original
       method specification. The method specification descriptor of OVMS includes:
        i)      An indication that the method specification is overriding.
        ii)     The <method name> of OVMS.
        iii)    The <specific method name> of OVMS.
        iv)     The <SQL parameter declaration list> contained in OVMS (augmented to include the implicit
                first parameter with parameter name SELF).
        v)      The <language name> included in DCMS.
        vi)     The <parameter style> included in DCMS (if any).
        vii)    The <returns data type> of OVMS.
        viii)   The <result cast from type> included in DCMS (if any).
        ix)     The determinism indication included in DCMS.
        x)      The SQL-data access indication included in DCMS.
        xi)     The indication included in DCMS, whether the method should not be invoked if any argument
                is the null value.
2) If UDTD specifies a distinct type, then:
    a) The degree of UDT is 0 (zero).
    b) The following SQL-statements are executed without further Access Rule checking:
        CREATE FUNCTION SN.FNUDT ( SDTP SDT )
            RETURNS UDTN
            LANGUAGE SQL
            DETERMINISTIC
          RETURN RV1
        CREATE FUNCTION SN.FNSDT ( UDTP UDTN )
            RETURNS SDT
            LANGUAGE SQL
            DETERMINISTIC
          RETURN RV2
        CREATE CAST ( UDTN AS SDT )
            WITH FUNCTION FNSDT ( UDTN )
            AS ASSIGNMENT
        CREATE CAST (SDT AS UDTN)
            WITH FUNCTION SN.FNUDT ( SDT )



646 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                               ISO/IEC 9075-2:2003 (E)
                                                                                     11.41 <user-defined type definition>



             AS ASSIGNMENT
         CREATE TRANSFORM FOR UDTN
             FNUDT ( FROM SQL WITH FUNCTION FNSDT ( UDTN ),
                       TO SQL WITH FUNCTION SN.FNUDT(SDT) )


         where: SN is the explicit or implicit <schema name> of UDTN; RV1 is an implementation-dependent
         <value expression> such that for every invocation of SN.FNUDT with argument value AV1, RV1
         evaluates to the representation of AV1 in the data type identified by UDTN; RV2 is an implementation-
         dependent <value expression> such that for every invocation of SN.FNSDT with argument value AV2,
         RV2 evaluates to the representation of AV2 in the data type SDT, and SDTP and UDTP are <SQL
         parameter name>s arbitrarily chosen.
    c) Case:
         i)       If SDT is not a large object type, then the following SQL-statement is executed without further
                  Access Rule checking:
                     CREATE ORDERING FOR UDTN
                     ORDER FULL BY
                     MAP WITH FUNCTION FNSDT(UDTN)
                     FOR UDTN


         ii)      If SDT is a large object type, and the SQL implementation supports Feature T042, “Extended
                  LOB data type support”, then the following SQL-statement is executed without further Access
                  Rule checking:
                     CREATE ORDERING FOR UDTN
                     ORDER EQUALS ONLY BY
                     MAP WITH FUNCTION FNSDT(UDTN)
                     FOR UDTN

                  NOTE 303 — If SDT is a large object type, and the SQL implementation does not support Feature T042, “Extended
                  LOB data type support”, then no ordering for UDTN is created.

3) If UDTD specifies a structured type, then:
    a) The degree of UDT is the number of attributes of UDT, including inherited attributes. The ordinal
       position of an inherited attribute is its ordinal position in the direct supertype of UDT. The ordinal
       position of an attribute that is an originally-defined attribute is the ordinal position of its corresponding
       <attribute definition> in <member list> plus the number of inherited attributes.
    b) If INSTANTIABLE is specified, then let V be a value of the most specific type UDT such that, for
       every attribute ATT of UDT, invocation of the corresponding observer function on V yields the default
       value for ATT. The following <SQL-invoked routine> is effectively executed:
               CREATE FUNCTION UDTN () RETURNS UDTN
                   RETURN V

         This SQL-invoked function is the constructor function for UDT.
    c) If <user-defined representation> is specified or if <subtype clause> is specified and the user-defined
       type descriptor of the direct supertype of UDT indicates that the referencing type of the direct supertype
       of UDT has a user-defined representation, then the following SQL-statements are executed without
       further Access Rule checking:


©ISO/IEC 2003 – All rights reserved                                             Schema definition and manipulation 647
ISO/IEC 9075-2:2003 (E)
11.41 <user-defined type definition>



           CREATE FUNCTION SN.FNREF ( BTP BT )
               RETURNS REF(UDTN)
               LANGUAGE SQL
               DETERMINISTIC
               STATIC DISPATCH
             RETURN RV1
           CREATE FUNCTION SN.FNTYP ( UDTNP REF(UDTN) )
               RETURNS BT
               LANGUAGE SQL
               DETERMINISTIC
               STATIC DISPATCH
             RETURN RV2
           CREATE CAST ( BT AS REF(UDTN) )
               WITH FUNCTION SN.FNREF(BT)
           CREATE CAST ( REF(UDTN) AS BT )
               WITH FUNCTION SN.FNTYP(REF(UDTN) )


        where: SN is the explicit or implicit <schema name> of UDTN; RV1 is an implementation-dependent
        <value expression> such that for every invocation of SN.FNREF with argument value AV1, RV1 eval-
        uates to the representation of AV1 in the data type identified by REF(UDTN); RV2 is an implementation-
        dependent <value expression> such that for every invocation of SN.FNTYP with argument value AV2,
        RV2 evaluates to the representation of AV2 in the data type BT; and UDTNP is an <SQL parameter
        name> arbitrarily chosen.
4) A privilege descriptor is created that defines the USAGE privilege on UDT to A. This privilege is grantable.
   The grantor for this privilege descriptor is set to the special grantor value “_SYSTEM”.
5) If UDTD specifies a structured type, then a privilege descriptor is created that defines the UNDER privilege
   on UDT to A. The grantor for the privilege descriptor is set to the special grantor value “_SYSTEM”. This
   privilege is grantable if and only if A holds the UNDER privilege on the direct supertype of UDT WITH
   GRANT OPTION.


Conformance Rules
1) Without Feature S023, “Basic structured types”, conforming SQL language shall not contain a <member
   list>.
2) Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain an
   <instantiable clause> that contains NOT INSTANTIABLE.
3) Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain an
   <original method specification> that immediately contains SELF AS RESULT.
4) Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain a <method
   characteristics> that contains a <parameter style> that contains GENERAL.
5) Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain an
   <original method specification> that contains an <SQL-data access indication> that immediately contains
   NO SQL.




648 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                              11.41 <user-defined type definition>



6) Without Feature T571, “Array-returning external SQL-invoked functions”, conforming SQL language shall
   not contain a <method specification> that contains a <returns clause> that satisfies either of the following
   conditions:
    a) A <result cast from type> is specified that simply contains an <array type> and does not contain a
       <locator indication>.
    b) A <result cast from type> is not specified and <returns data type> simply contains an <array type> and
       does not contain a <locator indication>.
7) Without Feature T572, “Multiset-returning external SQL-invoked functions”, conforming SQL language
   shall not contain a <method specification> that contains a <returns clause> that satisfies either of the fol-
   lowing conditions:
    a) A <result cast from type> is specified that simply contains a <multiset type> and does not contain a
       <locator indication>.
    b) A <result cast from type> is not specified and <returns data type> simply contains a <multiset type>
       and does not contain a <locator indication>.
8) Without Feature S043, “Enhanced reference types”, conforming SQL language shall not contain a <reference
   type specification>.
9) Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain a <partial
   method specification> that contains INSTANCE or STATIC.
10) Without Feature S023, “Basic structured types”, conforming SQL language shall not contain a <method
    specification list>.
11) Without Feature S025, “Final structured types”, in conforming SQL language, a <user-defined type defini-
    tion> that defines a structured type shall contain a <finality> that is NOT FINAL.
12) Without Feature S028, “Permutable UDT options list”, conforming SQL language shall not contain a <user-
    defined type option list> in which <instantiable clause>, if specified, <finality>, <reference type specifica-
    tion>, if specified, <cast to ref>, if specified, <cast to type>, if specified, <cast to distinct>, if specified,
    and <cast to source>, if specified, do not appear in that sequence.




©ISO/IEC 2003 – All rights reserved                                      Schema definition and manipulation 649
ISO/IEC 9075-2:2003 (E)
11.42 <attribute definition>



11.42 <attribute definition>

Function
Define an attribute of a structured type.


Format
<attribute definition> ::=
    <attribute name> <data type>
    [ <attribute default> ]
    [ <collate clause> ]

<attribute default> ::= <default clause>


Syntax Rules
1) An <attribute definition> defines a certain component of some structured type. Let UDT be that structured
   type, let UDTN be its name, and let SS be the SQL-schema whose descriptor includes the descriptor of
   UDT.
2) Let AN be the <attribute name> contained in the <attribute definition>.
3) The declared type DT of the attribute is <data type>.
4) <collate clause> shall not be both specified in <data type> and immediately contained in <attribute defini-
   tion>. If <collate clause> is immediately contained in <attribute definition>, then it is equivalent to speci-
   fying an equivalent <collate clause> in <data type>.
5) DT shall not be based on UDT.
    NOTE 304 — The notion of one data type being based on another data type is defined in Subclause 4.1, “Data types”.

6) If DT is a <character string type> and does not contain a <character set specification>, then the default
   character set for SS is implicit.


Access Rules
    None.


General Rules
1) A data type descriptor is created that describes DT.
2) Let A be the attribute defined by <attribute definition>.
3) An attribute descriptor is created that describes A. The attribute descriptor includes:
    a) AN, the name of the attribute.



650 Foundation (SQL/Foundation)                                                               ©ISO/IEC 2003 – All rights reserved
                                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                                               11.42 <attribute definition>



    b) The data type descriptor of DT.
    c) The ordinal position of the attribute in UDT.
    d) The implicit or explicit <attribute default>.
    e) The name UDTN of the user-defined type UDT.
4) An SQL-invoked method OF is created whose signature and result data type are as given in the descriptor
   of the original method specification of the observer function of A. Let V be a value in UDT. If V is the null
   value, then the invocation V.AN() of OF returns the result of:
        CAST (NULL AS DT)

    Otherwise, V.AN() returns the value of A in V.
    NOTE 305 — The original method specification of the observer function of A is defined in the Syntax Rules of Subclause 11.41,
    “<user-defined type definition>”.
    NOTE 306 — The descriptor of OF is created under the General Rules of Subclause 11.50, “<SQL-invoked routine>”.

5) An SQL-invoked method MF is created whose signature and result data type are as given in the descriptor
   of the original method specification of the mutator function of A. Let V be a value in UDT and let AV be a
   value in DT. If V is the null value, then the invocation V.AN(AV) of MF raises an exception condition: data
   exception — null value substituted for mutator subject parameter; otherwise, the invocation V.AN(AV)
   returns V2 such that V2.AN() = AV and for every other observer function ANX of UDT, V2.ANX() = V.ANX().
    NOTE 307 — The original method specification of the mutator function of A is defined in the Syntax Rules of Subclause 11.41,
    “<user-defined type definition>”.
    NOTE 308 — The descriptor of MF is created under the General Rules of Subclause 11.50, “<SQL-invoked routine>”.


Conformance Rules
1) Without Feature S023, “Basic structured types”, conforming SQL language shall not contain an <attribute
   definition>.
2) Without Feature F692, “Extended collation support”, conforming SQL language shall not contain an
   <attribute definition> that immediately contains a <collate clause>.
3) Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain an
   <attribute default>.
4) Without Feature S026, “Self-referencing structured types”, conforming SQL language shall not contain a
   <data type> simply contained in an <attribute definition> that is not be a <reference type> whose <referenced
   type> is equivalent to the <schema-resolved user-defined type name> simply contained in the <user-defined
   type definition> that contains <attribute definition>.




©ISO/IEC 2003 – All rights reserved                                              Schema definition and manipulation 651
ISO/IEC 9075-2:2003 (E)
11.43 <alter type statement>



11.43 <alter type statement>

Function
Change the definition of a user-defined type.


Format
<alter type statement> ::=
    ALTER TYPE <schema-resolved user-defined type name> <alter type action>

<alter type action> ::=
    <add attribute definition>
  | <drop attribute definition>
  | <add original method specification>
  | <add overriding method specification>
  | <drop method specification>


Syntax Rules
1) Let DN be the <schema-resolved user-defined type name> and let D be the data type identified by DN.
2) The schema identified by the explicit or implicit schema name of the <schema-resolved user-defined type
   name> shall include the descriptor of D. Let S be that schema.
3) The scope of the <schema-resolved user-defined type name> is the entire <alter type statement>.
4) If <alter type action> contains <add attribute definition>, <drop attribute definition>, or <add overriding
   method specification>, then D shall be a structured type.
5) Let A be the <authorization identifier> that owns the schema S.


Access Rules
1) If an <alter type statement> is contained in an <SQL-client module definition>, then the enabled authorization
   identifiers shall include A.
2) The applicable privileges for A shall include UNDER on each proper supertype of D.


General Rules
1) The user-defined type descriptor of D is modified as specified by <alter type action>.


Conformance Rules
1) Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain an <alter
   type statement>.



652 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                                 ISO/IEC 9075-2:2003 (E)
                                                                                          11.44 <add attribute definition>



11.44 <add attribute definition>

Function
Add an attribute to a user-defined type.


Format
<add attribute definition> ::= ADD ATTRIBUTE <attribute definition>


Syntax Rules
1) Let D be the user-defined type identified by the <schema-resolved user-defined type name> immediately
   contained in the containing <alter type statement>. Let SPD be any supertype of D. Let SBD be any subtype
   of D.
2) Let RD be the reference type whose referenced type is D. Let SPRD be any supertype of RD. Let SBRD be
   any subtype of RD. Let AD be any collection type whose element type is D. Let SPAD be any collection
   type whose element type is SPD or SPRD. Let SBAD be any collection type whose element type is SBD or
   SBRD.
3) The declared type of a column of a base table shall not be SPRD, SBRD, SPAD, or SBAD.
4) The declared type of a column of a base table shall not be based on D.
    NOTE 309 — The notion of one data type type being based on another data type is defined in Subclause 4.1, “Data types”.

5) SBD shall not be the structured type of a referenceable table.
6) Let M be the mutator function resulting from the <attribute definition>, had that <attribute definition> been
   simply contained in the <user-defined type definition> for D. There shall be no SQL-invoked routine F
   that satisfies all of the following conditions:
    a) The routine name included in the descriptor of F and the <schema qualified routine name> of M have
       equivalent <qualified identifier>s.
    b) F has 2 SQL parameters.
    c) The declared type of the first SQL parameter of F is a subtype or supertype of D.
    d) The declared type of the second SQL parameter of F is a compatible with the second SQL parameter
       of M.
7) Let O be the observer function resulting from the <attribute definition>, had that <attribute definition>
   been simply contained in the <user-defined type definition> for D. There shall be no SQL-invoked routine
   F that satisfies all of the following conditions:
    a) The <schema qualified routine name> of O and the routine name included in the descriptor of F have
       equivalent <qualified identifier>s.
    b) F has 1 (one) SQL parameter.



©ISO/IEC 2003 – All rights reserved                                             Schema definition and manipulation 653
ISO/IEC 9075-2:2003 (E)
11.44 <add attribute definition>



    c) The declared type of the first SQL parameter of F is a subtype or supertype of D.


Access Rules
    None.


General Rules
1) The attribute defined by the <attribute definition> is added to D.
2) In all other respects, the specification of an <attribute definition> in an <alter type statement> has the same
   effect as specification of the <attribute definition> simply contained in the <user-defined type definition>
   for D would have had. In particular, the degree of D is increased by 1 (one) and the ordinal position of that
   attribute is equal to the new degree of D as specified in the General Rules of Subclause 11.42, “<attribute
   definition>”.
3) Let A be the attribute defined by <attribute definition>. Let CPA be a copy of the descriptor of A, modified
   to include an indication that the attribute is an inherited attribute.
4) For each proper subtype PSBD of D:
    a) Let DPSBD be the descriptor of PSBD, let N be the number of attribute descriptors included in DPSBD,
       and let DAi, 1 (one) ≤ i ≤ N, be the attribute descriptors included in DPSBD.

    b) For every i between 1 (one) and N, if DAi is the descriptor of an originally-defined attribute, then
       increase the ordinal position included in DAi by 1 (one).

    c) Include CPA in DPSBD.


Conformance Rules
    None.




654 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                                ISO/IEC 9075-2:2003 (E)
                                                                                         11.45 <drop attribute definition>



11.45 <drop attribute definition>

Function
Destroy an attribute of a user-defined type.


Format
<drop attribute definition> ::= DROP ATTRIBUTE <attribute name> RESTRICT


Syntax Rules
1) Let D be the user-defined type identified by the <schema-resolved user-defined type name> immediately
   contained in the containing <alter type statement>.
2) Let A be the attribute identified by the <attribute name> AN.
3) A shall be an attribute of D that is not an inherited attribute, and A shall not be the only attribute of D.
4) Let SPD be any supertype of D. Let SBD be any subtype of D. Let RD be the reference type whose referenced
   type is D. Let SPRD be any supertype of RD. Let SBRD be any subtype of RD. Let AD be any collection
   type whose element type is D. Let SPAD be any collection type whose element type is SPD or SPRD. Let
   SBAD be any collection type whose element type is SBD or SBRD.
5) The declared type of any column of any base table shall not be SPRD, SBRD, SPAD, or SBAD.
6) The declared type of any column of any base table shall not be based on D.
    NOTE 310 — The notion of one data type type being based on another data type is defined in Subclause 4.1, “Data types”.

7) SBD shall not be the structured type of a referenceable table.
8) Let R1 be the mutator function and let R2 be the observer function of A.
    a) R1 and R2 shall not be the subject routine of any <routine invocation>, <method invocation>, <static
       method invocation>, or <method reference> that is contained in any of the following:
         i)       The SQL routine body of any routine descriptor.
         ii)      The <query expression> of any view descriptor.
         iii)     The <search condition> of any constraint descriptor.
         iv)      The trigger action of any trigger descriptor.
    b) The specific names of R1 and R2 shall not be included in any user-defined cast descriptor.
    c) R1 and R2 shall not be the ordering function in the descriptor of any user-defined type.


Access Rules
    None.


©ISO/IEC 2003 – All rights reserved                                             Schema definition and manipulation 655
ISO/IEC 9075-2:2003 (E)
11.45 <drop attribute definition>



General Rules
1) The descriptor of A is removed from the descriptor of every SBD.
2) The descriptor of A is destroyed.
3) The descriptors of the mutator and observer functions of A are destroyed.
4) The degree of every SBD is reduced by 1 (one). The ordinal position of all attributes having an ordinal
   position greater than the ordinal position of A in SBD is reduced by 1 (one).


Conformance Rules
    None.




656 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                     11.46 <add original method specification>



11.46 <add original method specification>

Function
Add an original method specification to a user-defined type.


Format
<add original method specification> ::= ADD <original method specification>


Syntax Rules
1) Let D be the user-defined type identified by the <schema-resolved user-defined type name> DN immediately
   contained in the containing <alter type statement>. Let SN be the specified or implied <schema name> of
   DN. Let SPD be any supertype of D, if any. Let SBD be any subtype of D, if any.
2) Let ORMS and PORMS be the <original method specification> and its immediately contained <partial
   method specification>, respectively.
3) Let MN, MPDL and MCH be the <method name>, the <SQL parameter declaration list> and the <method
   characteristics>, respectively, that are simply contained in ORMS. MPDL is called the unaugmented SQL
   parameter declaration list of ORMS.
4) If PORMS does not specify INSTANCE, CONSTRUCTOR, or STATIC, then INSTANCE is implicit.
5) If PORMS specifies CONSTRUCTOR, then:
    a) SELF AS RESULT shall be specified.
    b) MN shall be equivalent to the <qualified identifier> of DN.
    c) The <returns data type> shall specify DN.
    d) D shall be a structured type.
    e) PORMS specifies an SQL-invoked constructor method.
6) If PORMS specifies STATIC, then:
    a) Neither SELF AS RESULT nor SELF AS LOCATOR shall be specified.
    b) PORMS specifies a static method.
7) Let RN be SN.MN.
8) Case:
    a) If PORMS does not specify <specific method name>, then an implementation-dependent <specific
       method name> is implicit whose <schema name> is equivalent to SN.
    b) Otherwise:
         Case:


©ISO/IEC 2003 – All rights reserved                                   Schema definition and manipulation 657
ISO/IEC 9075-2:2003 (E)
11.46 <add original method specification>



        i)     If <specific method name> contains a <schema name>, then that <schema name> shall be
               equivalent to SN.
        ii)    Otherwise, the <schema name> SN is implicit.
    The schema identified by the explicit or implicit <schema name> of the <specific method name> shall not
    include a routine descriptor whose specific name is equivalent to <specific method name> or a user-defined
    type descriptor that includes a method specification descriptor whose specific method name is equivalent
    to <specific method name>.
9) MCH shall contain at most one <language clause>, at most one <parameter style clause>, at most one
   <deterministic characteristic>, at most one <SQL-data access indication>, and at most one <null-call
   clause>.
    a) If <language clause> is not specified in MCH, then LANGUAGE SQL is implicit.
    b) Case:
        i)     If LANGUAGE SQL is specified or implied, then:
               1) <parameter style clause> shall not be specified.
               2) <SQL-data access indication> shall not specify NO SQL.
               3) Every <SQL parameter declaration> contained in <SQL parameter declaration list> shall
                  contain an <SQL parameter name>.
               4) The <returns clause> shall not specify a <result cast>.
        ii)    Otherwise:
               1) If <parameter style clause> is not specified, then PARAMETER STYLE SQL is implicit.
               2) If a <result cast> is specified, then let V be some value of the <data type> specified in the
                  <result cast> and let RT be the <returns data type>. The following shall be valid according
                  to the Syntax Rules of Subclause 6.12, “<cast specification>”:
                      CAST ( V AS RT )

               3) If <result cast from type> RCT simply contains <locator indication>, then RCT shall be
                  either binary large object type, character large object type, array type, multiset type, or user-
                  defined type.
    c) If <deterministic characteristic> is not specified in MCH, then NOT DETERMINISTIC is implicit.
    d) If <SQL-data access indication> is not specified, then CONTAINS SQL is implicit.
    e) If <null-call clause> is not specified in MCH, then CALLED ON NULL INPUT is implicit.
10) No two <SQL parameter name>s contained in MPDL shall be equivalent.
11) No <SQL parameter name> contained in MPDL shall be equivalent to SELF.
12) Let N be the number of <SQL parameter declaration>s contained in MPDL. For every <SQL parameter
    declaration> PDj, 1 (one) ≤ j ≤ N:



658 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                         11.46 <add original method specification>



    a) PDj shall not contain <parameter mode>. A <parameter mode> of IN is implicit.

    b) PDj shall not specify RESULT.

    c) <parameter type> PTj immediately contained in PDj shall not specify ROW.

    d) If PTj simply contains <locator indication>, then:

         i)       MCH shall not specify LANGUAGE SQL, nor shall LANGUAGE SQL be implied.
         ii)      PTj shall specify either binary large object type, character large object type, array type, multiset
                  type, or user-defined type.
13) If <returns data type> RT simply contains <locator indication>, then:
    a) MCH shall not be specify LANGUAGE SQL, nor shall LANGUAGE SQL be implied.
    b) RT shall be either binary large object type, character large object type, array type, multiset type, or
       user-defined type.
    c) <result cast> shall not be specified.
14) If SELF AS RESULT is specified, then the <returns data type> shall specify DN.
15) Case:
    a) If ORMS specifies CONSTRUCTOR, then let a conflicting method specification CMS be a method
       specification whose descriptor is included in the descriptor of D, such that the following are all true:
         i)       MPDL and the unaugmented SQL parameter list of CMS have the same number N of SQL
                  parameters.

         ii)      Let PCMSj, 1 (one) ≤ j ≤ N, be the j-th SQL parameter in the unaugmented SQL parameter
                  declaration list of CMS. Let PMSj, 1 (one) ≤ j ≤ N, be the j-th SQL parameter in the unaugmented
                  SQL parameter declaration list MPDL.
         iii)     For j varying from 1 (one) to N, the declared type of PCMSj and the declared type of PMSj are
                  compatible.
         iv)      CMS is an SQL-invoked constructor method.
    b) Otherwise, let a conflicting method specification CMS be a method specification whose descriptor is
       included in the descriptor of some SPD or SBD, such that the following are all true:
         i)       MN and the method name included in the descriptor of CMS are equivalent.
         ii)      MPDL and the unaugmented SQL parameter list of CMS have the same number N of SQL
                  parameters.

         iii)     Let PCMSj, 1 (one) ≤ j ≤ N, be the j-th SQL parameter in the unaugmented SQL parameter
                  declaration list of CMS. Let PMSj, 1 (one) ≤ j ≤ N, be the j-th SQL parameter in the unaugmented
                  SQL parameter declaration list MPDL.




©ISO/IEC 2003 – All rights reserved                                        Schema definition and manipulation 659
ISO/IEC 9075-2:2003 (E)
11.46 <add original method specification>



        iv)    For j varying from 1 (one) to N, the declared type of PCMSj and the declared type of PMSj are
               compatible.
        v)     CMS and ORMS either both are not instance methods or one of CMS and ORMS is a static method
               and the other is an instance method.
16) There shall be no conflicting method specification.

17) Let MPi, 1 (one) ≤ i ≤ N, be the i-th <SQL parameter declaration> contained in MPDL. The augmented
    SQL parameter declaration list NPL of ORMS is defined as follows:
    Case:
    a) If PORMS specifies STATIC, then let NPL be:
             ( MP1, ..., MPN )

    b) If ORMS specifies SELF AS RESULT and SELF AS LOCATOR, then let NPL be:
             ( SELF DN RESULT AS LOCATOR, MP1, ..., MPN )

    c) If ORMS specifies SELF AS LOCATOR , then let NPL be:
             ( SELF DN AS LOCATOR, MP1, ..., MPN )

    d) If ORMS specifies SELF AS RESULT, then let NPL be:
             ( SELF DN RESULT, MP1 , ..., MPN )

    e) Otherwise, let NPL be:
             ( SELF DN, MP1, ..., MPN )

    Let AN be the number of <SQL parameter declaration>s in NPL.
18) If PORMS does not specify STATIC or CONSTRUCTOR, then there shall be no SQL-invoked function
    F that satisfies all the following conditions:
    a) F is not an SQL-invoked method.
    b) The <routine name> of F and RN have equivalent <qualified identifier>s.
    c) F has AN SQL parameters.
    d) D is a subtype or supertype of the declared type of the first SQL parameter of F.

    e) The declared type of the i-th SQL parameter in NPL, 2 ≤ i ≤ AN is compatible with the declared type
       of i-th SQL parameter of F.
19) If PORMS specifies STATIC, then there shall be no SQL-invoked function F that is not a static method
    that satisfies all the following conditions:
    a) The <routine name> of F and RN have equivalent <qualified identifier>s.


660 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                    11.46 <add original method specification>



    b) F has (AN+1) SQL parameters.
    c) D is a subtype or supertype of the declared type of the first SQL parameter of F.

    d) The declared type of the i-th SQL parameter of F, 2 ≤ i ≤ (AN+1), is compatible with the declared type
       of the (i-1)-th SQL parameter of NPL.


Access Rules
    None.


General Rules
1) Let STDS be the descriptor of D. A method specification descriptor DOMS is created for ORMS. DOMS
   includes:
    a) An indication that the method specification is original.
    b) An indication of whether STATIC or CONSTRUCTOR is specified.
    c) The <method name> MN.
    d) The <specific method name> contained in PORMS.
    e) The augmented SQL parameter declaration list NPL.
    f) For every parameter descriptor of a parameter of NPL, a locator indication (if specified).
    g) The <returns data type> contained in PORMS.
    h) The <result cast from type> contained in PORMS (if any).
    i)   The locator indication, if a <locator indication> is contained in the <returns clause> of PORMS (if
         any).
    j)   The <language name> explicitly or implicitly contained in MCH.
    k) The explicit or implicit <parameter style> contained in MCH, if the <language name> is not SQL.
    l)   The determinism indication contained in MCH.
    m) An indication of whether the method possibly modifies SQL-data, possibly reads SQL-data, possibly
       contains SQL, or does not possibly contain SQL.
    n) An indication of whether the method should not be invoked if any argument is the null value.
2) DOMS is added to STDS.
3) Let N be the number of table descriptors that include the user-defined type name of a subtype of D.
    For i varying from 1 (one) to N:
    a) Let TNi be the <table name> included in the i-th such table descriptor.




©ISO/IEC 2003 – All rights reserved                                   Schema definition and manipulation 661
ISO/IEC 9075-2:2003 (E)
11.46 <add original method specification>



    b) For every table privilege descriptor that specifies TNi and a privilege of SELECT, a new table/method
       privilege descriptor is created that specifies TNi, the same action, grantor, and grantee, and the same
       grantability, and the <specific method name> contained in ORMS.


Conformance Rules
    None.




662 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                 11.47 <add overriding method specification>



11.47 <add overriding method specification>

Function
Add an overriding method specification to a user-defined type.


Format
<add overriding method specification> ::=
    ADD <overriding method specification>


Syntax Rules
1) Let OVMS be the <overriding method specification> immediately contained in <add overriding method
   specification>. Let D be the user-defined type identified by the <schema-resolved user-defined type name>
   DN immediately contained in the <alter type statement> containing OVMS. Let SN be the specified or
   implied <schema name> of DN. Let SPD be any supertype of D, if any. Let SBD be any subtype of D, if
   any.
2) Let POVMS be the <partial method specification> immediately contained in OVMS. POVMS shall not
   specify STATIC or CONSTRUCTOR.
3) Let MN, RTC and MPDL be <routine name>, the <returns clause> and the <SQL parameter declaration
   list> immediately contained in POVMS.
4) MN shall not be equivalent to the <qualified identifier> of the user-defined type name of any SPD or SBD
   other than D.
5) Let RN be SN.MN.
6) Case:
    a) If POVMS does not specify <specific method name>, then an implementation-dependent <specific
       method name> is implicit whose <schema name> is equivalent to SN.
    b) Otherwise,
         Case:
         i)       If <specific method name> contains a <schema name>, then that <schema name> shall be
                  equivalent to SN.
         ii)      Otherwise, the <schema name> SN is implicit.
    The schema identified by the explicit or implicit <schema name> of the <specific method name> shall not
    include a routine descriptor whose specific name is equivalent to <specific method name> or a user-defined
    type descriptor that includes a method specification descriptor whose specific method name is equivalent
    to <specific method name>.
7) RTC shall not specify a <result cast> or <locator indication>.




©ISO/IEC 2003 – All rights reserved                                  Schema definition and manipulation 663
ISO/IEC 9075-2:2003 (E)
11.47 <add overriding method specification>



8) Let the candidate original method specification COMS be an original method specification that is included
   in the descriptor of a proper supertype of the user-defined type of D, such that the following are all true:
    a) MN and the <method name> of COMS are equivalent.
    b) Let N be the number of elements of the augmented SQL parameter declaration list UPCOMS generally
       included in the descriptor of COMS. MPDL contains (N-1) SQL parameter declarations.
    c) For i varying from 2 to N, the Syntax Rules of Subclause 9.16, “Data type identity”, are applied with
       the data types of the SQL parameters PCOMSi of UPCOMS and the data types of the SQL parameters
       POVMSi-1 of MPDL, respectively.

    d) The descriptor of COMS shall not include an indication that STATIC or CONSTRUCTOR was specified.
9) There shall exist exactly one such COMS.
10) COMS shall not be the corresponding method specification of a mutator or observer function.
    NOTE 311 — “Corresponding method specification” is defined in Subclause 11.50, “<SQL-invoked routine>”.

11) For i varying from 2 to N:
    a) If POVMSi-1 contains an <SQL parameter name> PNM1, then the descriptor of the i-th parameter of
       the augmented <SQL parameter declaration list> of UPCOMS shall include a parameter name that is
       equivalent to PNM1.
    b) If the descriptor of the i-th parameter of the augmented <SQL parameter declaration list> of UPCOMS
       includes a parameter name PNM2, then POVMSi-1 shall contain an <SQL parameter name> that is
       equivalent to PNM2.
    c) POVMSi-1 shall not contain <parameter mode>. A <parameter mode> IN is implicit.

    d) POVMSi-1 shall not specify RESULT.

    e) If the <parameter type> PTi-1 immediately contained in POVMSi-1 contains a <locator indication>,
       then the descriptor of the i-th parameter of the augmented <SQL parameter declaration list> of UPCOMS
       shall include a <locator indication>.
    f) If the the descriptor of the i-th parameter of the augmented <SQL parameter declaration list> of
       UPCOMS includes a <locator indication>, then the <parameter type> PTi-1 immediately contained in
       POVMSi-1 shall contain a <locator indication>.

12) Let ROVMS be the <returns data type> of RTC. Let RCOMS be the <returns data type> of COMS.
    Case:
    a) If RCOMS is a user-defined type, then:
        i)      Let a candidate overriding method specification COVRMS be a method specification that is
                included in the descriptor of a proper supertype or a proper subtype of UDT, such that all of the
                following are true:
                1) The <method name> of COVRMS and MN are equivalent.
                2) COVRMS and OVMS have the same number of SQL parameters Ni.


664 Foundation (SQL/Foundation)                                                           ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                   11.47 <add overriding method specification>



                  3) Let PCOVRMSi, 1 (one) ≤ i ≤ Ni, be the i-th SQL parameter in the unaugmented SQL
                      parameter declaration list of COVRMS. Let POVMSi, 1 (one) ≤ i ≤ Ni, be the i-th SQL
                      parameter in the unaugmented SQL parameter declaration list of OVMS.
                  4) For i varying from 1 (one) to Ni, the Syntax Rules of Subclause 9.16, “Data type identity”,
                     are applied with the declared type of PCOVRMSi and the declared type of POVMSi.

         ii)      Let NOVMS be the number of candidate overriding method specifications. For i varying from
                  1 (one) to NOVMS, let COVRMSi be the i-th candidate overriding method specification.

                  Case:
                  1) If COVRMSi is included in the descriptor of a proper supertype of D, then ROVMS shall be
                     a subtype of the <returns data type> of COVRMSi.

                  2) Otherwise, ROVMS shall be a supertype of the <returns data type> of COVRMSi.

    b) Otherwise, the Syntax Rules of Subclause 9.16, “Data type identity”, are applied with RCOMS and
       ROVMS as the data types.
13) Let a conflicting overriding method specification COVMS be an overriding method specification that is
    included in the descriptor of D, such that all of the following are true:
    a) MN and the method name of COVMS are equivalent.
    b) The augmented SQL parameter declaration list of COVMS contains N elements.
    c) For i varying from 2 to N, the data types of the SQL parameter POVMSi-1 and the SQL parameter
       PCOVMSi-1 of COVMS are compatible.

    There shall be no conflicting overriding method specification COVMS.
14) The augmented SQL parameter declaration list ASPDL of OVMS is formed from the augmented SQL
    parameter declaration list of COMS by replacing the <data type> of the first parameter (named SELF) with
    the <schema-resolved user-defined type name> DN.
15) There shall be no SQL-invoked function F that satisfies all the following conditions:
    a) F is not an SQL-invoked method.
    b) The <routine name> of F and the <routine name> MS have equivalent <qualified identifier>s.
    c) Let NPF be the number of SQL parameters in ASPDL. F has NPF SQL parameters.
    d) D is a subtype or supertype of the declared type of the first SQL parameter of F.

    e) The declared type of the i-th SQL parameter in ASPDL, 2 ≤ i ≤ NPF is compatible with the declared
       type of i-th SQL parameter of F.
16) If the descriptor of D includes any method specification descriptor, then:

    a) Let M be the number of method specification descriptors MSDi, 1 (one) ≤ i ≤ M, included in the
       descriptor of D.


©ISO/IEC 2003 – All rights reserved                                    Schema definition and manipulation 665
ISO/IEC 9075-2:2003 (E)
11.47 <add overriding method specification>



    b) For i ranging from 1 (one) to M:
         i)    Let Ni be the number of <SQL parameter declaration>s contained in the augmented SQL
               parameter declaration list included in MSDi. Let PTi,j, 1 (one) ≤ j ≤ Ni , be the j-th <parameter
               type> contained in MSDi.

         ii)   At least one of the following conditions shall be false:
               1) The <routine name> included in MSDi is equivalent to MN.

               2) ASPDL has Ni <SQL parameter declaration>s.

               3) The data type of PTi,j, 1 (one) ≤ j ≤ Ni, is compatible with the data type of the j-th <SQL
                  parameter declaration> of MPDL.
               4) MSDi does not include an indication that CONSTRUCTOR was specified.


Access Rules
    None.


General Rules
1) Let STDS be the descriptor of D, and DCMS the descriptor of the corresponding original method specification
   COMS. A method specification descriptor DOMS is created for OVMS. DOMS includes:
    a) An indication that the method specification is overriding.
    b) The <method name> MN.
    c) The <specific method name> contained in POVMS.
    d) The augmented SQL parameter declaration list APDL.
    e) For every parameter descriptor of a parameter of APDL, the locator indication of the descriptor of the
       corresponding parameter included in DCMS (if any).
    f) The <language name> included in DCMS.
    g) The <parameter style> included in DCMS (if any).
    h) The <returns data type> contained in POVMS.
    i)   The <result cast from type> included in DCMS (if any).
    j)   The locator indication contained in the <returns clause> included in the DCMS.
    k) The determinism indication included in DCMS.
    l)   The SQL-data access indication included in DCMS (if any).
    m) The indication included in DCMS (if at all), whether the method should be invoked if any argument is
       the null value.


666 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                    11.47 <add overriding method specification>



2) DOMS is added to STDS.
3) Let N be the number of table descriptors that include the user-defined type name of a subtype of D.
    For i varying from 1 (one) to N:
    a) Let TNi be the <table name> included in the i-th such table descriptor.

    b) Let M be the number of table/method privilege descriptors that specify TNi and the <specific method
       name> contained in COMS. For j varying from 1 (one) to M:
         i)       Let TMPDj be the j-th such table/method privilege descriptor.

         ii)      A new table/method privilege descriptor is created that specifies TNi, the same action, grantor,
                  and grantee, and the same grantability, and the <specific method name> contained in OVMS.
         iii)     TMPDj is deleted.


Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved                                     Schema definition and manipulation 667
ISO/IEC 9075-2:2003 (E)
11.48 <drop method specification>



11.48 <drop method specification>

Function
Remove a method specification from a user-defined type.


Format
<drop method specification> ::=
    DROP <specific method specification designator> RESTRICT

<specific method specification designator> ::=
    [ INSTANCE | STATIC | CONSTRUCTOR ]
    METHOD <method name> <data type list>


Syntax Rules
1) Let D be the user-defined type identified by the <schema-resolved user-defined type name> DN immediately
   contained in the <alter type statement> containing the <drop method specification> DORMS. Let DSN be
   the explicit or implicit <schema name> of DN. Let SMSD be the <specific method specification designator>
   immediately contained in DORMS.
2) If SMSD immediately contains a <specific method name> SMN, then:
   a) If SMN contains a <schema name>, then that <schema name> shall be equivalent to DSN. Otherwise,
      the <schema name> DSN is implicit.
   b) The descriptor of D shall include a method specification descriptor DOOMS whose specific method
      name is equivalent to SMN.
   c) Let PDL be the augmented parameter list included in DOOMS.
   d) Let MN be the <method name> included in DOOMS.
3) If SMSD immediately contains a <method name> ME, then:
   a) If none of INSTANCE, STATIC, or CONSTRUCTOR is immediately contained in SMSD, then
      INSTANCE is implicit.
   b) The descriptor of D shall include a method specification descriptor DOOMS whose method name MN
      is equivalent to ME.
   c) If SMSD immediately contains a <data type list> DTL, then
       Case:
       i)      If STATIC is specified, then the descriptor of D shall include exactly one method specification
               descriptor DOOMS that includes:
               1) An indication that the method specification is STATIC.
               2) An indication that the method specification is original.



668 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                 11.48 <drop method specification>



                  3) An augmented parameter list PDL such that the declared type of its i-th parameter, for all
                     i, is identical to the i-th declared type in DTL.
         ii)      If CONSTRUCTOR is specified, then the descriptor of D shall include exactly one method
                  specification descriptor DOOMS that includes:
                  1) An indication that the method specification is CONSTRUCTOR.
                  2) An indication that the method specification is original.
                  3) An augmented parameter list PDL such that the declared type of its i-th parameter, for all i
                     > 1 (one), is identical to the (i–1)-th declared type in DTL and the declared type of the first
                     parameter of PDL is identical to DN.
         iii)     Otherwise, the descriptor of D shall include exactly one method specification descriptor DOOMS
                  for which:
                  1) If DOOMS includes an indication that the method specification is original, then DOOMS
                     shall not include an indication that the method specification is either STATIC or CONSTRUC-
                     TOR.
                  2) DOOMS includes an augmented parameter list PDL such that the declared type of its i-th
                     parameter, for all i > 1 (one), is identical to the (i–1)-th declared type in DTL and the declared
                     type of the first parameter of PDL is identical to DN.
    d) If SMSD does not immediately contain a <data type list>, then
         Case:
         i)       If STATIC is specified, then the descriptor of D shall include exactly one method specification
                  descriptor DOOMS that includes an indication that the method specification is both original and
                  STATIC.
         ii)      If CONSTRUCTOR is specified, then the descriptor of D shall include exactly one method
                  specification descriptor DOOMS that includes an indications that the method specification is
                  both original and CONSTRUCTOR.
         iii)     Otherwise, the descriptor of D shall include exactly one method specification descriptor DOOMS
                  for which if DOOMS includes an indication that the method specification is original, then
                  DOOMS shall not include an indication that the method specification is either STATIC or
                  CONSTRUCTOR.
4) Case:
    a) If DOOMS includes an indication that the method specification is original, then
         Case:
         i)       If DOOMS includes an indication that the method specification specified STATIC, then there
                  shall be no SQL-invoked function F that satisfies all of the following conditions:
                  1) The <routine name> of F and MN have equivalent <qualified identifier>s.
                  2) If N is the number of elements in PDL, then F has N SQL parameters.
                  3) The declared type of the first SQL parameter of F is D.


©ISO/IEC 2003 – All rights reserved                                        Schema definition and manipulation 669
ISO/IEC 9075-2:2003 (E)
11.48 <drop method specification>



              4) The declared type of the i-th element of PDL, 1 (one) ≤ i ≤ N, is compatible with the declared
                 type of SQL parameter Pi of F.

              5) F is an SQL-invoked method.
              6) F includes an indication that STATIC is specified.
       ii)    If DOOMS includes an indication that the method specification specified CONSTRUCTOR,
              then there shall be no SQL-invoked function F that satisfies all of the following conditions:
              1) The <routine name> of F and MN have equivalent <qualified identifier>s.
              2) If N is the number of elements in PDL, then F has N SQL parameters.
              3) The declared type of the first SQL parameter of F is D.

              4) The declared type of the i-th element of PDL, 2 ≤ i ≤ N, is compatible with the declared type
                 of SQL parameter Pi of F.

              5) F is an SQL-invoked method.
              6) F includes an indication that CONSTRUCTOR is specified.
       iii)   Otherwise:
              1) There shall be no proper subtype PSBD of D whose descriptor includes the descriptor
                 DOVMS of an overriding method specification such that all of the following is true:
                  A) MN and the <method name> included in DOVMS have equivalent <qualified identifier>s.
                  B) If N is the number of elements in PDL, then the augmented SQL parameter declaration
                     list APDL included in DOVMS has N SQL parameters.
                  C) PSBD is the declared type the first SQL parameter of APDL.

                  D) The declared type of the i-th element of PDL, 2 ≤ i ≤ N, is compatible with the declared
                     type of SQL parameter Pi of APDL.

              2) There shall be no SQL-invoked function F that satisfies all of the following conditions:
                  A) The <routine name> of F and MN have equivalent <qualified identifier>s.
                  B) If N is the number of elements in PDL, then F has N SQL parameters.
                  C) The declared type of the first SQL parameter of F is D.

                  D) The declared type of the i-th element of PDL, 2 ≤ i ≤ N, is compatible with the declared
                     type of SQL parameter Pi of F.

                  E) F is an SQL-invoked method.
                  F) F does not include an indication that either STATIC or CONSTRUCTOR is specified.
   b) Otherwise, there shall be no SQL-invoked function F that satisfies all of the following conditions:
       i)     The <routine name> of F and MN have equivalent <qualified identifier>s.


670 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                              11.48 <drop method specification>



         ii)      If N is the number of elements in PDL, then F has N SQL parameters.
         iii)     The declared type of the first SQL parameter of F is D.

         iv)      The declared type of the i-th element of PDL, 2 ≤ i ≤ N, is compatible with the declared type of
                  SQL parameter Pi of F.

         v)       F is an SQL-invoked method.
         vi)      F does not include an indication that either STATIC or CONSTRUCTOR is specified.


Access Rules
    None.


General Rules
1) Let STDS be the descriptor of D.
2) DOOMS is removed from STDS.
3) DOOMS is destroyed.


Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved                                     Schema definition and manipulation 671
ISO/IEC 9075-2:2003 (E)
11.49 <drop data type statement>



11.49 <drop data type statement>

Function
Destroy a user-defined type.


Format
<drop data type statement> ::=
    DROP TYPE <schema-resolved user-defined type name> <drop behavior>


Syntax Rules
1) Let DN be the <schema-resolved user-defined type name> and let D be the data type identified by DN. Let
   SD be any supertype of D.
2) Let RD be the reference type whose referenced type is D. Let SRD be any supertype of RD. Let AD be any
   collection type whose element type is D. Let SAD be any collection type whose element type is a supertype
   of D or RD.
3) The schema identified by the explicit or implicit schema name of DN shall include the descriptor of D.
4) If RESTRICT is specified, then:
    a) The declared type of no column, field, or attribute whose descriptor is not included in the descriptor
       of D shall be SRD or SAD.
    b) The declared type of no column, attribute, or field shall be based on D.
    c) D shall have no proper subtypes.
    d) D shall not be the structured type of a referenceable table.
    e) The transform descriptor included in the user-defined type descriptor of D shall include an empty list
       of transform groups.
    f) D, RD, and AD shall not be referenced in any of the following:
        i)     The <query expression> of any view descriptor.
        ii)    The <search condition> of any constraint descriptor.
        iii)   A trigger action of any trigger descriptor.
        iv)    A user-defined cast descriptor.
        v)     A user-defined type descriptor other than that of D itself.
    g) There shall be no SQL-invoked routine that is not dependent on D and whose routine descriptor includes
       the descriptor of D, RD, or AD, or whose SQL routine body references D, RD, or AD.
    h) Let R be any SQL-invoked routine that is dependent on D and whose routine descriptor includes the
       descriptor of D or RD.


672 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                                  ISO/IEC 9075-2:2003 (E)
                                                                                          11.49 <drop data type statement>



         i)       R shall not be the subject routine of any <routine invocation>, <method invocation>, <static
                  method invocation>, or <method reference> that is contained in any of the following:
                  1) The SQL routine body of any routine descriptor.
                  2) The <query expression> of any view descriptor.
                  3) The <search condition> of any constraint descriptor.
                  4) The trigger action of any trigger descriptor.
         ii)      The specific name of R shall not be included in any user-defined cast descriptor.
         iii)     R shall not be the ordering function included in the descriptor of any user-defined type.
    NOTE 312 — If CASCADE is specified, then such referenced objects will be dropped by the execution of the <revoke statement>
    specified in the General Rules of this Subclause.
    NOTE 313 — The notion of an SQL-invoked routine being dependent on a user-defined type is defined in Subclause 4.27, “SQL-
    invoked routines”.
    NOTE 314 — The notion of one data type type being based on another data type is defined in Subclause 4.1, “Data types”.


Access Rules
1) The enabled authorization identifiers shall include the <authorization identifier> that owns the schema
   identified by the implicit or explicit <schema name> of D.


General Rules
1) Let SN be the <specific name> of any <SQL-invoked routine> that references D, RD, or AD or whose
   routine descriptor includes the descriptor of D, RD, or AD and that is not dependent on D. The following
   <drop routine statement> is effectively executed for each such <SQL-invoked routine> without further
   Access Rule checking:

    DROP SPECIFIC ROUTINE SN CASCADE
    NOTE 315 — The notion of an SQL-invoked routine being dependent on a user-defined type is defined in Subclause 4.27, “SQL-
    invoked routines”.

2) The following <drop transform statement> is effectively executed without further Access Rule checking:

    DROP TRANSFORM ALL FOR DN CASCADE
    NOTE 316 — This Rule should have no effect, since any external routine that depends on the transform being dropped also depends
    on the data type for which the transform is defined and hence should have already been dropped because of General Rule 1).

3) Let UDCD be the user-defined cast descriptor that references DN as the source data type. Let TD be the
   target data type included in UDCD. The following <drop user-defined cast statement> is effectively executed
   without further Access Rule checking:

    DROP CAST ( DN AS TD ) CASCADE

4) Let UDCD be the user-defined cast descriptor that references DN as the target data type. Let SD be the
   source data type included in UDCD. The following <drop user-defined cast statement> is effectively executed
   without further Access Rule checking:


©ISO/IEC 2003 – All rights reserved                                               Schema definition and manipulation 673
ISO/IEC 9075-2:2003 (E)
11.49 <drop data type statement>




    DROP CAST ( SD AS DN ) CASCADE

5) Let UDCD be the user-defined cast descriptor that references the reference type whose referenced type is
   DN as the source data type. Let TD be the target data type included in UDCD. The following <drop user-
   defined cast statement> is effectively executed without further Access Rule checking:

    DROP CAST ( REF (DN) AS TD ) CASCADE

6) Let UDCD be the user-defined cast descriptor that references the reference type whose referenced type is
   DN as the target data type. Let SD be the source data type included in UDCD. The following <drop user-
   defined cast statement> is effectively executed without further Access Rule checking:
    DROP CAST ( SD AS REF (DN) ) CASCADE

7) For every privilege descriptor that references D, the following <revoke statement> is effectively executed:

    REVOKE PRIV ON TYPE
    D FROM GRANTEE CASCADE

    where PRIV and GRANTEE are respectively the action and grantee in the privilege descriptor.
8) The descriptor of every SQL-invoked routine that is said to be dependent on D is destroyed.
    NOTE 317 — The notion of an SQL-invoked routine being dependent on a user-defined type is defined in Subclause 4.27, “SQL-
    invoked routines”.

9) The descriptor of D is destroyed.


Conformance Rules
1) Without Feature F032, “CASCADE drop behavior”, conforming SQL language shall not contain a <drop
   data type statement> that contains a <drop behavior> that contains CASCADE.




674 Foundation (SQL/Foundation)                                                             ©ISO/IEC 2003 – All rights reserved
                                                                      ISO/IEC 9075-2:2003 (E)
                                                                 11.50 <SQL-invoked routine>



11.50 <SQL-invoked routine>

Function
Define an SQL-invoked routine.


Format
<SQL-invoked routine> ::= <schema routine>

<schema routine> ::=
    <schema procedure>
  | <schema function>

<schema procedure> ::= CREATE <SQL-invoked procedure>

<schema function> ::= CREATE <SQL-invoked function>

<SQL-invoked procedure> ::=
    PROCEDURE <schema qualified routine name> <SQL parameter declaration list>
    <routine characteristics>
    <routine body>

<SQL-invoked function> ::=
    { <function specification> | <method specification designator> } <routine body>

<SQL parameter declaration list> ::=
    <left paren> [ <SQL parameter declaration>
    [ { <comma> <SQL parameter declaration> }... ] ] <right paren>

<SQL parameter declaration> ::=
    [ <parameter mode> ] [ <SQL parameter name> ] <parameter type> [ RESULT ]

<parameter mode> ::=
    IN
  | OUT
  | INOUT

<parameter type> ::= <data type> [ <locator indication> ]

<locator indication> ::= AS LOCATOR

<function specification> ::=
    FUNCTION <schema qualified routine name> <SQL parameter declaration list>
    <returns clause>
    <routine characteristics>
    [ <dispatch clause> ]

<method specification designator> ::=
    SPECIFIC METHOD <specific method name>
  | [ INSTANCE | STATIC | CONSTRUCTOR ] METHOD <method name> <SQL parameter declaration
list>
    [ <returns clause> ]
    FOR <schema-resolved user-defined type name>




©ISO/IEC 2003 – All rights reserved                     Schema definition and manipulation 675
ISO/IEC 9075-2:2003 (E)
11.50 <SQL-invoked routine>



<routine characteristics> ::= [ <routine characteristic>... ]

<routine characteristic> ::=
    <language clause>
  | <parameter style clause>
  | SPECIFIC <specific name>
  | <deterministic characteristic>
  | <SQL-data access indication>
  | <null-call clause>
  | <dynamic result sets characteristic>
  | <savepoint level indication>

<savepoint level indication> ::=
    NEW SAVEPOINT LEVEL
  | OLD SAVEPOINT LEVEL

<dynamic result sets characteristic> ::=
    DYNAMIC RESULT SETS <maximum dynamic result sets>

<parameter style clause> ::= PARAMETER STYLE <parameter style>

<dispatch clause> ::= STATIC DISPATCH

<returns clause> ::= RETURNS <returns type>

<returns type> ::=
    <returns data type> [ <result cast> ]
  | <returns table type>

<returns table type> ::= TABLE <table function column list>

<table function column list> ::=
    <left paren> <table function column list element>
    [ { <comma> <table function column list element> }... ] <right paren>

<table function column list element> ::= <column name> <data type>

<result cast> ::= CAST FROM <result cast from type>

<result cast from type> ::= <data type> [ <locator indication> ]

<returns data type> ::= <data type> [ <locator indication> ]

<routine body> ::=
    <SQL routine spec>
  | <external body reference>

<SQL routine spec> ::= [ <rights clause> ] <SQL routine body>

<rights clause> ::=
    SQL SECURITY INVOKER
  | SQL SECURITY DEFINER

<SQL routine body> ::= <SQL procedure statement>

<external body reference> ::=
    EXTERNAL [ NAME <external routine name> ]
    [ <parameter style clause> ]
    [ <transform group specification> ]



676 Foundation (SQL/Foundation)                                    ©ISO/IEC 2003 – All rights reserved
                                                                                 ISO/IEC 9075-2:2003 (E)
                                                                            11.50 <SQL-invoked routine>



     [ <external security clause> ]

<external security clause> ::=
    EXTERNAL SECURITY DEFINER
  | EXTERNAL SECURITY INVOKER
  | EXTERNAL SECURITY IMPLEMENTATION DEFINED

<parameter style> ::=
    SQL
  | GENERAL

<deterministic characteristic> ::=
    DETERMINISTIC
  | NOT DETERMINISTIC

<SQL-data access indication> ::=
    NO SQL
  | CONTAINS SQL
  | READS SQL DATA
  | MODIFIES SQL DATA

<null-call clause> ::=
    RETURNS NULL ON NULL INPUT
  | CALLED ON NULL INPUT

<maximum dynamic result sets> ::= <unsigned integer>

<transform group specification> ::=
    TRANSFORM GROUP { <single group specification> | <multiple group specification> }

<single group specification> ::= <group name>

<multiple group specification> ::=
    <group specification> [ { <comma> <group specification> }... ]

<group specification> ::=
    <group name> FOR TYPE <path-resolved user-defined type name>


Syntax Rules
1) An <SQL-invoked routine> specifies an SQL-invoked routine. Let R be the SQL-invoked routine specified
   by <SQL-invoked routine>.
2) If <SQL-invoked routine> immediately contains <schema routine>, then the SQL-invoked routine identified
   by <schema qualified routine name> is a schema-level routine.
3) An <SQL-invoked routine> specified as an <SQL-invoked procedure> is called an SQL-invoked procedure;
   an <SQL-invoked routine> specified as an <SQL-invoked function> is called an SQL-invoked function.
   An <SQL-invoked function> that specifies a <method specification designator> is further called an SQL-
   invoked method. An SQL-invoked method that specifies STATIC is called a static SQL-invoked method.
   An SQL-invoked method that specifies CONSTRUCTOR is called an SQL-invoked constructor method.
4) If <returns type> RST specifies TABLE, then let TCL be the <table function column list> contained in
   <returns table type>.




©ISO/IEC 2003 – All rights reserved                               Schema definition and manipulation 677
ISO/IEC 9075-2:2003 (E)
11.50 <SQL-invoked routine>



   a) For every <column name> CN contained in TCL, CN shall not be equivalent to any other <column
      name> contained in TCL.
   b) RST is equivalent to the <returns type>
       ROW TCL MULTISET

5) If <SQL-invoked routine> specifies an SQL-invoked method, then
   Case:
   a) If a <specific method name> SMN is specified, then:
       i)      Case:
               1) If SMN does not contain <schema name>, then
                   Case:
                   A) If the <SQL-invoked routine> is contained in a <schema definition>, then the <schema
                      name> that is specified or implicit in the <schema definition> is implicit.
                   B) Otherwise, the <schema name> that is specified or implicit for the <SQL-client module
                      definition> is implicit.
               2) Otherwise, if <SQL-invoked routine> is contained in a <schema definition> then the <schema
                  name> contained in SMN shall be equivalent to the specified or implicit <schema name> of
                  the containing <schema definition>.
       ii)     Let S be the schema identified by the implicit or explicit <schema name> of SMN.
       iii)    There shall exist a method specification descriptor DMS included in the descriptor of a user-
               defined type UDT included in S, whose <specific method name> is SMN.
       iv)     Let MN be the number of SQL parameters in the unaugmented SQL parameter declaration list
               in DMS. MN is the number of SQL parameters in the unaugmented SQL parameter declaration
               list of R.
       v)      If DMS includes <result cast> RC, then RC is the <result cast> of R.
       vi)     Let SPN be the <specific method name> in DMS. SPN is the <specific name> of R.
       vii)    Let NPL be the augmented SQL parameter declaration list of DMS. NPL is the augmented SQL
               parameter declaration list of R.
       viii)   Let RN be SN.<method name>, where SN is the <schema name> of the schema that includes the
               descriptor of UDT.
   b) Otherwise:
       i)      Let UDTN be the <schema-resolved user-defined type name> immediately contained in <method
               specification designator>. Let UDT be the user-defined type identified by UDTN.
       ii)     There shall exist a method specification descriptor DMS in the descriptor of UDT such that the
               <method name> of DMS is equivalent to the <method name>, DMS indicates STATIC if and
               only if the <method specification designator> specifies STATIC, DMS indicates CONSTRUC-
               TOR if and only if the <method specification designator> specifies CONSTRUCTOR, and the


678 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                   11.50 <SQL-invoked routine>



                  declared type of every SQL parameter in the unaugmented SQL parameter declaration list in
                  DMS is compatible with the declared type of the corresponding SQL parameter in the <SQL
                  parameter declaration list> contained in the <method specification designator>. DMS identifies
                  the corresponding method specification of the <method specification designator>.
         iii)     Let MN be the number of SQL parameters in the unaugmented SQL parameter declaration list
                  in DMS.

         iv)      Let PCOMSi, 1 (one) ≤ i ≤ MN, be the i-th SQL parameter in the unaugmented SQL parameter
                  declaration list of DMS. Let POVMSi, 1 (one) ≤ i ≤ MN, be the i-th SQL parameter contained
                  in <method specification designator>.
         v)       For i varying from 1 (one) to MN, the <SQL parameter name>s contained in PCOMSi and
                  POVMSi shall be equivalent.

         vi)      Let PDMSi, 1 (one) ≤ i ≤ MN, be the declared type of the i-th SQL parameter in the unaugmented
                  SQL parameter declaration list in DMS. Let PSMi be the declared type of the i-th SQL parameter
                  contained in <method specification designator>.
         vii)     With i ranging from 1 (one) to MN, the Syntax Rules of Subclause 9.16, “Data type identity”,
                  are applied with PDMSi and PSMi.

         viii)    Case:
                  1) If <returns clause> is specified, then let RT be the <returns data type> of R. Let RDMS be
                     the <returns data type> in DMS. The Syntax Rules of Subclause 9.16, “Data type identity”,
                     are applied with RT and RDMS.
                  2) Otherwise, let RDMS be the <returns data type> of R.
         ix)      If DMS includes <result cast> RC, then
                  Case:
                  1) If <returns clause> is specified, then <returns clause> shall contain <result cast>. Let RDCT
                     be the <data type> specified in RC. Let RCT be the <data type> specified in the <result cast>
                     contained in <returns clause>. The Syntax Rules of Subclause 9.16, “Data type identity”,
                     are applied with RDCT and RCT.
                  2) Otherwise, RC is the <result cast> of R.
         x)       Let SPN be the <specific method name> in DMS. SPN is the <specific name> of R.
         xi)      Let NPL be the augmented SQL parameter declaration list of DMS.
         xii)     Let RN be SN.<method name>, where SN is the <schema name> of the schema that includes the
                  descriptor of UDT.
6) If <SQL-invoked routine> specifies an SQL-invoked procedure or an SQL-invoked regular function, then:
    a) <routine characteristics> shall contain at most one <language clause>, at most one <parameter style
       clause>, at most one <specific name>, at most one <deterministic characteristic>, at most one <SQL-




©ISO/IEC 2003 – All rights reserved                                     Schema definition and manipulation 679
ISO/IEC 9075-2:2003 (E)
11.50 <SQL-invoked routine>



        data access indication>, at most one <null-call clause>, and at most one <dynamic result sets character-
        istic>.
   b) <parameter style clause> shall not be specified both in <routine characteristics> and in <external body
      reference>.
   c) The <routine characteristics> of a <function specification> shall not contain a <dynamic result sets
      characteristic>.
   d) If <dynamic result sets characteristic> is not specified, then DYNAMIC RESULT SETS 0 (zero) is
      implicit.
   e) If <deterministic characteristic> is not specified, then NOT DETERMINISTIC is implicit.
   f) Case:
        i)     If PROCEDURE is specified, then:
               1) <null-call clause> shall not be specified.
               2) <routine characteristics> shall not contain more than one <savepoint level indication>.
        ii)    Otherwise, if <null-call clause> is not specified, then CALLED ON NULL INPUT is implicit.
   g) <SQL-data access indication> shall be specified.
   h) If <language clause> is not specified, then LANGUAGE SQL is implicit.
   i)   An <SQL-invoked routine> that specifies or implies LANGUAGE SQL is called an SQL routine; an
        <SQL-invoked routine> that does not specify LANGUAGE SQL is called an external routine.
   j)   If <savepoint level indication> is specified, then PROCEDURE shall be specified.
   k) If PROCEDURE is specified and <savepoint level indication> is not specified, then OLD SAVEPOINT
      LEVEL is implicit.
   l)   If NEW SAVEPOINT LEVEL is specified, then MODIFIES SQL DATA shall be specified.
   m) If R is an SQL routine, then:
        i)     The <returns clause> shall not specify a <result cast>.
        ii)    <SQL-data access indication> shall not specify NO SQL.
        iii)   <parameter style clause> shall not be specified.
   n) An array-returning external function is an SQL-invoked function that is an external routine and that
      satisfies one of the following conditions:
        i)     A <result cast from type> is specified that simply contains an <array type> and does not contain
               a <locator indication>.
        ii)    A <result cast from type> is not specified and <returns data type> simply contains an <array
               type> and does not contain a <locator indication>.
   o) A multiset-returning external function is an SQL-invoked function that is an external routine and that
      satisfies one of the following conditions:



680 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)
                                                                                      11.50 <SQL-invoked routine>



         i)       A <result cast from type> is specified that simply contains a <multiset type> and does not contain
                  a <locator indication>.
         ii)      A <result cast from type> is not specified and <returns data type> simply contains a <multiset
                  type> and does not contain a <locator indication>.
    p) Let RN be the <schema qualified routine name> of R.
    q) If <SQL-invoked routine> is contained in a <schema definition> and RN contains a <schema name>
       SN, then SN shall be equivalent to the specified or implicit <schema name> of the containing <schema
       definition>. Let S be the SQL-schema identified by SN.
    r) Case:
         i)       If R is an SQL-invoked regular function and the <SQL parameter declaration list> contains an
                  <SQL parameter declaration> that specifies a <data type> that is one of:
                  1) A user-defined type.
                  2) A collection type whose element type is a user-defined type.
                  3) A collection type whose element type is a reference type.
                  4) A reference type.
                  then <dispatch clause> shall be specified.
         ii)      Otherwise, <dispatch clause> shall not be specified.
    s) If <specific name> is not specified, then an implementation-dependent <specific name> whose <schema
       name> is the equivalent to the <schema name> of S is implicit.
    t)   If <specific name> contains a <schema name>, then that <schema name> shall be equivalent to the
         <schema name> of S. If <specific name> does not contain a <schema name>, then the <schema name>
         of S is implicit.
    u) The schema identified by the explicit or implicit <schema name> of the <specific name> shall not
       include a routine descriptor whose specific name is equivalent to <specific name> or a user-defined
       type descriptor that includes a method specification descriptor whose specific name is equivalent to
       <specific name>.
    v) If <returns data type> RT simply contains <locator indication>, then:
         i)       R shall be an external routine.
         ii)      RT shall be either binary large object type, character large object type, array type, multiset type,
                  or user-defined type.
         iii)     <result cast> shall not be specified.
    w) If <result cast from type> RCT simply contains <locator indication>, then:
         i)       R shall be an external routine.
         ii)      RCT shall be either binary large object type, character large object type, array type, multiset
                  type, or user-defined type.



©ISO/IEC 2003 – All rights reserved                                        Schema definition and manipulation 681
ISO/IEC 9075-2:2003 (E)
11.50 <SQL-invoked routine>



   x) If R is an external routine, then:
       i)     If <parameter style> is not specified, then PARAMETER STYLE SQL is implicit.
       ii)    If R is an array-returning external function or a multiset-returning external function, then
              PARAMETER STYLE SQL shall be either specified or implied.
       iii)   Case:
              1) If <transform group specification> is not specified, then a <multiple group specification>
                 with a <group specification> GS for each <SQL parameter declaration> contained in <SQL
                 parameter declaration list> whose <parameter type> UDT identifies a user-defined type with
                 no <locator indication> is implicit. The <group name> of GS is implementation-defined and
                 its <path-resolved user-defined type name> is UDT.
              2) If <single group specification> with a <group name> GN is specified, then <transform group
                 specification> is equivalent to a <transform group specification> that contains a <multiple
                 group specification> that contains a <group specification> GS for each <SQL parameter
                 declaration> contained in <SQL parameter declaration list> whose <parameter type> UDT
                 identifies a user-defined type with no <locator indication>. The <group name> of GS is GN
                 and its <path-resolved user-defined type name> is UDT.
              3) Otherwise, <multiple group specification> is extended with a <group specification> GS for
                 each <SQL parameter declaration> contained in <SQL parameter declaration list> whose
                 <parameter type> UDT identifies a user-defined type with no <locator indication> and no
                 equivalent of UDT is contained in any <group specification> contained in <multiple group
                 specification>. The <group name> of GS is implementation-defined and its <path-resolved
                 user-defined type name> is UDT.
       iv)    If a <result cast> is specified, then let V be some value of the <data type> specified in the <result
              cast> and let RT be the <returns data type>. The following shall be valid according to the Syntax
              Rules of Subclause 6.12, “<cast specification>”:
                 CAST ( V AS RT )


   y) Let NPL be the <SQL parameter declaration list> contained in the <SQL-invoked routine>.
7) NPL specifies the list of SQL parameters of R. Each SQL parameter of R is specified by an <SQL parameter
   declaration>. If <SQL parameter name> is specified, then that SQL parameter of R is identified by an SQL
   parameter name.
8) NPL shall specify at most one <SQL parameter declaration> that specifies RESULT.
9) If R is an SQL-invoked function, then no <SQL parameter declaration> in NPL shall contain a <parameter
   mode>.
10) If R is an SQL routine, then every <SQL parameter declaration> in NPL shall contain an <SQL parameter
    name>.
11) No two <SQL parameter name>s contained in NPL shall be equivalent.
12) Let N and PN be the number of <SQL parameter declaration>s contained in NPL. For every <SQL
    parameter declaration> PDi, 1 (one) ≤ i ≤ N:



682 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)
                                                                                      11.50 <SQL-invoked routine>



    a) <parameter type> PTi immediately contained in PDi shall not specify ROW.

    b) If PTi simply contains <locator indication>, then:

         i)       R shall be an external routine.
         ii)      PTi shall specify either binary large object type, character large object type, array type, multiset
                  type, or user-defined type.
    c) If PDi immediately contains RESULT, then:

         i)       R shall be an SQL-invoked function.
         ii)      PTi shall specify a structured type ST. Let STN be the <user-defined type name> that identifies
                  ST.
         iii)     The <returns data type> shall specify STN.
         iv)      R is a type-preserving function and PDi specifies the result SQL parameter of R.

    d) If PDi does not contain a <parameter mode>, then a <parameter mode> that specifies IN is implicit.

    e) Let Pi be the i-th SQL parameter.

         Case:
         i)       If the <parameter mode> specifies IN, then Pi is an input SQL parameter.

         ii)      If the <parameter mode> specifies OUT, then Pi is an output SQL parameter.

         iii)     If the <parameter mode> specifies INOUT, then Pi is both an input SQL parameter and an output
                  SQL parameter.
13) The scope of RN is the <routine body> of R.
14) The scope of an <SQL parameter name> contained in NPL is the <routine body> RB of the <SQL-invoked
    procedure> or <SQL-invoked function> that contains NPL.
15) An <SQL-invoked routine> shall not contain a <host parameter name>, a <dynamic parameter specification>,
    or an <embedded variable name>.
16) Case:
    a) If R is an SQL-invoked procedure, then S shall not include another SQL-invoked procedure whose
       <schema qualified routine name> is equivalent to RN and whose number of SQL parameters is PN.
    b) Otherwise:
         i)       Case:
                  1) If R is a static SQL-invoked method, then let SCR be the set containing every static SQL-
                     invoked method of type UDT, including R, whose <schema qualified routine name> is
                     equivalent to RN and whose number of SQL parameters is PN.




©ISO/IEC 2003 – All rights reserved                                        Schema definition and manipulation 683
ISO/IEC 9075-2:2003 (E)
11.50 <SQL-invoked routine>



               2) If R is an SQL-invoked constructor method, then let SCR be the set containing every SQL-
                  invoked constructor method of type UDT, including R, whose <schema qualified routine
                  name> is equivalent to RN and whose number of SQL parameters is PN.
               3) Otherwise, let SCR be the set containing every SQL-invoked function in S that is neither a
                  static SQL-invoked method nor an SQL-invoked constructor method, including R, whose
                  <schema qualified routine name> is equivalent to RN and whose number of SQL parameters
                  is PN.
        ii)    Let AL be an <SQL argument list> constructed from a list of arbitrarily-selected values in which
               the declared type of every value Ai in AL is compatible with the declared type of the corresponding
               SQL parameter Pi of R.

        iii)   For every Ai, eliminate from SCR every SQL-invoked routine SIR for which the type designator
               of the declared type of the SQL parameter Pi of SIR is not in the type precedence list of the
               declared type of Ai.

        iv)    Let SR be the set of subject routines defined by applying the Syntax Rules of Subclause 9.4,
               “Subject routine determination”, with the set of SQL-invoked routines as SCR and <SQL argument
               list> as AL. There shall be exactly one subject routine in SR.
17) If R is an SQL-invoked method but not a static SQL-invoked method, then the first SQL parameter of NPL
    is called the subject parameter of R.
18) If R is an SQL-invoked regular function F whose first SQL parameter has a declared type that is a user-
    defined type, then:
    a) Let UDT be the declared type of the first SQL parameter of F.
    b) Let DMS be a method specification descriptor of an instance method in the descriptor of UDT such
       that:
        i)     The <schema qualified routine name> of F and the <routine name> of DMS have equivalent
               <qualified identifier>s.
        ii)    F and the augmented SQL parameter declaration list of DMS have the same number of SQL
               parameters.

    c) Let PDMSi, 1 (one) ≤ i ≤ PN, be the declared type of the i-th SQL parameter in the unaugmented SQL
       parameter declaration list in DMS and let PMSi be the declared type of the i-th SQL parameter contained
       in <function specification>.
    d) One of the following conditions shall be false:

        i)     The declared type of PDMSi, 1 (one) ≤ i ≤ N is compatible with the declared type of SQL
               parameter PMSi+1.

        ii)    UDT is a subtype or a supertype of the declared type of PMS1.

19) If R is an SQL routine, then:
    a) <SQL routine spec> shall be specified.



684 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                                              11.50 <SQL-invoked routine>



    b) If <rights clause> is not specified, then SQL SECURITY DEFINER is implicit.
    c) If READS SQL DATA is specified, then it is implementation-defined whether the <SQL routine body>
       shall not contain an <SQL procedure statement> S that satisfies at least one of the following:
         i)       S is an <SQL data change statement>.
         ii)      S contains a <routine invocation> whose subject routine is an SQL-invoked routine that possibly
                  modifies SQL-data.
         iii)     S contains an <SQL procedure statement> that is an <SQL data change statement>.
    d) If CONTAINS SQL is specified, then it is implementation-defined whether the <SQL routine body>
       shall not contain an <SQL procedure statement> S that satisfies at least one of the following:
         i)       S is an <SQL data statement> other than <free locator statement> and <hold locator statement>.
         ii)      S contains a <routine invocation> whose subject routine is an SQL-invoked routine that possibly
                  modifies SQL-data or possibly reads SQL-data.
         iii)     S contains an <SQL procedure statement> that is an <SQL data statement> other than <free
                  locator statement> and <hold locator statement>.
    e) If DETERMINISTIC is specified, then it is implementation-defined whether the <SQL routine body>
       shall not contain an <SQL procedure statement> that is possibly non-deterministic.
    f) It is implementation-defined whether the <SQL routine body> shall not contain an <SQL connection
       statement>, an <SQL schema statement>, an <SQL dynamic statement>, or an <SQL transaction
       statement> other than a <savepoint statement>, <release savepoint statement>, or a <rollback statement>
       that specifies a <savepoint clause>.
         NOTE 318 — Conforming SQL language shall not contain an <SQL connection statement> or an <SQL transaction statement>
         other than a <savepoint statement>, a <release savepoint statement>, or a <rollback statement> that specifies a <savepoint
         clause>, but an implementation is not required to treat this as a syntax error.

    g) An <SQL routine body> shall not immediately contain an <SQL procedure statement> that simply
       contains a <schema definition>.
20) If R is an external routine, then:
    a) <SQL routine spec> shall not be specified.
    b) If <external security clause> is not specified, then EXTERNAL SECURITY IMPLEMENTATION
       DEFINED is implicit.
    c) If an <external routine name> is not specified, then an <external routine name> that is equivalent to
       the <qualified identifier> of R is implicit.
    d) If PARAMETER STYLE SQL is specified, then:
         i)       Case:
                  1) If R is an array-returning external function or a multiset-returning external function with
                     the element type being a row type, then let FRN be the degree of the element type.
                  2) Otherwise, let FRN be 1 (one).



©ISO/IEC 2003 – All rights reserved                                               Schema definition and manipulation 685
ISO/IEC 9075-2:2003 (E)
11.50 <SQL-invoked routine>



       ii)    If R is an array-returning external function or a multiset-returning external function, then let
              AREF be FRN+6. Otherwise, let AREF be FRN+4.
       iii)   If R is an SQL-invoked function, then let the effective SQL parameter list be a list of
              PN+FRN+N+AREF SQL parameters, as follows:
              1) For i ranging from 1 (one) to PN, the i-th effective SQL parameter list entry is defined as
                 follows.
                  Case:
                  A) If the <parameter type> Ti simply contained in the i-th <SQL parameter declaration>
                     contains <locator indication>, then the i-th effective SQL parameter list entry is the i-th
                     <SQL parameter declaration> with the <parameter type> replaced by INTEGER.
                  B) If the <parameter type> Ti immediately contained in the i-th <SQL parameter declaration>
                     is a <path-resolved user-defined type name> without a <locator indication>, then:
                      I)     Case:
                             1) If R is an SQL-invoked method that is an overriding method, then the Syntax
                                Rules of Subclause 9.18, “Determination of a from-sql function for an over-
                                riding method”, are applied with R and i as ROUTINE and POSITION,
                                respectively. There shall be an applicable from-sql function FSFi.

                             2) Otherwise, the Syntax Rules of Subclause 9.17, “Determination of a from-
                                sql function”, are applied with the data type identified by Ti, and the <group
                                name> contained in the <group specification> that contains Ti as TYPE and
                                GROUP, respectively. There shall be an applicable from-sql function FSFi.

                      II)    FSFi is called the from-sql function associated with the i-th SQL parameter.

                      III)   The i-th effective SQL parameter list entry is the i-th <SQL parameter declaration>
                             with the <parameter type> replaced by the <returns data type> of FSFi.

                  C) Otherwise, the i-th effective SQL parameter list entry is the i-th <SQL parameter decla-
                     ration>.
              2) Case:
                  A) If FRN is 1 (one), then effective SQL parameter list entry PN+FRN has <parameter
                     mode> OUT; its <parameter type> PT is defined as follows:
                      I)     If <result cast> is specified, then let RT be <result cast from type>; otherwise,
                             let RT be <returns data type>.
                      II)    Case:
                             1) If RT simply contains <locator indication>, then PT is INTEGER.
                             2) If RT specifies a <path-resolved user-defined type name> without a <locator
                                indication>, then:
                                 a) Case:



686 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                             ISO/IEC 9075-2:2003 (E)
                                                                                        11.50 <SQL-invoked routine>



                                              i)     If R is an SQL-invoked method that is an overriding method, then
                                                     the Syntax Rules of Subclause 9.20, “Determination of a to-sql
                                                     function for an overriding method”, are applied with R as ROU-
                                                     TINE. There shall be an applicable to-sql function TSF.
                                              ii)    Otherwise, the Syntax Rules of Subclause 9.19, “Determination
                                                     of a to-sql function”, are applied with the data type identified by
                                                     RT and the <group name> contained in the <group specification>
                                                     that contains RT as TYPE and GROUP, respectively. There shall
                                                     be an applicable to-sql function TSF.
                                          b) TSF is called the to-sql function associated with the result.
                                          c) Case:
                                              i)     If TSF is an SQL-invoked method, then PT is the <parameter
                                                     type> of the second SQL parameter of TSF.
                                              ii)    Otherwise, PT is the <parameter type> of the first SQL parameter
                                                     of TSF.
                                      3) If R is an array-returning external function or a multiset-returning external
                                         function, then let PT be the element type of RT.
                                      4) Otherwise, PT is RT.
                      B) Otherwise, for i ranging from PN+1 to PN+FRN, the i-th effective SQL parameter list
                         entry is defined as follows.
                           Case:
                           I)         Its <parameter mode> is OUT.
                           II)        Let RFTi-PN be the data type of the i-PN-th field of the element type of the
                                      <returns data type>. The <parameter type> PTi of the i-th effective SQL param-
                                      eter list entry is determined as follows:
                                      1) If RFTi-PN specifies a <path-resolved user-defined type name>, then:

                                          a) Case:
                                              i)     If R is an SQL-invoked method that is an overriding method, then
                                                     the Syntax Rules of Subclause 9.20, “Determination of a to-sql
                                                     function for an overriding method”, are applied with R as ROU-
                                                     TINE. There shall be an applicable to-sql function TSF.
                                              ii)    Otherwise, the Syntax Rules of Subclause 9.19, “Determination
                                                     of a to-sql function”, are applied with the data type identified by
                                                     RFTi-PN and the <group name> contained in the <group specifica-
                                                     tion> that contains RFTi-PN as TYPE and GROUP, respectively.
                                                     There shall be an applicable to-sql function TSF.
                                          b) TSF is called the to-sql function associated with RFTi-PN.




©ISO/IEC 2003 – All rights reserved                                           Schema definition and manipulation 687
ISO/IEC 9075-2:2003 (E)
11.50 <SQL-invoked routine>



                                 c) Case:
                                      i)     If TSF is an SQL-invoked method, then PTi is the <parameter
                                             type> of the second SQL parameter of TSF.
                                      ii)    Otherwise, PTi is the <parameter type> of the first SQL parameter
                                             of TSF.
                             2) Otherwise, PTi is RFTi-PN.

             3) Effective SQL parameter list entries (PN+FRN)+1 to (PN+FRN)+N+FRN are N+FRN
                occurrences of SQL parameters of an implementation-defined <data type> that is an exact
                numeric type with scale 0 (zero). For i ranging from (PN+FRN)+1 to (PN+FRN)+N+FRN,
                the <parameter mode> for the i-th such effective SQL parameter is the same as that of the
                i–FRN–PN-th effective SQL parameter.
             4) Effective SQL parameter list entry (PN+FRN)+(N+FRN)+1 is an SQL parameter of a <data
                type> that is character string of length 5 and the character set specified for SQLSTATE
                values, with <parameter mode> INOUT.
                 NOTE 319 — The character set specified for SQLSTATE values is defined in Subclause 23.1, “SQLSTATE”.

             5) Effective SQL parameter list entry (PN+FRN)+(N+FRN)+2 is an SQL parameter of a <data
                type> that is character string of implementation-defined length and character set SQL_TEXT
                with <parameter mode> IN.
             6) Effective SQL parameter list entry (PN+FRN)+(N+FRN)+3 is an SQL parameter of a <data
                type> that is character string of implementation-defined length and character set SQL_TEXT
                with <parameter mode> IN.
             7) Effective SQL parameter list entry (PN+FRN)+(N+FRN)+4 is an SQL parameter of a <data
                type> that is character string of implementation-defined length and character set SQL_TEXT
                with <parameter mode> INOUT.
             8) If R is an array-returning external function or a multiset-returning external function, then:
                 A) Effective SQL parameter type list entry (PN+FRN)+(N+FRN)+5 is an SQL parameter
                    whose <data type> is character string of implementation-defined length and character
                    set SQL_TEXT with <parameter mode> INOUT.
                 B) Effective SQL parameter type list entry (PN+FRN)+(N+FRN)+6 is an SQL parameter
                    whose <data type> is an exact numeric type with scale 0 (zero) and with <parameter
                    mode> IN.
       iv)   If R is an SQL-invoked procedure, then let the effective SQL parameter list be a list of PN+N+4
             SQL parameters, as follows:
             1) For i ranging from 1 (one) to PN, the i-th effective SQL parameter list entry is defined as
                follows.
                 Case:
                 A) If the <parameter type> Ti simply contained in the i-th <SQL parameter declaration>
                    simply contains <locator indication>, then the i-th effective SQL parameter list entry



688 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                            ISO/IEC 9075-2:2003 (E)
                                                                                       11.50 <SQL-invoked routine>



                           is the i-th <SQL parameter declaration> with the <parameter type> replaced by INTE-
                           GER.
                      B) If the <parameter type> Ti simply contained in the i-th <SQL parameter declaration>
                         is a <path-resolved user-defined type name> without a <locator indication>, then:
                           I)         Case:
                                      1) If the <parameter mode> immediately contained in the i-th <SQL parameter
                                         declaration> is IN, then:
                                         a) The Syntax Rules of Subclause 9.17, “Determination of a from-sql
                                            function”, are applied with the data type identified by Ti and the <group
                                            name> contained in the <group specification> that contains Ti as TYPE
                                            and GROUP, respectively. There shall be an applicable from-sql function
                                            FSFi. FSFi is called the from-sql function associated with the i-th SQL
                                            parameter.
                                         b) The i-th effective SQL parameter list entry is the i-th <SQL parameter
                                            declaration> with the <parameter type> replaced by the <returns data
                                            type> of FSFi.

                                      2) If the <parameter mode> immediately contained in the i-th <SQL parameter
                                         declaration> is OUT, then:
                                         a) The Syntax Rules of Subclause 9.19, “Determination of a to-sql function”,
                                            are applied with the data type identified by Ti and the <group name>
                                            contained in the <group specification> that contains Ti as TYPE and
                                            GROUP, respectively. There shall be an applicable to-sql function TSFi.
                                            TSFi is called the to-sql function associated with i-th SQL parameter.

                                         b) The i-th effective SQL parameter list entry is the i-th <SQL parameter
                                            declaration> with the <parameter type> replaced by
                                              Case:
                                              i)      If TSFi is an SQL-invoked method, then the <parameter type> of
                                                      the second SQL parameter of TSFi.

                                              ii)     Otherwise, the <parameter type> of the first SQL parameter of
                                                      TSFi.

                                      3) Otherwise:
                                         a) The Syntax Rules of Subclause 9.17, “Determination of a from-sql
                                            function”, are applied with the data type identified by Ti and the <group
                                            name> contained in the <group specification> that contains Ti as TYPE
                                            and GROUP, respectively. There shall be an applicable from-sql function
                                            FSFi. FSFi is called the from-sql function associated with the i-th SQL
                                            parameter.




©ISO/IEC 2003 – All rights reserved                                          Schema definition and manipulation 689
ISO/IEC 9075-2:2003 (E)
11.50 <SQL-invoked routine>



                                  b) The Syntax Rules of Subclause 9.19, “Determination of a to-sql function”,
                                     are applied with the data type identified by Ti and the <group name>
                                     contained in the <group specification> that contains Ti as TYPE and
                                     GROUP, respectively. There shall be an applicable to-sql function TSFi.
                                     TSFi is called the to-sql function associated with the i-th SQL parameter.

                                  c) The i-th effective SQL parameter list entry is the i-th <SQL parameter
                                     declaration> with the <parameter type> replaced by the <returns data
                                     type> of FSFi.

                   C) Otherwise, the i-th effective SQL parameter list entry is the i-th <SQL parameter decla-
                      ration>.
               2) Effective SQL parameter list entries PN+1 to PN+N are N occurrences of an SQL parameter
                  of an implementation-defined <data type> that is an exact numeric type with scale 0. The
                  <parameter mode> for the i-th such effective SQL parameter is the same as that of the
                  i–PN-th effective SQL parameter.
               3) Effective SQL parameter list entry (PN+N)+1 is an SQL parameter of a <data type> that is
                  character string of length 5 and character set SQL_TEXT with <parameter mode> INOUT.
               4) Effective SQL parameter list entry (PN+N)+2 is an SQL parameter of a <data type> that is
                  character string of implementation-defined length and character set SQL_TEXT with
                  <parameter mode> IN.
               5) Effective SQL parameter list entry (PN+N)+3 is an SQL parameter of a <data type> that is
                  character string of implementation-defined length and character set SQL_TEXT with
                  <parameter mode> IN.
               6) Effective SQL parameter list entry (PN+N)+4 is an SQL parameter of a <data type> that is
                  character string of implementation-defined length and character set SQL_TEXT with
                  <parameter mode> INOUT.
   e) If PARAMETER STYLE GENERAL is specified, then let the effective SQL parameter list be a list of
      PN parameters such that, for i ranging from 1 (one) to PN, the i-th effective SQL parameter list entry
      is defined as follows.
       Case:
       i)      If the <parameter type> Ti simply contained in the i-th <SQL parameter declaration> simply
               contains <locator indication>, then the i-th effective SQL parameter list entry is the i-th <SQL
               parameter declaration> with the <parameter type> replaced by INTEGER.
       ii)     If the <parameter type> Ti simply contained in the i-th <SQL parameter declaration> is a <path-
               resolved user-defined type name> without a <locator indication>, then:
               1) Case:
                   A) If the <parameter mode> immediately contained in the i-th <SQL parameter declaration>
                      is IN, then:
                       I)     The Syntax Rules of Subclause 9.17, “Determination of a from-sql function”,
                              are applied with the data type identified by Ti and the <group name> contained


690 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                                ISO/IEC 9075-2:2003 (E)
                                                                                           11.50 <SQL-invoked routine>



                                      in the <group specification> that contains Ti as TYPE and GROUP, respectively.
                                      There shall be an applicable from-sql function FSFi. FSFi is called the from-sql
                                      function associated with the i-th SQL parameter.
                           II)        The i-th effective SQL parameter list entry is the i-th <SQL parameter declaration>
                                      with the <parameter type> replaced by the <returns data type> of FSFi.

                      B) If the <parameter mode> immediately contained in the i-th <SQL parameter declaration>
                         is OUT, then:
                           I)         The Syntax Rules of Subclause 9.19, “Determination of a to-sql function”, are
                                      applied with the data type identified by Ti and the <group name> contained in
                                      the <group specification> that contains Ti as TYPE and GROUP, respectively.
                                      There shall be an applicable to-sql function TSFi. TSFi is called the to-sql function
                                      associated with the i-th SQL parameter.
                           II)        The i-th effective SQL parameter list entry is the i-th <SQL parameter declaration>
                                      with the <parameter type> replaced by
                                      Case:
                                      1) If TSFi is an SQL-invoked method, then the <parameter type> of the second
                                         SQL parameter of TSFi.

                                      2) Otherwise, the <parameter type> of the first SQL parameter of TSFi.

                      C) Otherwise:
                           I)         The Syntax Rules of Subclause 9.17, “Determination of a from-sql function”,
                                      are applied with the data type identified by Ti and the <group name> contained
                                      in the <group specification> that contains Ti as TYPE and GROUP, respectively.
                                      There shall be an applicable from-sql function FSFi. FSFi is called the from-sql
                                      function associated with the i-th SQL parameter.
                           II)        The Syntax Rules of Subclause 9.19, “Determination of a to-sql function”, are
                                      applied with the data type identified by Ti and the <group name> contained in
                                      the <group specification> that contains Ti as TYPE and GROUP, respectively.
                                      There shall be an applicable to-sql function TSFi. TSFi is called the to-sql function
                                      associated with the i-th SQL parameter.
                           III)       The i-th effective SQL parameter list entry is the i-th <SQL parameter declaration>
                                      with the <parameter type> replaced by the <returns data type> of FSFi.

         iii)     Otherwise, the i-th effective SQL parameter list entry is the i-th <SQL parameter declaration>.
         NOTE 320 — If the SQL-invoked routine is an SQL-invoked function, then the value returned from the external routine is
         passed to the SQL-implementation in an implementation-dependent manner. An SQL parameter is not used for this purpose.

    f) Depending on whether the <language clause> specifies ADA, C, COBOL, FORTRAN, M, PASCAL,
       or PLI, let the operative data type correspondences table be Table 16, “Data type correspondences for
       Ada”, Table 17, “Data type correspondences for C”, Table 18, “Data type correspondences for COBOL”,
       Table 19, “Data type correspondences for Fortran”, Table 20, “Data type correspondences for M”,


©ISO/IEC 2003 – All rights reserved                                            Schema definition and manipulation 691
ISO/IEC 9075-2:2003 (E)
11.50 <SQL-invoked routine>



        Table 21, “Data type correspondences for Pascal”, or Table 22, “Data type correspondences for PL/I”,
        respectively. Refer to the two columns of the operative data type correspondences table as the “SQL
        data type” column and the “host data type column”.
    g) Any <data type> in an effective SQL parameter list entry shall specify a data type listed in the SQL
       data type column for which the corresponding row in the host data type column is not “None”.
21) Case:
    a) If <method specification designator> is specified, then:
        i)     R is deterministic if DMS indicates that the method is deterministic; otherwise, R is possibly
               non-deterministic.
        ii)    R possibly modifies SQL-data if the SQL-data access indication of DMS indicates that the method
               possibly modifies SQL-data. R possibly reads SQL-data if the SQL-data access indication of
               DMS indicates that the method possibly reads SQL-data. R possibly contains SQL if the SQL-
               data access indication of DMS indicates that the method possibly contains SQL. Otherwise, R
               does not possibly contain SQL.
    b) Otherwise:
        i)     If DETERMINISTIC is specified, then R is deterministic; otherwise, it is possibly non-determin-
               istic.
        ii)    An <SQL-invoked routine> possibly modifies SQL-data if and only if <SQL-data access indica-
               tion> specifies MODIFIES SQL DATA.
        iii)   An <SQL-invoked routine> possibly reads SQL-data if and only if <SQL-data access indication>
               specifies READS SQL DATA.
        iv)    An <SQL-invoked routine> possibly contains SQL if and only if <SQL-data access indication>
               specifies CONTAINS SQL.
        v)     An <SQL-invoked routine> does not possibly contain SQL if and only if <SQL-data access
               indication> specifies NO SQL.
22) If R is a schema-level routine, then let the containing schema be the schema identified by the <schema
    name> explicitly or implicitly contained in <schema qualified routine name>.
23) If the <SQL-invoked routine> is contained in a <schema definition>, then let A be the explicit or implicit
    <authorization identifier> of the <schema definition>; otherwise, let A be the <authorization identifier>
    that owns the schema identified by the explicit or implicit <schema name> of the <schema qualified routine
    name>.


Access Rules
1) If an <SQL-invoked routine> is contained in an <SQL-client module definition> M with no intervening
   <schema definition>, then the enabled authorization identifiers shall include the <authorization identifier>
   that owns S.
2) If R is an external routine and if any of its SQL parameters have an associated from-sql function or a to-
   sql function, or if R has a to-sql function associated with the result, then



692 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                 11.50 <SQL-invoked routine>



    Case:
    a) If <SQL-invoked routine> is contained, without an intervening <SQL routine spec> that specifies SQL
       SECURITY INVOKER, in an <SQL schema statement>, then the applicable privileges of the
       <authorization identifier> that owns the containing schema shall include EXECUTE on all from-sql
       functions (if any) and on all to-sql functions (if any) associated with the SQL parameters and on the
       to-sql function associated with the result (if any).
    b) Otherwise, the current privileges shall include EXECUTE on all from-sql functions (if any) and on all
       to-sql functions (if any) associated with the SQL parameters and on the to-sql function associated with
       the result (if any).


General Rules
1) If R is a schema-level routine, then a privilege descriptor is created that defines the EXECUTE privilege
   on R to the <authorization identifier> that owns the schema that includes R. The grantor for the privilege
   descriptor is set to the special grantor value “_SYSTEM”. This privilege is grantable if and only if one of
   the following is satisfied:
    a) R is an SQL routine and all of the privileges necessary for the <authorization identifier> to successfully
       execute the <SQL procedure statement> contained in the <routine body> are grantable. The necessary
       privileges include the EXECUTE privilege on every subject routine of every <routine invocation>
       contained in the <SQL procedure statement>.
    b) R is an SQL routine and SQL SECURITY INVOKER is specified.
    c) R is an external routine.
2) Case:
    a) If <SQL-invoked routine> is contained in a <schema definition>, then let DP be the SQL-path of that
       <schema definition>.
    b) If <SQL-invoked routine> is contained in a <preparable statement> or in a <direct SQL statement>,
       then let DP be the SQL-path of the current SQL-session.
    c) Otherwise, let DP be the SQL-path of the <SQL-client module definition> that contains <SQL-invoked
       routine>.
3) If <method specification designator> is not specified, then a routine descriptor is created that describes the
   SQL-invoked routine being defined:
    a) The routine name included in the routine descriptor is <schema qualified routine name>.
    b) The specific name included in the routine descriptor is <specific name>.
    c) The routine descriptor includes, for each SQL parameter in NPL, the name, declared type, ordinal
       position, an indication of whether the SQL parameter is input, output, or both, and an indication of
       whether the SQL parameter is a RESULT SQL parameter.
    d) If the SQL-invoked routine is an SQL-invoked procedure, then the explicit or implicit value of <maxi-
       mum dynamic result sets>.




©ISO/IEC 2003 – All rights reserved                                    Schema definition and manipulation 693
ISO/IEC 9075-2:2003 (E)
11.50 <SQL-invoked routine>



   e) The routine descriptor includes an indication of whether the SQL-invoked routine is an SQL-invoked
      function or an SQL-invoked procedure.
   f) If the SQL-invoked routine is an SQL-invoked function, then:
        i)     The routine descriptor includes an indication that the SQL-invoked function is not an SQL-
               invoked method.
        ii)    The routine descriptor includes the data type in the <returns data type>. If the <returns data
               type> simply contains <locator indication>, then the routine descriptor includes an indication
               that the return value is a locator.
        iii)   The SQL-invoked routine descriptor includes an indication of whether the SQL-invoked routine
               is a null-call function.
   g) If the SQL-invoked routine is a type-preserving function, then the routine descriptor includes an indi-
      cation that the SQL-invoked routine is a type-preserving function.
   h) The name of the language in which the body of the SQL-invoked routine was written is the <language
      name> contained in the <language clause>.
   i)   If the SQL-invoked routine is an SQL routine, then the SQL routine body of the routine descriptor is
        the <SQL routine body>.
   j)   If the SQL-invoked routine is an SQL-invoked function or NEW SAVEPOINT LEVEL is specified,
        then an indication that a new savepoint level is to be established whenever the routine is invoked.
        NOTE 321 — The use of savepoint levels is dependent on Feature T272, “Enhanced savepoint management”.

   k) Case:
        i)     If SQL SECURITY INVOKER is specified, then the SQL security characteristic in the routine
               descriptor is INVOKER.
        ii)    Otherwise, the SQL security characteristic in the routine descriptor is DEFINER.
   l)   If the SQL-invoked routine is an external routine, then:
        i)     The external name of the routine descriptor is <external routine name>.
        ii)    The routine descriptor includes an indication of whether the parameter passing style is
               PARAMETER STYLE SQL or PARAMETER STYLE GENERAL.
   m) The SQL-invoked routine descriptor includes an indication of whether the SQL-invoked routine is
      DETERMINISTIC or NOT DETERMINISTIC.
   n) The SQL-invoked routine descriptor includes an indication of whether the SQL-invoked routine does
      not possibly contain SQL, possibly contains SQL, possibly reads SQL-data, or possibly modifies SQL-
      data.
   o) If the SQL-invoked routine specifies a <result cast>, then the routine descriptor includes an indication
      that the SQL-invoked routine specifies a <result cast> and the <data type> specified in the <result
      cast>. If <result cast> contains <locator indication>, then the routine descriptor includes an indication
      that the <data type> specified in the <result cast> has a locator indication.




694 Foundation (SQL/Foundation)                                                          ©ISO/IEC 2003 – All rights reserved
                                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                                                11.50 <SQL-invoked routine>



    p) For every SQL parameter that has an associated from-sql function FSF, the routine descriptor includes
       the specific name of FSF.
    q) For every SQL parameter that has an associated to-sql function TSF, the routine descriptor includes
       the specific name of TSF.
    r) If R is an external function and if R has a to-sql function associated with its result TRF, then the routine
       descriptor includes the specific name of TRF.
    s) For every SQL parameter whose <SQL parameter declaration> contains <locator indication>, the
       routine descriptor includes an indication that the SQL parameter is a locator parameter.
    t)   The routine authorization identifier is the <authorization identifier> that owns S.
    u) The routine SQL-path is DP.
         NOTE 322 — The routine SQL-path is used to set the routine SQL-path of the current SQL-session when R is invoked. The
         routine SQL-path of the current SQL-session is used by the Syntax Rules of Subclause 10.4, “<routine invocation>”, to define
         the subject routines of <routine invocation>s contained in R. The same routine SQL-path is used whenever R is invoked.

    v) An indication that the routine is a schema-level routine.
    w) An indication of whether the SQL-invoked routine is dependent on a user-defined type.
         NOTE 323 — The notion of an SQL-invoked routine being dependent on a user-defined type is defined in Subclause 4.27,
         “SQL-invoked routines”.

4) If <method specification designator> is specified, then let DMS be the descriptor of the corresponding
   method specification. A routine descriptor is created that describes the SQL-invoked routine being defined.
    a) The routine name included in the routine descriptor is RN.
    b) The specific name included in the routine descriptor is <specific name>.
    c) The routine descriptor includes, for each SQL parameter in NPL, the name, data type, ordinal position,
       an indication of whether the SQL parameter is input, output, or both, and an indication of whether the
       SQL parameter is a RESULT SQL parameter.
    d) The routine descriptor includes an indication that the SQL-invoked routine is an SQL-invoked function
       that is an SQL-invoked method, an indication of the user-defined type UDT, and an indication of
       whether STATIC or CONSTRUCTOR was specified.
    e) If the SQL-invoked routine is a type-preserving function, then the routine descriptor includes an indi-
       cation that the SQL-invoked routine is a type-preserving function.
    f) If the SQL-invoked routine is a mutator function, then the routine descriptor includes an indication that
       the SQL-invoked routine is a mutator function.
    g) The routine descriptor includes the data type in the <returns data type>.
    h) The name of the language in which the body of the SQL-invoked routine was written is the <language
       name> contained in the <language clause> in DMS.
    i)   If the SQL-invoked routine is an SQL routine, then the SQL routine body of the routine descriptor is
         the <SQL routine body>.
    j)   Case:



©ISO/IEC 2003 – All rights reserved                                                Schema definition and manipulation 695
ISO/IEC 9075-2:2003 (E)
11.50 <SQL-invoked routine>



         i)      If SQL SECURITY INVOKER is specified, then the SQL security characteristic in the routine
                 descriptor is INVOKER.
         ii)     Otherwise, the SQL security characteristic in the routine descriptor is DEFINER.
    k) If the SQL-invoked routine is an external routine, then:
         i)      The external name of the routine descriptor is <external routine name>.
         ii)     The routine descriptor includes an indication of whether the parameter passing style is
                 PARAMETER STYLE SQL or PARAMETER STYLE GENERAL, which is the same as the
                 indication of <parameter style> in DMS.
    l)   The SQL-invoked routine descriptor includes an indication of whether the SQL-invoked routine is
         deterministic.
    m) The SQL-invoked routine descriptor includes an indication of whether the SQL-invoked routine possibly
       modifies SQL-data, possibly read SQL-data, possibly contains SQL, or does not possibly contain SQL.
    n) The SQL-invoked routine descriptor includes an indication of whether the SQL-invoked routine is a
       null-call function, which is the same as the indication in DMS.
    o) If DMS specifies a <result cast>, then the routine descriptor includes an indication that the SQL-invoked
       routine specifies a <result cast> and the <data type> specified in the <result cast> of DMS.
    p) The routine authorization identifier is the <authorization identifier> that owns S.
    q) The routine SQL-path is DP.
         NOTE 324 — The routine SQL-path is used to set the routine SQL-path of the current SQL-session when R is invoked. The
         routine SQL-path of the current SQL-session is used by the Syntax Rules of Subclause 10.4, “<routine invocation>”, to define
         the subject routine of <routine invocation>s contained in R. The same routine SQL-path is used whenever R is invoked.

    r) An indication of whether the routine is a schema-level routine.
    s) An indication of whether the SQL-invoked routine is dependent on a user-defined type.
         NOTE 325 — The notion of an SQL-invoked routine being dependent on a user-defined type is defined in Subclause 4.27,
         “SQL-invoked routines”.

5) The creation timestamp and the last-altered timestamp included in the routine descriptor are the values of
   CURRENT_TIMESTAMP.
6) If R is an external routine, then the routine descriptor of R includes further elements determined as follows:
    a) Case:
         i)      If <SQL-data access indication> in the descriptor of R is MODIFIES SQL DATA, READS SQL
                 DATA, or CONTAINS SQL, then:
                 1) Let P be the program identified by the <external routine name>.
                 2) The external routine authorization identifier of R is the <module authorization identifier>
                    of the <SQL-client module definition> of P.
                 3) The external routine SQL-path is the <schema name list> immediately contained in the
                    <path specification> that is immediately contained in the <module path specification> of
                    the <SQL-client module definition> of P.


696 Foundation (SQL/Foundation)                                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                                                11.50 <SQL-invoked routine>



         ii)      Otherwise:
                  1) The external routine authorization identifier is implementation-defined.
                  2) The external routine SQL-path is implementation-defined.
         NOTE 326 — The external routine SQL-path is used to set the routine SQL-path of the current SQL-session when R is invoked.
         The routine SQL-path of the current SQL-session is used by the Syntax Rules of Subclause 10.4, “<routine invocation>”, to
         define the subject routines of <routine invocation>s contained in the <SQL-client module definition> of P. The same external
         routine SQL-path is used whenever R is invoked.

    b) The external security characteristic in the routine descriptor is
         Case:
         i)       If <external security clause> specifies EXTERNAL SECURITY DEFINER, then DEFINER.
         ii)      If <external security clause> specifies EXTERNAL SECURITY INVOKER, then INVOKER.
         iii)     Otherwise, EXTERNAL SECURITY IMPLEMENTATION DEFINED.
    c) The effective SQL parameter list is the effective SQL parameter list.


Conformance Rules
1) Without Feature T471, “Result sets return value”, conforming SQL language shall not contain a <dynamic
   result sets characteristic>.
2) Without Feature T322, “Overloading of SQL-invoked functions and procedures”, conforming SQL language
   shall not contain a <schema routine> in which the schema identified by the explicit or implicit schema
   name of the <schema qualified routine name> includes a routine descriptor whose routine name is <schema
   qualified routine name>.
3) Without Feature S023, “Basic structured types”, conforming SQL language shall not contain a <method
   specification designator>.
4) Without Feature S241, “Transform functions”, conforming SQL language shall not contain a <transform
   group specification>.
5) Without Feature S024, “Enhanced structured types”, an <SQL parameter declaration> shall not contain
   RESULT.
6) Without Feature T571, “Array-returning external SQL-invoked functions”, conforming SQL language shall
   not contain an <SQL-invoked routine> that defines an array-returning external function.
7) Without Feature T572, “Multiset-returning external SQL-invoked functions”, conforming SQL language
   shall not contain an <SQL-invoked routine> that defines a multiset-returning external function.
8) Without Feature S201, “SQL-invoked routines on arrays”, conforming SQL language shall not contain a
   <parameter type> that is based on an array type.
9) Without Feature S201, “SQL-invoked routines on arrays”, conforming SQL language shall not contain a
   <returns data type> that is based on an array type.
10) Without Feature S202, “SQL-invoked routines on multisets”, conforming SQL language shall not contain
    a <parameter type> that is based on a multiset type.


©ISO/IEC 2003 – All rights reserved                                                Schema definition and manipulation 697
ISO/IEC 9075-2:2003 (E)
11.50 <SQL-invoked routine>



11) Without Feature S202, “SQL-invoked routines on multisets”, conforming SQL language shall not contain
    a <returns data type> that is based on a multiset type.
12) Without Feature T323, “Explicit security for external routines”, conforming SQL language shall not contain
    an <external security clause>.
13) Without Feature S231, “Structured type locators”, conforming SQL language shall not contain a <parameter
    type> that contains a <locator indication> and that simply contains a <data type> that identifies a structured
    type.
14) Without Feature S231, “Structured type locators”, conforming SQL language shall not contain a <returns
    data type> that contains a <locator indication> and that simply contains a <data type> that identifies a
    structured type.
15) Without Feature S232, “Array locators”, conforming SQL language shall not contain a <parameter type>
    that contains a <locator indication> and that simply contains a <data type> that identifies an array type.
16) Without Feature S232, “Array locators”, conforming SQL language shall not contain a <returns data type>
    that contains a <locator indication> and that simply contains a <data type> that identifies an array type.
17) Without Feature S233, “Multiset locators”, conforming SQL language shall not contain a <parameter type>
    that contains a <locator indication> and that simply contains a <data type> that identifies a multiset type.
18) Without Feature S233, “Multiset locators”, conforming SQL language shall not contain a <returns data
    type> that contains a <locator indication> and that simply contains a <data type> that identifies a multiset
    type.
19) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain a
    <parameter type> that contains a <locator indication> and that simply contains a <data type> that identifies
    a large object type.
20) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain a
    <returns data type> that contains a <locator indication> and that simply contains a <data type> that identifies
    a large object type.
21) Without Feature S027, “Create method by specific method name”, conforming SQL language shall not
    contain a <method specification designator> that contains SPECIFIC METHOD.
22) Without Feature T324, “Explicit security for SQL routines”, conforming SQL language shall not contain
    a <rights clause>.
23) Without Feature T326, “Table functions”, conforming SQL language shall not contain a <returns table
    type>.
24) Without Feature T651, “SQL-schema statements in SQL routines”, conforming SQL language shall not
    contain an <SQL routine body> that contains an SQL-schema statement.
25) Without Feature T652, “SQL-dynamic statements in SQL routines”, conforming SQL language shall not
    contain an <SQL routine body> that contains an SQL-dynamic statement.
26) Without Feature T653, “SQL-schema statements in external routines”, conforming SQL language shall not
    contain an <external routine name> that identifies a program in which an SQL-schema statement appears.




698 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                  ISO/IEC 9075-2:2003 (E)
                                                                             11.50 <SQL-invoked routine>



27) Without Feature T654, “SQL-dynamic statements in external routines”, conforming SQL language shall
    not contain an <external routine name> that identifies a program in which an SQL-dynamic statement
    appears.
28) Without Feature T655, “Cyclically dependent routines”, conforming SQL language shall not contain an
    <SQL routine body> that contains a <routine invocation> whose subject routine is generally dependent on
    the routine descriptor of the SQL-invoked routine specified by <SQL-invoked routine>.
29) Without Feature T272, “Enhanced savepoint management”, conforming SQL language shall not contain a
    <routine characteristics> that contains a <savepoint level indication>.
30) Without Feature B121, “Routine language Ada”, conforming SQL language shall not contain a <routine
    characteristic> that contains a <language clause> that contains ADA.
31) Without Feature B122, “Routine language C”, conforming SQL language shall not contain a <routine
    characteristic>that contains a <language clause> that contains C.
32) Without Feature B123, “Routine language COBOL”, conforming SQL language shall not contain a <routine
    characteristic> that contains a <language clause> that contains COBOL.
33) Without Feature B124, “Routine language Fortran”, conforming SQL language shall not contain a <routine
    characteristic> that contains a <language clause> that contains FORTRAN.
34) Without Feature B125, “Routine language MUMPS”, conforming SQL language shall not contain a <routine
    characteristic> that contains a <language clause> that contains M.
35) Without Feature B126, “Routine language Pascal”, conforming SQL language shall not contain a <routine
    characteristic> that contains a <language clause> that contains PASCAL.
36) Without Feature B127, “Routine language PL/I”, conforming SQL language shall not contain a <routine
    characteristic> that contains a <language clause> that contains PLI.
37) Without Feature B128, “Routine language SQL”, conforming SQL language shall not contain a <routine
    characteristic> that contains a <language clause> that contains SQL.




©ISO/IEC 2003 – All rights reserved                                Schema definition and manipulation 699
ISO/IEC 9075-2:2003 (E)
11.51 <alter routine statement>



11.51 <alter routine statement>

Function
Alter a characteristic of an SQL-invoked routine.


Format
<alter routine statement> ::=
    ALTER <specific routine designator>
    <alter routine characteristics> <alter routine behavior>

<alter routine characteristics> ::= <alter routine characteristic>...

<alter routine characteristic> ::=
    <language clause>
  | <parameter style clause>
  | <SQL-data access indication>
  | <null-call clause>
  | <dynamic result sets characteristic>
  | NAME <external routine name>

<alter routine behavior> ::= RESTRICT


Syntax Rules
1) Let SR be the SQL-invoked routine identified by the <specific routine designator> and let SN be the <specific
   name> of SR. The schema identified by the explicit or implicit <schema name> of SN shall include the
   descriptor of SR.
2) SR shall be a schema-level routine.
3) SR shall not be an SQL-invoked routine that is dependent on a user-defined type.
    NOTE 327 — “SQL-invoked routine dependent on a user-defined type” is defined in Subclause 4.27, “SQL-invoked routines”.

4) If RESTRICT is specified, then:
    a) SR shall not be the ordering function included in the descriptor of any user-defined type UDT.
    b) SR shall not be the subject routine of any <routine invocation>, <method invocation>, <static method
       invocation>, or <method reference> that is contained in any of the following:
        i)      The SQL routine body of any routine descriptor.
        ii)     The <query expression> of any view descriptor.
        iii)    The <search condition> of any constraint descriptor.
        iv)     The triggered action of any trigger descriptor.
    c) SN shall not be included in any of the following:
        i)      A group descriptor of any transform descriptor.


700 Foundation (SQL/Foundation)                                                            ©ISO/IEC 2003 – All rights reserved
                                                                                              ISO/IEC 9075-2:2003 (E)
                                                                                        11.51 <alter routine statement>



         ii)      A user-defined cast descriptor.
5) SR shall be an external routine.
6) SR shall not be an SQL-invoked method that is an overriding method and the set of overriding methods of
   SR shall be empty.
7) <alter routine characteristics> shall contain at most one <language clause>, at most one <parameter style
   clause>, at most one <SQL-data access indication>, at most one <null-call clause>, at most one <maximum
   dynamic result sets>, and at most one <external routine name>.
8) If <maximum dynamic result sets> is specified, then SR shall be an SQL-invoked procedure.
9) If <language clause> is specified, then:
    a) <language clause> shall not specify SQL.
    b) Depending on whether the <language clause> specifies ADA, C, COBOL, FORTRAN, M, PASCAL,
       or PLI, let the operative data type correspondences table be Table 16, “Data type correspondences for
       Ada”, Table 17, “Data type correspondences for C”, Table 18, “Data type correspondences for COBOL”,
       Table 19, “Data type correspondences for Fortran”, Table 20, “Data type correspondences for M”,
       Table 21, “Data type correspondences for Pascal”, or Table 22, “Data type correspondences for PL/I”,
       respectively. Refer to the two columns of the operative data type correspondences table as the “SQL
       data type” column and the “host data type column”.
    c) Any <data type> in the effective SQL parameter list entry of SR shall specify a data type listed in the
       SQL data type column for which the corresponding row in the host data type column is not “None”.
         NOTE 328 — “Effective SQL parameter list” is defined in Subclause 11.50, “<SQL-invoked routine>”.


Access Rules
1) The enabled authorization identifiers shall include the <authorization identifier> that owns the schema
   identified by the implicit or explicit <schema name> of SN.


General Rules
1) If SR is not a method, then the routine descriptor of SR is modified:
    a) If <dynamic result sets characteristic> is specified, then the value of <maximum dynamic result sets>.
    b) If <language clause> is specified, then the <language name> contained in the <language clause>.
    c) If <external routine name> is specified, then the external name of the routine descriptor is <external
       routine name>.
    d) If <parameter style clause> is specified, then the routine descriptor includes an indication of whether
       the parameter passing style is PARAMETER STYLE SQL or PARAMETER STYLE GENERAL.
    e) If the <SQL-data access indication> is specified, then an indication of whether the SQL-invoked routine's
       <SQL-data access indication> is READS SQL DATA, MODIFIES SQL DATA, CONTAINS SQL,
       or NO SQL.




©ISO/IEC 2003 – All rights reserved                                           Schema definition and manipulation 701
ISO/IEC 9075-2:2003 (E)
11.51 <alter routine statement>



    f) If <null-call clause> is specified, then an indication of whether the SQL-invoked routine is a null-call
       function.
2) If SR is a method, then let DMS be the descriptor of the corresponding method specification. DMS is
   modified:
    a) If <language clause> is specified, then the <language name> contained in the <language clause>.
    b) If <parameter style clause> is specified, then the method specification descriptor includes an indication
       of whether the parameter passing style is PARAMETER STYLE SQL or PARAMETER STYLE
       GENERAL.
    c) If the <SQL-data access indication> is specified, then an indication of whether the SQL-invoked routine's
       <SQL-data access indication> is READS SQL DATA, MODIFIES SQL DATA, CONTAINS SQL,
       or NO SQL.
    d) If <null-call clause> is specified, then an indication of whether the method should not be invoked if
       any argument is the null value.
3) If SR is a method, then the routine descriptor of SR is modified:
    a) If <external routine name> is specified, then the external name of the routine descriptor is <external
       routine name>. If <parameter style clause> is specified, then the method specification descriptor includes
       an indication of whether the parameter passing style is PARAMETER STYLE SQL or PARAMETER
       STYLE GENERAL.


Conformance Rules
1) Without Feature F381, “Extended schema manipulation”, conforming SQL language shall not contain an
   <alter routine statement>.




702 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                                ISO/IEC 9075-2:2003 (E)
                                                                                          11.52 <drop routine statement>



11.52 <drop routine statement>

Function
Destroy an SQL-invoked routine.


Format
<drop routine statement> ::= DROP <specific routine designator> <drop behavior>


Syntax Rules
1) Let SR be the SQL-invoked routine identified by the <specific routine designator> and let SN be the <specific
   name> of SR. The schema identified by the explicit or implicit <schema name> of SN shall include the
   descriptor of SR.
2) SR shall be a schema-level routine.
3) SR shall not be dependent on any user-defined type.
    NOTE 329 — The notion of an SQL-invoked routine being dependent on a user-defined type is defined in Subclause 4.27, “SQL-
    invoked routines”.

4) If RESTRICT is specified, then SR shall not be the ordering function included in the descriptor of any user-
   defined type UDT.
5) If RESTRICT is specified, then:
    a) SR shall not be the subject routine of any <routine invocation>, <method invocation>, <static method
       invocation>, or <method reference> that is contained in any of the following:
         i)       The SQL routine body of any routine descriptor.
         ii)      The <query expression> of any view descriptor.
         iii)     The <search condition> of any constraint descriptor.
         iv)      The triggered action of any trigger descriptor.
    b) SN shall not be a included in any of the following:
         i)       A group descriptor of any transform descriptor.
         ii)      A user-defined cast descriptor.
    NOTE 330 — If CASCADE is specified, then such referencing objects will be dropped by the execution of the <revoke statement>
    specified in the General Rules of this Subclause.

6) Let the containing schema be the schema identified by the <schema name> explicitly or implicitly contained
   in SN.




©ISO/IEC 2003 – All rights reserved                                             Schema definition and manipulation 703
ISO/IEC 9075-2:2003 (E)
11.52 <drop routine statement>



Access Rules
1) Let A be the <authorization identifier> that owns the schema identified by the <schema name> of SN. The
   enabled authorization identifiers shall include A.


General Rules
1) The following <revoke statement> is effectively executed with a current authorization identifier of
   “_SYSTEM” and without further Access Rule checking:

    REVOKE EXECUTE ON SPECIFIC ROUTINE
        SN FROM A CASCADE

2) Let DN be the <user-defined type name> of a user-defined type whose descriptor includes SN in the group
   descriptor of any transform descriptor. Let GN be the <group name> of that group descriptor. The following
   <drop transform statement> is effectively executed without further Access Rule checking:

    DROP TRANSFORM GN FOR DN CASCADE

3) Let UDCD be a user-defined cast descriptor that includes SN as its cast function. Let SDT be the source
   data type included in UDCD. Let TDT be the target data type included in UDCD. The following <drop
   user-defined cast statement> is effectively executed without further Access Rule checking:

    DROP CAST ( DN AS TD ) CASCADE

4) If SR is the ordering function included in the descriptor of a user-defined type UDT, then let UDTN be a
   <path-resolved user-defined type name> that identifies UDT. The following <drop user-defined ordering
   statement> is effectively executed without further Access Rule checking:

    DROP ORDERING FOR UDTN CASCADE

5) The descriptor of SR is destroyed.


Conformance Rules
1) Without Feature F032, “CASCADE drop behavior”, conforming SQL language shall not contain a <drop
   routine statement> that contains a <drop behavior> that contains CASCADE.
2) Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain a <drop
   routine statement> that contains a <specific routine designator> that identifies a method.




704 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                            11.53 <user-defined cast definition>



11.53 <user-defined cast definition>

Function
Define a user-defined cast.


Format
<user-defined cast definition> ::=
    CREATE CAST <left paren> <source data type> AS <target data type> <right paren>
    WITH <cast function>
    [ AS ASSIGNMENT ]

<cast function> ::= <specific routine designator>

<source data type> ::= <data type>

<target data type> ::= <data type>


Syntax Rules
1) Let SDT be the <source data type>. The data type identified by SDT is called the source data type.
2) Let TDT be the <target data type>. The data type identified by TDT is called the target data type.
3) There shall be no user-defined cast for SDT and TDT.
4) At least one of SDT or TDT shall contain a <schema-resolved user-defined type name> or a <reference
   type>.
5) If SDT contains a <schema-resolved user-defined type name>, then let SSDT be the schema that includes
   the descriptor of the user-defined type identified by SDT.
6) If SDT contains a <reference type>, then let SSDT be the schema that includes the descriptor of the referenced
   type of the reference type identified by SDT.
7) If TDT contains a <schema-resolved user-defined type name>, then let STDT be the schema that includes
   the descriptor of the user-defined type identified by TDT.
8) If TDT contains a <reference type>, then let STDT be the schema that includes the descriptor of the referenced
   type of the reference type identified by TDT.
9) If both SDT and TDT contain a <schema-resolved user-defined type name> or a <reference type>, then the
   <authorization identifier> that owns SSDT and the <authorization identifier> that owns STDT shall be
   equivalent.
10) Let F be the SQL-invoked routine identified by <cast function>. F is called the cast function for source
    data type SDT and target data type TDT.
    a) F shall have exactly one SQL parameter, and its declared type shall be SDT.
    b) The result data type of F shall be TDT.



©ISO/IEC 2003 – All rights reserved                                    Schema definition and manipulation 705
ISO/IEC 9075-2:2003 (E)
11.53 <user-defined cast definition>



    c) The <authorization identifier> that owns SSDT or STDT (both, if both SDT and TDT are <schema-
       resolved user-defined type name>s) shall own the schema that includes the SQL-invoked routine
       descriptor of F.
    d) F shall be deterministic.
    e) F shall not possibly modify SQL-data.
    f) F shall not possibly read SQL-data.


Access Rules
1) The enabled authorization identifiers shall include the <authorization identifier> that owns the schema that
   includes the routine descriptor of F.
2) If SDT contains a <schema-resolved user-defined type name> or a <reference type>, then the enabled
   authorization identifiers shall include the <authorization identifier> that owns SSDT.
3) If TDT contains a <schema-resolved user-defined type name> or a <reference type>, then the enabled
   authorization identifiers shall include the <authorization identifier> that owns STDT.


General Rules
1) A user-defined cast descriptor CFD is created that describes the user-defined cast. CFD includes the name
   of the source data type, the name of the target data type, the specific name of the cast function, and, if and
   only if AS ASSIGNMENT is specified, an indication that the cast function is implicitly invocable.


Conformance Rules
1) Without Feature S211, “User-defined cast functions”, conforming SQL language shall not contain a <user-
   defined cast definition>.




706 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                              ISO/IEC 9075-2:2003 (E)
                                                                               11.54 <drop user-defined cast statement>



11.54 <drop user-defined cast statement>

Function
Destroy a user-defined cast.


Format
<drop user-defined cast statement> ::=
    DROP CAST <left paren> <source data type> AS <target data type> <right paren>
    <drop behavior>


Syntax Rules
1) Let SDT be the <source data type> and let TDT be the <target data type>.
2) Let CF be the user-defined cast whose user-defined cast descriptor includes SDT as the source data type
   and TDT as the target data type.
3) Let SN be the specific name of the cast function F included in the user-defined cast descriptor of CF.
4) The schema identified by the <schema name> of SN shall include the descriptor of F.
5) Let CS be any <cast specification> such that:
    a) The <value expression> of CS has declared type P.
    b) The <cast target> of CS is either TDT or a domain with declared type TDT.
    c) The type designator of SDT is in the type precedence of P.
    d) No other data type Q whose type designator precedes SDT in the type precedence list of P such that
       there is a user-defined cast CFq whose user-defined cast descriptor includes Q as the source data type
       and TDT as the target data type.
6) Let PS be any SQL procedure statement that is dependent on F.
7) If RESTRICT is specified, then neither CS nor PS shall be generally contained in any of the following:
    a) The SQL routine body of any routine descriptor.
    b) The <query expression> of any view descriptor.
    c) The <search condition> of any constraint descriptor.
    d) The trigger action of any trigger descriptor.
    NOTE 331 — If CASCADE is specified, then such referencing objects will be dropped as specified in the General Rules of this
    Subclause.




©ISO/IEC 2003 – All rights reserved                                             Schema definition and manipulation 707
ISO/IEC 9075-2:2003 (E)
11.54 <drop user-defined cast statement>



Access Rules
1) The enabled authorization identifier shall include the <authorization identifier> that owns the schema
   identified by the implicit or explicit <schema name> of SN.


General Rules
1) Let R be any SQL-invoked routine that contains CS or PS in its SQL routine body. Let SN be the specific
   name of R. The following <drop routine statement> is effectively executed without further Access Rule
   checking:
      DROP SPECIFIC ROUTINE SN CASCADE

2) Let V be any view that contains CS or PS in its <query expression>. Let VN be the <table name> of V. The
   following <drop view statement> is effectively executed without further Access Rule checking:
      DROP VIEW VN CASCADE

3) Let T be any table that contains CS or PS in the <search condition> of any constraint descriptor included
   in the table descriptor of T. Let TN be the <table name> of T. The following <drop table statement> is
   effectively executed without further Access Rule checking:
      DROP TABLE TN CASCADE

4) Let A be any assertion that contains CS or PS in its <search condition>. Let AN be the <constraint name>
   of A. The following <drop assertion statement> is effectively executed without further Access Rule
   checking:
      DROP ASSERTION AN CASCADE

5) Let D be any domain that contains CS or PS in the <search condition> of any constraint descriptor. Let DN
   be the <domain name> of D. The following <drop domain statement> is effectively executed without further
   Access Rule checking:
      DROP DOMAIN DN CASCADE

6) Let T be any trigger whose trigger descriptor includes a trigger action that contains CS or PS. Let TN be
   the <trigger name> of T. The following <drop trigger statement> is effectively executed without further
   Access Rule checking:
      DROP TRIGGER TN

7) The descriptor of CF is destroyed.


Conformance Rules
1) Without Feature S211, “User-defined cast functions”, conforming SQL language shall not contain a <drop
   user-defined cast statement>.



708 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                    11.55 <user-defined ordering definition>



11.55 <user-defined ordering definition>

Function
Define a user-defined ordering for a user-defined type.


Format
<user-defined ordering definition> ::=
    CREATE ORDERING FOR <schema-resolved user-defined type name> <ordering form>

<ordering form> ::=
    <equals ordering form>
  | <full ordering form>

<equals ordering form> ::= EQUALS ONLY BY <ordering category>

<full ordering form> ::= ORDER FULL BY <ordering category>

<ordering category> ::=
    <relative category>
  | <map category>
  | <state category>

<relative category> ::= RELATIVE WITH <relative function specification>

<map category> ::= MAP WITH <map function specification>

<state category> ::= STATE [ <specific name> ]

<relative function specification> ::= <specific routine designator>

<map function specification> ::= <specific routine designator>


Syntax Rules
1) Let UDTN be the <schema-resolved user-defined type name>. Let UDT be the user-defined type identified
   by UDTN.
2) The descriptor of UDT shall include an ordering form that specifies NONE.
3) If UDT is not a maximal supertype, then
    Case:
    a) If <equals ordering form> is specified, then the comparison form of every direct supertype of UDT
       shall be EQUALS.
    b) Otherwise, the comparison form of every direct supertype of UDT shall be FULL.
4) If <relative category> or <state category> is specified, then UDT shall be a maximal supertype.




©ISO/IEC 2003 – All rights reserved                                 Schema definition and manipulation 709
ISO/IEC 9075-2:2003 (E)
11.55 <user-defined ordering definition>



5) If <map category> is specified and UDT is not a maximal supertype, then the comparison category of every
   direct supertype of UDT shall be MAP.
    NOTE 332 — The comparison categories of two user-defined types in the same subtype family shall be the same.

6) Case:
    a) If <state category> is specified, then
        i)      UDT shall not be a distinct type.
        ii)     EQUALS ONLY shall be specified.
        iii)    The declared type of each attribute of UDT shall not be UDT-NC-ordered.
        iv)     Case:
                1) If <specific name> is specified, then let SN be <specific name>. If SN contains a <schema
                   name>, then that <schema name> shall be equivalent to the <schema name> of UDTN.
                2) Otherwise, let SN be an implementation-dependent <specific name> whose <schema name>
                   is equivalent to the <schema name> S of UDTN. This implementation-dependent <specific
                   name> shall not be equivalent to the <specific name> of any other routine descriptor in the
                   schema identified by S.
    b) Otherwise:
        i)      Let F be the SQL-invoked routine identified by the <specific routine designator> SRD.
        ii)     F shall be deterministic.
        iii)    F shall not possibly modify SQL-data.
7) If <relative function specification> is specified, then:
    a) F shall have exactly two SQL parameters whose declared type is UDT.
    b) F shall be an SQL-invoked regular function.
    c) The result data type of F shall be INTEGER.
8) If <map function specification> is specified, then:
    a) F shall have exactly one SQL parameter whose declared type is UDT.
    b) The result data type of F shall be a predefined data type.
    c) The result data type of F is an operand of an equality operation. The Syntax Rules of Subclause 9.9,
       “Equality operations”, apply.
    d) If FULL is specified, then the result data type of F is an operand of an ordering operation. The Syntax
       Rules of Subclause 9.12, “Ordering operations”, apply.


Access Rules
1) The enabled authorization identifiers shall include the <authorization identifier> that owns the schema that
   includes the descriptor of UDT and the schema that includes the routine descriptor of F.


710 Foundation (SQL/Foundation)                                                             ©ISO/IEC 2003 – All rights reserved
                                                                                            ISO/IEC 9075-2:2003 (E)
                                                                             11.55 <user-defined ordering definition>



General Rules
1) If <state category> is specified, then:
    a) Let C1, ..., Cn be the components of the representation of the user-defined type.

    b) Let SNUDT be the <schema name> of the schema that includes the descriptor of UDT.
    c) The following <SQL-invoked routine> is effectively executed:
             CREATE FUNCTION SNUDT.EQUALS ( UDT1 UDTN, UDT2 UDTN )
                 RETURNS BOOLEAN
                 SPECIFIC SN
                 DETERMINISTIC
                 CONTAINS SQL
                 STATIC DISPATCH
                 RETURN
                   ( TRUE AND
                     UDT1.SPECIFICTYPE = UDT2.SPECIFICTYPE AND
                     UDT1.C1 = UDT2.C1 AND
                     ...
                     UDT1.Cn = UDT2.Cn )


2) Case:
    a) If EQUALS is specified, then the ordering form in the user-defined type descriptor of UDT is set to
       EQUALS.
    b) Otherwise, the ordering form in the user-defined type descriptor of UDT is set to FULL.
3) Case:
    a) If RELATIVE is specified, then the ordering category in the user-defined type descriptor of UDT is
       set to RELATIVE.
    b) If MAP is specified, then the ordering category in the user-defined type descriptor of UDT is set to
       map.
    c) Otherwise, the ordering category in the user-defined type descriptor of UDT is set to STATE.
4) The <specific routine designator> identifying the ordering function, depending on the ordering category,
   in the descriptor of UDT is set to SRD.


Conformance Rules
1) Without Feature S251, “User-defined orderings”, conforming SQL shall not contain a <user-defined
   ordering definition>.
    NOTE 333 — If MAP is specified, then the Conformance Rules of Subclause 9.9, “Equality operations”, apply. If ORDER FULL
    BY MAP is specified, then the Conformance Rules of Subclause 9.12, “Ordering operations”, also apply.




©ISO/IEC 2003 – All rights reserved                                           Schema definition and manipulation 711
ISO/IEC 9075-2:2003 (E)
11.56 <drop user-defined ordering statement>



11.56 <drop user-defined ordering statement>

Function
Destroy a user-defined ordering method.


Format
<drop user-defined ordering statement> ::=
    DROP ORDERING FOR <schema-resolved user-defined type name> <drop behavior>


Syntax Rules
1) Let UDTN be the <schema-resolved user-defined type name>. Let UDT be the user-defined type identified
   by UDTN.
2) The descriptor of UDT shall include an ordering form that specifies EQUALS or FULL.
3) Let OF be the ordering function of UDT.
4) If RESTRICT is specified, then none of the following shall contain an operand of an equality operation,
   grouping operation or ordering operation whose declared type is some user-defined type T1 whose compar-
   ison type is UDT:
    a) The SQL routine body of any routine descriptor.
    b) The <query expression> of any view descriptor.
    c) The <search condition> of any constraint descriptor.
    d) The triggered action of any trigger descriptor.
    NOTE 334 — If CASCADE is specified, then such referencing objects will be dropped as specified in the General Rules of this
    Subclause.


Access Rules
1) The enabled authorization identifiers shall include the <authorization identifier> that owns the schema
   identified by the implicit or explicit <schema name> of UDTN.


General Rules
1) Let R be any SQL-invoked routine whose SQL routine body contains an operand of an equality operation,
   grouping operation, or ordering operation whose declared type is some user-defined type T1 whose com-
   parison type is UDT. Let SN be the specific name of R. The following <drop routine statement> is effectively
   executed without further Access Rule checking:
       DROP SPECIFIC ROUTINE SN CASCADE




712 Foundation (SQL/Foundation)                                                              ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                 11.56 <drop user-defined ordering statement>



2) Let V be any view whose <query expression> contains an operand of an equality operation, grouping
   operation, or ordering operation whose declared type is some user-defined type T1 whose comparison type
   is UDT. Let VN be the <table name> of V. The following <drop view statement> is effectively executed
   without further Access Rule checking:
        DROP VIEW VN CASCADE

3) Let T be any table whose table descriptor includes a constraint descriptor of a constraint C whose <search
   condition> contains an operand of an equality operation, grouping operation, or ordering operation whose
   declared type is some user-defined type T1 whose comparison type is UDT. Let TN be the <table name>
   of T . Let TCN be the <constraint name> of C . The following <alter table statement> is effectively executed
   without further Access Rule checking:
        ALTER TABLE TN DROP CONSTRAINT TCN CASCADE

4) Let A be any assertion whose <search condition> contains an operand of an equality operation, grouping
   operation, or ordering operation whose declared type is some user-defined type T1 whose comparison type
   is UDT. Let AN be the <constraint name> of A. The following <drop assertion statement> is effectively
   executed without further Access Rule checking:
        DROP ASSERTION AN CASCADE

5) Let D be any domain whose descriptor includes a constraint descriptor that includes an operand of an
   equality operation, grouping operation, or ordering operation whose declared type is some user-defined
   type T1 whose comparison type is UDT in the <search condition> of any constraint descriptor or in the
   <default option> included in the domain descriptor of D. Let DN be the <domain name> of D . The following
   <drop domain statement> is effectively executed without further Access Rule checking:
        DROP DOMAIN DN CASCADE

6) Let T be any trigger whose triggered action contains an operand of an equality operation, grouping operation,
   or ordering operation whose declared type is some user-defined type T1 whose comparison type is UDT.
   Let TN be the <trigger name> of T. The following <drop trigger statement> is effectively executed without
   further Access Rule checking:
        DROP TRIGGER TN

7) In the descriptor of UDT, the ordering form is set to NONE and the ordering category is set to STATE. No
   ordering function is included in the descriptor of UDT.


Conformance Rules
1) Without Feature S251, “User-defined orderings”, conforming SQL language shall not contain a <drop user-
   defined ordering statement>.




©ISO/IEC 2003 – All rights reserved                                   Schema definition and manipulation 713
ISO/IEC 9075-2:2003 (E)
11.57 <transform definition>



11.57 <transform definition>

Function
Define one or more transform functions for a user-defined type.


Format
<transform definition> ::=
    CREATE { TRANSFORM | TRANSFORMS } FOR
    <schema-resolved user-defined type name> <transform group>...

<transform group> ::=
    <group name> <left paren> <transform element list> <right paren>

<group name> ::= <identifier>

<transform element list> ::= <transform element> [ <comma> <transform element> ]

<transform element> ::=
    <to sql>
  | <from sql>

<to sql> ::= TO SQL WITH <to sql function>

<from sql> ::= FROM SQL WITH <from sql function>

<to sql function> ::= <specific routine designator>

<from sql function> ::= <specific routine designator>


Syntax Rules
1) Let TD be the <transform definition>. Let DTN be the <schema-resolved user-defined type name> imme-
   diately contained in TD. Let DT be the data type identified by DTN. Let SDT be the schema that includes
   the descriptor of DT. Let TRD be the transform descriptor included in the data type descriptor of DT.
2) No two <transform group>s immediately contained in TD shall have the same <group name>.
3) The SQL-invoked function identified by <to sql function> is called the to-sql function. The SQL-invoked
   function identified by <from sql function> is called the from-sql function.
4) Let n be the number of <transform group>s immediately contained in TD. For i ranging from 1 to n:
    a) Let TGi be the i-th <transform group> immediately contained in TD. Let GNi be the <group name>
       contained in TGi.

    b) Each of <to sql> and <from sql> immediately contained in TGi shall be contained at most once in a
       <transform element list>.
    c) The SQL-invoked routines identified by <to sql function> and <from sql function> shall be SQL-
       invoked functions that are deterministic and do not possibly modify SQL-data.


714 Foundation (SQL/Foundation)                                              ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                     11.57 <transform definition>



    d) TRD shall not include a transform group descriptor GD that includes a group name that is equivalent
       to GNi.

    e) Let SDTT be the set that includes every data type DTTj that is either a proper supertype or a proper
       subtype of DT such that the transform descriptor included in the data type descriptor of DTTj includes
       a group descriptor GDTj,k that includes a group name that is equivalent to GNi. SDTT shall be empty.

    f) If <to sql> is specified, then let TSFi be the SQL-invoked function identified by <to sql function>.

         i)       Case:
                  1) If TSFi is an SQL-invoked method, then TSFi shall have exactly two SQL parameters such
                     that the declared type of the first SQL parameter is DT and the declared type of the second
                     SQL parameter is a predefined data type. The result data type of TSFi shall be DT.

                  2) Otherwise, TSFi shall have exactly one SQL parameter whose declared type is a predefined
                     data type. The result data type of TSFi shall be DT.

         ii)      If DT is a structured type and TSFi is an SQL-invoked method, then TSFi shall be a type-preserv-
                  ing function.
    g) If <from sql> is specified, then let FSFi be the SQL-invoked function identified by <from sql function>.
       FSFi shall have exactly one SQL parameter whose declared type is DT. The result data type of FSFi
       shall be a predefined data type.
    h) If <to sql> and <from sql> are both specified, then
         Case:
         i)       If TSFi is an SQL-invoked method, then the result data type of FSFi and the data type of the
                  second SQL parameter of TSFi shall be compatible.

         ii)      Otherwise, the result data type of FSFi and the data type of the first SQL parameter of TSFi shall
                  be compatible.


Access Rules
1) For i ranging from 1 to n, the enabled authorization identifiers shall include the <authorization identifier>
   that owns SDT and the schema that includes the routine descriptors of TSFi, if any, and FSFi, if any.


General Rules
1) A <group name> specifies the group name that identifies a transform group.

2) For every TGi, 1 (one) ≤ i ≤ n:

    a) A new group descriptor GDi is created that includes the <group name> immediately contained in TGi.
       GDi is included in the list of transform group descriptors included in TRD.




©ISO/IEC 2003 – All rights reserved                                       Schema definition and manipulation 715
ISO/IEC 9075-2:2003 (E)
11.57 <transform definition>



   b) If <to sql> is specified, then the specific name of the to-sql function in GDi is set to TSFi.

   c) If <from sql> is specified, then the specific name of the from-sql function in GDi is set to FSFi.


Conformance Rules
1) Without Feature S241, “Transform functions”, conforming SQL language shall not contain a <transform
   definition>.




716 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                           11.58 <alter transform statement>



11.58 <alter transform statement>

Function
Change the definition of one or more transform groups.


Format
<alter transform statement> ::=
    ALTER { TRANSFORM | TRANSFORMS }
    FOR <schema-resolved user-defined type name> <alter group>...

<alter group> ::=
    <group name> <left paren> <alter transform action list> <right paren>

<alter transform action list> ::=
    <alter transform action> [ { <comma> <alter transform action> }... ]

<alter transform action> ::=
    <add transform element list>
  | <drop transform element list>


Syntax Rules
1) Let DN be the <schema-resolved user-defined type name> and let D be the data type identified by DN. The
   schema identified by the explicit or implicit schema name of DN shall include the data type descriptor of
   D. Let S be that schema. Let TD be the transform descriptor included in the data type descriptor of D.
2) The scope of DN is the entire <alter transform statement> AT.
3) Let n be the number of <group name>s contained in AT. For i ranging from 1 to n:
    a) Let GNi be the i-th <group name> contained in AT.

    b) For each GNi, there shall be a transform group descriptor included in TD whose group name is equivalent
       to GNi. Let GDi be this transform group descriptor.


Access Rules
1) The enabled authorization identifiers shall include the <authorization identifier> that owns S.


General Rules
1) For i ranging from 1 to n, GDi is modified as specified by <alter transform action list>.




©ISO/IEC 2003 – All rights reserved                                  Schema definition and manipulation 717
ISO/IEC 9075-2:2003 (E)
11.58 <alter transform statement>



Conformance Rules
1) Without Feature S242, “Alter transform statement”, conforming SQL language shall not contain an <alter
   transform statement>.




718 Foundation (SQL/Foundation)                                              ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                              11.59 <add transform element list>



11.59 <add transform element list>

Function
Add a transform element (<to sql> and/or <from sql>) to an existing transform group.


Format
<add transform element list> ::=
    ADD <left paren> <transform element list> <right paren>


Syntax Rules
1) Let AD be the <add transform element list>.
2) Let DN be the <schema-resolved user-defined type name> immediately contained in the containing <alter
   transform statement>. Let D be the user-defined type identified by DN. Let TD be the transform descriptor
   included in the data type descriptor of D.
3) Let GD be the transform group descriptor included in TD whose group name is equivalent to <group name>
   immediately contained in the containing <alter group>.
4) Each of <to sql> and <from sql> (immediately contained in AD) shall be contained at most once in the
   <transform element list>.
5) If GD includes a specific name of the to-sql function, then AD shall not contain <to sql>.
6) If GD includes a specific name of the from-sql function, then AD shall not contain <from sql>.
7) The SQL-invoked routine identified by either <to sql function> or <from sql function> shall be an SQL-
   invoked function that is deterministic and does not possibly modify SQL-data.
8) If <to sql> is specified, then let TSF be the SQL-invoked function identified by <to sql function>.
    a) Case:
         i)       If TSF is an SQL-invoked method, then TSF shall have exactly two SQL parameters such that
                  the declared type of the first SQL parameter is D and the declared type of the second SQL
                  parameter is a predefined data type. The result data type of TSF shall be D.
         ii)      Otherwise, TSF shall have exactly one SQL parameter whose declared type is a predefined data
                  type. The result data type of TSF shall be D.
    b) If D is a structured type, then TSF shall be a type-preserving function.
    c) If GD includes the specific name of a from-sql function, then let FS be the SQL-invoked function that
       is identified by this specific name.
         Case:
         i)       If TSF is an SQL-invoked method, then the result data type of FS and the data type of the second
                  SQL parameter of TSF shall be compatible.


©ISO/IEC 2003 – All rights reserved                                     Schema definition and manipulation 719
ISO/IEC 9075-2:2003 (E)
11.59 <add transform element list>



        ii)     Otherwise, the result data type of FS and the data type of the first SQL parameter of TSF shall
                be compatible.
9) If <from sql> is specified, then let FSF be the SQL-invoked function identified by <from sql function>.
    a) FSF shall have exactly one SQL parameter whose declared type is D. The result data type of FSF shall
       be a predefined data type.
    b) If GD includes the specific name of a to-sql function, then let TS be the SQL-invoked routine that is
       identified by this specific name.
        Case:
        i)      If TS is an SQL-invoked method, then the result data type of FSF and the data type of the second
                SQL parameter of TS shall be compatible.
        ii)     Otherwise, the result data type of FSF and the data type of the first SQL parameter of TS shall
                be compatible.


Access Rules
1) The enabled authorization identifiers shall include the <authorization identifier> that owns the schema that
   includes the routine descriptors of TSF, if any, and FSF, if any.


General Rules
1) If <to sql> is specified, then the specific name of the to-sql function in GD is set to TSF.
2) If <from sql> is specified, then the specific name of the from-sql function in GD is set to FSF.


Conformance Rules
    None.




720 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                           11.60 <drop transform element list>



11.60 <drop transform element list>

Function
Remove a transform element (<to sql> and/or <from sql>) from a transform group.


Format
<drop transform element list> ::=
    DROP <left paren> <transform kind>
    [ <comma> <transform kind> ] <drop behavior> <right paren>

<transform kind> ::=
    TO SQL
  | FROM SQL


Syntax Rules
1) Let DN be the <schema-resolved user-defined type name> immediately contained in the containing <alter
   transform statement>. Let D be the user-defined type identified by DN. Let TD be the transform descriptor
   included in the data type descriptor of D.
2) Let GD be the transform group descriptor included in TD whose group name is equivalent to <group name>
   immediately contained in the containing <alter group>.
3) Each of TO SQL and FROM SQL shall only be specified at most once in the <drop transform element
   list>.
4) If TO SQL is specified then GD shall include the specific name of a to-sql function. Let this function be
   TSF.
5) If FROM SQL is specified then GD shall include the specific name of a from-sql function. Let this function
   be FSF.
6) If RESTRICT is specified, then:
    a) If TO SQL is specified, then there shall be no external routine that has an SQL parameter whose asso-
       ciated to-sql function is TSF nor shall there be an external function that has TSF as the to-sql function
       associated with the result.
    b) If FROM SQL is specified, then there shall be no external routine that has an SQL parameter whose
       associated from-sql function is FSF.


Access Rules
    None.




©ISO/IEC 2003 – All rights reserved                                   Schema definition and manipulation 721
ISO/IEC 9075-2:2003 (E)
11.60 <drop transform element list>



General Rules
1) If FROM SQL is specified, then:
   a) Let FSN be the <specific name> of any external routine that has an SQL parameter whose associated
      from-sql function is FSF. The following <drop routine statement> is effectively executed without further
      Access Rule checking:
           DROP SPECIFIC ROUTINE FSN CASCADE

   b) The specific name of the from-sql function is removed from GD.
2) If TO SQL is specified, then:
   a) Let TSN be the <specific name> of any external routine that has an SQL parameter whose associated
      to-sql function is TSF. The following <drop routine statement> is effectively executed without further
      Access Rule checking:
           DROP SPECIFIC ROUTINE TSN CASCADE

   b) Let RSN be the <specific name> of any external function that has TSF as the to-sql function associated
      with the result. The following <drop routine statement> is effectively executed without further Access
      Rule checking:
           DROP SPECIFIC ROUTINE RSN CASCADE

   c) The specific name of the to-sql function is removed from GD.


Conformance Rules
   None.




722 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                                11.61 <drop transform statement>



11.61 <drop transform statement>

Function
Remove one or more transform functions associated with a transform.


Format
<drop transform statement> ::=
    DROP { TRANSFORM | TRANSFORMS } <transforms to be dropped>
    FOR <schema-resolved user-defined type name> <drop behavior>

<transforms to be dropped> ::=
    ALL
  | <transform group element>

<transform group element> ::= <group name>


Syntax Rules
1) Let DT be the data type identified by <schema-resolved user-defined type name>. Let SDT be the schema
   that includes the descriptor of DT. Let TRD be the transform descriptor included in the data type descriptor
   of DT. Let n be the number of transform group descriptors in TRD.
2) If <transform group element> is specified, then TRD shall include a transform group descriptor GD that
   includes a group name that is equivalent to the <group name> immediately contained in <transform group
   element>.
3) If RESTRICT is specified, then
    Case:
    a) If ALL is specified, then for i ranging from 1 (one) to n:
         i)       Let GDi be the i-th transform group descriptor included in TRD.

         ii)      If GDi includes the specific name of a from-sql function FSFi then there shall be no external
                  routine that has an SQL parameter whose associated from-sql function is FSFi.

         iii)     If GDi includes the specific name of a to-sql function TSFi then there shall be no external routine
                  that has an SQL parameter whose associated to-sql function is TSFi nor shall there be an external
                  function that has TSFi as the to-sql function associated with the result.

    b) Otherwise:
         i)       If GD includes the specific name of a from-sql function FSF then there shall be no external
                  routine that has an SQL parameter whose associated from-sql function is FSF.
         ii)      If GD includes the specific name of a to-sql function TSF then there shall be no external routine
                  that has an SQL parameter whose associated to-sql function is TSF nor shall there be an external
                  function that has TSF as the to-sql function associated with the result.


©ISO/IEC 2003 – All rights reserved                                       Schema definition and manipulation 723
ISO/IEC 9075-2:2003 (E)
11.61 <drop transform statement>



Access Rules
1) The enabled authorization identifiers shall include the <authorization identifier> that owns SDT.


General Rules
1) Case:
    a) If ALL is specified, then, for i ranging from 1 (one) to n:
        i)     Let GDi be the i-th transform group descriptor included in TRD.

        ii)    If GDi includes the specific name of a from-sql function FSFi, then let FSN be the <specific
               name> of any external routine that has an SQL parameter whose associated from-sql function
               is FSFi. The following <drop routine statement> is effectively executed without further Access
               Rule checking:
                 DROP SPECIFIC ROUTINE FSN CASCADE

        iii)   If GDi includes the specific name of a to-sql function TSFi, then:

               1) Let TSN be the <specific name> of any external routine that has an SQL parameter whose
                  associated to-sql function is TSFi. The following <drop routine statement> is effectively
                  executed without further Access Rule checking:
                      DROP SPECIFIC ROUTINE TSN CASCADE

               2) Let RSN be the <specific name> of any external function that has TSFi as the to-sql function
                  associated with the result. The following <drop routine statement> is effectively executed
                  without further Access Rule checking:
                      DROP SPECIFIC ROUTINE RSN CASCADE

        iv)    GDi is removed from TRD.

    b) Otherwise:
        i)     If GD includes the specific name of a from-sql function FSF, then let FSN be the <specific
               name> of any external routine that has an SQL parameter whose associated from-sql function
               is FSF. The following <drop routine statement> is effectively executed without further Access
               Rule checking:
                 DROP SPECIFIC ROUTINE FSN CASCADE

        ii)    If GD includes the specific name of a to-sql function TSF, then:
               1) Let TSN be the <specific name> of any external routine that has an SQL parameter whose
                  associated to-sql function is TSF. The following <drop routine statement> is effectively
                  executed without further Access Rule checking:
                      DROP SPECIFIC ROUTINE TSN CASCADE


724 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                             11.61 <drop transform statement>



                  2) Let RSN be the <specific name> of any external function that has TSF as the to-sql function
                     associated with the result. The following <drop routine statement> is effectively executed
                     without further Access Rule checking:
                          DROP SPECIFIC ROUTINE RSN CASCADE

         iii)     GD is removed from TRD.


Conformance Rules
1) Without Feature S241, “Transform functions”, conforming SQL language shall not contain a <drop transform
   statement>.




©ISO/IEC 2003 – All rights reserved                                    Schema definition and manipulation 725
ISO/IEC 9075-2:2003 (E)
11.62 <sequence generator definition>



11.62 <sequence generator definition>

Function
Define an external sequence generator.


Format
<sequence generator definition> ::=
    CREATE SEQUENCE <sequence generator name> [ <sequence generator options> ]

<sequence generator options> ::= <sequence generator option> ...

<sequence generator option> ::=
    <sequence generator data type option>
  | <common sequence generator options>

<common sequence generator options> ::= <common sequence generator option> ...

<common sequence generator option> ::=
    <sequence generator start with option>
  | <basic sequence generator option>

<basic sequence generator option> ::=
    <sequence generator increment by option>
  | <sequence generator maxvalue option>
  | <sequence generator minvalue option>
  | <sequence generator cycle option>

<sequence generator data type option> ::= AS <data type>

<sequence generator start with option> ::= START WITH <sequence generator start value>

<sequence generator start value> ::= <signed numeric literal>

<sequence generator increment by option> ::= INCREMENT BY <sequence generator increment>

<sequence generator increment> ::= <signed numeric literal>

<sequence generator maxvalue option> ::=
    MAXVALUE <sequence generator max value>
  | NO MAXVALUE

<sequence generator max value> ::= <signed numeric literal>

<sequence generator minvalue option> ::=
    MINVALUE <sequence generator min value>
  | NO MINVALUE

<sequence generator min value> ::= <signed numeric literal>

<sequence generator cycle option> ::=
    CYCLE
  | NO CYCLE




726 Foundation (SQL/Foundation)                                    ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                          11.62 <sequence generator definition>



Syntax Rules
1) Let SEQ be the sequence generator defined by the <sequence generator definition> SEQD.
2) If SEQD is contained in a <schema definition> SD and the <sequence generator name> SQN contains a
   <schema name>, then that <schema name> shall be equivalent to the implicit or explicit <schema name>
   of SD.
3) The schema identified by the explicit or implicit schema name of SQN shall not include a sequence gener-
   ator descriptor whose sequence generator name is equivalent to SQN.
4) If SEQD is contained in a <schema definition>, then let A be the explicit or implicit <authorization identifier>
   of the <schema definition>. Otherwise, let A be the <authorization identifier> that owns the schema identified
   by the implicit or explicit <schema name> of SQN.
5) Each of <sequence generator data type option>, <sequence generator start with option>, <sequence gener-
   ator increment by option>, <sequence generator maxvalue option>, <sequence generator minvalue option>,
   and <sequence generator cycle option> shall be specified at most once.
6) If <sequence generator data type option> is specified, then <data type> shall be an exact numeric type DT
   with scale 0 (zero); otherwise, let DT be an implementation-defined exact numeric type with scale 0 (zero).
7) The Syntax Rules of Subclause 9.22, “Creation of a sequence generator”, are applied with <common
   sequence generator options> as OPTIONS and DT as DATA TYPE.


Access Rules
1) If a <sequence generator definition> is contained in an <SQL-client module definition>, then the enabled
   authorization identifiers shall include A.


General Rules
1) The General Rules of Subclause 9.22, “Creation of a sequence generator”, are applied with <common
   sequence generator options> as OPTIONS and DT as DATA TYPE, yielding a sequence generator descriptor
   SEQDS. The sequence generator name included in SEQDS is set to SQN.
2) A privilege descriptor is created that defines the USAGE privilege on SEQ to A. This privilege is grantable.
   The grantor for this privilege descriptor is set to the special grantor value “_SYSTEM”.


Conformance Rules
1) Without Feature T176, “Sequence generator support”, conforming SQL language shall not contain a
   <sequence generator definition>.




©ISO/IEC 2003 – All rights reserved                                     Schema definition and manipulation 727
ISO/IEC 9075-2:2003 (E)
11.63 <alter sequence generator statement>



11.63 <alter sequence generator statement>

Function
Change the definition of an external sequence generator.


Format
<alter sequence generator statement> ::=
    ALTER SEQUENCE <sequence generator name> <alter sequence generator options>

<alter sequence generator options> ::= <alter sequence generator option>...

<alter sequence generator option> ::=
    <alter sequence generator restart option>
  | <basic sequence generator option>

<alter sequence generator restart option> ::=
    RESTART WITH <sequence generator restart value>

<sequence generator restart value> ::= <signed numeric literal>


Syntax Rules
1) Let SEQ be the sequence generator descriptor identified by the <sequence generator name> SQN. Let DT
   be the data type of SEQ.
2) The schema identified by the explicit or implicit schema name of SQN shall include SEQ.
3) The scope of SQN is the <alter sequence generator statement>.
4) The Syntax Rules of Subclause 9.23, “Altering a sequence generator”, are applied with <alter sequence
   generator options> as OPTIONS and SEQ as SEQUENCE.


Access Rules
1) The enabled authorization identifiers shall include the <authorization identifier> that owns the schema
   identified by the explicit or implicit schema name of SQN.


General Rules
1) The General Rules of Subclause 9.23, “Altering a sequence generator”, are applied with <alter sequence
   generator options> as OPTIONS and SEQ as SEQUENCE.


Conformance Rules
1) Without Feature T176, “Sequence generator support”, conforming SQL language shall not contain an <alter
   sequence generator statement>.


728 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                              ISO/IEC 9075-2:2003 (E)
                                                                            11.63 <alter sequence generator statement>



11.64 <drop sequence generator statement>

Function
Destroy an external sequence generator.


Format
<drop sequence generator statement> ::=
    DROP SEQUENCE <sequence generator name> <drop behavior>


Syntax Rules
1) Let SEQ be the sequence generator identified by the <sequence generator name> SQN.
2) The schema identified by the explicit or implicit schema name of SQN shall include the descriptor of SEQ.
3) If RESTRICT is specified, then SEQ shall not be referenced in any of the following:
    a) The SQL routine body of any routine descriptor.
    b) The trigger action of any trigger descriptor.
    NOTE 335 — If CASCADE is specified, then such referenced objects will be dropped by the execution of the <revoke statement>
    specified in the General Rules of this Subclause.

4) Let A be the <authorization identifier> that owns the schema identified by the <schema name> of the
   sequence generator identified by SQN.


Access Rules
1) The enabled authorization identifiers shall include A.


General Rules
1) The following <revoke statement> is effectively executed with a current authorization identifier of
   “_SYSTEM” and without further Access Rule checking:
    REVOKE USAGE ON SEQUENCE SQN FROM A CASCADE

2) The descriptor of SEQ is destroyed.


Conformance Rules
1) Without Feature T176, “Sequence generator support”, conforming SQL language shall not contain a <drop
   sequence generator statement>.




©ISO/IEC 2003 – All rights reserved                                            Schema definition and manipulation 729
ISO/IEC 9075-2:2003 (E)




                                  This page intentionally left blank.




730 Foundation (SQL/Foundation)                                         ©ISO/IEC 2003 – All rights reserved
                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                                    12.1 <grant statement>




12 Access control


12.1 <grant statement>

Function
Define privileges and role authorizations.


Format
<grant statement> ::=
    <grant privilege statement>
  | <grant role statement>


Syntax Rules
    None.


Access Rules
    None.


General Rules
1) For every involved grantee G and for every domain D1 owned by G, if all of the following are true:
    a) The applicable privileges for G include the grantable REFERENCES privilege on every column refer-
       enced in the <search condition> SC included in a domain constraint descriptor included in the domain
       descriptor of D1.
    b) The applicable privileges for G include the grantable EXECUTE privileges on all SQL-invoked routines
       that are subject routines of <routine invocation>s contained in SC.
    c) The applicable privileges for G include the grantable SELECT privilege on every table T1 and every
       method M such that there is a <method reference> MR contained in SC such that T1 is in the scope of
       the <value expression primary> of MR and M is the method identified by the <method name> of MR
       included in a domain constraint descriptor included in the domain descriptor of D1.
    d) The applicable privileges for G include the grantable SELECT privilege WITH HIERARCHY OPTION
       on at least one supertable of the scoped table of every <reference resolution> contained in SC.




©ISO/IEC 2003 – All rights reserved                                                     Access control 731
ISO/IEC 9075-2:2003 (E)
12.1 <grant statement>



    e) The applicable privileges for G include the grantable USAGE privilege on all domains, character sets,
       collations, and transliterations whose <domain name>s, <character set name>s, <collation name>s,
       and <transliteration name>s, respectively, are included in the domain descriptor of D1.
    then for every privilege descriptor with <action> USAGE, a grantor of “_SYSTEM”, object D1, and grantee
    G that is not grantable, the following <grant statement> is effectively executed with a current user identifier
    of “_SYSTEM” and without further Access Rule checking:
      GRANT USAGE ON DOMAIN D1 TO G WITH GRANT OPTION

2) For every involved grantee G and for every collation C1 owned by G, if the applicable privileges for G
   include a grantable USAGE privilege for the character set name included in the collation descriptor of C1
   and a grantable USAGE privilege for the transliteration name, if any, included in the collation descriptor
   of C1, then for every privilege descriptor with <action> USAGE, a grantor of “_SYSTEM”, object of C1,
   and grantee G that is not grantable, the following <grant statement> is effectively executed with a current
   user identifier of “_SYSTEM” and without further Access Rule checking:
      GRANT USAGE ON COLLATION C1 TO G WITH GRANT OPTION

3) For every involved grantee G and for every transliteration T1 owned by G, if the applicable privileges for
   G contain a grantable USAGE privilege for every character set identified by a <character set specification>
   contained in the <transliteration definition> of T1, then for every privilege descriptor with <action> P, a
   grantor of “_SYSTEM”, object of T1, and grantee G that is not grantable, the following <grant statement>
   is effectively executed as though the current user identifier were “_SYSTEM” and without further Access
   Rule checking:
      GRANT P ON TRANSLATION T1 TO G WITH GRANT OPTION

4) For every table T specified by some involved privilege descriptor and for each view V owned by some
   involved grantee G such that T or some column CT of T is referenced in the <query expression> QE of V,
   or T is a supertable of the scoped table of a <reference resolution> contained in QE, let RTi, for i ranging
   from 1 (one) to the number of tables identified by the <table reference>s contained in QE, be the <table
   name>s of those tables. For every column CV of V:
    a) Let CRTi,j, for j ranging from 1 (one) to the number of columns of RTi that are underlying columns of
       CV, be the <column name>s of those columns.
    b) If, following successful execution of the <grant statement>, all of the following are true:
        i)     The applicable privileges for G include grantable SELECT privileges on all of the columns
               CRTi,j.

        ii)    The applicable privileges for G include grantable EXECUTE privileges on all SQL-invoked
               routines that are subject routines of <routine invocation>s contained in QE.
        iii)   The applicable privileges for G include grantable SELECT privilege on every table T1 and every
               method M such that there is a <method reference>. MR contained in QE such that T1 is in the
               scope of the <value expression primary> of MR and M is the method identified by the <method
               name> of MR.




732 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                         12.1 <grant statement>



         iv)      The applicable privileges for G include grantable SELECT privilege WITH HIERARCHY
                  OPTION on at least one supertable of the scoped table of every <reference resolution> that is
                  contained in QE.
         then the following <grant statement> is effectively executed as though the current user identifier were
         “_SYSTEM” and without further Access Rule checking:
               GRANT SELECT (CV) ON V TO G WITH GRANT OPTION

    c) If, following successful execution of the <grant statement>, the applicable privileges for G will include
       REFERENCES(CRTi,j) for all i and for all j, and will include a REFERENCES privilege on some
       column of RTi for all i, then:

         i)       Case:
                  1) If all of the following are true, then let WGO be “WITH GRANT OPTION”.
                      A) The applicable privileges for G will include grantable REFERENCES(CRTi,j) for all i
                         and for all j, and will include a grantable REFERENCES privilege on some column of
                         RTi for all i.

                      B) The applicable privileges for G include grantable EXECUTE privileges on all SQL-
                         invoked routines that are subject routines of <routine invocation>s contained in QE.
                      C) The applicable privileges for G include grantable SELECT privilege on every table T1
                         and every method M such that there is a <method reference>. MR contained in QE such
                         that T1 is in the scope of the <value expression primary> of MR and M is the method
                         identified by the <method name> of MR.
                      D) The applicable privileges for G include grantable SELECT privilege WITH HIERAR-
                         CHY OPTION on at least one supertable of the scoped table of every <reference reso-
                         lution> that is contained in QE.
                  2) Otherwise, let WGO be a zero-length string.
         ii)      The following <grant statement> is effectively executed as though the current user identifier
                  were “_SYSTEM” and without further Access Rule checking:
                     GRANT REFERENCES (CV) ON V TO G WGO

    d) If, following successful execution of the <grant statement>, the applicable privileges for G include
       grantable SELECT privilege on every column of V, then the following <grant statement> is effectively
       executed as though the current user identifier were “_SYSTEM” and without further Access Rule
       checking:
               GRANT SELECT ON V TO G WITH GRANT OPTION

    e) Following successful execution of the <grant statement>,
         Case:
         i)       If the applicable privileges for G include REFERENCES privilege on every column of V, then
                  let WGO be a zero-length string.


©ISO/IEC 2003 – All rights reserved                                                          Access control 733
ISO/IEC 9075-2:2003 (E)
12.1 <grant statement>



        ii)     If the applicable privileges for G include grantable REFERENCES privilege on every column
                of V, then let WGO be “WITH GRANT OPTION”.
        iii)    The following <grant statement> is effectively executed as though the current user identifier
                were “_SYSTEM” and without further Access Rule checking:
                  GRANT REFERENCES ON V TO G WITH GRANT OPTION

5) Following the successful execution of the <grant statement>, for every table T specified by some involved
   privilege descriptor and for every effectively updatable view V owned by some grantee G such that T is
   some leaf underlying table of the <query expression> of V:
    a) Let VN be the <table name> of V.
    b) If QE is fully updatable with respect to T, and the applicable privileges for G include PA, where PA is
       either INSERT, UPDATE, or DELETE, then the following <grant statement> is effectively executed
       as though the current user identifier were “_SYSTEM” and without further Access Rule checking:
              GRANT PA ON VN TO G

    c) If QE is fully updatable with respect to T, and the applicable privileges for G include grantable PA
       privilege on T, where PA is either INSERT, UPDATE, or DELETE, then the following <grant statement>
       is effectively executed as though the current user identifier were “_SYSTEM” and without further
       Access Rule checking:
              GRANT PA ON VN TO G WITH GRANT OPTION

    d) For each column CV of V, named CVN, that has a counterpart CT in T, named CTN, if QE is fully or
       partially updatable with respect to T, and the applicable privileges for G include PA(CTN) privilege
       on T, where PA is INSERT or UPDATE, then the following <grant statement> is effectively executed
       as though the current user identifier were “_SYSTEM” and without further Access Rule checking:
              GRANT PA(CVN) ON VN TO G

    e) For each column CV of V, named CVN, that has a counterpart CT in T, named CTN, if QE is fully or
       partially updatable with respect to T, and the applicable privileges for G include grantable PA(CTN)
       privilege on T, where PA is INSERT or UPDATE, then the following <grant statement> is effectively
       executed as though the current user identifier were “_SYSTEM” and without further Access Rule
       checking:
              GRANT PA(CVN) ON VN TO G WITH GRANT OPTION

6) For every involved grantee G and for every referenceable view V, named VN, owned by G, if following
   the successful execution of the <grant statement>, the applicable privileges for G include grantable UNDER
   privilege on the direct supertable of V, then the following <grant statement> is effectively executed with
   a current authorization identifier of “_SYSTEM” and without further Access Rule checking:
      GRANT UNDER ON VN TO G WITH GRANT OPTION

7) For every involved grantee G and for every schema-level SQL-invoked routine R1 owned by G, if the
   applicable privileges for G contain all of the privileges necessary to successfully execute every <SQL
   procedure statement> contained in the <routine body> of R1 are grantable, then for every privilege


734 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                                ISO/IEC 9075-2:2003 (E)
                                                                                                 12.1 <grant statement>



    descriptor with <action> EXECUTE, a grantor of “_SYSTEM”, object of R1, and grantee G that is not
    grantable, the following <grant statement> is effectively executed with a current authorization identifier
    of “_SYSTEM” and without further Access Rule checking:
        GRANT EXECUTE ON R1 TO G WITH GRANT OPTION
    NOTE 336 — The privileges necessary include the EXECUTE privilege on every subject routine of every <routine invocation>
    contained in the <SQL procedure statement>.

8) If two privilege descriptors are identical except that one indicates that the privilege is grantable and the
   other indicates that the privilege is not grantable, then both privilege descriptors are set to indicate that the
   privilege is grantable.
9) If two privilege descriptors are identical except that one indicates WITH HIERARCHY OPTION and the
   other does not, then both privilege descriptors are set to indicate that the privilege has the WITH HIERAR-
   CHY OPTION.
10) Redundant duplicate privilege descriptors are removed from the collection of all privilege descriptors.


Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved                                                                   Access control 735
ISO/IEC 9075-2:2003 (E)
12.2 <grant privilege statement>



12.2 <grant privilege statement>

Function
Define privileges.


Format
<grant privilege statement> ::=
    GRANT <privileges> TO <grantee> [ { <comma> <grantee> }... ]
    [ WITH HIERARCHY OPTION ]
    [ WITH GRANT OPTION ]
    [ GRANTED BY <grantor> ]


Syntax Rules
1) Let O be the object identified by the <object name> contained in <privileges>.
2) Let U be the current user identifier and let R be the current role name.
3) Case:
    a) If GRANTED BY <grantor> is not specified, then
        Case:
        i)      If U is not the null value, then let A be U.
        ii)     Otherwise, let A be R.
    b) If GRANTED BY CURRENT_USER is specified, then let A be U.
    c) If GRANTED BY CURRENT_ROLE is specified, then let A be R.
4) A set of privilege descriptors is identified. The privilege descriptors identified are those defining, for each
   <action> explicitly or implicitly in <privileges>, that <action> on O held by A with grant option.
5) The schema identified by the explicit or implicit qualifier of the <object name> shall include the descriptor
   of O.
6) If WITH HIERARCHY OPTION is specified, then:
    a) <privileges> shall specify an <action> of SELECT without a <privilege column list> and without a
       <privilege method list>.
    b) O shall be a table of a structured type.


Access Rules
1) The applicable privileges shall include a privilege identifying O.




736 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                               12.2 <grant privilege statement>



General Rules
1) The <object privileges> specify one or more privileges on the object identified by the <object name>.
2) For every identified privilege descriptor IPD, a privilege descriptor is created for each <grantee>, that
   specifies grantee <grantee>, action <action>, object O, and grantor A. Let CPD be the set of privilege
   descriptors created.
3) For every privilege descriptor in CPD whose action is INSERT, UPDATE, or REFERENCES without a
   column name, privilege descriptors are also created and added to CPD for each column C in O for which
   A holds the corresponding privilege with grant option. For each such column, a privilege descriptor is created
   that specifies the identical <grantee>, the identical <action>, object C, and grantor A.
4) For every privilege descriptor in CPD whose action is SELECT without a column name or method name,
   privilege descriptors are also created and added to CPD for each column C in O for which A holds the
   corresponding privilege with grant option. For each such column, a privilege descriptor is created that
   specifies the identical <grantee>, the identical <action>, object C, and grantor A.
5) For every privilege descriptor in CPD whose action is SELECT without a column name or method name,
   if the table T identified by the object of the privilege descriptor is a table of a structured type TY, then
   table/method privilege descriptors are also created and added to CPD for each method M of TY for which
   A holds the corresponding privilege with grant option. For each such method, a table/method privilege
   descriptor is created that specifies the identical <grantee>, the identical <action>, object consisting of the
   pair of table T and method M, and grantor A.
6) If WITH GRANT OPTION was specified, then each privilege descriptor also indicates that the privilege
   is grantable.
7) Let SWH be the set of privilege descriptors in CPD whose action is SELECT WITH HIERARCHY OPTION.
   Let ST be the set of subtables of O. For every table T in ST and for every privilege descriptor in SWH grantee
   G, and grantor A,
    Case:
    a) If the privilege is grantable, then let WG be “WITH GRANT OPTION”.
    b) Otherwise, let WGO be the zero-length string.
    The following <grant statement> is effectively executed without further Access Rule checking:
        GRANT SELECT ON T TO G WGO GRANTED BY A

8) For every combination of <grantee> and <action> on O specified in <privileges>, if there is no corresponding
   privilege descriptor in CPD, then a completion condition is raised: warning — privilege not granted.
9) If ALL PRIVILEGES was specified, then for each grantee G, if there is no privilege descriptor in CPD
   specifying grantee G, then a completion condition is raised: warning — privilege not granted.
10) The set of involved privilege descriptors is defined to be CPD.
11) The set of involved grantees is defined as the set of specified <grantee>s.




©ISO/IEC 2003 – All rights reserved                                                          Access control 737
ISO/IEC 9075-2:2003 (E)
12.2 <grant privilege statement>



Conformance Rules
1) Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain a <specific
   routine designator> contained in a <grant privilege statement> that identifies a method.
2) Without Feature S081, “Subtables”, conforming SQL language shall not contain a <grant privilege statement>
   that contains WITH HIERARCHY OPTION.




738 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                        ISO/IEC 9075-2:2003 (E)
                                                                              12.3 <privileges>



12.3 <privileges>

Function
Specify privileges.


Format
<privileges> ::= <object privileges> ON <object name>

<object name> ::=
    [ TABLE ] <table name>
  | DOMAIN <domain name>
  | COLLATION <collation name>
  | CHARACTER SET <character set name>
  | TRANSLATION <transliteration name>
  | TYPE <schema-resolved user-defined type name>
  | SEQUENCE <sequence generator name>
  | <specific routine designator>

<object privileges> ::=
    ALL PRIVILEGES
  | <action> [ { <comma> <action> }... ]

<action> ::=
    SELECT
  | SELECT <left paren> <privilege column list> <right paren>
  | SELECT <left paren> <privilege method list> <right paren>
  | DELETE
  | INSERT [ <left paren> <privilege column list> <right paren> ]
  | UPDATE [ <left paren> <privilege column list> <right paren> ]
  | REFERENCES [ <left paren> <privilege column list> <right paren> ]
  | USAGE
  | TRIGGER
  | UNDER
  | EXECUTE

<privilege method list> ::=
    <specific routine designator> [ { <comma> <specific routine designator> }... ]

<privilege column list> ::= <column name list>

<grantee> ::=
    PUBLIC
  | <authorization identifier>

<grantor> ::=
    CURRENT_USER
  | CURRENT_ROLE




©ISO/IEC 2003 – All rights reserved                                          Access control 739
ISO/IEC 9075-2:2003 (E)
12.3 <privileges>



Syntax Rules
1) ALL PRIVILEGES is equivalent to the specification of all of the privileges on <object name> for which
   the <grantor> has grantable privilege descriptors.
2) If the <object name> of the <grant statement> or <revoke statement> specifying <privileges> specifies
   <table name>, then let T be the table identified by that <table name>. T shall not be a declared local temporary
   table.
3) If <object name> specifies a <domain name>, <collation name>, <character set name>, <transliteration
   name>, <schema-resolved user-defined type name>, or <sequence generator name>, then <privileges>
   may specify USAGE. Otherwise, USAGE shall not be specified.
4) If <object name> specifies a <table name> that identifies a base table, then <privileges> may specify
   TRIGGER; otherwise, TRIGGER shall not be specified.
5) If <object name> specifies a <schema-resolved user-defined type name> that identifies a structured type
   or specifies a <table name>, then <privileges> may specify UNDER; otherwise, UNDER shall not be
   specified.
6) If T is a temporary table, then <privileges> shall specify ALL PRIVILEGES.
7) If the object identified by <object name> of the <grant statement> or <revoke statement> is an SQL-invoked
   routine, then <privileges> may specify EXECUTE; otherwise, EXECUTE shall not be specified.
8) The <object privileges> specify one or more privileges on the object identified by <object name>.
9) Each <column name> in a <privilege column list> shall identify a column of T.
10) If <privilege method list> is specified, then <object name> shall specify a <table name> that identifies a
    table of a structured type TY and each <specific routine designator> in the <privilege method list> shall
    identify a method of TY.
11) UPDATE (<privilege column list>) is equivalent to the specification of UPDATE (<column name>) for
    each <column name> in <privilege column list>. INSERT (<privilege column list>) is equivalent to the
    specification of INSERT (<column name>) for each <column name> in <privilege column list>. REFER-
    ENCES (<privilege column list>) is equivalent to the specification of REFERENCES (<column name>)
    for each <column name> in <privilege column list>. SELECT (<privilege column list>) is equivalent to
    the specification of SELECT (<column name>) for each <column name> in <privilege column list>.
    SELECT (<privilege method list>) is equivalent to the specification of SELECT (<specific routine desig-
    nator>) for each <specific routine designator> in <privilege method list>.


Access Rules
    None.


General Rules
1) Case:
    a) If a <grantor> of CURRENT_USER is specified and there is no current user identifier, then an exception
       condition is raised: invalid grantor.


740 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                                          12.3 <privileges>



    b) If a <grantor> of CURRENT_ROLE is specified and there is no current role, then an exception condition
       is raised: invalid grantor.
2) A <grantee> of PUBLIC denotes at all times a list of <grantee>s containing all of the <authorization iden-
   tifier>s in the SQL-environment.
3) SELECT (<column name>) specifies the SELECT privilege on the indicated column and implies one or
   more column privilege descriptors.
4) SELECT (<specific routine designator>) specifies the SELECT privilege on the indicated method for the
   table identified by <object name> and implies one or more table/method privilege descriptors.
5) SELECT with neither <privilege column list> nor <privilege method list> specifies the SELECT privilege
   on all columns of T including any columns subsequently added to T and implies a table privilege descriptor
   and one or more column privilege descriptors. If T is a table of a structured type TY, then SELECT also
   specifies the SELECT privilege on all methods of the type TY, including any methods subsequently added
   to the type TY, and implies one or more table/method privilege descriptors.
6) UPDATE (<column name>) specifies the UPDATE privilege on the indicated column and implies one or
   more column privilege descriptors. If the <privilege column list> is omitted, then UPDATE specifies the
   UPDATE privilege on all columns of T, including any column subsequently added to T and implies a table
   privilege descriptor and one or more column privilege descriptors.
7) INSERT (<column name>) specifies the INSERT privilege on the indicated column and implies one or
   more column privilege descriptors. If the <privilege column list> is omitted, then INSERT specifies the
   INSERT privilege on all columns of T, including any column subsequently added to T and implies a table
   privilege descriptor and one or more column privilege descriptors.
8) REFERENCES (<column name>) specifies the REFERENCES privilege on the indicated column and
   implies one or more column privilege descriptors. If the <privilege column list> is omitted, then REFER-
   ENCES specifies the REFERENCES privilege on all columns of T, including any column subsequently
   added to T and implies a table privilege descriptor and one or more column privilege descriptors.
9) B has the WITH ADMIN OPTION on a role if a role authorization descriptor identifies the role as granted
   to B WITH ADMIN OPTION or a role authorization descriptor identifies it as granted WITH ADMIN
   OPTION to another applicable role for B.


Conformance Rules
1) Without Feature T332, “Extended roles”, conforming SQL language shall not contain a <grantor>.
2) Without Feature T211, “Basic trigger capability”, conforming SQL language shall not contain an <action>
   that contains TRIGGER.
3) Without Feature S081, “Subtables”, conforming SQL language shall not contain a <privileges> that contains
   an <action> that contains UNDER and that contains an <object name> that contains a <table name>.
4) Without Feature S023, “Basic structured types”, conforming SQL language shall not contain a <privileges>
   that contains an <action> that contains UNDER and that contains an <object name> that contains a <schema-
   resolved user-defined type name> that identifies a structured type.




©ISO/IEC 2003 – All rights reserved                                                       Access control 741
ISO/IEC 9075-2:2003 (E)
12.3 <privileges>



5) Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain a <privi-
   leges> that contains an <action> that contains USAGE and that contains an <object name> that contains a
   <schema-resolved user-defined type name> that identifies a structured type.
6) Without Feature T281, “SELECT privilege with column granularity”, in conforming SQL language, an
   <action> that contains SELECT shall not contain a <privilege column list>.
7) Without Feature F731, “INSERT column privileges”, in conforming SQL language, an <action> that contains
   INSERT shall not contain a <privilege column list>.
8) Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain a <privilege
   method list>.




742 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                        12.4 <role definition>



12.4 <role definition>

Function
Define a role.


Format
<role definition> ::= CREATE ROLE <role name> [ WITH ADMIN <grantor> ]


Syntax Rules
1) The specified <role name> shall not be equivalent to any other <authorization identifier> in the SQL-
   environment.


Access Rules
1) The privileges necessary to execute the <role definition> are implementation-defined.


General Rules
1) A <role definition> defines a role.
2) Let U be the current user identifier and R be the current role name.
3) Case:
    a) If WITH ADMIN <grantor> is not specified, then
         Case:
         i)       If U is not the null value, then let A be U.
         ii)      Otherwise, let A be R.
    b) If WITH ADMIN CURRENT_USER is specified, then let A be U.
    c) If WITH ADMIN CURRENT_ROLE is specified, then let A be R.
4) A role authorization descriptor is created that identifies that the role identified by <role name> has been
   granted to A WITH ADMIN OPTION, with a grantor of “_SYSTEM”.


Conformance Rules
1) Without Feature T331, “Basic roles”, conforming SQL language shall not contain a <role definition>.
2) Without Feature T332, “Extended roles”, conforming SQL language shall not contain a <role definition>
   that immediately contains WITH ADMIN.



©ISO/IEC 2003 – All rights reserved                                                         Access control 743
ISO/IEC 9075-2:2003 (E)
12.5 <grant role statement>



12.5 <grant role statement>

Function
Define role authorizations.


Format
<grant role statement> ::=
    GRANT <role granted> [ { <comma> <role granted> }... ]
    TO <grantee> [ { <comma> <grantee> }... ]
    [ WITH ADMIN OPTION ]
    [ GRANTED BY <grantor> ]

<role granted> ::= <role name>


Syntax Rules
1) No role identified by a specified <grantee> shall be contained in any role identified by a specified <role
   granted>; that is, no cycles of role grants are allowed.
2) Let U be the current user identifier and R be the current role name.
3) Case:
    a) If GRANTED BY <grantor> is not specified, then
        Case:
        i)      If U is not the null value, then let A be U.
        ii)     Otherwise, let A be R.
    b) If GRANTED BY CURRENT_USER is specified, then let A be U.
    c) If GRANTED BY CURRENT_ROLE is specified, then let A be R.


Access Rules
1) Every role identified by <role granted> shall be contained in the applicable roles for A and the corresponding
   role authorization descriptors shall specify WITH ADMIN OPTION.


General Rules
1) For every <grantee> specified, a set of role authorization descriptors is created that defines the grant of
   each role identified by a <role granted> to the <grantee> with a grantor of A.
2) If WITH ADMIN OPTION is specified, then each role authorization descriptor also indicates that the role
   is grantable with the WITH ADMIN OPTION.



744 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                                   12.5 <grant role statement>



3) If two role authorization descriptors are identical except that one indicates that the role is grantable WITH
   ADMIN OPTION and the other indicates that the role is not, then both role authorization descriptors are
   set to indicate that the role is grantable with the WITH ADMIN OPTION.
4) Redundant duplicate role authorization descriptors are removed from the collection of all role authorization
   descriptors.
5) The set of involved privilege descriptors is the union of the sets of privilege descriptors corresponding to
   the applicable privileges for every <role granted> specified.
6) The set of involved grantees is the union of the set of <grantee>s and the set of <role name>s that contain
   at least one of the <role name>s that is possibly specified as a <grantee>.


Conformance Rules
1) Without Feature T331, “Basic roles”, conforming SQL language shall not contain a <grant role statement>.




©ISO/IEC 2003 – All rights reserved                                                         Access control 745
ISO/IEC 9075-2:2003 (E)
12.6 <drop role statement>



12.6 <drop role statement>

Function
Destroy a role.


Format
<drop role statement> ::= DROP ROLE <role name>


Syntax Rules
1) Let R be the role identified by the specified <role name>.


Access Rules
1) At least one of the enabled authorization identifiers shall have a role authorization identifier that authorizes
   R with the WITH ADMIN OPTION.


General Rules
1) Let A be any <authorization identifier> identified by a role authorization descriptor as having been granted
   to R.
2) The following <revoke role statement> is effectively executed without further Access Rule checking:
       REVOKE R FROM A

3) The descriptor of R is destroyed.


Conformance Rules
1) Without Feature T331, “Basic roles”, conforming SQL language shall not contain a <drop role statement>.




746 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                                       12.7 <revoke statement>



12.7 <revoke statement>

Function
Destroy privileges and role authorizations.


Format
<revoke statement> ::=
    <revoke privilege statement>
  | <revoke role statement>

<revoke privilege statement> ::=
    REVOKE [ <revoke option extension> ] <privileges>
    FROM <grantee> [ { <comma> <grantee> }... ]
    [ GRANTED BY <grantor> ]
    <drop behavior>

<revoke option extension> ::=
    GRANT OPTION FOR
  | HIERARCHY OPTION FOR

<revoke role statement> ::=
    REVOKE [ ADMIN OPTION FOR ] <role revoked> [ { <comma> <role revoked> }... ]
    FROM <grantee> [ { <comma> <grantee> }... ]
    [ GRANTED BY <grantor> ]
    <drop behavior>

<role revoked> ::= <role name>


Syntax Rules
1) Let O be the object identified by the <object name> contained in <privileges>. If O is a table T, then let S
   be the set of subtables of O. If T is a table of a structured type, then let TY be that type.
2) If WITH HIERARCHY OPTION is specified, the <privileges> shall specify an <action> of SELECT
   without a <privilege column list> and without a <privilege method list> and O shall be a table of a structured
   type.
3) Let U be the current user identifier and R be the current role name.
4) Case:
    a) If GRANTED BY <grantor> is not specified, then
         Case:
         i)       If U is not the null value, then let A be U.
         ii)      Otherwise, let A be R.
    b) If GRANTED BY CURRENT_USER is specified, then let A be U.



©ISO/IEC 2003 – All rights reserved                                                          Access control 747
ISO/IEC 9075-2:2003 (E)
12.7 <revoke statement>



    c) If GRANTED BY CURRENT_ROLE is specified, then let A be R.
5) SELECT is equivalent to specifying both the SELECT table privilege and SELECT (<privilege column
   list>) for all columns of <table name>. If T is a table of a structured type TY, then SELECT also specifies
   SELECT (<privilege column list>) for all columns inherited from T in each of the subtables of T, and
   SELECT (<privilege method list>) for all methods of TY in each of the subtables of T.
6) INSERT is equivalent to specifying both the INSERT table privilege and INSERT (<privilege column
   list>) for all columns of <table name>.
7) UPDATE is equivalent to specifying both the UPDATE table privilege and UPDATE (<privilege column
   list>) for all columns of <table name>, as well as UPDATE (<privilege column list>) for all columns
   inherited from T in each of the subtables of T.
8) REFERENCES is equivalent to specifying both the REFERENCES table privilege and REFERENCES
   (<privilege column list>) for all columns of <table name>, as well as REFERENCES (<privilege column
   list>) for all columns inherited from T in each of the subtables of T.
9) Case:
    a) If the <revoke statement> is a <revoke privilege statement>, then for every <grantee> specified, a set
       of privilege descriptors is identified. A privilege descriptor P is said to be identified if it belongs to the
       set of privilege descriptors that defined, for any <action> explicitly or implicitly in <privileges>, that
       <action> on O, or any of the objects in S, granted by A to <grantee>.
        NOTE 337 — Column privilege descriptors become identified when <action> explicitly or implicitly contains a <privilege
        column list>. Table/method descriptors become identified when <action> explicitly or implicitly contains a <privilege method
        list>.

    b) If the <revoke statement> is a <revoke role statement>, then for every <grantee> specified, a set of
       role authorization descriptors is identified. A role authorization descriptor is said to be identified if it
       defines the grant of any of the specified <role revoked>s to <grantee> with grantor A.
10) A privilege descriptor D is said to be directly dependent on another privilege descriptor P if either:
    a) All of the following conditions hold:
        i)      P indicates that the privilege that it represents is grantable.
        ii)     The grantee of P is the same as the grantor of D or the grantee of P is PUBLIC, or, if the grantor
                of D is a <role name>, the grantee of P belongs to the set of applicable roles of the grantor of
                D.
        iii)    Case:
                1) P and D are both column privilege descriptors. The action and the identified column of P
                   are the same as the action and identified column of D, respectively.
                2) P and D are both table privilege descriptors. The action and the identified table of P are the
                   same as the action and the identified table of D, respectively.
                3) P and D are both execute privilege descriptors. The action and the identified SQL-invoked
                   routine of P are the same as the action and the identified SQL-invoked routine of D,
                   respectively.




748 Foundation (SQL/Foundation)                                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)
                                                                                           12.7 <revoke statement>



                  4) P and D are both usage privilege descriptors. The action and the identified domain, character
                     set, collation, transliteration, user-defined type, or sequence generator of P are the same as
                     the action and the identified domain, character set, collation, transliteration, user-defined
                     type, or sequence generator of D, respectively.
                  5) P and D are both under privilege descriptors. The action and the identified user-defined type
                     or table of P are the same as the action and the identified user-defined type or table of D,
                     respectively.
                  6) P and D are both table/method privilege descriptors. The action and the identified method
                     and table of P are the same as the action and the identified method and table of D, respec-
                     tively.
    b) All of the following conditions hold:
         i)       The privilege descriptor for D indicates that its grantor is the special grantor value “_SYSTEM”.
         ii)      The action of P is the same as the action of D.
         iii)     The grantee of P is the owner of the table, collation, or transliteration identified by D or the
                  grantee of P is PUBLIC.
         iv)      One of the following conditions hold:
                  1) P and D are both table privilege descriptors, the privilege descriptor for D identifies the
                     <table name> of an updatable view V, and the identified table of P is the underlying table
                     of the <query expression> of V.
                  2) P and D are both column privilege descriptors, the privilege descriptor D identifies a <column
                     name> CVN explicitly or implicitly contained in the <view column list> of a <view defini-
                     tion> V, and one of the following is true:
                      A) V is an updatable view. For every column CV identified by a <column name> CVN,
                         there is a corresponding column in the underlying table of the <query expression> TN.
                         Let CTN be the <column name> of the column of the <query expression> from which
                         CV is derived. The action for P is UPDATE or INSERT and the identified column of
                         P is TN.CTN.
                      B) For every table T identified by a <table reference> contained in the <query expression>
                         of V and for every column CT that is a column of T and an underlying column of CV,
                         the action for P is REFERENCES and either the identified column of P is CT or the
                         identified table of P is T.
                      C) For every table T identified by a <table reference> contained in the <query expression>
                         of V and for every column CT that is a column of T and an underlying column of CV,
                         the action for P is SELECT and either the identified column of P is CT or the identified
                         table of P is T.
                  3) The privilege descriptor D identifies the <collation name> of a <collation definition> CO
                     and the identified character set name of P is included in the collation descriptor for CO, or
                     the identified transliteration name of P is included in the collation descriptor for CO.




©ISO/IEC 2003 – All rights reserved                                                              Access control 749
ISO/IEC 9075-2:2003 (E)
12.7 <revoke statement>



               4) The privilege descriptor D identifies the <transliteration name> of a <transliteration defini-
                  tion> TD and the identified character set name of P is contained in the <source character
                  set specification> or the <target character set specification> immediately contained in TD.
    c) All of the following conditions hold:
        i)     The privilege descriptor for D indicates that its grantor is the special grantor value “_SYSTEM”.
        ii)    The grantee of P is the owner of the domain identified by D or the grantee of P is PUBLIC.
        iii)   The privilege descriptor D identifies the <domain name> of a <domain definition> DO and
               either the column privilege descriptor P has an action of REFERENCES and identifies a column
               referenced in the <search condition> included in the domain descriptor for DO, or the privilege
               descriptor P has an action of USAGE and identifies a domain, collation, character set, or
               transliteration whose <domain name>, <collation name>, <character set name> or <transliteration
               name>, respectively, is contained in the <search condition> of the domain descriptor for DO.
11) The privilege dependency graph is a directed graph such that all of the following are true:
    a) Each node represents a privilege descriptor.
    b) Each arc from node P1 to node P2 represents the fact that P2 directly depends on P1.
    An independent node is a node that has no incoming arcs.
12) A privilege descriptor P is said to be modified if all of the following are true:
    a) P indicates that the privilege that it represents is grantable.
    b) P directly depends on an identified privilege descriptor or a modified privilege descriptor.
    c) Case:
        i)     If P is neither a SELECT nor a REFERENCES column privilege descriptor that identifies a
               <column name> CVN explicitly or implicitly contained in the <view column list> of a <view
               definition> V, then let XO and XA respectively be the identifier of the object identified by a
               privilege descriptor X and the action of X. Within the set of privilege descriptors upon which P
               directly depends, there exist some XO and XA for which the set of identified privilege descriptors
               unioned with the set of modified privilege descriptors include all privilege descriptors specifying
               the grant of XA on XO WITH GRANT OPTION.
        ii)    If P is a column privilege descriptor that identifies a column CV identified by a <column name>
               CVN explicitly or implicitly contained in the <view column list> of a <view definition> V with
               an action PA of REFERENCES or SELECT, then let SP be the set of privileges upon which P
               directly depends. For every table T identified by a <table reference> contained in the <query
               expression> of V, let RT be the <table name> of T. There exists a column CT whose <column
               name> is CRT, such that all of the following are true:
               1) CT is a column of T and an underlying column of CV.
               2) Every privilege descriptor PD that is the descriptor of some member of SP that specifies
                  the action PA on CRT WITH GRANT OPTION is either an identified privilege descriptor
                  for CRT or a modified privilege descriptor for CRT.
    d) At least one of the following is true:



750 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                          12.7 <revoke statement>



         i)       GRANT OPTION FOR is specified and the grantor of P is the special grantor value “_SYSTEM”.
         ii)      There exists a path to P from an independent node that includes no identified or modified privilege
                  descriptors. P is said to be a marked modified privilege descriptor.
         iii)     P directly depends on a marked modified privilege descriptor, and the grantor of P is the special
                  grantor value “_SYSTEM”. P is said to be a marked modified privilege descriptor.
13) A role authorization descriptor D is said to be directly dependent on another role authorization descriptor
    RD if all of the following conditions hold:
    a) RD indicates that the role that it represents is grantable.
    b) The role name of D is the same as the role name of RD.
    c) The grantee of RD is the same as the grantor of D or the grantee of RD is PUBLIC, or, if the grantor
       of D is a <role name>, the grantee of RD belongs to the set of applicable roles of the grantor of D.
14) The role dependency graph is a directed graph such that all of the following are true:
    a) Each node represents a role authorization descriptor.
    b) Each arc from node R1 to node R2 represents the fact that R2 directly depends on R1.
    An independent node is one that has no incoming arcs.
15) A role authorization descriptor RD is said to be abandoned if it is not an independent node, and it is not
    itself an identified role authorization descriptor, and there exists no path to RD from any independent node
    other than paths that include an identified role authorization descriptor.
16) An arc from a node P to a node D of the privilege dependency graph is said to be unsupported if all of the
    following are true:
    a) The grantor of D and the grantee of P are both <role name>s.
    b) The destruction of all abandoned role authorization descriptors and, if ADMIN OPTION FOR is not
       specified, all identified role authorization descriptors would result in the grantor of D no longer having
       in its applicable roles the grantee of P.
17) A privilege descriptor P is abandoned if:
    Case:
    a) It is not an independent node, and P is not itself an identified or a modified privilege descriptor, and
       there exists no path to P from any independent node other than paths that include an identified privilege
       descriptor or a modified privilege descriptor or an unsupported arc and, if <revoke statement> specifies
       WITH HIERARCHY OPTION, then P has the WITH HIERARCHY OPTION.
    b) All of the following conditions hold:
         i)       P is a column privilege descriptor that identifies a <column name> CVN explicitly or implicitly
                  contained in the <view column list> of a <view definition> V, with an action PA of REFER-
                  ENCES or SELECT.
         ii)      Letting SP be the set of privileges upon which P directly depends, at least one of the following
                  is true:



©ISO/IEC 2003 – All rights reserved                                                              Access control 751
ISO/IEC 9075-2:2003 (E)
12.7 <revoke statement>



                1) There exists some table name RT such that all of the following are true:
                    A) RT is the name of the table identified by some <table reference> contained in the <query
                       expression> of V.
                    B) For every column privilege descriptor CPD that is the descriptor of some member of
                       SP that specifies the action PA on RT, CPD is either an identified privilege descriptor
                       for RT or an abandoned privilege descriptor for RT.
                2) There exists some column name CRT such that all of the following are true:
                    A) CRT is the name of some column of the table identified by some <table reference>
                       contained in the <query expression> of V.
                    B) For every column privilege descriptor CPD that is the descriptor of some member of
                       SP that specifies the action PA on CRT, CPD is either an identified privilege descriptor
                       for CRT or an abandoned privilege descriptor for CRT.
18) The revoke destruction action is defined as
    Case:
    a) If the <revoke statement> is a <revoke privilege statement>, then
        Case:
        i)      If the <revoke statement> specifies the WITH HIERARCHY OPTION, then the removal of the
                WITH HIERARCHY OPTION from all identified and abandoned privilege descriptors.
        ii)     Otherwise, the destruction of all abandoned privilege descriptors and, if GRANT OPTION FOR
                is not specified, all identified privilege descriptors.
    b) If the <revoke statement> is a <revoke role statement>, then the destruction of all abandoned role
       authorization descriptors, all abandoned privilege descriptors and, if GRANT OPTION FOR is not
       specified, all identified role authorization descriptors.
19) Let S1 be the name of any schema and A1 be the <authorization identifier> that owns the schema identified
    by S1.
20) Let V be any view descriptor included in S1. Let QE be the <query expression> of V. V is said to be aban-
    doned if the revoke destruction action would result in A1 no longer having in its applicable privileges all
    of the following:
    a) SELECT privilege on at least one column of every table identified by a <table reference> is contained
       in QE.
    b) SELECT privilege on every column identified by a <column reference> contained in QE.
    c) USAGE privilege on every domain, every collation, every character set, and every transliteration whose
       names are contained in QE.
    d) USAGE privilege on any user-defined type UDT such that some <data type> contained in V is usage-
       dependent on UDT.




752 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                        12.7 <revoke statement>



    e) EXECUTE privilege on every SQL-invoked routine that is the subject routine of any <routine invoca-
       tion>, <method invocation>, <static method invocation>, or <method reference> that is contained in
       QE.
    f) The table/method privilege on every table T1 and every method M such that there is a <method refer-
       ence> MR contained in QE such that T1 is in the scope of the <value expression primary> of MR and
       M is subject routine of MR.
    g) SELECT privilege on any column identified by a <column reference> contained in the <scalar subquery>
       that is equivalent to some <dereference operation> contained in QE.
    h) SELECT privilege WITH HIERARCHY OPTION on at least one supertable of the scoped table of any
       <reference resolution> that is contained in QE.
    i)   SELECT privilege on the scoped table of any <reference resolution> that is contained in QE.
    j)   If V is the descriptor of a referenceable table, then USAGE privilege on the structured type associated
         with the view described by V.
    k) UNDER privilege on every direct supertable of the view described by V.
    l)   SELECT privilege WITH HIERARCHY OPTION privilege on at least one supertable of every typed
         table identified by a <table reference> that simply contains an <only spec> and that is contained in QE.
21) Let T be any table descriptor included in S1. T is said to be abandoned if the revoke destruction action
    would result in A1 no longer having all of the following:
    a) If T is the descriptor of a referenceable table, then USAGE privilege on the structured type associated
       with the table described by T.
    b) UNDER privilege on every direct supertable of the table described by T.
22) Let TC be any table constraint descriptor included in S1. TC is said to be abandoned if the revoke destruction
    action would result in A1 no longer having in its applicable privileges all of the following:
    a) REFERENCES privilege on at least one column of every table identified by a <table reference> contained
       in TC.
    b) REFERENCES privilege on every column identified by a <column reference> contained in the <search
       condition> of TC.
    c) USAGE privilege on every domain, every collation, every character set, and every transliteration whose
       names are contained in any <search condition> of TC.
    d) USAGE privilege on any user-defined type UDT such that some <data type> contained in TC is usage-
       dependent on UDT.
    e) EXECUTE privilege on every SQL-invoked routine that is the subject routine of any <routine invoca-
       tion>, <method invocation>, <static method invocation>, or <method reference> that is contained in
       any <search condition> of TC.
    f) The table/method privilege on every table T1 and every method M such that there is a <method refer-
       ence> MR contained in any <search condition> of TC such that T1 is in the scope of the <value
       expression primary> of MR and M is the subject routine of MR.




©ISO/IEC 2003 – All rights reserved                                                           Access control 753
ISO/IEC 9075-2:2003 (E)
12.7 <revoke statement>



    g) SELECT privilege on any column identified by a <column reference> contained in the <scalar subquery>
       that is equivalent to some <dereference operation> contained in any <search condition> of TC.
    h) SELECT privilege WITH HIERARCHY OPTION on at least one supertable of the scoped table of any
       <reference resolution> that is contained in any <search condition> of TC.
    i)   SELECT privilege on the scoped table of any <reference resolution> that is contained in any <search
         condition> of TC.
    j)   SELECT privilege WITH HIERARCHY OPTION on at least one supertable of every typed table
         identified by a <table reference> that simply contains an <only spec> and that is contained in TC.
23) Let AX be any assertion descriptor included in S1. AX is said to be abandoned if the revoke destruction
    action would result in A1 no longer having in its applicable privileges all of the following:
    a) REFERENCES privilege on at least one column of every table identified by a <table reference> contained
       in AX.
    b) REFERENCES privilege on every column identified by a <column reference> contained in the <search
       condition> of AX.
    c) USAGE privilege on every domain, every collation, every character set, and every transliteration whose
       names are contained in any <search condition> of AX.
    d) USAGE privilege on any user-defined type UDT such that some <data type> contained in AX is usage-
       dependent on UDT.
    e) EXECUTE privilege on every SQL-invoked routine that is the subject routine of any <routine invoca-
       tion>, <method invocation>, <static method invocation>, or <method reference> that is contained in
       any <search condition> of AX.
    f) The table/method privilege on every table T1 and every method M such that there is a <method refer-
       ence> MR contained in AX such that T1 is in the scope of the <value expression primary> of MR and
       M is the subject routine of MR.
    g) SELECT privilege on any column identified by a <column reference> contained in the <scalar subquery>
       that is equivalent to some <dereference operation> contained in any <search condition> of AX.
    h) SELECT privilege WITH HIERARCHY OPTION on at least one supertable of the scoped table of any
       <reference resolution> that is contained in any <search condition> of AX.
    i)   SELECT privilege on the scoped table of any <reference resolution> that is contained in any <search
         condition> of AX.
    j)   SELECT privilege WITH HIERARCHY OPTION on at least one supertable of every typed table
         identified by a <table reference> that simply contains an <only spec> and that is contained in AX.
24) Let TR be any trigger descriptor included in S1. TR is said to be abandoned if the revoke destruction action
    would result in A1 no longer having in its applicable privileges all of the following:
    a) TRIGGER privilege on the subject table of TR.
    b) REFERENCES privilege on at least one column of every table identified by a <table reference> contained
       in any <search condition> of TR.




754 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                        12.7 <revoke statement>



    c) SELECT privilege on every column identified by a <column reference> contained in any <search
       condition> of TR.
    d) USAGE privilege on every domain, collation, character set, and transliteration whose name is contained
       in any <search condition> of TR.
    e) USAGE privilege on any user-defined type UDT such that some <data type> contained in any <search
       condition> of TR is usage-dependent on UDT.
    f) The table/method privilege on every table T1 and every method M such that there is a <method refer-
       ence> MR contained in any <search condition> of TR such that T1 is in the scope of the <value
       expression primary> of MR and M is the subject routine of MR.
    g) EXECUTE privilege on the SQL-invoked routine that is the subject routine of any <routine invocation>,
       <method invocation>, <static method invocation>, or <method reference> that is contained in any
       <search condition> of TR.
    h) EXECUTE privilege on the SQL-invoked routine that is the subject routine of any <routine invocation>,
       <method invocation>, <static method invocation>, or <method reference> that is contained in the
       <triggered SQL statement> of TR.
    i)   SELECT privilege on at least one column of every table identified by a <table reference> contained
         in a <query expression> simply contained in a <cursor specification>, an <insert statement>, or a
         <merge statement> contained in the <triggered SQL statement> of TR.
    j)   SELECT privilege on at least one column of every table identified by a <table reference> contained
         in a <table expression> or <select list> immediately contained in a <select statement: single row>
         contained in the <triggered SQL statement> of TR.
    k) SELECT privilege on at least one column of every table identified by a <table reference> and <column
       reference> contained in a <search condition> contained in a <delete statement: searched>, an <update
       statement: searched>, or a <merge statement> contained in the <triggered SQL statement> of TR.
    l)   SELECT privilege on at least one column of every table identified by a <table reference> and <column
         reference> contained in a <value expression> simply contained in a an <update source> or an <assigned
         row>contained in the <triggered SQL statement> of TR.
    m) INSERT privilege on every column
         Case:
         i)       Identified by a <column name> contained in the <insert column list> of an <insert statement>
                  or a <merge statement> contained in the <triggered SQL statement> of TR.
         ii)      Of the table identified by the <table name> immediately contained in an <insert statement> that
                  does not contain an <insert column list> and that is contained in the <triggered SQL statement>
                  of TR.
         iii)     Of the table identified by the <target table> contained in a <merge statement> that contains a
                  <merge insert specification> and that does not contain an <insert column list> and that is con-
                  tained in the <triggered SQL statement> of TR.
    n) UPDATE privilege on every column identified by a <column name> is contained in an <object column>
       contained in either an <update statement: positioned>, an <update statement: searched>, or a <merge
       statement> contained in the <triggered SQL statement> of TR.


©ISO/IEC 2003 – All rights reserved                                                           Access control 755
ISO/IEC 9075-2:2003 (E)
12.7 <revoke statement>



   o) DELETE privilege on every table identified by a <table name> contained in either a <delete statement:
      positioned> or a <delete statement: searched> contained in the <triggered SQL statement> of TR.
   p) USAGE privilege on every domain, collation, character set, transliteration, and sequence generator
      whose name is contained in the <triggered SQL statement> of TR.
   q) USAGE privilege on any user-defined type UDT such that some <data type> contained in the <triggered
      SQL statement> of TR is usage-dependent on UDT.
   r) The table/method privilege on every table T1 and every method M such that there is a <method refer-
      ence> MR contained in any <triggered SQL statement> of TR such that T1 is in the scope of the <value
      expression primary> of MR and M is the subject routine of MR.
   s) SELECT privilege on any column identified by a <column reference> contained in the <scalar subquery>
      that is equivalent to some <dereference operation> contained in any of the following:
        i)     A <search condition> of TR.
        ii)    A <query expression> simply contained in a <cursor specification>, an <insert statement>, or
               a <merge statement> contained in the <triggered SQL statement> of TR.
        iii)   A <table expression> or <select list> immediately contained in a <select statement: single row>
               contained in the <triggered SQL statement> of TR.
        iv)    A <search condition> contained in a <delete statement: searched>, an <update statement:
               searched>, or a <merge statement> contained in the <triggered SQL statement> of TR.
        v)     A <value expression> contained in an <update source> or an <assigned row> contained in the
               <triggered SQL statement> of TR.
   t)   SELECT privilege WITH HIERARCHY OPTION on at least one supertable of the scoped table of any
        <reference resolution> that is contained in any of the following:
        i)     A <search condition> of TR.
        ii)    A <query expression> simply contained in a <cursor specification>, an <insert statement>, or
               a <merge statement> contained in the <triggered SQL statement> of TR.
        iii)   A <table expression> or <select list> immediately contained in a <select statement: single row>
               contained in the <triggered SQL statement> of TR.
        iv)    A <search condition> contained in a <delete statement: searched>, an <update statement:
               searched>, or a <merge statement> contained in the <triggered SQL statement> of TR.
        v)     A <value expression> contained in an <update source> or an <assigned row> contained in the
               <triggered SQL statement> of TR.
   u) SELECT privilege on the scoped table of any <reference resolution> contained in any of the following:
        i)     A <search condition> of TR.
        ii)    A <query expression> simply contained in a <cursor specification>, an <insert statement>, or
               a <merge statement> contained in the <triggered SQL statement> of TR.
        iii)   A <table expression> or <select list> immediately contained in a <select statement: single row>
               contained in the <triggered SQL statement> of TR.


756 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                                       12.7 <revoke statement>



         iv)      A <search condition> contained in a <delete statement: searched>, an <update statement:
                  searched>, or a <merge statement> contained in the <triggered SQL statement> of TR.
         v)       A <value expression> contained in an <update source> or an <assigned row> contained in the
                  <triggered SQL statement> of TR.
    v) SELECT privilege WITH HIERARCHY OPTION on at least one supertable of every typed table
       identified by a <table reference> that simply contains an <only spec> and that is contained in the
       <triggered SQL statement> of TR.
25) Let DC be any domain constraint descriptor included in S1. DC is said to be abandoned if the revoke
    destruction action would result in A1 no longer having in its applicable privileges all of the following:
    a) REFERENCES privilege on at least one column of every table identified by a <table reference> contained
       in TR.
    b) REFERENCES privilege on every column identified by a <column reference> contained in the <search
       condition> of DC.
    c) USAGE privilege on every domain, every user-defined type, every collation, every character set, and
       every transliteration whose names are contained in any <search condition> of DC.
    d) USAGE privilege on any user-defined type UDT such that some <data type> contained in any <search
       condition> of DC is usage-dependent on UDT.
    e) EXECUTE privilege on every SQL-invoked routine that is the subject routine of any <routine invoca-
       tion>, <method invocation>, <static method invocation>, or <method reference> that is contained in
       any <search condition> of DC.
    f) The table/method privilege on every table T1 and every method M such that there is a <method refer-
       ence> MR contained in any <search condition> of DC such that T1 is in the scope of the <value
       expression primary> of MR and M is the subject routine of MR.
    g) SELECT privilege on any column identified by a <column reference> contained in a <scalar subquery>
       that is equivalent to some <dereference operation> contained in any <search condition> of DC.
    h) SELECT privilege WITH HIERARCHY OPTION on at least one supertable of the scoped table of any
       <reference resolution> that is contained in any <search condition> of DC.
    i)   SELECT privilege on the scoped table of any <reference resolution> that is contained in contained in
         any <search condition> of DC.
    j)   SELECT privilege WITH HIERARCHY OPTION on at least one supertable of every typed table
         identified by a <table reference> that simply contains an <only spec> and that is contained in the
         <triggered SQL statement> of TR.
26) For every domain descriptor DO included in S1, DO is said to be lost if the revoke destruction action would
    result in A1 no longer having in its applicable privileges USAGE privilege on every character set included
    in the data type descriptor included in DO.
27) For every table descriptor TD contained in S1, for every column descriptor CD included in TD, CD is said
    to be lost if any of the following are true:
    a) The revoke destruction action would result in A1 no longer having in its applicable privileges USAGE
       privilege on any character set included in the data type descriptor included in CD.


©ISO/IEC 2003 – All rights reserved                                                         Access control 757
ISO/IEC 9075-2:2003 (E)
12.7 <revoke statement>



    b) The revoke destruction action would result in A1 no longer having in its applicable privileges USAGE
       privilege on any user-defined type UDT such that a data type descriptor included in CD describes a
       type that is usage-dependent on UDT.
    c) The name of the domain DN included in CD, if any, identifies a lost domain descriptor and the revoke
       destruction action would result in A1 no longer having in its applicable privileges USAGE privilege
       on any character set included in the data type descriptor of the domain descriptor of DN.
28) For every SQL-client module MO, let G be the <module authorization identifier> that owns MO. MO is
    said to be lost if the revoke destruction action would result in G no longer having in its applicable privileges
    USAGE privilege on the character set referenced in the <module character set specification> of MO.
29) For every user-defined type descriptor DT included in S1, DT is said to be abandoned if any of the following
    are true:
    a) The revoke destruction action would result in A1 no longer having in its applicable privileges USAGE
       privilege on any user-defined type UDT such that a data type descriptor included in DT describes a
       type that is usage-dependent on UDT.
    b) The revoke destruction action would result in A1 no longer having in its applicable privileges the
       UNDER privilege on any user-defined type that is a direct supertype of DT.
30) S1 is said to be lost if the revoke destruction action would result in A1 no longer having in its applicable
    privileges USAGE privilege on the default character set included in the S1.
31) For every collation descriptor CN contained in S1, CN is said to be impacted if the revoke destruction action
    would result in A1 no longer having in its applicable privileges USAGE privilege on the collation whose
    name is contained in the <existing collation name> of CN.
32) For every character set descriptor CSD contained in S1, CSD is said to be impacted if the revoke destruction
    action would result in A1 no longer having in its applicable privileges USAGE privilege on the collation
    whose name is contained in CSD.
33) For every descriptor included in S1 that includes a data type descriptor DTD, DTD is said to be impacted
    if the revoke destruction action would result in A1 no longer having, in its applicable privileges, USAGE
    privilege on the collation whose name is included in DTD.
34) Let RD be any routine descriptor with an SQL security characteristic of DEFINER that is included in S1.
    RD is said to be abandoned if the revoke destruction action would result in A1 no longer having in its
    applicable privileges all of the following:
    a) EXECUTE privilege on the SQL-invoked routine that is the subject routine of any <routine invocation>,
       <method invocation>, <static method invocation>, or <method reference> that is contained in the
       <routine body> of RD.
    b) SELECT privilege on at least one column of each table identified by a <table reference> contained in
       a <query expression> simply contained in a <cursor specification>, an <insert statement>, or a <merge
       statement> contained in the SQL routine body of RD.
    c) SELECT privilege on at least one column of each table identified by a <table reference> contained in
       a <table expression> or <select list> immediately contained in a <select statement: single row> contained
       in the SQL routine body of RD.




758 Foundation (SQL/Foundation)                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                        12.7 <revoke statement>



    d) SELECT privilege on at least one column of each table identified by a <table reference> contained in
       a <search condition> contained in a <delete statement: searched>, an <update statement: searched>,
       or a <merge statement> contained in the SQL routine body of RD.
    e) SELECT privilege on at least one column of each table identified by a <table reference> contained in
       a <value expression> simply contained in an <update source> or an <assigned row> contained in the
       SQL routine body of RD.
    f) SELECT privilege on at least one column identified by a <column reference> contained in a <search
       condition> contained in a <delete statement: searched>, an <update statement: searched>, or a <merge
       statement> contained in the <SQL routine body> of RD.
    g) SELECT privilege on at least one column identified by a <column reference> contained in a <value
       expression> simply contained in an <update source> or an <assigned row> contained in the SQL routine
       body of RD.
    h) INSERT privilege on each column
         Case:
         i)       Identified by a <column name> contained in the <insert column list> of an <insert statement>
                  or a <merge statement> contained in the SQL routine body of RD.
         ii)      Of the table identified by the <table name> immediately contained in an <insert statement> that
                  does not contain an <insert column list> and that is contained in the SQL routine body of RD.
         iii)     Of the table identified by the <target table> immediately contained in a <merge statement> that
                  contains a <merge insert specification> and that does not contain an <insert column list> and
                  that is contained in the SQL routine body of RD.
    i)   UPDATE privilege on each column whose name is contained in an <object column> contained in either
         an <update statement: positioned>, an <update statement: searched>, or a <merge statement> contained
         in the SQL routine body of RD.
    j)   DELETE privilege on each table whose name is contained in a <table name> contained in either a
         <delete statement: positioned> or a <delete statement: searched> contained in the SQL routine body
         of RD.
    k) USAGE privilege on each domain, collation, character set, transliteration, and sequence generator
       whose name is contained in the SQL routine body of RD.
    l)   USAGE privilege on each user-defined type UDT such that a declared type of any SQL parameter,
         returns data type, or result cast included in RD is usage-dependent on UDT.
    m) USAGE privilege on each user-defined type UDT such that some <data type> contained in the SQL
       routine body of RD is usage-dependent on UDT.
    n) The table/method privilege on every table T1 and every method M such that there is a <method refer-
       ence> MR contained in the SQL routine body of RI such that T1 is in the scope of the <value expression
       primary> of MR and M is the subject routine of MR.
    o) SELECT privilege on any column identified by a <column reference> contained in a <scalar subquery>
       that is equivalent to a <dereference operation> contained in any of the following:




©ISO/IEC 2003 – All rights reserved                                                          Access control 759
ISO/IEC 9075-2:2003 (E)
12.7 <revoke statement>



        i)     A <query expression> simply contained in a <cursor specification>, an <insert statement>, or
               a <merge statement> contained in the <SQL routine body> of RD.
        ii)    A <table expression> or <select list> immediately contained in a <select statement: single row>
               contained in the <SQL routine body> of RD.
        iii)   A <search condition> contained in a <delete statement: searched>, an <update statement:
               searched>, or a <merge statement> contained in the <SQL routine body> of RD.
        iv)    A <value expression> contained in an <update source> or an <assigned row> contained in the
               <SQL routine body> of RD.
    p) SELECT privilege WITH HIERARCHY OPTION on at least one supertable of the scoped table of any
       <reference resolution> that is contained in any of the following:
        i)     A <query expression> simply contained in a <cursor specification>, an <insert statement>, or
               a <merge statement> contained in the SQL routine body of RD.
        ii)    A <table expression> or <select list> immediately contained in a <select statement: single row>
               contained in the SQL routine body of RD.
        iii)   A <search condition> contained in a <delete statement: searched>, an <update statement:
               searched>, or a <merge statement> contained in the SQL routine body of RD.
        iv)    A <value expression> simply contained in an <update source> or an <assigned row> contained
               in the SQL routine body of RD.
    q) SELECT privilege on the scoped table of any <reference resolution> that is contained in any of the
       following:
        i)     A <query expression> simply contained in a <cursor specification>, an <insert statement>, or
               a <merge statement> contained in the <SQL routine body> of RD.
        ii)    A <table expression> or <select list> immediately contained in a <select statement: single row>
               contained in the <SQL routine body> of RD.
        iii)   A <search condition> contained in a <delete statement: searched>, an <update statement:
               searched>, or a <merge statement> contained in the <SQL routine body> of RD.
        iv)    A <value expression> contained in an <update source> or an <assigned row> contained in the
               <SQL routine body> of RD.
    r) SELECT privilege WITH HIERARCHY OPTION on at least one supertable of every typed table
       identified by a <table reference> that simply contains an <only spec> and that is contained in the <SQL
       routine body> of RD.
35) For every table descriptor TD included in S1, for every column descriptor CD included in TD, CD is said
    to be contaminated if CD includes one of the following:
    a) A user-defined type descriptor that describes a supertype of a user-defined type described by an aban-
       doned user-defined type descriptor.
    b) A reference type descriptor that includes a user-defined type descriptor that describes a supertype of a
       user-defined type described by an abandoned user-defined type descriptor.




760 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                                         12.7 <revoke statement>



    c) A collection type descriptor that includes a user-defined type descriptor that describes a supertype of
       a user-defined type described by an abandoned user-defined type descriptor.
    d) A collection type descriptor that includes a reference type descriptor that includes a user-defined type
       descriptor that describes a supertype of a user-defined type described by an abandoned user-defined
       type descriptor.
36) If RESTRICT is specified, then there shall be no abandoned privilege descriptor, abandoned view, abandoned
    table constraint, abandoned assertion, abandoned domain constraint, lost domain, lost column, lost schema,
    and no descriptor that includes an impacted data type descriptor, impacted collation, impacted character
    set, abandoned user-defined type, forsaken column descriptor, forsaken domain descriptor, or abandoned
    routine descriptor.
37) If CASCADE is specified, then the impact on an SQL-client module that is determined to be a lost module
    is implementation-defined.


Access Rules
1) Case:
    a) If the <revoke statement> is a <revoke privilege statement>, then the applicable privileges for A shall
       include a privilege identifying O.
    b) If the <revoke statement> is a <revoke role statement>, then for every role R identified by a <role
       revoked>, the applicable roles of A shall include a role AR such that there exists a role authorization
       descriptor with role R, grantee AR, and the indication that the WITH ADMIN OPTION was granted.


General Rules
1) Case:
    a) If the <revoke statement> is a <revoke privilege statement>, then
         Case:
         i)       If neither WITH HIERARCHY OPTION nor GRANT OPTION FOR is specified, then:
                  1) All abandoned privilege descriptors are destroyed.
                  2) The identified privilege descriptors are destroyed.
                  3) The modified privilege descriptors are set to indicate that they are not grantable.
         ii)      If WITH HIERARCHY OPTION is specified, then the WITH HIERARCHY OPTION is removed
                  from all identified and abandoned privilege descriptors, if present.
         iii)     If GRANT OPTION FOR is specified, then
                  Case:
                  1) If CASCADE is specified, then all abandoned privilege descriptors are destroyed.




©ISO/IEC 2003 – All rights reserved                                                           Access control 761
ISO/IEC 9075-2:2003 (E)
12.7 <revoke statement>



              2) Otherwise, if there are any privilege descriptors directly dependent on an identified privilege
                 descriptor that are not modified privilege descriptors, then an exception condition is raised:
                 dependent privilege descriptors still exist.
              The identified privilege descriptors and the modified privilege descriptors are set to indicate
              that they are not grantable.
   b) If the <revoke statement> is a <revoke role statement>, then:
       i)     If CASCADE is specified, then all abandoned role authorization descriptors are destroyed.
       ii)    All abandoned privilege descriptors are destroyed.
       iii)   Case:
              1) If ADMIN OPTION FOR is specified, then the identified role authorization descriptors are
                 set to indicate that they are not grantable.
              2) If ADMIN OPTION FOR is not specified, then the identified role authorization descriptors
                 are destroyed.
2) For every abandoned view descriptor V, let S1.VN be the <table name> of V. The following <drop view
   statement> is effectively executed without further Access Rule checking:
      DROP VIEW S1.VN CASCADE


3) For every abandoned table descriptor T, let S1.TN be the <table name> of T. The following <drop table
   statement> is effectively executed without further Access Rule checking:
      DROP TABLE S1.TN CASCADE


4) For every abandoned table constraint descriptor TC, let S1.TCN be the <constraint name> of TC and let
   S2.T2 be the <table name> of the table that contains TC (S1 and S2 possibly equivalent). The following
   <alter table statement> is effectively executed without further Access Rule checking:
      ALTER TABLE S2.T2 DROP CONSTRAINT S1.TCN CASCADE

5) For every abandoned assertion descriptor AX, let S1.AXN be the <constraint name> of AX. The following
   <drop assertion statement> is effectively executed without further Access Rule checking:
      DROP ASSERTION S1.AXN CASCADE

6) For every abandoned trigger descriptor TR, let S1.TRN be the <trigger name> of TR. The following <drop
   trigger statement> is effectively executed without further Access Rule checking:
      DROP TRIGGER S1.TRN

7) For every abandoned domain constraint descriptor DC, let S1.DCN be the <constraint name> of DC and
   let S2.DN be the <domain name> of the domain that contains DC. The following <alter domain statement>
   is effectively executed without further Access Rule checking:
      ALTER DOMAIN S2.DN DROP CONSTRAINT S1.DCN




762 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)
                                                                                           12.7 <revoke statement>



8) For every lost column descriptor CD, let S1.TN be the <table name> of the table whose descriptor includes
   the descriptor CD and let CN be the <column name> of CD. The following <alter table statement> is
   effectively executed without further Access Rule checking:
        ALTER TABLE S1.TN DROP COLUMN CN CASCADE

9) For every lost domain descriptor DO, let S1.DN be the <domain name> of DO. The following <drop domain
   statement> is effectively executed without further Access Rule checking:
        DROP DOMAIN S1.DN CASCADE

10) For every lost schema S1, the default character set of that schema is modified to include the name of the
    implementation-defined <character set specification> that would have been this schema's default character
    set had the <schema definition> not specified a <schema character set specification>.
11) If the object identified by O is a collation, let OCN be the name of that collation.
12) For every descriptor that includes an impacted data type descriptor DTD, DTD is modified such that it does
    not include OCN.
13) For every impacted collation descriptor CD with included collation name CN, the following <drop collation
    statement> is effectively executed without further Access Rule checking:
        DROP COLLATION CN CASCADE

14) For every impacted character set descriptor CSD with included character set name CSN, CSD is modified
    so that the included collation name is the name of the default collation for the character set on which CSD
    is based.
15) For every abandoned user-defined type descriptor DT with <user-defined type name> S1.DTN, the following
    <drop data type statement> is effectively executed without further Access Rule checking:
        DROP TYPE S1.DTN CASCADE

16) For every abandoned SQL-invoked routine descriptor RD, let R be the SQL-invoked routine whose
    descriptor is RD. Let SN be the <specific name> of R. The following <drop routine statement> is effectively
    executed without further Access Rule checking:
        DROP SPECIFIC ROUTINE SN CASCADE

17) If the <revoke statement> is a <revoke privilege statement>, then:
    a) For every combination of <grantee> and <action> on O specified in <privileges>, if there is no corre-
       sponding privilege descriptor in the set of identified privilege descriptors, then a completion condition
       is raised: warning — privilege not revoked.
    b) If ALL PRIVILEGES was specified, then for each <grantee>, if no privilege descriptors were identified,
       then a completion condition is raised: warning — privilege not revoked.
18) For every contaminated column descriptor CD, let S1.TN be the <table name> of the table whose descriptor
    includes the descriptor CD and let CN be the <column name> of CD. The following <alter table statement>
    is effectively executed without further Access Rule checking:



©ISO/IEC 2003 – All rights reserved                                                             Access control 763
ISO/IEC 9075-2:2003 (E)
12.7 <revoke statement>



       ALTER TABLE S1.TN DROP COLUMN CN CASCADE


Conformance Rules
1) Without Feature T331, “Basic roles”, conforming SQL language shall not contain a <revoke role statement>.
2) Without Feature F034, “Extended REVOKE statement”, conforming SQL language shall not contain a
   <revoke statement> that contains a <drop behavior> that contains CASCADE.
3) Without Feature F034, “Extended REVOKE statement”, conforming SQL language shall not contain a
   <revoke option extension> that contains GRANT OPTION FOR.
4) Without Feature F034, “Extended REVOKE statement”, conforming SQL language shall not contain a
   <revoke statement> that contains a <privileges> that contains an <object name> where the owner of the
   SQL-schema that is specified explicitly or implicitly in the <object name> is not the current authorization
   identifier.
5) Without Feature F034, “Extended REVOKE statement”, conforming SQL language shall not contain a
   <revoke statement> such that there exists a privilege descriptor PD that satisfies all the following conditions:
    a) PD identifies the object identified by <object name> simply contained in <privileges> contained in the
       <revoke statement>.
    b) PD identifies the <grantee> identified by any <grantee> simply contained in <revoke statement> and
       that <grantee> does not identify the owner of the SQL-schema that is specified explicitly or implicitly
       in the <object name> simply contained in <privileges> contained in the <revoke statement>.
    c) PD identifies the action identified by the <action> simply contained in <privileges> contained in the
       <revoke statement>.
    d) PD indicates that the privilege is grantable.
6) Without Feature S081, “Subtables”, conforming SQL language shall not contain a <revoke option extension>
   that contains HIERARCHY OPTION FOR.




764 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                        ISO/IEC 9075-2:2003 (E)
                                                              13.1 <SQL-client module definition>




13 SQL-client modules


13.1 <SQL-client module definition>

Function
Define an SQL-client module.


Format
<SQL-client module definition> ::=
    <module name clause> <language clause> <module authorization clause>
    [ <module path specification> ]
    [ <module transform group specification> ]
    [ <module collations> ]
    [ <temporary table declaration>... ]
    <module contents>...

<module authorization clause> ::=
    SCHEMA <schema name>
  | AUTHORIZATION <module authorization identifier>
    [ FOR STATIC { ONLY | AND DYNAMIC } ]
  | SCHEMA <schema name> AUTHORIZATION <module authorization identifier>
    [ FOR STATIC { ONLY | AND DYNAMIC } ]

<module authorization identifier> ::= <authorization identifier>

<module path specification> ::= <path specification>

<module transform group specification> ::= <transform group specification>

<module collations> ::= <module collation specification>...

<module collation specification> ::=
    COLLATION <collation name> [ FOR <character set specification list> ]

<character set specification list> ::=
    <character set specification> [ { <comma> <character set specification> }... ]

<module contents> ::=
    <declare cursor>
  | <dynamic declare cursor>
  | <externally-invoked procedure>


Syntax Rules
1) The <language clause> shall not specify SQL.



©ISO/IEC 2003 – All rights reserved                                      SQL-client modules 765
ISO/IEC 9075-2:2003 (E)
13.1 <SQL-client module definition>



2) If SCHEMA <schema name> is not specified, then a <schema name> equivalent to <module authorization
   identifier> is implicit.
3) If the explicit or implicit <schema name> does not specify a <catalog name>, then an implementation-
   defined <catalog name> is implicit.
4) The implicit or explicit <catalog name> is the implicit <catalog name> for all unqualified <schema name>s
   in the <SQL-client module definition>.
5) If <module path specification> is not specified, then a <module path specification> containing an imple-
   mentation-defined <schema name list> that contains the <schema name> contained in <module authorization
   clause> is implicit.
6) The explicit or implicit <catalog name> of each <schema name> contained in the <schema name list> of
   the <module path specification> shall be equivalent to the <catalog name> of the explicit or implicit <schema
   name> contained in <module authorization clause>.
7) The <schema name list> of the explicit or implicit <module path specification> is used as the SQL-path
   of the <SQL-client module definition>. The SQL-path is used to effectively qualify unqualified <routine
   name>s that are immediately contained in <routine invocation>s that are contained in the <SQL-client
   module definition>.
8) Case:
    a) If <module transform group specification> is not specified, then a <module transform group specifica-
       tion> containing a <multiple group specification> with a <group specification> GS for each <host
       parameter declaration> contained in <host parameter declaration list> of each <externally-invoked
       procedure> contained in <SQL-client module definition> whose <host parameter data type> UDT
       identifies a user-defined type with no <locator indication> is implicit. The <group name> of GS is
       implementation-defined and its <path-resolved user-defined type name> is UDT.
    b) If <module transform group specification> contains a <single group specification> with a <group
       name> GN, then a <module transform group specification> containing a <multiple group specification>
       that contains a <group specification> GS for each <host parameter declaration> contained in <host
       parameter declaration list> of each <externally-invoked procedure> contained in <SQL-client module
       definition> whose <host parameter data type> UDT identifies a user-defined type with no <locator
       indication> is implicit. The <group name> of GS is GN and its <path-resolved user-defined type name>
       is UDT.
    c) If <module transform group specification> contains a <multiple group specification> MGS, then a
       <module transform group specification> containing <multiple group specification> that contains MGS
       extended with a <group specification> GS for each <host parameter declaration> contained in <host
       parameter declaration list> of each <externally-invoked procedure> contained in <SQL-client module
       definition> whose <host parameter data type> UDT identifies a user-defined type with no <locator
       indication> and no equivalent of UDT is contained in any <group specification> contained in MGS is
       implicit. The <group name> of GS is implementation-defined and its <path-resolved user-defined type
       name> is UDT.
9) No two <character set specification>s contained in any <module collation specification> shall be equivalent.
10) A <module collation specification> MCS specifies the SQL-client module collation for one or more char-
    acter sets for the SQL-client module. Let CO be the collation identified by the <collation name> contained
    in MCS.



766 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                             13.1 <SQL-client module definition>



    Case:
    a) If <character set specification list> is specified, then the collation specified by CO shall be applicable
       to every character set identified by a <character set specification> simply contained in the <module
       collation specification>. For each character set specified, the SQL-client module collation for that
       character set is set to CO.
    b) Otherwise, the character sets for which the SQL-client module collation is set to CO are implementation-
       defined.
11) A <declare cursor> shall precede in the text of the <SQL-client module definition> any <externally-invoked
    procedure> or <SQL-invoked routine> that references the <cursor name> of the <declare cursor>.
12) A <dynamic declare cursor> shall precede in the text of the <SQL-client module definition> any <externally-
    invoked procedure> that references the <cursor name> of the <dynamic declare cursor>.
13) If neither FOR STATIC ONLY nor FOR STATIC AND DYNAMIC is specified, then FOR STATIC AND
    DYNAMIC is implicit.
14) For every <declare cursor> in an <SQL-client module definition>, the <SQL-client module definition>
    shall contain exactly one <open statement> that specifies the <cursor name> declared in the <declare cursor>.
    NOTE 338 — See the Syntax Rules of Subclause 14.1, “<declare cursor>”.

15) Let EIP1 and EIP2 be two <externally-invoked procedure>s contained in an <SQL-client module definition>
    that have the same number of <host parameter declaration>s and immediately contain a <fetch statement>
    referencing the same <cursor name>. Let n be the number of <host parameter declaration>s. Let P1i, 1
    (one) ≤ i ≤ n, be the i-th <host parameter declaration> of EIP1. Let DT1i be the <data type> contained in
    P1i. Let P2i be the i-th <host parameter declaration> of EIP2. Let DT2i be the <data type> contained in
    P2i. For each i, 1 (one) ≤ i ≤ n,

    Case:
    a) If DT1i and DT2i both identify a binary large object type, then either P1i and P2i shall both be binary
       large object locator parameters or neither shall be binary large object locator parameters.
    b) If DT1i and DT2i both identify a character large object type, then either P1i and P2i shall both be
       character large object locator parameters or neither shall be character large object locator parameters.
    c) If DT1i and DT2i both identify an array type, then either P1i and P2i shall both be array locator
       parameters or neither shall be array locator parameters.
    d) If DT1i and DT2i both identify a multiset type, then either P1i and P2i shall both be multiset locator
       parameters or neither shall be multiset locator parameters.
    e) If DT1i and DT2i both identify a user-defined type, then either P1i and P2i shall both be user-defined
       type locator parameters or neither shall be user-defined type locator parameters.


Access Rules
    None.



©ISO/IEC 2003 – All rights reserved                                                     SQL-client modules 767
ISO/IEC 9075-2:2003 (E)
13.1 <SQL-client module definition>



General Rules
1) If the SQL-agent that performs a call of an <externally-invoked procedure> in an <SQL-client module
   definition> is not a program that conforms to the programming language standard for the programming
   language specified by the <language clause> of that <SQL-client module definition>, then the effect is
   implementation-dependent.
2) If the SQL-agent performs calls of <externally-invoked procedure>s from more than one Ada task, then
   the results are implementation-dependent.
3) If FOR STATIC ONLY is specified, then the SQL-client module includes an indication that prepared
   statements resulting from execution of externally-invoked procedures included in that module have no
   owner.
4) After the last time that an SQL-agent performs a call of an <externally-invoked procedure>:
    a) A <rollback statement> or a <commit statement> is effectively executed. If an unrecoverable error has
       occurred, or if the SQL-agent terminated unexpectedly, or if any constraint is not satisfied, then a
       <rollback statement> is performed. Otherwise, the choice of which of these SQL-statements to perform
       is implementation-dependent. If the implementation choice is <commit statement>, then all holdable
       cursors are first closed. The determination of whether an SQL-agent has terminated unexpectedly is
       implementation-dependent.
    b) For every SQL descriptor area that is currently allocated within an SQL-session associated with the
       SQL-agent, let D be the <descriptor name> of that SQL descriptor area; a <deallocate descriptor
       statement> that specifies
          DEALLOCATE DESCRIPTOR D
        is effectively executed.
    c) All SQL-sessions associated with the SQL-agent are terminated.


Conformance Rules
1) Without Feature S071, “SQL paths in function and type name resolution”, conforming SQL language shall
   not contain a <module path specification>.
2) Without Feature S241, “Transform functions”, conforming SQL language shall not contain a <module
   transform group specification>.
3) Without Feature F693, “SQL-session and client module collations”, conforming SQL language shall not
   contain a <module collation specification>.
4) Without Feature B051, “Enhanced execution rights”, conforming SQL language shall not contain a
   <module authorization clause> that immediately contains FOR STATIC ONLY or FOR STATIC AND
   DYNAMIC.
5) Without Feature B111, “Module language Ada”, conforming SQL language shall not contain an <SQL-
   client module definition> that contains a <language clause> that contains ADA.
6) Without Feature B112, “Module language C”, conforming SQL language shall not contain an <SQL-client
   module definition> that contains a <language clause> that contains C.


768 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                             ISO/IEC 9075-2:2003 (E)
                                                                   13.1 <SQL-client module definition>



7) Without Feature B113, “Module language COBOL”, conforming SQL language shall not contain an <SQL-
   client module definition> that contains a <language clause> that contains COBOL.
8) Without Feature B114, “Module language Fortran”, conforming SQL language shall not contain an <SQL-
   client module definition> that contains a <language clause> that contains FORTRAN.
9) Without Feature B115, “Module language MUMPS”, conforming SQL language shall not contain an <SQL-
   client module definition> that contains a <language clause> that contains M.
10) Without Feature B116, “Module language Pascal”, conforming SQL language shall not contain an <SQL-
    client module definition> that contains a <language clause> that contains PASCAL.
11) Without Feature B117, “Module language PL/I”, conforming SQL language shall not contain an <SQL-
    client module definition> that contains a <language clause> that contains PLI.




©ISO/IEC 2003 – All rights reserved                                            SQL-client modules 769
ISO/IEC 9075-2:2003 (E)
13.2 <module name clause>



13.2 <module name clause>

Function
Name an SQL-client module.


Format
<module name clause> ::=
    MODULE [ <SQL-client module name> ] [ <module character set specification> ]

<module character set specification> ::= NAMES ARE <character set specification>


Syntax Rules
1) If a <module name clause> does not specify an <SQL-client module name>, then the <SQL-client module
   definition> is unnamed.
2) The <SQL-client module name> shall not be equivalent to the <SQL-client module name> of any other
   <SQL-client module definition> in the same SQL-environment.
    NOTE 339 — An SQL-environment may have multiple <SQL-client module definition>s that are unnamed.

3) If the <language clause> of the containing <SQL-client module definition> specifies ADA, then an <SQL-
   client module name> shall be specified, and that <SQL-client module name> shall be a valid Ada library
   unit name.
4) If a <module character set specification> is not specified, then a <module character set specification> that
   specifies an implementation-defined character set that contains at least every character that is in <SQL
   language character> is implicit.


Access Rules
    None.


General Rules
1) If <SQL-client module name> is specified, then, in the SQL-environment, the containing <SQL-client
   module definition> has the name given by <SQL-client module name>.


Conformance Rules
1) Without Feature F461, “Named character sets”, conforming SQL language shall not contain a <module
   character set specification>.




770 Foundation (SQL/Foundation)                                                        ©ISO/IEC 2003 – All rights reserved
                                                                                                ISO/IEC 9075-2:2003 (E)
                                                                                     13.3 <externally-invoked procedure>



13.3 <externally-invoked procedure>

Function
Define an externally-invoked procedure.


Format
<externally-invoked procedure> ::=
    PROCEDURE <procedure name> <host parameter declaration list> <semicolon>
    <SQL procedure statement> <semicolon>

<host parameter declaration list> ::=
    <left paren> <host parameter declaration>
    [ { <comma> <host parameter declaration> }... ] <right paren>

<host parameter declaration> ::=
    <host parameter name> <host parameter data type>
  | <status parameter>

<host parameter data type> ::= <data type> [ <locator indication> ]

<status parameter> ::= SQLSTATE


Syntax Rules
1) The <procedure name> shall not be equivalent to the <procedure name> of any other <externally-invoked
   procedure> in the containing <SQL-client module definition>.
    NOTE 340 — The <procedure name> should be a standard-conforming procedure, function, or routine name of the language
    specified by the subject <language clause>. Failure to observe this recommendation will have implementation-dependent effects.

2) The <host parameter name> of each <host parameter declaration> in an <externally-invoked procedure>
   shall not be equivalent to the <host parameter name> of any other <host parameter declaration> in that
   <externally-invoked procedure>.
3) Any <host parameter name> contained in the <SQL procedure statement> of an <externally-invoked pro-
   cedure> shall be specified in a <host parameter declaration> in that <externally-invoked procedure>.
4) If <locator indication> is simply contained in <host parameter declaration>, then:
    a) The declared type T identified by the <data type> immediately contained in <host parameter data type>
       shall be either binary large object type, character large object type, array type, multiset type, or user-
       defined type.
    b) If T is a binary large object type, then the host parameter identified by <host parameter name> is called
       a binary large object locator parameter.
    c) If T is a character large object type, then the host parameter identified by <host parameter name> is
       called a character large object locator parameter.




©ISO/IEC 2003 – All rights reserved                                                                 SQL-client modules 771
ISO/IEC 9075-2:2003 (E)
13.3 <externally-invoked procedure>



    d) If T is an array type, then the host parameter identified by <host parameter name> is called an array
       locator parameter.
    e) If T is a multiset type, then the host parameter identified by <host parameter name> is called a multiset
       locator parameter.
    f) If T is a user-defined type, then the host parameter identified by <host parameter name> is called a
       user-defined type locator parameter.
5) A call of an <externally-invoked procedure> shall supply n arguments, where n is the number of <host
   parameter declaration>s in the <externally-invoked procedure>.
6) An <externally-invoked procedure> shall contain one <status parameter> referred to as an SQLSTATE host
   parameter. The SQLSTATE host parameter is referred to as a status parameter.
7) The Syntax Rules of Subclause 9.6, “Host parameter mode determination”, with <host parameter declaration>
   as PD and <SQL procedure statement> as SPS for each <host parameter declaration>, are applied to
   determine whether the corresponding host parameter is an input host parameter, an output host parameter,
   or both an input host parameter and an output host parameter.
8) The Syntax Rules of Subclause 13.4, “Calls to an <externally-invoked procedure>”, shall be satisfied.


Access Rules
    None.


General Rules
1) An <externally-invoked procedure> defines an externally-invoked procedure that may be called by an SQL-
   agent.
2) If the <SQL-client module definition> that contains the <externally-invoked procedure> is associated with
   an SQL-agent that is associated with another <SQL-client module definition> that contains an <externally-
   invoked procedure> with equivalent <procedure name>s, then the effect is implementation-defined.
3) The language identified by the <language name> contained in the <language clause> of the <SQL-client
   module definition> that contains an <externally-invoked procedure> is the caller language of the <externally-
   invoked procedure>.
4) If the SQL-agent that performs a call of a <externally-invoked procedure> is not a program that conforms
   to the programming language standard specified by the caller language of the <externally-invoked proce-
   dure>, then the effect is implementation-dependent.
5) If the caller language of an <externally-invoked procedure> is ADA and the SQL-agent performs calls of
   <externally-invoked procedure>s from more than one Ada task, then the results are implementation-
   dependent.
6) If the <SQL-client module definition> that contains the <externally-invoked procedure> has an explicit
   <module authorization identifier> MAI that is not equivalent to the SQL-session <authorization identifier>
   SAI, then:




772 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                         13.3 <externally-invoked procedure>



    a) Whether or not SAI can invoke <externally-invoked procedure>s in an <SQL-client module definition>
       with explicit <module authorization identifier> MAI is implementation-defined, as are any restrictions
       pertaining to such invocation.
    b) If SAI is restricted from invoking an <externally-invoked procedure> in an <SQL-client module defi-
       nition> with explicit <module authorization identifier> MAI, then an exception condition is raised:
       invalid authorization specification.
7) If the value of any input host parameter provided by the SQL-agent falls outside the set of allowed values
   of the declared type of the host parameter, or if the value of any output host parameter resulting from the
   execution of the <externally-invoked procedure> falls outside the set of values supported by the SQL-agent
   for that host parameter, then the effect is implementation-defined. If the implementation-defined effect is
   the raising of an exception condition, then an exception condition is raised: data exception — invalid
   parameter value.
8) A copy of the top cell of the authorization stack is pushed onto the authorization stack. If the SQL-client
   module M that includes the externally-invoked procedure has an owner, then the top cell of the authorization
   stack is set to contain only the authorization identifier of the owner of M.
9) Let S be the <SQL procedure statement> of the <externally-invoked procedure>.
10) The General Rules of Subclause 13.5, “<SQL procedure statement>”, are evaluated with S as the executing
    statement.
11) Upon completion of execution, the top cell in the authorization stack is removed.


Conformance Rules
1) Without Feature S231, “Structured type locators”, conforming SQL language shall not contain a <host
   parameter data type> that simply contains a <data type> that specifies a structured type and that contains
   a <locator indication>.
2) Without Feature S232, “Array locators”, conforming SQL language shall not contain a <host parameter
   data type> that simply contains an <array type> and that contains a <locator indication>.
3) Without Feature S233, “Multiset locators”, conforming SQL language shall not contain a <host parameter
   data type> that simply contains a <multiset type> and that contains a <locator indication>.




©ISO/IEC 2003 – All rights reserved                                                     SQL-client modules 773
ISO/IEC 9075-2:2003 (E)
13.4 Calls to an <externally-invoked procedure>



13.4 Calls to an <externally-invoked procedure>

Function
Define the call to an <externally-invoked procedure> by an SQL-agent.


Syntax Rules
1) Let n be the number of <host parameter declaration>s in the <externally-invoked procedure> EP being
   called. Let PDi, 1 (one) ≤ i ≤ n, be the i-th <host parameter declaration>. Let PDTi be the <data type>
   contained in PDi.

2) If the caller language of the <externally-invoked procedure> is ADA, then:
    a) The SQL-implementation shall generate the source code of an Ada library unit package ALUP the
       name of which shall be
        Case:
        i)      If the <SQL-client module name> SCMN of the <SQL-client module definition> <SQL-client
                module name> is a valid Ada identifier, then equivalent to SCMN.
        ii)     Otherwise, implementation-defined.
    b) For each <externally-invoked procedure> of the <SQL-client module definition>, there shall appear
       within ALUP a subprogram declaration declaring a procedure.
        i)      If <procedure name> is a valid Ada identifier, then the name of that procedure PN shall be
                equivalent to <procedure name>; otherwise, PN shall be implementation-defined.
        ii)     The parameters in each Ada procedure declaration APD shall appear in the same order as the
                <host parameter declaration>s of the corresponding <externally-invoked procedure> EIP. If the
                names of the parameters declared in the <host parameter declaration>s of EIP are valid Ada
                identifiers, then the parameters in APD shall have parameter names that are equivalent to the
                names of the corresponding parameters declared in the <host parameter declaration>s contained
                in EIP; otherwise, the parameters in APD shall parameter names that are implementation-defined
        iii)    The parameter modes and subtype marks used in the parameter specifications are constrained
                by the remaining paragraphs of this Subclause.

    c) For each i, 1 (one) ≤ i ≤ n, PDTi shall not identify a data type listed in the “SQL data type” column of
       Table 16, “Data type correspondences for Ada”, for which the corresponding row in the “Ada data
       type” column is 'None'.
    d) The types of parameter specifications within the Ada subprogram declarations shall be taken from the
       library unit package Interfaces.SQL and its children Numerics and Varying and optional
       children Adacsn and Adacsn.Varying.
    e) The declaration of the library unit package Interfaces.SQL shall conform to the following template:

        package Interfaces.SQL is



774 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                           ISO/IEC 9075-2:2003 (E)
                                                    13.4 Calls to an <externally-invoked procedure>



         – The declarations of CHAR and NCHAR may be subtype declarations
           type CHAR is (See the Syntax Rules)
           type NCHAR is (See the Syntax Rules)
           type SMALLINT is range bs .. ts;
           type INT is range bi .. ti;
           type BIGINT is range bb .. tb;
           type REAL is digits dr;
           type DOUBLE_PRECISION is digits dd;
           type BOOLEAN is new Boolean;
           subtype INDICATOR_TYPE is t;
           type SQLSTATE_TYPE is new CHAR (1 .. 5);
           package SQLSTATE_CODES is
             AMBIGUOUS_CURSOR_NAME_NO_SUBCLASS:
               constant SQLSTATE_TYPE :="3C000";
             ATTEMPT_TO_ASSIGN_TO_NON_UPDATABLE_COLUMN_NO_SUBCLASS:
               constant SQLSTATE_TYPE := "0U000";
             ATTEMPT_TO_ASSIGN_TO_ORDERING_COLUMN_NO_SUBCLASS:
               constant SQLSTATE_TYPE := "0V000";
             CARDINALITY_VIOLATION_NO_SUBCLASS:
               constant SQLSTATE_TYPE :="21000";
             CLI_SPECIFIC_CONDITION_NO_SUBCLASS:
               constant SQLSTATE_TYPE :="HY000";
             CONNECTION_EXCEPTION_NO_SUBCLASS:
               constant SQLSTATE_TYPE :="08000";
             CONNECTION_EXCEPTION_CONNECTION_DOES_NOT_EXIST:
               constant SQLSTATE_TYPE :="08003";
             CONNECTION_EXCEPTION_CONNECTION_FAILURE:
               constant SQLSTATE_TYPE :="08006";
             CONNECTION_EXCEPTION_CONNECTION_NAME_IN_USE:
               constant SQLSTATE_TYPE :="08002";
             CONNECTION_EXCEPTION_SQLCLIENT_UNABLE_TO_ESTABLISH_SQLCONNECTION:
               constant SQLSTATE_TYPE :="08001";
             CONNECTION_EXCEPTION_SQLSERVER_REJECTED_ESTABLISHMENT_OF_SQLCONNECTION:
               constant SQLSTATE_TYPE :="08004";
             CONNECTION_EXCEPTION_TRANSACTION_RESOLUTION_UNKNOWN:
               constant SQLSTATE_TYPE :="08007";
             DATA_EXCEPTION_NO_SUBCLASS:
               constant SQLSTATE_TYPE :="22000";
             DATA_EXCEPTION_ARRAY_ELEMENT_ERROR:
               constant SQLSTATE_TYPE :="2202E";
             DATA_EXCEPTION_CHARACTER_NOT_IN_REPERTOIRE:
               constant SQLSTATE_TYPE :="22021";
             DATA_EXCEPTION_DATETIME_FIELD_OVERFLOW:
               constant SQLSTATE_TYPE :="22008";
             DATA_EXCEPTION_DIVISION_BY_ZERO:
               constant SQLSTATE_TYPE :="22012";
             DATA_EXCEPTION_ERROR_IN_ASSIGNMENT:
               constant SQLSTATE_TYPE :="22005";
             DATA_EXCEPTION_ESCAPE_CHARACTER_CONFLICT:
               constant SQLSTATE_TYPE :="2200B";
             DATA_EXCEPTION_INDICATOR_OVERFLOW:
               constant SQLSTATE_TYPE :="22022";
             DATA_EXCEPTION_INTERVAL_FIELD_OVERFLOW:
               constant SQLSTATE_TYPE :="22015";
             DATA_EXCEPTION_INTERVAL_VALUE_OUT_OF_RANGE:
               constant SQLSTATE_TYPE :="2200P";



©ISO/IEC 2003 – All rights reserved                                        SQL-client modules 775
ISO/IEC 9075-2:2003 (E)
13.4 Calls to an <externally-invoked procedure>



            DATA_EXCEPTION_INVALID_ARGUMENT_FOR_NATURAL_LOGARITHM:
              constant SQLSTATE_TYPE :="2201E";
            DATA_EXCEPTION_INVALID_ARGUMENT_FOR_POWER_FUNCTION:
              constant SQLSTATE_TYPE :="2201F";
            DATA_EXCEPTION_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION:
              constant SQLSTATE_TYPE :="2201G";
            DATA_EXCEPTION_INVALID_CHARACTER_VALUE_FOR_CAST:
              constant SQLSTATE_TYPE :="22018";
            DATA_EXCEPTION_INVALID_DATETIME_FORMAT:
              constant SQLSTATE_TYPE :="22007";
            DATA_EXCEPTION_INVALID_ESCAPE_CHARACTER:
              constant SQLSTATE_TYPE :="22019";
            DATA_EXCEPTION_INVALID_ESCAPE_OCTET:
              constant SQLSTATE_TYPE :="2200D";
            DATA_EXCEPTION_INVALID_ESCAPE_SEQUENCE:
              constant SQLSTATE_TYPE :="22025";
            DATA_EXCEPTION_INVALID_INDICATOR_PARAMETER_VALUE:
              constant SQLSTATE_TYPE :="22010";
            DATA_EXCEPTION_INVALID_INTERVAL_FORMAT:
              constant SQLSTATE_TYPE :="22006";
            DATA_EXCEPTION_INVALID_PARAMETER_VALUE:
              constant SQLSTATE_TYPE :="22023";
            DATA_EXCEPTION_INVALID_PRECEDING_OR_FOLLOWING_SIZE_IN_WINDOW_FUNCTION:
              constant SQLSTATE_TYPE :="22013";
            DATA_EXCEPTION_INVALID_REGULAR_EXPRESSION:
              constant SQLSTATE_TYPE :="2201B";
            DATA_EXCEPTION_INVALID_REPEAT_ARGUMENT_IN_A_SAMPLE_CLAUSE:
              constant SQLSTATE_TYPE :="2202G";
            DATA_EXCEPTION_INVALID_SAMPLE_SIZE:
              constant SQLSTATE_TYPE :="2202H";
            DATA_EXCEPTION_INVALID_TIME_ZONE_DISPLACEMENT_VALUE:
              constant SQLSTATE_TYPE :="22009";
            DATA_EXCEPTION_INVALID_USE_OF_ESCAPE_CHARACTER:
              constant SQLSTATE_TYPE :="2200C";
            DATA_EXCEPTION_NULL_VALUE_NO_INDICATOR_PARAMETER:
              constant SQLSTATE_TYPE :="2200G";
            DATA_EXCEPTION_MOST_SPECIFIC_TYPE_MISMATCH:
              constant SQLSTATE_TYPE :="22002";
            DATA_EXCEPTION_MULTISET_VALUE_OVERFLOW:
              constant SQLSTATE_TYPE :="2200Q";
            DATA_EXCEPTION_NONCHARACTER_IN_UCS_STRING:
              constant SQLSTATE_TYPE :="22029";
            DATA_EXCEPTION_NULL_VALUE_NOT_ALLOWED:
              constant SQLSTATE_TYPE :="22004";
            DATA_EXCEPTION_NULL_VALUE_SUBSTITUTED_FOR_MUTATOR_SUBJECT_PARAMETER:
              constant SQLSTATE_TYPE :="2202D";
            DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE:
              constant SQLSTATE_TYPE :="22003";
            DATA_EXCEPTION_SEQUENCE_GENERATOR_LIMIT_EXCEEDED:
              constant SQLSTATE_TYPE :="2200H";
            DATA_EXCEPTION_STRING_DATA_LENGTH_MISMATCH:
              constant SQLSTATE_TYPE :="22026";
            DATA_EXCEPTION_STRING_DATA_RIGHT_TRUNCATION:
              constant SQLSTATE_TYPE :="22001";
            DATA_EXCEPTION_SUBSTRING_ERROR:
              constant SQLSTATE_TYPE :="22011";



776 Foundation (SQL/Foundation)                                   ©ISO/IEC 2003 – All rights reserved
                                                                             ISO/IEC 9075-2:2003 (E)
                                                      13.4 Calls to an <externally-invoked procedure>



               DATA_EXCEPTION_TRIM_ERROR:
                 constant SQLSTATE_TYPE :="22027";
               DATA_EXCEPTION_UNTERMINATED_C_STRING:
                 constant SQLSTATE_TYPE :="22024";
               DATA_EXCEPTION_ZERO_LENGTH_CHARACTER_STRING:
                 constant SQLSTATE_TYPE :="2200F";
               DEPENDENT_PRIVILEGE_DESCRIPTORS_STILL_EXIST_NO_SUBCLASS:
                 constant SQLSTATE_TYPE :="2B000";
               DIAGNOSTICS_EXCEPTION_NO_SUBCLASS:
                 constant SQLSTATE_TYPE :="0Z000";
               DIAGNOSTICS_EXCEPTION_MAXIMUM_NUMBER_OF_DIAGNOSTICS_AREAS_EXCEEDED:
                 constant SQLSTATE_TYPE :="0Z001";
               DYNAMIC_SQL_ERROR_NO_SUBCLASS:
                 constant SQLSTATE_TYPE := "07000";
               DYNAMIC_SQL_ERROR_CURSOR_SPECIFICATION_CANNOT_BE_EXECUTED:
                 constant SQLSTATE_TYPE := "07003";
               DYNAMIC_SQL_ERROR_INVALID_DATETIME_INTERVAL_CODE:
                 constant SQLSTATE_TYPE := "0700F";
               DYNAMIC_SQL_ERROR_INVALID_DESCRIPTOR_COUNT:
                 constant SQLSTATE_TYPE := "07008";
               DYNAMIC_SQL_ERROR_INVALID_DESCRIPTOR_INDEX:
                 constant SQLSTATE_TYPE := "07009";
               DYNAMIC_SQL_ERROR_PREPARED_STATEMENT_NOT_A_CURSOR_SPECIFICATION:
                 constant SQLSTATE_TYPE := "07005";
               DYNAMIC_SQL_ERROR_RESTRICTED_DATA_TYPE_ATTRIBUTE_VIOLATION:
                 constant SQLSTATE_TYPE := "07006";
               DYNAMIC_SQL_ERROR_DATA_TYPE_TRANSFORM_FUNCTION_VIOLATION:
                 constant SQLSTATE_TYPE := "0700B";
               DYNAMIC_SQL_ERROR_INVALID_DATA_TARGET:
                 constant SQLSTATE_TYPE := "0700D";
               DYNAMIC_SQL_ERROR_INVALID_LEVEL_VALUE:
                 constant SQLSTATE_TYPE := "0700E";
               DYNAMIC_SQL_ERROR_UNDEFINED_DATA_VALUE:
                 constant SQLSTATE_TYPE := "0700C";
               DYNAMIC_SQL_ERROR_USING_CLAUSE_DOES_NOT_MATCH_DYNAMIC_PARAMETER_SPEC:
                 constant SQLSTATE_TYPE := "07001";
               DYNAMIC_SQL_ERROR_USING_CLAUSE_DOES_NOT_MATCH_TARGET_SPEC:
                 constant SQLSTATE_TYPE := "07002";
               DYNAMIC_SQL_ERROR_USING_CLAUSE_REQUIRED_FOR_DYNAMIC_PARAMETERS:
                 constant SQLSTATE_TYPE := "07004";
               DYNAMIC_SQL_ERROR_USING_CLAUSE_REQUIRED_FOR_RESULT_FIELDS:
                 constant SQLSTATE_TYPE := "07007";
               EXTERNAL_ROUTINE_EXCEPTION_NO_SUBCLASS:
                 constant SQLSTATE_TYPE :="38000";
               EXTERNAL_ROUTINE_EXCEPTION_CONTAINING_SQL_NOT_PERMITTED:
                 constant SQLSTATE_TYPE :="38001";
               EXTERNAL_ROUTINE_EXCEPTION_MODIFYING_SQL_DATA_NOT_PERMITTED:
                 constant SQLSTATE_TYPE :="38002";
               EXTERNAL_ROUTINE_EXCEPTION_PROHIBITED_SQL_STATEMENT_ATTEMPTED:
                 constant SQLSTATE_TYPE :="38003";
               EXTERNAL_ROUTINE_EXCEPTION_READING_SQL_DATA_NOT_PERMITTED:
                 constant SQLSTATE_TYPE :="38004";
               EXTERNAL_ROUTINE_INVOCATION_EXCEPTION_NO_SUBCLASS:
                 constant SQLSTATE_TYPE :="39000";
               EXTERNAL_ROUTINE_INVOCATION_EXCEPTION_NULL_VALUE_NOT_ALLOWED:
                 constant SQLSTATE_TYPE :="39004";



©ISO/IEC 2003 – All rights reserved                                          SQL-client modules 777
ISO/IEC 9075-2:2003 (E)
13.4 Calls to an <externally-invoked procedure>



            FEATURE_NOT_SUPPORTED_NO_SUBCLASS:
              constant SQLSTATE_TYPE :="0A000";
            FEATURE_NOT_SUPPORTED_MULTIPLE_ENVIRONMENT_TRANSACTIONS:
              constant SQLSTATE_TYPE :="0A001";
            INTEGRITY_CONSTRAINT_VIOLATION_NO_SUBCLASS:
              constant SQLSTATE_TYPE :="23000";
            INTEGRITY_CONSTRAINT_VIOLATION_RESTRICT_VIOLATION:
              constant SQLSTATE_TYPE :="23001";
            INVALID_AUTHORIZATION_SPECIFICATION_NO_SUBCLASS:
              constant SQLSTATE_TYPE :="28000";
            INVALID_CATALOG_NAME_NO_SUBCLASS:
              constant SQLSTATE_TYPE :="3D000";
            INVALID_CHARACTER_SET_NAME_NO_SUBCLASS:
              constant SQLSTATE_TYPE :="2C000";
            INVALID_COLLATION_NAME_NO_SUBCLASS:
              constant SQLSTATE_TYPE :="2H000";
            INVALID_CONDITION_NUMBER_NO_SUBCLASS:
              constant SQLSTATE_TYPE :="35000";
            INVALID_CONNECTION_NAME_NO_SUBCLASS:
              constant SQLSTATE_TYPE :="2E000";
            INVALID_CURSOR_NAME_NO_SUBCLASS:
              constant SQLSTATE_TYPE :="34000";
            INVALID_CURSOR_STATE_NO_SUBCLASS:
              constant SQLSTATE_TYPE :="24000";
            INVALID_GRANTOR_STATE_NO_SUBCLASS:
              constant SQLSTATE_TYPE :="0L000";
            INVALID_ROLE_SPECIFICATION:
              constant SQLSTATE_TYPE :="0P000";
            INVALID_SCHEMA_NAME_NO_SUBCLASS:
              constant SQLSTATE_TYPE :="3F000";
            INVALID_SCHEMA_NAME_LIST_SPECIFICATION_NO_SUBCLASS:
              constant SQLSTATE_TYPE :="0E000";
            INVALID_SQL_DESCRIPTOR_NAME_NO_SUBCLASS:
              constant SQLSTATE_TYPE :="33000";
            INVALID_SQL_INVOKED_PROCEDURE_REFERENCE_NO_SUBCLASS:
              constant SQLSTATE_TYPE :="0M000";
            INVALID_SQL_STATEMENT:
              constant SQLSTATE_TYPE :="30000";
            INVALID_SQL_STATEMENT_IDENTIFIER_NO_SUBCLASS:
              constant SQLSTATE_TYPE :="30000";
            INVALID_SQL_STATEMENT_NAME_NO_SUBCLASS:
              constant SQLSTATE_TYPE :="26000";
            INVALID_TRANSFORM_GROUP_NAME_SPECIFICATION_NO_SUBCLASS:
              constant SQLSTATE_TYPE :="0S000";
            INVALID_TRANSACTION_STATE_NO_SUBCLASS:
              constant SQLSTATE_TYPE :="25000";
            INVALID_TRANSACTION_STATE_ACTIVE_SQL_TRANSACTION:
              constant SQLSTATE_TYPE :="25001";
            INVALID_TRANSACTION_STATE_BRANCH_TRANSACTION_ALREADY_ACTIVE:
              constant SQLSTATE_TYPE :="25002";
            INVALID_TRANSACTION_STATE_HELD_CURSOR_REQUIRES_SAME_ISOLATION_LEVEL:
              constant SQLSTATE_TYPE :="25008";
            INVALID_TRANSACTION_STATE_INAPPROPRIATE_ACCESS_MODE_FOR_BRANCH_TRANSACTION:
              constant SQLSTATE_TYPE :="25003";
            INVALID_TRANSACTION_STATE_INAPPROPRIATE_ISOLATION_LEVEL_FOR_BRANCH_TRANSACTION:




778 Foundation (SQL/Foundation)                                    ©ISO/IEC 2003 – All rights reserved
                                                                             ISO/IEC 9075-2:2003 (E)
                                                      13.4 Calls to an <externally-invoked procedure>



                 constant SQLSTATE_TYPE :="25004";
               INVALID_TRANSACTION_STATE_NO_ACTIVE_SQL_TRANSACTION_FOR_BRANCH_TRANSACTION:
                 constant SQLSTATE_TYPE :="25005";
               INVALID_TRANSACTION_STATE_READ_ONLY_SQL_TRANSACTION:
                 constant SQLSTATE_TYPE :="25006";
               INVALID_TRANSACTION_STATE_SCHEMA_AND_DATA_STATEMENT_MIXING_NOT_SUPPORTED:
                 constant SQLSTATE_TYPE :="25007";
               INVALID_TRANSACTION_INITIATION_NO_SUBCLASS:
                 constant SQLSTATE_TYPE :="0B000";
               INVALID_TRANSACTION_TERMINATION_NO_SUBCLASS:
                 constant SQLSTATE_TYPE :="2D000";
               LOCATOR_EXCEPTION_INVALID_SPECIFICATION:
                 constant SQLSTATE_TYPE :="0F001";
               LOCATOR_EXCEPTION_NO_SUBCLASS:
                 constant SQLSTATE_TYPE :="0F000";
               NO_DATA_NO_SUBCLASS:
                 constant SQLSTATE_TYPE :="02000";
               NO_DATA_NO_ADDITIONAL_DYNAMIC_RESULT_SETS_RETURNED:
                 constant SQLSTATE_TYPE :="02001";
               REMOTE_DATABASE_ACCESS_NO_SUBCLASS:
                 constant SQLSTATE_TYPE :="HZ000";
               SAVEPOINT_EXCEPTION_INVALID_SPECIFICATION:
                 constant SQLSTATE_TYPE :="3B001";
               SAVEPOINT_EXCEPTION_NO_SUBCLASS:
                 constant SQLSTATE_TYPE :="3B000";
               SAVEPOINT_EXCEPTION_TOO_MANY:
                 constant SQLSTATE_TYPE :="3B002";
               SQL_ROUTINE_EXCEPTION_NO_SUBCLASS:
                 constant SQLSTATE_TYPE :="2F000";
               SQL_ROUTINE_EXCEPTION_FUNCTION_EXECUTED_NO_RETURN_STATEMENT:
                 constant SQLSTATE_TYPE :="2F005";
               SQL_ROUTINE_EXCEPTION_MODIFYING_SQL_DATA_NOT_PERMITTED:
                 constant SQLSTATE_TYPE :="2F002";
               SQL_ROUTINE_EXCEPTION_PROHIBITED_SQL_STATEMENT_ATTEMPTED:
                 constant SQLSTATE_TYPE :="2F003";
               SQL_ROUTINE_EXCEPTION_READING_SQL_DATA_NOT_PERMITTED:
                 constant SQLSTATE_TYPE :="2F004";
               SUCCESSFUL_COMPLETION_NO_SUBCLASS:
                 constant SQLSTATE_TYPE :="00000";
               SYNTAX_ERROR_OR_ACCESS_RULE_VIOLATION_NO_SUBCLASS:
                 constant SQLSTATE_TYPE :="42000";
               SYNTAX_ERROR_OR_ACCESS_RULE_VIOLATION_IN_DIRECT_STATEMENT_NO_SUBCLASS:
                 constant SQLSTATE_TYPE :="2A000";
               SYNTAX_ERROR_OR_ACCESS_RULE_VIOLATION_IN_DYNAMIC_STATEMENT_NO_SUBCLASS:
                 constant SQLSTATE_TYPE :="37000";
               TARGET_TABLE_DISAGREES_WITH_CURSOR_SPECIFICATION_NO_SUBCLASS:
                 constant SQLSTATE_TYPE :="0T000";
               TRANSACTION_ROLLBACK_NO_SUBCLASS:
                 constant SQLSTATE_TYPE :="40000";
               TRANSACTION_ROLLBACK_INTEGRITY_CONSTRAINT_VIOLATION:
                 constant SQLSTATE_TYPE :="40002";
               TRANSACTION_ROLLBACK_SERIALIZATION_FAILURE:
                 constant SQLSTATE_TYPE :="40001";
               TRANSACTION_ROLLBACK_STATEMENT_COMPLETION_UNKNOWN:
                 constant SQLSTATE_TYPE :="40003";
               TRIGGERED_DATA_CHANGE_VIOLATION_NO_SUBCLASS:



©ISO/IEC 2003 – All rights reserved                                          SQL-client modules 779
ISO/IEC 9075-2:2003 (E)
13.4 Calls to an <externally-invoked procedure>



              constant SQLSTATE_TYPE :="27000";
            WARNING_NO_SUBCLASS:
              constant SQLSTATE_TYPE :="01000";
            WARNING_ADDITIONAL_RESULT_SETS_RETURNED:
              constant SQLSTATE_TYPE :="0100D";
            WARNING_ARRAY_DATA_RIGHT_TRUNCATION:
              constant SQLSTATE_TYPE :="0102F";
            WARNING_ATTEMPT_TO_RETURN_TOO_MANY_RESULT_SETS:
              constant SQLSTATE_TYPE :="0100E";
            WARNING_CURSOR_OPERATION_CONFLICT:
              constant SQLSTATE_TYPE :="01001";
            WARNING_DEFAULT_VALUE_TOO_LONG_FOR_INFORMATION_SCHEMA:
              constant SQLSTATE_TYPE :="0100B";
            WARNING_DISCONNECT_ERROR:
              constant SQLSTATE_TYPE :="01002";
            WARNING_DYNAMIC_RESULT_SETS_RETURNED:
              constant SQLSTATE_TYPE :="0100C";
            WARNING_INSUFFICIENT_ITEM_DESCRIPTOR_AREAS:
              constant SQLSTATE_TYPE :="01005";
            WARNING_NULL_VALUE_ELIMINATED_IN_SET_FUNCTION:
              constant SQLSTATE_TYPE :="01003";
            WARNING_PRIVILEGE_NOT_GRANTED:
              constant SQLSTATE_TYPE :="01007";
            WARNING_PRIVILEGE_NOT_REVOKED:
              constant SQLSTATE_TYPE :="01006";
            WARNING_QUERY_EXPRESSION_TOO_LONG_FOR_INFORMATION_SCHEMA:
              constant SQLSTATE_TYPE :="0100A";
            WARNING_SEARCH_CONDITION_TOO_LONG_FOR_INFORMATION_SCHEMA:
              constant SQLSTATE_TYPE :="01009";
            WARNING_STATEMENT_TOO_LONG_FOR_INFORMATION_SCHEMA:
              constant SQLSTATE_TYPE :="0100F";
            WARNING_STRING_DATA_RIGHT_TRUNCATION_WARNING:
              constant SQLSTATE_TYPE :="01004";
            WITH_CHECK_OPTION_VIOLATION_NO_SUBCLASS:
              constant SQLSTATE_TYPE :="44000";
          end SQLSTATE_CODES;
        end Interfaces.SQL;

        where bs, ts, bi, ti, bb, tb, dr, dd, bsc, and tsc are implementation-defined integer values. t is INT or
        SMALLINT, corresponding with an implementation-defined <exact numeric type> of indicator
        parameters.
        NOTE 341 — The Ada identifier INVALID_SQL_STATEMENT appears for compatibility with earlier editions of ISO/IEC
        9075. However, the intended symbol is INVALID_SQL_STATEMENT_IDENTIFIER_NO_SUBCLASS, which has been
        added in this edition of ISO/IEC 9075 to correspond correctly with the exception condition name.

    f) The library unit package Interfaces.SQL.Numerics shall contain a sequence of decimal fixed
       point type declarations of the following form.
          type Scale_s is delta 10.0 ** - s digits max_p;

        where s is an integer ranging from 0 (zero) to an implementation-defined maximum value and max_p
        is an implementation-defined integer maximum precision.
    g) The library unit package Interfaces.SQL.Varying shall contain type or subtype declarations
       with the defining identifiers CHAR and NCHAR.


780 Foundation (SQL/Foundation)                                                       ©ISO/IEC 2003 – All rights reserved
                                                                                                 ISO/IEC 9075-2:2003 (E)
                                                                          13.4 Calls to an <externally-invoked procedure>



    h) Let SQLcsn be a <character set name> and let Adacsn be the result of replacing <period>'s in SQLcsn
       with <underscore>s. If Adacsn is a valid Ada identifier, then the library unit packages Inter-
       faces.SQL.Adacsn and Interfaces.SQL.Adacsn.Varying shall contain a type or subtype
       declaration with defining identifier CHAR. If Adacsn is not a valid Ada identifier, then the names of
       these packages shall be implementation-defined.
    i)   Interfaces.SQL and its children may contain context clauses and representation items as needed.
         These packages may also contain declarations of Ada character types as needed to support the declara-
         tions of the types CHAR and NCHAR.
         NOTE 342 — If the implementation-defined character set specification used by default with a fixed-length character string
         type is Latin1, then the declaration

             subtype CHAR is String;

         within Interfaces.SQL and the declaration

             subtype CHAR is
                 Ada.Strings.Unbounded.Unbounded_String;

         within Interfaces.SQL.Varying (assuming the appropriate context clause) conform to the requirements of this paragraph
         of this Subclause. If the character set underlying NATIONAL CHARACTER is supported by an Ada package specification
         Host_Char_Pkg that declares a type String_Type that stores strings over the given character set, and furthermore the
         package specification Host_Char_Pkg_Varying (not necessary distinct from Host_Char_Pkg) declares a type
         String_Type_Varying that reproduces the functionality of Ada.Strings.Unbounded.Unbounded_String
         over the national character string type (rather than Latin1), then the declaration

             subtype NCHAR is Host_Char_Pkg.String_Type;

         within Interfaces.SQL and the declaration

             subtype NCHAR is Host_Char_Pkg_Varying.String_Type_Varying;

         within Interfaces.SQL.Varying conform to the requirements of this paragraph. Similar comments apply to other
         character sets and the packages Interfaces.SQL.Adacsn and Interfaces.SQL.Adacsn.Varying.

    j)   The library unit package Interfaces.SQL shall contain declarations of the following form:
             package CHARACTER_SET renames Interfaces.SQL.Adacsn;
             subtype CHARACTER_TYPE is CHARACTER_SET.cst;

         where cst is a data type capable of storing a single character from the default character set. The package
         Interfaces.SQL.Adacsn shall contain the necessary declaration for cst.
         NOTE 343 — If the default character set is Latin1, then a declaration of the form:

             package CHARACTER_SET is
                subtype cst is Character;
             end CHARACTER_SET;

         may be substituted for the renaming declaration of CHARACTER_SET.

    k) The base type of the SQLSTATE parameter shall be Interfaces.SQL.SQLSTATE_TYPE.
    l)   The Ada parameter mode of the SQLSTATE parameter is out.
    m) If the i-th <host parameter declaration> specifies a <data type> that is:




©ISO/IEC 2003 – All rights reserved                                                                  SQL-client modules 781
ISO/IEC 9075-2:2003 (E)
13.4 Calls to an <externally-invoked procedure>



         i)       CHARACTER(L) for some L, then the subtype mark in the i-th parameter declaration shall
                  specify Interfaces.SQL.CHAR.
         ii)      CHARACTER VARYING(L) for some L, then the subtype mark in the i-th parameter declaration
                  shall specify Interfaces.SQL.VARYING.CHAR.
         iii)     NATIONAL CHARACTER(L) for some L, then the subtype mark in the i-th parameter declara-
                  tion shall specify Interfaces.SQL.NCHAR.
         iv)      NATIONAL CHARACTER VARYING(L) for some L, then the subtype mark in the i-th
                  parameter declaration shall specify Interfaces.SQL.VARYING.NCHAR.
         v)       CHARACTER(L) CHARACTER SET csn for some L and some character set name csn, then
                  the subtype mark in the i-th parameter declaration shall specify Inter-
                  faces.SQL.Adacsn.CHAR.
         vi)      CHARACTER VARYING(L) CHARACTER SET csn for some L and some character set name
                  csn, then the subtype mark in the i-th parameter declaration shall specify Inter-
                  faces.SQL.Adacsn.VARYING.CHAR.
         If P is an actual parameter associated with the i-th parameter in a call to the encompassing procedure,
         then P shall be sufficient to hold a character string of length L in the appropriate character set.
         NOTE 344 — If a character set uses fixed length encodings then the definition of the subtype CHAR for fixed length strings
         may be an array type whose element type is an Ada character type. If that Ada character type is defined so as to use the
         number of bits per character used by the SQL encoding, then the restriction on P is precisely P'LENGTH = L. For variable
         length strings using fixed length encodings, if the definition of CHAR in the appropriate VARYING package is based on the
         type Ada.Strings.Unbounded.Unbounded_String, there is no restriction on P. Otherwise, a precise statement of
         the restriction on P is implementation-defined.

    n) If the i-th <host parameter declaration> specifies a <data type> that is NUMERIC(P,S) for some
       <precision> P and <scale> S, then the Ada library unit package generated for the encompassing module
       shall contain a declaration equivalent to:
               subtype Numeric_p_s is
                 Interfaces.SQL.Numerics.Scale_s digits p;

         The subtype mark in the i-th parameter specification shall specify this subtype.
    o) If the i-th <host parameter declaration> specifies a <data type> that is SMALLINT, then the subtype
       mark in the i-th parameter declaration shall specify Interfaces.SQL.SMALLINT.
    p) If the i-th <host parameter declaration> specifies a <data type> that is INTEGER, then the subtype
       mark in the i-th parameter declaration shall specify Interfaces.SQL.INT.
    q) If the i-th <host parameter declaration> specifies a <data type> that is BIGINT, then the subtype mark
       in the i-th parameter declaration shall specify Interfaces.SQL.BIGINT.
    r) If the i-th <host parameter declaration> specifies a <data type> that is REAL, then the subtype mark
       in the i-th parameter declaration shall specify Interfaces.SQL.REAL.
    s) If the i-th <host parameter declaration> specifies a <data type> that is DOUBLE_PRECISION, then
       the subtype mark in the i-th parameter declaration shall specify Interfaces.SQL.DOUBLE_PRE-
       CISION.
    t)   For every parameter,


782 Foundation (SQL/Foundation)                                                                ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                 13.4 Calls to an <externally-invoked procedure>



         Case:
         i)       If the parameter is an input parameter but not an output parameter, then the Ada parameter mode
                  is in.
         ii)      If the parameter is an output parameter but not an input parameter, then the Ada parameter mode
                  is out.
         iii)     If the parameter is both an input parameter and an output parameter, then the Ada parameter
                  mode is in out.
         iv)      Otherwise, the Ada parameter mode is in, out, or in out.
    u) The following Ada library unit renaming declaration exists:
               with Interfaces.SQL;
               package SQL_Standard renames Interfaces.SQL.


3) If the caller language of the <externally-invoked procedure> is C, then:
    a) The declared type of an SQLSTATE host parameter shall be C char with length 6.

    b) For each i, 1 (one) < i ≤ n, PDTi shall not identify a data type listed in the “SQL data type” column of
       Table 17, “Data type correspondences for C”, for which the corresponding row in the “C data type”
       column is 'None'.

    c) For each i, 1 (one) < i ≤ n, the type of the i-th host parameter shall be the data type listed in the “C data
       type” column of Table 17, “Data type correspondences for C”, for which the corresponding row in the
       “SQL data type” column is PDTi.

4) If the caller language of the <externally-invoked procedure> is COBOL, then:
    a) The declared type of an SQLSTATE host parameter shall be COBOL PICTURE X(5).

    b) For each i, 1 (one) ≤ i ≤ n, PDTi shall not identify a data type listed in the “SQL data type” column of
       Table 18, “Data type correspondences for COBOL”, for which the corresponding row in the “COBOL
       data type” column is 'None'.

    c) For each i, 1 (one) < i ≤ n, the type of the i-th host parameter shall be the data type listed in the “COBOL
       data type” column of Table 18, “Data type correspondences for COBOL”, for which the corresponding
       row in the “SQL data type” column is PDTi.

5) If the caller language of the <externally-invoked procedure> is FORTRAN, then:
    a) The declared type of an SQLSTATE host parameter shall be Fortran CHARACTER with length 5.

    b) For each i, 1 (one) ≤ i ≤ n, PDTi shall not identify a data type listed in the “SQL data type” column of
       Table 19, “Data type correspondences for Fortran”, for which the corresponding row in the “Fortran
       data type” column is 'None'.




©ISO/IEC 2003 – All rights reserved                                                       SQL-client modules 783
ISO/IEC 9075-2:2003 (E)
13.4 Calls to an <externally-invoked procedure>



    c) For each i, 1 (one) < i ≤ n, the type of the i-th host parameter shall be the data type listed in the “Fortran
       data type” column of Table 19, “Data type correspondences for Fortran”, for which the corresponding
       row in the “SQL data type” column is PDTi.

6) If the caller language of the <externally-invoked procedure> is M, then:
    a) The declared type of an SQLSTATE host parameter shall be M character with maximum length greater
       than or equal to 5.

    b) For each i, 1 (one) ≤ i ≤ n, PDTi shall not identify a data type listed in the “SQL data type” column of
       Table 20, “Data type correspondences for M”, for which the corresponding row in the “MUMPS data
       type” column is 'None'.

    c) For each i, 1 (one) < i ≤ n, the type of the i-th host parameter shall be the data type listed in the “MUMPS
       data type” column of Table 20, “Data type correspondences for M”, for which the corresponding row
       in the “SQL data type” column is PDTi.

7) If the caller language of the <externally-invoked procedure> is PASCAL, then:
    a) The declared type of an SQLSTATE host parameter shall be Pascal PACKED ARRAY[1..5] OF CHAR.

    b) For each i, 1 (one) ≤ i ≤ n, PDTi shall not identify a data type listed in the “SQL data type” column of
       Table 21, “Data type correspondences for Pascal”, for which the corresponding row in the “Pascal data
       type” column is 'None'.

    c) For each i, 1 (one) < i ≤ n, the type of the i-th host parameter shall be the data type listed in the “Pascal
       data type” column of Table 21, “Data type correspondences for Pascal”, for which the corresponding
       row in the “SQL data type” column is PDTi.

8) If the caller language of the <externally-invoked procedure> is PLI, then:
    a) The declared type of an SQLSTATE host parameter shall be PL/I CHARACTER(5).

    b) For each i, 1 (one) ≤ i ≤ n, PDTi shall not identify a data type listed in the “SQL data type” column of
       Table 22, “Data type correspondences for PL/I”, for which the corresponding row in the “PL/I data
       type” column is 'None'.

    c) For each i, 1 (one) < i ≤ n, the type of the i-th host parameter shall be the data type listed in the “PL/I
       data type” column of Table 22, “Data type correspondences for PL/I”, for which the corresponding
       row in the “SQL data type” column is PDTi.


Access Rules
    None.


General Rules
1) Let EP, PD, PN, DT, and PI be a PROC, a DECL, a NAME, a TYPE, and an ARG specified in an application
   of the General Rules of this Subclause. Let P be the host parameter corresponding to PD.


784 Foundation (SQL/Foundation)                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                                  ISO/IEC 9075-2:2003 (E)
                                                                           13.4 Calls to an <externally-invoked procedure>



2) If the General Rules of this Subclause are being applied for the evaluation of input parameters, and P is
   either an input host parameter or both an input host parameter and an output host parameter, then
    Case:
    a) If DT identifies a CHARACTER(L) or CHARACTER VARYING(L) data type and the caller language
       of EP is C, then a reference to PN is implicitly treated as a character string type value in the specified
       character set in which the octets of PI are the corresponding octets of that value.
         When such a reference is evaluated,
         Case:
         i)       If DT identifies a CHARACTER(L) data type and some C character preceding the least significant
                  C character of the value PI contains the implementation-defined null character that terminates
                  a C character string, then the remaining characters of the value are set to <space>s.
         ii)      If DT identifies a CHARACTER VARYING(L), then the length in characters of the value is set
                  to the number of characters of PIi that precede the implementation-defined null character that
                  terminates a C character string.
         iii)     If the least significant C character of the value PI does not contain the implementation-defined
                  null character that terminates a C character string, then an exception condition is raised: data
                  exception — unterminated C string; otherwise, that least significant C character does not corre-
                  spond to any character in PIi and is ignored.

    b) If DT identifies a CHARACTER(L) data type and the caller language of EP is either COBOL, FOR-
       TRAN, or PASCAL, or DT identifies a CHARACTER VARYING(L) data type and the caller language
       of EP is M, or DT identifies a CHARACTER(L) data type or CHARACTER VARYING(L) data type
       and the caller language of EP is PLI, then a reference to PN is implicitly treated as a character string
       type value in the specified character set in which the octets of PI are the corresponding octets of that
       value.
         NOTE 345 — In the preceding 2 Rules, the phrase “implementation-defined null character that terminates a C character
         string” implies one or more octets all of whose bits are zero and whose number is equal to the number of octets in the largest
         character of the character set of DT.

    c) If DT identifies INT, DEC, or REAL and the caller language of EP is M, then a reference to PN is
       implicitly treated as:
               CAST ( PI AS DT )


    d) If DT identifies a BOOLEAN type, then
         Case:
         i)       If the caller language of EP is ADA, then if PI is False, then a reference to PN has the value
                  False; otherwise, a reference to PN has the value True.
         ii)      If the caller language of EP is C, then if PI is 0 (zero), then a reference to PN has the value
                  False; otherwise, a reference to PN has the value True.
         iii)     If the caller language of EP is COBOL, then if PI is 'F', then a reference to PN has the value
                  False; otherwise, a reference to PN has the value True.



©ISO/IEC 2003 – All rights reserved                                                                     SQL-client modules 785
ISO/IEC 9075-2:2003 (E)
13.4 Calls to an <externally-invoked procedure>



        iv)     If the caller language of EP is FORTRAN, then if PI is .FALSE., then a reference to PN has the
                value False; otherwise, a reference to PN has the value True.
        v)      If the caller language of EP is PLI, then if PI is '0'B, then a reference to PN has the value False;
                otherwise, a reference to PN has the value True.
        NOTE 346 — Pascal has a Boolean-type whose values are True and False.

    e) If P is a binary large object locator parameter, a character large object locator parameter, an array
       locator parameter, a multiset locator parameter, or a user-defined type locator parameter, then a reference
       to PN in a <general value specification> has the corresponding large object value, the large object
       character string value, the array value, the multiset value, or the user-defined type value, respectively,
       corresponding to PI.
    f) If DT identifies a CHARACTER LARGE OBJECT or BINARY LARGE OBJECT type, then
        Case:
        i)      If the caller language of EP is C, then a reference to PN is implicitly treated as
                Case:
                1) If DT identifies a CHARACTER LARGE OBJECT type, then a character string containing
                   the PN.PN_length characters of PN.PN_data starting at character number 1 (one) in the
                   same order that the characters appear in PN.PN_data.
                2) If DT identifies a BINARY LARGE OBJECT type, then a binary large object string contain-
                   ing the PN.PN_length octets of PN.PN_data starting at octet number 1 (one) in the same
                   order that the octets appear in PN.PN_data.
        ii)     If the caller language of EP is COBOL, then a reference to PN is implicitly treated as
                Case:
                1) If DT identifies a CHARACTER LARGE OBJECT type, then a character string containing
                   the PN.PN_length characters of PN.PN_data starting at character number 1 (one) in the
                   same order that the characters appear in PN.PN_data.
                2) If DT identifies a BINARY LARGE OBJECT type, then a binary large object string contain-
                   ing the PN.PN_length octets of PN.PN_data starting at octet number 1 (one) in the same
                   order that the octets appear in PN.PN_data.
        iii)    If the caller language of EP is FORTRAN, then a reference to PN is implicitly treated as
                Case:
                1) If DT identifies a CHARACTER LARGE OBJECT type, then a character string containing
                   the PN.PN_length characters of PN.PN_data starting at character number 1 (one) in the
                   same order that the characters appear in PN.PN_data.
                2) If DT identifies a BINARY LARGE OBJECT type, then a binary large object string contain-
                   ing the PN.PN_length octets of PN.PN_data starting at octet number 1 (one) in the same
                   order that the octets appear in PN.PN_data.
        iv)     If the caller language of EP is PLI, then a reference to PN is implicitly treated as



786 Foundation (SQL/Foundation)                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                                  ISO/IEC 9075-2:2003 (E)
                                                                           13.4 Calls to an <externally-invoked procedure>



                  Case:
                  1) If DT identifies a CHARACTER LARGE OBJECT type, then a character string containing
                     the PN.PN_length characters of PN.PN_data starting at character number 1 (one) in the
                     same order that the characters appear in PN.PN_data.
                  2) If DT identifies a BINARY LARGE OBJECT type, then a binary large object string contain-
                     ing the PN.PN_length octets of PN.PN_data starting at octet number 1 (one) in the same
                     order that the octets appear in PN.PN_data.
    g) Otherwise, a reference to PN in a <general value specification> has the value PI.
3) If the General Rules of this Subclause are being applied for the evaluation of output parameters, and P is
   either an output host parameter or both an input host parameter and an output host parameter, then
    Case:
    a) If DT identifies CHARACTER(L) or CHARACTER VARYING(L) data types and the caller language
       of EP is C, then let CL be k greater than the maximum possible length in octets of PN, where k is the
       size in octets of the largest character in the character set of DT. A reference to PN that assigns some
       value SV to PN implicitly assigns a value that is an SQL CHARACTER(CL) data type in which octets
       of the value are the corresponding octets of SVi, padded on the right with <space>s as necessary to
       reach the length CL, concatenated with a single implementation-defined null character that terminates
       a C character string.
    b) If DT identifies a CHARACTER(L) data type and the caller language of EP is either COBOL, FOR-
       TRAN, or PASCAL, then let CL be the maximum possible length in octets of PN. A reference to PN
       that assigns some value SV to PN implicitly assigns a value that is an SQL CHARACTER(CL) data
       type in which octets of the value are the corresponding octets of SV, padded on the right with <space>s
       as necessary to reach the length CL.
    c) If DT identifies a CHARACTER VARYING(L) data type and the caller language of EP is M, then a
       reference to PN that assigns some value SV to PN implicitly assigns a value that is an SQL CHARACTER
       VARYING(ML) data type in which octets of the value are the corresponding octets of SV, padded on
       the right with <space>s as necessary to reach the length CL. ML is the implementation-defined maximum
       length of variable-length character strings.
    d) If DT identifies a CHARACTER(L) or CHARACTER VARYING(L) data types and the caller language
       of EP is PLI, then let CL be the maximum possible length in octets of PN. A reference to PN that
       assigns some value SV to PN implicitly assigns a value that is
         Case:
         i)       If DT identifies CHARACTER(L), then an SQL CHARACTER(CL) data type.
         ii)      Otherwise, an SQL CHARACTER VARYING(CL) data type in which octets of the value are
                  the corresponding octets of SV, padded on the right with <space>s as necessary to reach the
                  length CL.
         NOTE 347 — In the preceding 4 Rules, the phrase “implementation-defined null character that terminates a C character
         string” implies one or more octets all of whose bits are zero and whose number is equal to the number of octets in the largest
         character of the character set of DT.

    e) If DT identifies INT, DEC, or REAL and the caller language of EP is M, then a reference to PN that
       assigns some value SV to PN implicitly assigns the value


©ISO/IEC 2003 – All rights reserved                                                                     SQL-client modules 787
ISO/IEC 9075-2:2003 (E)
13.4 Calls to an <externally-invoked procedure>



               CAST ( SV AS CHARACTER VARYING(ML) )

         to PI, where ML is the implementation-defined maximum length of variable-length of character strings.
    f) If DT identifies a BOOLEAN type, then
         Case:
         i)       If the caller language of EP is ADA, then a reference to PN that assigns the value False to PN
                  implicitly assigns the False to PI; a reference to PN that assigns the value True implicitly assigns
                  the value True to PI.
         ii)      If the caller language of EP is C, then a reference to PN that assigns the value False to PN
                  implicitly assigns the value 0 (zero) to PI; a reference to PN that assigns the value True implicitly
                  assigns the value 1 (one) to PI.
         iii)     If the caller language of EP is COBOL, then a reference to PN that assigns the value False to
                  PN implicitly assigns the value 'F' to PI; a reference to PN that assigns the value True implicitly
                  assigns the value 'T' to PI.
         iv)      If the caller language of EP is FORTRAN, then a reference to PN that assigns the value False
                  to PN implicitly assigns the value .FALSE. to PI; a reference to PN that assigns the value True
                  implicitly assigns the value .TRUE. to PI.
         v)       If the caller language of EP is PLI, then a reference to PN that assigns the value False to PN
                  implicitly assigns the value '0'B to PI; a reference to PN that assigns the value True implicitly
                  assigns the value '1'B to PI.
         NOTE 348 — Pascal has a Boolean-type, whose values are True and False.

    g) If P is a binary large object locator parameter, a character large object locator parameter, an array
       locator parameter, a multiset locator parameter, or a user-defined type locator parameter, then a reference
       to PN that assigns some value SV to PN implicitly assigns the corresponding large object locator value,
       the character large object locator value, the array locator value, the multiset locator value, or the user-
       defined type locator value, respectively, that uniquely identifies SV to PI.
    h) If DT identifies a CHARACTER LARGE OBJECT or BINARY LARGE OBJECT type, then
         Case:
         i)       If the caller language of EP is C, then a reference to PN that assigns some value SV to PN
                  implicitly assigns the value LENGTH(SV) to PN.PN_length and the value SV to PN.PN_data.
         ii)      If the caller language of EP is COBOL, then a reference to PN that assigns some value SV to
                  PN implicitly assigns the value LENGTH(SV) to PN.PN-LENGTH and the value SV to
                  PN.PN-DATA.
         iii)     If the caller language of EP is FORTRAN, then a reference to PN that assigns some value SV
                  to PN implicitly assigns the value LENGTH(SV) to PN_LENGTH and the value SV to PN_DATA.
         iv)      If the caller language of EP is PLI, then a reference to PN that assigns some value SV to PN
                  implicitly assigns the value LENGTH(SV) to PN.PN_length and the value SV to PN.PN_data.
    i)   Otherwise, a reference to PN that assigns some value SV to PN implicitly assigns the value SV to PI.
         If the caller language of EP is ADA and no value has been assigned to PI, then an implementation-
         dependent value is assigned to PI.


788 Foundation (SQL/Foundation)                                                        ©ISO/IEC 2003 – All rights reserved
                                                             ISO/IEC 9075-2:2003 (E)
                                      13.4 Calls to an <externally-invoked procedure>



Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved                          SQL-client modules 789
ISO/IEC 9075-2:2003 (E)
13.5 <SQL procedure statement>



13.5 <SQL procedure statement>

Function
Define all of the SQL-statements that are <SQL procedure statement>s.


Format
<SQL procedure statement> ::= <SQL executable statement>

<SQL executable statement> ::=
    <SQL schema statement>
  | <SQL data statement>
  | <SQL control statement>
  | <SQL transaction statement>
  | <SQL connection statement>
  | <SQL session statement>
  | <SQL diagnostics statement>
  | <SQL dynamic statement>

<SQL schema statement> ::=
    <SQL schema definition statement>
  | <SQL schema manipulation statement>

<SQL schema definition statement> ::=
    <schema definition>
  | <table definition>
  | <view definition>
  | <SQL-invoked routine>
  | <grant statement>
  | <role definition>
  | <domain definition>
  | <character set definition>
  | <collation definition>
  | <transliteration definition>
  | <assertion definition>
  | <trigger definition>
  | <user-defined type definition>
  | <user-defined cast definition>
  | <user-defined ordering definition>
  | <transform definition>
  | <sequence generator definition>

<SQL schema manipulation statement> ::=
    <drop schema statement>
  | <alter table statement>
  | <drop table statement>
  | <drop view statement>
  | <alter routine statement>
  | <drop routine statement>
  | <drop user-defined cast statement>
  | <revoke statement>
  | <drop role statement>



790 Foundation (SQL/Foundation)                                         ©ISO/IEC 2003 – All rights reserved
                                                      ISO/IEC 9075-2:2003 (E)
                                               13.5 <SQL procedure statement>



  |   <alter domain statement>
  |   <drop domain statement>
  |   <drop character set statement>
  |   <drop collation statement>
  |   <drop transliteration statement>
  |   <drop assertion statement>
  |   <drop trigger statement>
  |   <alter type statement>
  |   <drop data type statement>
  |   <drop user-defined ordering statement>
  |   <alter transform statement>
  |   <drop transform statement>
  |   <alter sequence generator statement>
  |   <drop sequence generator statement>

<SQL data statement> ::=
    <open statement>
  | <fetch statement>
  | <close statement>
  | <select statement: single row>
  | <free locator statement>
  | <hold locator statement>
  | <SQL data change statement>

<SQL data change statement> ::=
    <delete statement: positioned>
  | <delete statement: searched>
  | <insert statement>
  | <update statement: positioned>
  | <update statement: searched>
  | <merge statement>

<SQL control statement> ::=
    <call statement>
  | <return statement>

<SQL transaction statement> ::=
    <start transaction statement>
  | <set transaction statement>
  | <set constraints mode statement>
  | <savepoint statement>
  | <release savepoint statement>
  | <commit statement>
  | <rollback statement>

<SQL connection statement> ::=
    <connect statement>
  | <set connection statement>
  | <disconnect statement>

<SQL session statement> ::=
    <set session user identifier statement>
  | <set role statement>
  | <set local time zone statement>
  | <set session characteristics statement>
  | <set catalog statement>
  | <set schema statement>



©ISO/IEC 2003 – All rights reserved                    SQL-client modules 791
ISO/IEC 9075-2:2003 (E)
13.5 <SQL procedure statement>



  |   <set    names statement>
  |   <set    path statement>
  |   <set    transform group statement>
  |   <set    session collation statement>

<SQL diagnostics statement> ::= <get diagnostics statement>

<SQL dynamic statement> ::=
    <SQL descriptor statement>
  | <prepare statement>
  | <deallocate prepared statement>
  | <describe statement>
  | <execute statement>
  | <execute immediate statement>
  | <SQL dynamic data statement>

<SQL dynamic data statement> ::=
    <allocate cursor statement>
  | <dynamic open statement>
  | <dynamic fetch statement>
  | <dynamic close statement>
  | <dynamic delete statement: positioned>
  | <dynamic update statement: positioned>

<SQL descriptor statement> ::=
    <allocate descriptor statement>
  | <deallocate descriptor statement>
  | <set descriptor statement>
  | <get descriptor statement>


Syntax Rules
1) Let S be the <SQL procedure statement>.
2) An <SQL connection statement> shall not be generally contained in an <SQL control statement>.
3) The SQL-invoked routine specified by <SQL-invoked routine> shall be a schema-level routine.
      NOTE 349 — “schema-level routine” is defined in Subclause 11.50, “<SQL-invoked routine>”.

4) S is possibly non-deterministic if and only if S is not an <SQL schema statement> and at least one of the
   following is satisfied:
      a) S is a <select statement: single row> that is possibly non-deterministic.
      b) S contains a <routine invocation> whose subject routine is an SQL-invoked routine that is possibly
         non-deterministic.
      c) S generally contains a <query specification> or a <query expression> that is possibly non-deterministic.
      d) S generally contains a <value expression> that is possibly non-deterministic.


Access Rules
      None.


792 Foundation (SQL/Foundation)                                                             ©ISO/IEC 2003 – All rights reserved
                                                                                                 ISO/IEC 9075-2:2003 (E)
                                                                                          13.5 <SQL procedure statement>



General Rules
1) Let S be the executing statement specified in an application of this Subclause.
    NOTE 350 — S is necessarily the innermost executing statement of the SQL-session as defined in Subclause 4.37, “SQL-sessions”.

2) A statement execution context NEWSEC is established for the execution of S. Let OLDSEC be the most
   recent statement execution context. NEWSEC becomes the most recent statement execution context.
   NEWSEC is an atomic execution context, and therefore the most recent atomic execution context, if and
   only if S is an atomic SQL-statement.
3) If the non-dynamic or dynamic execution of an <SQL data statement>, <SQL dynamic data statement>,
   <dynamic select statement>, or <dynamic single row select statement> occurs within the same SQL-
   transaction as the non-dynamic or dynamic execution of an SQL-schema statement and this is not allowed
   by the SQL-implementation, then an exception condition is raised: invalid transaction state — schema and
   data statement mixing not supported.
4) Case:
    a) If S is immediately contained in an <externally-invoked procedure> EP, then let n be the number of
       <host parameter declaration>s specified in EP; let PDi, 1 (one) ≤ i ≤ n, be the i-th such <host parameter
       declaration>; and let PNi and DTi be the <host parameter name> and <data type>, respectively, specified
       in PDi. When EP is called by an SQL-agent, let PIi be the i-th argument in the procedure call.

         Case:
         i)       If S is an <SQL connection statement>, then:
                  1) The SQL-client module that contains S is associated with the SQL-agent.
                  2) The first diagnostics area is emptied.

                  3) For each i, 1 (one) ≤ i ≤ n, the General Rules of Subclause 13.4, “Calls to an <externally-
                     invoked procedure>”, are evaluated for input parameters with EP, PDi, PNi, DTi, and PIi
                     as PROC, DECL, NAME, TYPE, and ARG, respectively.
                  4) The General Rules of S are evaluated.

                  5) For each i, 1 (one) ≤ i ≤ n, the General Rules of Subclause 13.4, “Calls to an <externally-
                     invoked procedure>”, are evaluated for output parameters with EP, PDi, PNi, DTi, and PIi
                     as PROC, DECL, NAME, TYPE, and ARG, respectively.
                  6) If S successfully initiated or resumed an SQL-session, then subsequent calls to an <externally-
                     invoked procedure> and subsequent invocations of <direct SQL statement>s by the SQL-
                     agent are associated with that SQL-session until the SQL-agent terminates the SQL-session
                     or makes it dormant.
         ii)      If S is an <SQL diagnostics statement>, then:
                  1) The SQL-client module that contains S is associated with the SQL-agent.




©ISO/IEC 2003 – All rights reserved                                                                 SQL-client modules 793
ISO/IEC 9075-2:2003 (E)
13.5 <SQL procedure statement>



              2) For each i, 1 (one) ≤ i ≤ n, the General Rules of Subclause 13.4, “Calls to an <externally-
                 invoked procedure>”, are evaluated for input parameters with EP, PDi, PNi, DTi, and PIi
                 as PROC, DECL, NAME, TYPE, and ARG, respectively.
              3) The General Rules of S are evaluated.

              4) For each i, 1 (one) ≤ i ≤ n, the General Rules of Subclause 13.4, “Calls to an <externally-
                 invoked procedure>”, are evaluated for output parameters with EP, PDi, PNi, DTi, and PIi
                 as PROC, DECL, NAME, TYPE, and ARG, respectively.
       iii)   Otherwise:
              1) If no SQL-session is current for the SQL-agent, then
                  Case:
                  A) If the SQL-agent has not executed an <SQL connection statement> and there is no
                     default SQL-session associated with the SQL-agent, then the following <connect state-
                     ment> is effectively executed:

                      CONNECT TO DEFAULT

                  B) If the SQL-agent has not executed an <SQL connection statement> and there is a default
                     SQL-session associated with the SQL-agent, then the following <set connection state-
                     ment> is effectively executed:

                      SET CONNECTION DEFAULT

                  C) Otherwise, an exception condition is raised: connection exception — connection does
                     not exist.
              2) Subsequent calls to an <externally-invoked procedure> and subsequent invocations of <direct
                 SQL statement>s by the SQL-agent are associated with the SQL-session until the SQL-agent
                 terminates the SQL-session or makes it dormant.
              3) If an SQL-transaction is active for the SQL-agent, then S is associated with that SQL-
                 transaction.
              4) If no SQL-transaction is active for the SQL-agent and S is a transaction-initiating SQL-
                 statement, then
                  A) An SQL-transaction is effectively initiated and associated with this call and with subse-
                     quent calls of any <externally-invoked procedure> by that SQL-agent and with this and
                     subsequent invocations of <direct SQL statement>s by that SQL-agent until the SQL-
                     agent terminates that SQL-transaction.
                  B) If S is not a <start transaction statement>, then
                      Case:
                      I)      If a <set transaction statement> has been executed since the termination of the
                              last SQL-transaction in the SQL-session, then the access mode, constraint mode,
                              and isolation level of the SQL-transaction are set as specified by the <set transac-



794 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                             ISO/IEC 9075-2:2003 (E)
                                                                                      13.5 <SQL procedure statement>



                                      tion statement>. If a <set constraints mode statement> SCM has been executed
                                      since the termination of the last SQL-transaction in the SQL-session, then the
                                      constraint modes of constraints specified in SCM are set as specified in SCM.
                           II)        If a <set session characteristics statement> has been executed in the current SQL-
                                      session, then:
                                      1) If that <set session characteristics statement> set the enduring transaction
                                         characteristics of access mode, then the access mode of the SQL-transaction
                                         is set to the specified access mode.
                                      2) If that <set session characteristics statement> set the enduring transaction
                                         characteristics of isolation level, then the isolation level of the SQL-transac-
                                         tion is set to the specified isolation level.
                                      3) The constraint modes for all constraints in the SQL-transaction are set to
                                         their initial state.
                           III)       Otherwise, the access mode of that SQL-transaction is read-write, the constraint
                                      mode for all constraints in that SQL-transaction is immediate, and the isolation
                                      level of that SQL-transaction is SERIALIZABLE.
                      C) The SQL-transaction is associated with the SQL-session.
                      D) The <SQL-client module definition> that contains S is associated with the SQL-transac-
                         tion.
                  5) The SQL-client module that contains S is associated with the SQL-agent.
                  6) If S contains an <SQL schema statement> and the access mode of the current SQL-transaction
                     is read-only, then an exception condition is raised: invalid transaction state.
                  7) The first diagnostics area is emptied.

                  8) For each i, 1 (one) ≤ i ≤ n, the General Rules of Subclause 13.4, “Calls to an <externally-
                     invoked procedure>”, are evaluated for input parameters with EP, PDi, PNi, DTi, and PIi
                     as PROC, DECL, NAME, TYPE, and ARG, respectively.
                  9) If S does not conform to the Syntax Rules and Access Rules of an <SQL procedure state-
                     ment>, then an exception condition is raised: syntax error or access rule violation.
                  10) The General Rules of S are evaluated.

                  11) For each i, 1 (one) ≤ i ≤ n, the General Rules of Subclause 13.4, “Calls to an <externally-
                      invoked procedure>”, are evaluated for output parameters with EP, PDi, PNi, DTi, and PIi
                      as PROC, DECL, NAME, TYPE, and ARG, respectively.
                  12) If S is a <select statement: single row> or a <fetch statement> and a completion condition
                      is raised: no data, or an exception condition is raised, then the value of each PIi for which
                      PNi is referenced in a <target specification> in S is implementation-dependent.

    b) Otherwise:
         i)       If an SQL-transaction is active for the SQL-agent, then S is associated with that SQL-transaction.


©ISO/IEC 2003 – All rights reserved                                                            SQL-client modules 795
ISO/IEC 9075-2:2003 (E)
13.5 <SQL procedure statement>



       ii)     If no SQL-transaction is active for the SQL-agent and S is a transaction-initiating SQL-statement,
               then
               1) An SQL-transaction is effectively initiated as follows.
                   Case:
                   A) If a <set transaction statement> has been executed since the termination of the last SQL-
                      transaction in the SQL-session, then the access mode, constraint mode, and isolation
                      level of the SQL-transaction are set as specified by the <set transaction statement>.
                   B) Otherwise, the access mode of that SQL-transaction is read-write, the constraint mode
                      for all constraints in that SQL-transaction is immediate, and the isolation level of that
                      SQL-transaction is SERIALIZABLE.
               2) The SQL-transaction is associated with the SQL-session.
       iii)    If S is an <SQL schema statement> and the access mode of the current SQL-transaction is read-
               only, then an exception condition is raised: invalid transaction state.
       iv)     If S is not an <SQL diagnostics statement>, then the first diagnostics area is emptied.
5) Case:
   a) If S is immediately contained in an <externally-invoked procedure>, then
       Case:
       i)      If S executed successfully, then either a completion condition is raised: successful completion,
               or a completion condition is raised: warning, or a completion condition is raised: no data, as
               determined by the General Rules in this and other Subclauses of ISO/IEC 9075.
       ii)     If S did not execute successfully, then:
               1) The status parameter is set to the value specified for the condition in Clause 23, “Status
                  codes”.
               2) If S is not an <SQL control statement>, then all changes made to SQL-data or schemas by
                  the execution of S are canceled.
   b) Otherwise, the General Rules for S are evaluated.
       Case:
       i)      If S executed successfully, then either a completion condition is raised: successful completion,
               or a completion condition is raised: warning, or a completion condition is raised: no data, as
               determined by the General Rules in this and other Subclauses of ISO/IEC 9075.
       ii)     Otherwise:
               1) If S is not an <SQL control statement>, then all changes made to SQL-data or schemas by
                  the execution of S are canceled.
               2) The exception condition with which the execution of S completed is raised.




796 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                               ISO/IEC 9075-2:2003 (E)
                                                                                        13.5 <SQL procedure statement>



6) If S is not an <SQL diagnostics statement>, then diagnostics information resulting from the execution of
   S is placed into the first diagnostics area, causing the first condition area in the first diagnostics area to
   become occupied. Whether any other condition areas become occupied is implementation-defined.
7) If NEWSEC is atomic, then all savepoints established during its existence are destroyed.
8) NEWSEC ceases to exist and OLDSEC becomes the most recent statement execution context.
9) S ceases to be an executing statement.
    NOTE 351 — The innermost executing statement, if any, is now the one that was the innermost executing statement that caused
    S to be executed.


Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved                                                                SQL-client modules 797
ISO/IEC 9075-2:2003 (E)
13.6 Data type correspondences



13.6 Data type correspondences

Function
Specify the data type correspondences for SQL data types and host language types.
NOTE 352 — These tables are referenced in Subclause 11.50, “<SQL-invoked routine>”, for the definitions of external routines and
in Subclause 10.4, “<routine invocation>”, for the invocation of external routines.

In the following tables, let P be <precision>, S be <scale>, L be <length>, T be <time fractional seconds preci-
sion>, Q be <interval qualifier>, and N be the implementation-defined size of a structured type reference.


Tables

                                  Table 16 — Data type correspondences for Ada


 SQL Data Type                             Ada Data Type

 SQLSTATE                                  SQL_STANDARD.SQLSTATE_TYPE

 CHARACTER (L)                             SQL_STANDARD.CHAR, with P'LENGTH of L

 CHARACTER VARYING (L)                     None

 CHARACTER LARGE                           None
 OBJECT(L)

 BINARY LARGE OBJECT(L)                    None

 NUMERIC(P,S)                              None

 DECIMAL(P,S)                              None

 SMALLINT                                  SQL_STANDARD.SMALLINT

 INTEGER                                   SQL_STANDARD.INT

 BIGINT                                    SQL_STANDARD.BIGINT

 FLOAT(P)                                  None

 REAL                                      SQL_STANDARD.REAL

 DOUBLE PRECISION                          SQL_STANDARD.DOUBLE_PRECISION

 BOOLEAN                                   SQL_STANDARD.BOOLEAN

 DATE                                      None



798 Foundation (SQL/Foundation)                                                               ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                               13.6 Data type correspondences



 SQL Data Type                             Ada Data Type

 TIME(T)                                   None

 TIMESTAMP(T)                              None

 INTERVAL(Q)                               None

 user-defined type                         None

 REF                                       SQL_STANDARD.CHAR with P'LENGTH of N

 ROW                                       None

 ARRAY                                     None

 MULTISET                                  None


                                      Table 17 — Data type correspondences for C


 SQL Data Type                             C Data Type

 SQLSTATE                                  char, with length 6

 CHARACTER (L)3                            char, with length (L+1)*k1

 CHARACTER VARYING (L)3                    char, with length (L+1)*k1

 CHARACTER LARGE                           struct {
 OBJECT(L)                                     long hvn_reserved
                                               unsigned long hvn_length
                                               char hvn_data[L];
                                             } hvn2 3

 BINARY LARGE OBJECT(L)                    struct {
                                               long hvn_reserved
                                               unsigned long hvn_length
                                               char hvn_data[L];
                                             } hvn2

 NUMERIC(P,S)                              None

 DECIMAL(P,S)                              None

 SMALLINT                                  pointer to short

 INTEGER                                   pointer to long



©ISO/IEC 2003 – All rights reserved                                                   SQL-client modules 799
ISO/IEC 9075-2:2003 (E)
13.6 Data type correspondences



 SQL Data Type                                C Data Type

 BIGINT                                       pointer to long long

 FLOAT(P)                                     None

 REAL                                         pointer to float

 DOUBLE PRECISION                             pointer to double

 BOOLEAN                                      pointer to long

 DATE                                         None

 TIME(T)                                      None

 TIMESTAMP(T)                                 None

 INTERVAL(Q)                                  None

 user-defined type                            None

 REF                                          char, with length N

 ROW                                          None

 ARRAY                                        None

 MULTISET                                     None
 1
   For character set UTF16, as well as other implementation-defined character sets in which a code unit occupies two octets, k is
 the length in units of C unsigned short of the character encoded using the greatest number of such units in the character set; for
 character set UTF32, as well as other implementation-defined character sets in which a code unit occupies four octets, k is four;
 for other character sets, k is the length in units of C char of the character encoded using the greatest number of such units in the
 character set.
 2
   hvn is the name of the host variable defined to correspond to the SQL data type
 3
   For character set UTF16, as well as other implementation-defined character sets in which a code unit occupies two octets, char
 or unsigned char should be replaced with unsigned short; for character set UTF32, as well as other implementation-defined
 character sets in which a code unit occupies four octets, char or unsigned char should be replaced with unsigned int. Otherwise,
 char or unsigned char should be used.



                                 Table 18 — Data type correspondences for COBOL


 SQL Data Type                                COBOL Data Type

 SQLSTATE                                     PICTURE X(5)

 CHARACTER (L)                                PICTURE X(L)3




800 Foundation (SQL/Foundation)                                                                      ©ISO/IEC 2003 – All rights reserved
                                                                              ISO/IEC 9075-2:2003 (E)
                                                                        13.6 Data type correspondences



 SQL Data Type                        COBOL Data Type

 CHARACTER VARYING (L)                None

 CHARACTER LARGE                      01 hvn.
 OBJECT(L)                               49 hvn-RESERVED PIC S9(9) USAGE IS BINARY.
                                         49 hvn-LENGTH PIC S9(9) USAGE IS BINARY.
                                         49 hvn-DATA PIC X(L)2 3.

 BINARY LARGE OBJECT (L)              01 hvn.
                                         49 hvn-RESERVED PIC S9(9) USAGE IS BINARY.
                                         49 hvn-LENGTH PIC S9(9) USAGE IS BINARY.
                                         49 hvn-DATA PIC X(L)2.

 NUMERIC(P,S)                         USAGE DISPLAY SIGN LEADING SEPARATE, with PICTURE
                                      as specified1

 DECIMAL(P,S)                         None

 SMALLINT                             PICTURE S9(SPI) USAGE BINARY, where SPI is implementation-
                                      defined

 INTEGER                              PICTURE S9(PI) USAGE BINARY, where PI is implementation-
                                      defined

 BIGINT                               PICTURE S9(BPI) USAGE BINARY, where BPI is implementation-
                                      defined

 FLOAT(P)                             None

 REAL                                 None

 DOUBLE PRECISION                     None

 BOOLEAN                              PICTURE X

 DATE                                 None

 TIME(T)                              None

 TIMESTAMP(T)                         None

 INTERVAL(Q)                          None

 user-defined type                    None

 REF                                  alphanumeric with length N

 ROW                                  None




©ISO/IEC 2003 – All rights reserved                                            SQL-client modules 801
ISO/IEC 9075-2:2003 (E)
13.6 Data type correspondences



 SQL Data Type                                COBOL Data Type

 ARRAY                                        None

 MULTISET                                     None
 1
     Case:
 a)     If S=P, then a PICTURE with an 'S' followed by a 'V' followed by P '9's.
 b)     If P>S>0, then a PICTURE with an 'S' followed by P--S '9's followed by a 'V' followed by S '9's.
 c) If S=0, then a PICTURE with an 'S' followed by P '9's optionally followed by a 'V'.
 2
   hvn is the name of the host variable defined to correspond to the SQL data type
 3
   For character set UTF16, as well as other implementation-defined character sets in which a code unit occupies two octets,
 “PICTURE X(L)” should be replaced with “PICTURE N(L)”. For character set UTF32, as well as other implementation-defined
 character sets in which a code unit occupies four octets, “PICTURE X(L)” should be replaced with “PICTURE (????)”. Otherwise,
 “PICTURE X(L)” should be used.



                                  Table 19 — Data type correspondences for Fortran


 SQL Data Type                                Fortran Data Type

 SQLSTATE                                     CHARACTER, with length 5

 CHARACTER (L)                                CHARACTER2, with length L

 CHARACTER VARYING (L)                        None

 CHARACTER LARGE                              CHARACTER hvn(L+8)
 OBJECT(L)                                        INTEGER*4 hvn_RESERVED
                                                  INTEGER*4 hvn_LENGTH
                                                  CHARACTER hvn_DATA
                                                  EQUIVALENCE(hvn(5), hvn_LENGTH)
                                                    EQUIVALENCE(hvn(9), hvn_DATA)1 2

 BINARY LARGE OBJECT(L)                       CHARACTER hvn(L+8)
                                                  INTEGER*4 hvn_RESERVED
                                                  INTEGER*4 hvn_LENGTH
                                                  CHARACTER hvn_DATA
                                                  EQUIVALENCE(hvn(5), hvn_LENGTH)
                                                    EQUIVALENCE(hvn(9), hvn_DATA)1

 NUMERIC(P,S)                                 None

 DECIMAL(P,S)                                 None

 SMALLINT                                     None

 INTEGER                                      INTEGER


802 Foundation (SQL/Foundation)                                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                                  ISO/IEC 9075-2:2003 (E)
                                                                                            13.6 Data type correspondences



 SQL Data Type                              Fortran Data Type

 BIGINT                                     None

 FLOAT(P)                                   None

 REAL                                       REAL

 DOUBLE PRECISION                           DOUBLE PRECISION

 BOOLEAN                                    LOGICAL

 DATE                                       None

 TIME(T)                                    None

 TIMESTAMP(T)                               None

 INTERVAL(Q)                                None

 user-defined type                          None

 REF                                        CHARACTER with length N

 ROW                                        None

 ARRAY                                      None

 MULTISET                                   None
 1
  hvn is the name of the host variable defined to correspond to the SQL data type
 2
  For character set UTF16, as well as other implementation-defined character sets in which a code unit occupies more than one
 octet, “CHARACTER KIND=n” should be used; in this case, the value of n that corresponds to a given character set is
 implementation-defined. Otherwise, “CHARACTER” (without “KIND=n”) should be used.



                                      Table 20 — Data type correspondences for M


 SQL Data Type                              M Data Type

 SQLSTATE                                   character, with maximum length at least 5

 CHARACTER (L)                              None

 CHARACTER VARYING (L)                      character with maximum length L

 CHARACTER LARGE                            None
 OBJECT(L)

 BINARY LARGE OBJECT(L)                     None


©ISO/IEC 2003 – All rights reserved                                                                  SQL-client modules 803
ISO/IEC 9075-2:2003 (E)
13.6 Data type correspondences



 SQL Data Type                    M Data Type

 NUMERIC(P,S)                     character

 DECIMAL(P,S)                     character

 SMALLINT                         None

 INTEGER                          character

 BIGINT                           None

 FLOAT(P)                         None

 REAL                             character

 DOUBLE PRECISION                 None

 BOOLEAN                          None

 DATE                             None

 TIME(T)                          None

 TIMESTAMP(T)                     None

 INTERVAL(Q)                      None

 user-defined type                None

 REF                              character

 ROW                              None

 ARRAY                            None

 MULTISET                         None


                          Table 21 — Data type correspondences for Pascal


 SQL Data Type                    Pascal Data Type

 SQLSTATE                         PACKED ARRAY [1..5] OF CHAR

 CHARACTER(1)                     CHAR

 CHARACTER (L), L>1               PACKED ARRAY [1..L] OF CHAR

 CHARACTER VARYING (L)            None


804 Foundation (SQL/Foundation)                                         ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                13.6 Data type correspondences



 SQL Data Type                               Pascal Data Type

 CHARACTER LARGE                             None
 OBJECT(L)

 BINARY LARGE OBJECT(L)                      None

 NUMERIC(P,S)                                None

 DECIMAL(P,S)                                None

 SMALLINT                                    None

 INTEGER                                     INTEGER

 BIGINT                                      None

 FLOAT(P)                                    None

 REAL                                        REAL

 DOUBLE PRECISION                            None

 BOOLEAN                                     BOOLEAN

 DATE                                        None

 TIME(T)                                     None

 TIMESTAMP(T)                                None

 INTERVAL(Q)                                 None

 user-defined type                           None

 REF                                         PACKED ARRAY[1..N] OF CHAR

 ROW                                         None

 ARRAY                                       None

 MULTISET                                    None


                                      Table 22 — Data type correspondences for PL/I


 SQL Data Type                               PL/I Data Type

 SQLSTATE                                    CHARACTER(5)



©ISO/IEC 2003 – All rights reserved                                                    SQL-client modules 805
ISO/IEC 9075-2:2003 (E)
13.6 Data type correspondences



 SQL Data Type                    PL/I Data Type

 CHARACTER (L)                    CHARACTER(L)

 CHARACTER VARYING (L)            CHARACTER VARYING(L)

 CHARACTER LARGE                  DCL 01 hvn
 OBJECT(L)                            49 hvn_reserved FIXED BINARY (31)
                                      49 hvn_length FIXED BINARY (31)
                                      49 hvn_data CHAR (n)1;

 BINARY LARGE OBJECT (L)          DCL 01 hvn
                                      49 hvn_reserved FIXED BINARY (31)
                                      49 hvn_length FIXED BINARY (31)
                                      49 hvn_data CHAR (n)1;

 NUMERIC(P,S)                     None

 DECIMAL(P,S)                     FIXED DECIMAL (P,S)

 SMALLINT                         FIXED BINARY(SPI), where SPI is implementation-defined

 INTEGER                          FIXED BINARY(PI), where PI is implementation-defined

 BIGINT                           FIXED BINARY(BPI), where BPI is implementation-defined

 FLOAT(P)                         FLOAT BINARY (P)

 REAL                             None

 DOUBLE PRECISION                 None

 BOOLEAN                          BIT(1)

 DATE                             None

 TIME(T)                          None

 TIMESTAMP(T)                     None

 INTERVAL(Q)                      None

 user-defined type                None

 REF                              CHARACTER VARYING(N)

 ROW                              None

 ARRAY                            None




806 Foundation (SQL/Foundation)                                         ©ISO/IEC 2003 – All rights reserved
                                                                                             ISO/IEC 9075-2:2003 (E)
                                                                                       13.6 Data type correspondences



 SQL Data Type                                 PL/I Data Type

 MULTISET                                      None
 1
     hvn is the name of the host variable defined to correspond to the SQL data type



Conformance Rules
      None.




©ISO/IEC 2003 – All rights reserved                                                           SQL-client modules 807
ISO/IEC 9075-2:2003 (E)




                                  This page intentionally left blank.




808 Foundation (SQL/Foundation)                                         ©ISO/IEC 2003 – All rights reserved
                                                                                  ISO/IEC 9075-2:2003 (E)
                                                                                    14.1 <declare cursor>




14 Data manipulation


14.1 <declare cursor>

Function
Define a cursor.


Format
<declare cursor> ::=
    DECLARE <cursor name> [ <cursor sensitivity> ] [ <cursor scrollability> ] CURSOR
    [ <cursor holdability> ]
    [ <cursor returnability> ]
    FOR <cursor specification>

<cursor sensitivity> ::=
    SENSITIVE
  | INSENSITIVE
  | ASENSITIVE

<cursor scrollability> ::=
    SCROLL
  | NO SCROLL

<cursor holdability> ::=
    WITH HOLD
  | WITHOUT HOLD

<cursor returnability> ::=
    WITH RETURN
  | WITHOUT RETURN

<cursor specification> ::=
    <query expression> [ <order by clause> ] [ <updatability clause> ]

<updatability clause> ::=
    FOR { READ ONLY | UPDATE [ OF <column name list> ] }

<order by clause> ::= ORDER BY <sort specification list>


Syntax Rules
1) If a <declare cursor> is contained in an <SQL-client module definition> M, then:
    a) The <cursor name> shall not be equivalent to the <cursor name> of any other <declare cursor> in M.




©ISO/IEC 2003 – All rights reserved                                                   Data manipulation 809
ISO/IEC 9075-2:2003 (E)
14.1 <declare cursor>



    b) Any <host parameter name> contained in the <cursor specification> shall be defined in a <host
       parameter declaration> in the <externally-invoked procedure> that contains an <open statement> that
       specifies the <cursor name>.
    NOTE 353 — See the Syntax Rules of Subclause 13.1, “<SQL-client module definition>”.

2) When <cursor name> is referenced in an <update statement: positioned>, no <object column> in the <set
   clause> shall identify a column that is specified in a <sort specification> of an <order by clause>.
3) Let T be the result of evaluating the <query expression> QE immediately contained in the <cursor specifi-
   cation>.
4) Let CS be the cursor specified by the <declare cursor>.
5) If <cursor sensitivity> is not specified, then ASENSITIVE is implicit.
6) CS is sensitive if SENSITIVE is specified, insensitive if INSENSITIVE is specified, and asensitive if
   ASENSITIVE is specified or implied.
7) If <cursor scrollability> is not specified, then NO SCROLL is implicit.
8) If <cursor holdability> is not specified, then WITHOUT HOLD is implicit.
9) If <cursor returnability> is not specified, then WITHOUT RETURN is implicit.
10) If <updatability clause> is not specified, then
    Case:
    a) If either INSENSITIVE, SCROLL, or ORDER BY is specified, or if QE is not a simply updatable
       table, then an <updatability clause> of READ ONLY is implicit.
    b) Otherwise, an <updatability clause> of FOR UPDATE without a <column name list> is implicit.
11) If an <updatability clause> of FOR UPDATE with or without a <column name list> is specified, then
    INSENSITIVE shall not be specified, QE shall be updatable, and and QE shall have only one leaf underlying
    table LUT such that QE is one-to-one with respect to LUT.
12) If an <updatability clause> specifying FOR UPDATE is specified or implicit, then CS is updatable; otherwise,
    CS is not updatable.
13) If CS is updatable, then let LUTN be a <table name> that references LUT. LUTN is an exposed <table or
    query name> whose scope is <updatability clause>.
14) If an <order by clause> is specified, then the cursor specified by the <cursor specification> is said to be an
    ordered cursor.
15) If WITH HOLD is specified, then the cursor specified by the <cursor specification> is said to be a holdable
    cursor.
16) If WITH RETURN is specified, then the cursor specified by the <cursor specification> is said to be a result
    set cursor.
    NOTE 354 — “result set cursor” is defined in Subclause 4.32, “Cursors”.

17) QE is the simply underlying table of CS.
18) If an <order by clause> is specified, then:


810 Foundation (SQL/Foundation)                                                            ©ISO/IEC 2003 – All rights reserved
                                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                                        14.1 <declare cursor>



    a) Let OBC be the <order by clause>. Let NSK be the number of <sort specification>s in OBC. For each
       i between 1 (one) and NSK, let Ki be the <sort key> contained in the i-th <sort specification> in OBC.

    b) Each Ki shall contain a <column reference> and shall not contain a <subquery> or a <set function
       specification>.
    c) If QE is a <query expression body> that is a <query term> that is a <query primary> that is a <simple
       table> that is a <query specification>, then the <cursor specification> is said to be a simple table query.
    d) Case:
         i)       If <sort specification list> contains any <sort key> Ki that contains a column reference to a
                  column that is not a column of T, then:
                  1) The <cursor specification> shall be a simple table query.
                  2) Let TE be the <table expression> immediately contained in the <query specification> QS
                     contained in QE.
                  3) Let SL be the <select list> of QS. Let SLT be obtained from SL by replacing each <column
                     reference> with its fully qualified equivalent.
                  4) Let OBCT be obtained from OBC by replacing each <column reference> that references a
                     column of TE with its fully qualified equivalent; in the case of common column names, each
                     common column name is regarded as fully qualified.
                  5) For each i between 1 (one) and NSK, let KTi be the <sort key> contained in the i-th <sort
                     specification> contained in OBCT.
                  6) For each i between 1 (one) and NSK, if KTi has the same left normal form derivation as the
                     <value expression> immediately contained in some <derived column> DC of SLT, then:
                      NOTE 355 — “Left normal form derivation” is defined in Subclause 6.2, “Notation provided in this International
                      Standard”, in ISO/IEC 9075-1.

                      A) Case:
                           I)         If DC simply contains an <as clause>, then let CN be the <column name> con-
                                      tained in the <as clause>.
                           II)        Otherwise, let CN be an implementation-dependent <column name> that is not
                                      equivalent to the explicit or implicit <column name> of any other <derived col-
                                      umn> contained in SLT. Let VE be the <value expression> simply contained in
                                      DC. DC is replaced in SLT by
                                      VE AS CN

                      B) KTi is replaced in OBCT by
                           CN

                  7) Let SCR be the set of <column reference>s to columns of TE that remain in OBCT after the
                     preceding transformation.
                  8) Let NSCR be the number of <column reference>s contained in SCR. For each j between 1
                     (one) and NCR, let Cj be an enumeration of these <column reference>s.



©ISO/IEC 2003 – All rights reserved                                                                    Data manipulation 811
ISO/IEC 9075-2:2003 (E)
14.1 <declare cursor>



               9) Case:
                   A) If NSCR is 0 (zero), then let SKL be the zero-length string.
                   B) Otherwise:
                       I)     T shall not be a grouped table.
                       II)    QS shall not specify the <set quantifier> DISTINCT or directly contain one or
                              more <set function specification>s.
                       III)   Let SKL be the comma-separated list of <derived column>s:
                                   , C1, C2, ..., CNCR

                              The columns Cj are said to be extended sort key columns.

               10) Let ST be the result of evaluating the <query specification>:
                      SELECT SLT SKL TE

               11) Let EOBC be OBCT.
        ii)    Otherwise, let ST be T and let EOBC be OBC.
    e) ST is said to be a sort table.
19) If an <updatability clause> of FOR UPDATE without a <column name list> is specified or implicit, then
    a <column name list> that consists of the <column name> of every column of LUT is implicit.
20) If an <updatability clause> of FOR UPDATE with a <column name list> is specified, then each <column
    name> in the <column name list> shall be the <column name> of a column of LUT.


Access Rules
    None.


General Rules
1) If an <order by clause> is not specified, then the table specified by the <cursor specification> is T and the
   ordering of rows in T is implementation-dependent.
2) If an <order by clause> is specified, then the ordering of rows of the result is determined by the <sort
   specification list>. The result table specified by the <cursor specification> is TS with all extended sort key
   columns (if any) removed.
    a) Let TS be the sort table.
    b) Each <sort specification> contained in EOBC specifies the sort direction for the corresponding sort
       key EKi. If DESC is not specified in the i-th <sort specification>, then the sort direction for EKi is
       ascending and the applicable <comp op> is the <less than operator>. Otherwise, the sort direction for
       EKi is descending and the applicable <comp op> is the <greater than operator>.



812 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                                            14.1 <declare cursor>



    c) Let P be any row of TS and let Q be any other row of TS, and let PVi and QVi be the values of EKi in
       these rows, respectively. The relative position of rows P and Q in the result is determined by comparing
       PVi and QVi according to the rules of Subclause 8.2, “<comparison predicate>”, where the <comp op>
       is the applicable <comp op> for EKi, with the following special treatment of null values. A sort key
       value that is null is considered equal to another sort key value that is null. Whether a sort key value
       that is null is considered greater or less than a non-null value is implementation-defined, but all sort
       key values that are null shall either be considered greater than all non-null values or be considered less
       than all non-null values. PVi is said to precede QVi if the value of the <comparison predicate> “PVi
       <comp op> QVi” is True for the applicable <comp op>. If PVi and QVi are not null and the result of
       “PVi <comp op> QVi” is Unknown, then the relative ordering of PVi and QVi is implementation-
       dependent.
    d) In TS, the relative position of row P is before row Q if PVn precedes QVn for some n greater than 0
       (zero) and less than or equal to the number of <sort specification>s and PVi = QVi for all i < n. The
       relative order of two rows that are not distinct with respect to the <sort specification>s are implemen-
       tation-dependent.
    e) The result table specified by the <cursor specification> is TS with all extended sort key columns (if
       any) removed.
3) If WITH HOLD is specified and the cursor is in an open state when an SQL-transaction is terminated with
   a <commit statement>, then the cursor is not closed and remains open into the next SQL-transaction.
    NOTE 356 — A holdable cursor that has been held open retains its position when the new SQL-transaction is initiated. However,
    even if the cursor is currently positioned on a row when the SQL-transaction is terminated, before either an <update statement:
    positioned> or a <delete statement: positioned> is permitted to reference that cursor in the new SQL-transaction, a <fetch statement>
    shall be issued against the cursor.


Conformance Rules
1) Without Feature T231, “Sensitive cursors”, conforming SQL language shall not contain a <cursor sensitivity>
   that immediately contains SENSITIVE.
2) Without Feature F791, “Insensitive cursors”, conforming SQL language shall not contain a <cursor sensi-
   tivity> that immediately contains INSENSITIVE.
3) Without Feature F791, “Insensitive cursors”, or Feature T231, “Sensitive cursors”, conforming SQL language
   shall not contain a <cursor sensitivity> that immediately contains ASENSITIVE.
4) Without Feature F431, “Read-only scrollable cursors”, conforming SQL language shall not contain a
   <cursor scrollability>.
5) Without Feature T471, “Result sets return value”, conforming SQL language shall not contain a <cursor
   returnability>.
6) Without Feature F831, “Full cursor update”, conforming SQL language shall not contain an <updatability
   clause> that contains FOR UPDATE and that contains a <cursor scrollability>.
7) Without Feature F831, “Full cursor update”, conforming SQL language shall not contain an <updatability
   clause> that specifies FOR UPDATE and that contains an <order by clause>.




©ISO/IEC 2003 – All rights reserved                                                                        Data manipulation 813
ISO/IEC 9075-2:2003 (E)
14.1 <declare cursor>



8) Without Feature T551, “Optional key words for default syntax”, conforming SQL language shall not contain
   a <cursor holdability> that immediately contains WITHOUT HOLD.
9) Without Feature T111, “Updatable joins, unions, and columns”, in conforming SQL language, if FOR
   UPDATE is specified, then QE shall be simply updatable.




814 Foundation (SQL/Foundation)                                               ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                          14.2 <open statement>



14.2 <open statement>

Function
Open a cursor.


Format
<open statement> ::= OPEN <cursor name>


Syntax Rules
1) The containing <SQL-client module definition> shall contain a <declare cursor> DC whose <cursor name>
   is equivalent to the <cursor name> contained in the <open statement>. Let CR be the cursor specified by
   DC.


Access Rules
1) The Access Rules for the <query expression> simply contained in the <declare cursor> identified by the
   <cursor name> are applied.


General Rules
1) If CR is not in the closed state, then an exception condition is raised: invalid cursor state.
2) Let S be the <cursor specification> of cursor CR.
3) Cursor CR is opened in the following steps:
    a) A copy of S is effectively created in which:
         i)       Each <target specification> is replaced by the value of the target.
         ii)      Each <value specification> generally contained in S that is CURRENT_USER, CUR-
                  RENT_ROLE, SESSION_USER, SYSTEM_USER, CURRENT_PATH, CUR-
                  RENT_DEFAULT_TRANSFORM_GROUP, or CURRENT_TRANS-
                  FORM_GROUP_FOR_TYPE <path-resolved user-defined type name> is replaced by the value
                  resulting from evaluation of CURRENT_USER, CURRENT_ROLE, SESSION_USER, SYS-
                  TEM_USER, CURRENT_PATH, CURRENT_DEFAULT_TRANSFORM_GROUP, or CUR-
                  RENT_TRANSFORM_GROUP_FOR_TYPE <path-resolved user-defined type name>,
                  respectively, with all such evaluations effectively done at the same instant in time.
         iii)     Each <datetime value function> generally contained in S is replaced by the value resulting from
                  evaluation of that <datetime value function>, with all such evaluations effectively done at the
                  same instant in time.
    b) Let T be the table specified by the copy of S.



©ISO/IEC 2003 – All rights reserved                                                      Data manipulation 815
ISO/IEC 9075-2:2003 (E)
14.2 <open statement>



   c) A table descriptor for T is effectively created.
   d) The General Rules of Subclause 14.1, “<declare cursor>”, are applied.
   e) Case:
       i)      If S specifies INSENSITIVE, then a copy of T is effectively created and cursor CR is placed in
               the open state and its position is before the first row of the copy of T.
       ii)     Otherwise, cursor CR is placed in the open state and its position is before the first row of T.
4) If CR specifies INSENSITIVE, and the SQL-implementation is unable to guarantee that significant changes
   will be invisible through CR during the SQL-transaction in which CR is opened and every subsequent SQL-
   transaction during which it may be held open, then an exception condition is raised: cursor sensitivity
   exception — request rejected.
5) If CR specifies SENSITIVE, and the SQL-implementation is unable to guarantee that significant changes
   will be visible through CR during the SQL-transaction in which CR is opened, then an exception condition
   is raised: cursor sensitivity exception — request rejected.
   NOTE 357 — The visibility of significant changes through a sensitive holdable cursor during a subsequent SQL-transaction is
   implementation-defined.

6) Whether an SQL-implementation is able to disallow significant changes that would not be visible through
   a currently open cursor is implementation-defined.


Conformance Rules
   None.




816 Foundation (SQL/Foundation)                                                              ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                         14.3 <fetch statement>



14.3 <fetch statement>

Function
Position a cursor on a specified row of a table and retrieve values from that row.


Format
<fetch statement> ::=
    FETCH [ [ <fetch orientation> ] FROM ] <cursor name> INTO <fetch target list>

<fetch orientation> ::=
    NEXT
  | PRIOR
  | FIRST
  | LAST
  | { ABSOLUTE | RELATIVE } <simple value specification>

<fetch target list> ::=
    <target specification> [ { <comma> <target specification> }... ]


Syntax Rules
1) <fetch target list> shall not contain a <target specification> that specifies a <column reference>.
2) If the <fetch orientation> is omitted, then NEXT is implicit.
3) Let DC be the <declare cursor> denoted by the <cursor name> and let T be the table defined by the <cursor
   specification> of DC. Let CR be the cursor specified by DC.
4) If the implicit or explicit <fetch orientation> is not NEXT, then DC shall specify SCROLL.
5) If a <fetch orientation> that contains a <simple value specification> is specified, then the declared type of
   that <simple value specification> shall be exact numeric with a scale of 0 (zero).
6) Case:
    a) If the <fetch target list> contains a single <target specification> TS and the degree of table T is greater
       than 1 (one), then the declared type of TS shall be a row type.
         Case:
         i)       If TS is an <SQL parameter reference>, then the Syntax Rules of Subclause 9.2, “Store assign-
                  ment”, apply to TS and the row type of table T as TARGET and VALUE, respectively.
         ii)      Otherwise, the Syntax Rules of Subclause 9.1, “Retrieval assignment”, apply to TS and the row
                  type of table T as TARGET and VALUE, respectively.
    b) Otherwise:




©ISO/IEC 2003 – All rights reserved                                                      Data manipulation 817
ISO/IEC 9075-2:2003 (E)
14.3 <fetch statement>



        i)     The number of <target specification>s NTS in the <fetch target list> shall be the same as the
               degree of table T. The i-th <target specification>, 1 (one) ≤ i, ≤ NTS, in the <fetch target list>
               corresponds with the i-th column of table T.
        ii)    For i varying from 1 (one) to NTS, let TS1i be the i-th <target specification> in the <fetch target
               list> that is either an <SQL parameter reference> or a <target array element specification>, and
               let CSi be the i-th column of table T that corresponds with the <target specification> in the <fetch
               target list>.
               Case:
               1) If TS1i contains a <simple value specification>, then the Syntax Rules of Subclause 9.2,
                  “Store assignment”, apply to an arbitrary site whose declared type is the declared type of
                  TS1i and CSi as TARGET and VALUE, respectively.

               2) Otherwise, the Syntax Rules of Subclause 9.2, “Store assignment”, apply to TS1i and the
                  corresponding column of table T as TARGET and VALUE, respectively.

        iii)   For each <target specification> TS2i, 1 (one) ≤ i, ≤ NTS, that is a <host parameter specification>,
               the Syntax Rules of Subclause 9.1, “Retrieval assignment”, apply to TS2i and the corresponding
               column of table T, as TARGET and VALUE, respectively.

        iv)    For each <target specification> TS2i, 1 (one) ≤ i, ≤ NTS, that is an <embedded variable specifi-
               cation>, the Syntax Rules of Subclause 9.1, “Retrieval assignment”, apply to TS2i and the cor-
               responding column of table T, as TARGET and VALUE, respectively.


Access Rules
    None.


General Rules
1) If cursor CR is not in the open state, then an exception condition is raised: invalid cursor state.
2) Case:
    a) If the <fetch orientation> contains a <simple value specification>, then let J be the value of that <simple
       value specification>.
    b) If the <fetch orientation> specifies NEXT or FIRST, then let J be +1.
    c) If the <fetch orientation> specifies PRIOR or LAST, then let J be –1.
3) Let Tt be a table of the same degree as T.

    Case:
    a) If the <fetch orientation> specifies ABSOLUTE, FIRST, or LAST, then let Tt contain all rows of T,
       preserving their order in T.



818 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                             ISO/IEC 9075-2:2003 (E)
                                                                                              14.3 <fetch statement>



    b) If the <fetch orientation> specifies NEXT or specifies RELATIVE with a positive value of J, then:
         i)       If the table T identified by cursor CR is empty or if the position of CR is on or after the last row
                  of T, then let Tt be a table of no rows.

         ii)      If the position of CR is on a row R that is other than the last row of T, then let Tt contain all rows
                  of T ordered after row R, preserving their order in T.
         iii)     If the position of CR is before a row R, then let Tt contain row R and all rows of T ordered after
                  row R, preserving their order in T.
    c) If the <fetch orientation> specifies PRIOR or specifies RELATIVE with a negative value of J, then:
         i)       If the table T identified by cursor CR is empty or if the position of CR is on or before the first
                  row of T, then let Tt be a table of no rows.

         ii)      If the position of CR is on a row R that is other than the first row of T, then let Tt contain all
                  rows of T ordered before row R, preserving their order in T.
         iii)     If the position of CR is before a row R that is not the first row of T, then let Tt contain row all
                  rows of T ordered before row R, preserving their order in T.
         iv)      If the position of CR is after the last row of T, then let Tt contain all rows of T, preserving their
                  order in T.
    d) If RELATIVE is specified with a zero value of J, then
         Case:
         i)       If the position of CR is on a row of T, then let Tt be a table comprising that one row.

         ii)      Otherwise, let Tt be an empty table.

4) Let N be the number of rows in Tt. If J is positive, then let K be J. If J is negative, then let K be N+J+1. If
   J is zero and ABSOLUTE is specified, then let K be zero; if J is zero and RELATIVE is specified, then let
   K be 1.
5) Case:
    a) If K is greater than 0 (zero) and not greater than N, then CR is positioned on the K-th row of Tt and the
       corresponding row of T. That row becomes the current row of CR.
    b) Otherwise, no SQL-data values are assigned to any targets in the <fetch target list>, and a completion
       condition is raised: no data.
         Case:
         i)       If the <fetch orientation> specifies RELATIVE with J equal to zero, then the position of CR is
                  unchanged.
         ii)      If the <fetch orientation> implicitly or explicitly specifies NEXT, specifies ABSOLUTE or
                  RELATIVE with K greater than N, or specifies LAST, then CR is positioned after the last row.




©ISO/IEC 2003 – All rights reserved                                                           Data manipulation 819
ISO/IEC 9075-2:2003 (E)
14.3 <fetch statement>



        iii)    Otherwise, the <fetch orientation> specifies PRIOR, FIRST, or ABSOLUTE or RELATIVE
                with K not greater than N and CR is positioned before the first row.
6) If a completion condition no data has been raised, then no further General Rules of this Subclause are
   applied.
7) Case:
    a) If the <fetch target list> contains a single <target specification> TS and the degree of table T is greater
       than 1 (one), then the current row is assigned to TS and
        Case:
        i)      If TS is an <SQL parameter reference>, then the General Rules of Subclause 9.2, “Store
                assignment”, apply to TS and the current row as TARGET and VALUE, respectively.
        ii)     Otherwise, the General Rules of Subclause 9.1, “Retrieval assignment”, are applied to TS and
                the current row as TARGET and VALUE, respectively.
    b) Otherwise, if the <fetch target list> contains more than one <target specification>, then values from
       the current row are assigned to their corresponding targets identified by the <fetch target list>. The
       assignments are made in an implementation-dependent order. Let TV be a target and let SV denote its
       corresponding value in the current row of CR.
        Case:
        i)      If TV is either an <SQL parameter reference> or a <target array element specification>, then for
                each <target specification> in the <fetch target list>, let TVi be the i-th <target specification>
                in the <fetch target list> and let SVi denote the i-th corresponding value in the current row of
                CR.
                Case:
                1) If <target array element specification> is specified, then
                    Case:
                    A) If the value of TVi, denoted by C, is null, then an exception condition is raised: data
                       exception — null value in array target.
                    B) Otherwise:
                        I)     Let N be the maximum cardinality of C.
                        II)    Let M be the cardinality of the value of C.
                        III)   Let I be the value of the <simple value specification> immediately contained in
                               TVi.

                        IV)    Let EDT be the element type of C.
                        V)     Case:
                               1) If I is greater than zero and less than or equal to M, then the value of C is
                                  replaced by an array A with element type EDT and cardinality M derived as
                                  follows:


820 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                                ISO/IEC 9075-2:2003 (E)
                                                                                                 14.3 <fetch statement>



                                          a) For j varying from 1 (one) to I–1 and from I+1 to M, the j-th element in
                                             A is the value of the j-th element in C.
                                          b) The I-th element of A is set to the value of SV, denoted by SVi, by
                                             applying the General Rules of Subclause 9.2, “Store assignment”, to the
                                             I-th element of A and SVi as TARGET and VALUE, respectively.

                                      2) If I is greater than M and less than or equal to N, then the value of C is
                                         replaced by an array A with element type EDT and cardinality I derived as
                                         follows:
                                          a) For j varying from 1 (one) to M, the j-th element in A is the value of the
                                             j-th element in C.
                                          b) For j varying from M+1 to I, the j-th element in A is the null value.
                                          c) The I-th element of A is set to the value of SV, denoted by SVi, by
                                             applying the General Rules of Subclause 9.2, “Store assignment”, to the
                                             I-th element of A and SVi as TARGET and VALUE, respectively.

                                      3) Otherwise, an exception condition is raised: data exception — array element
                                         error.
                  2) Otherwise, the General Rules of Subclause 9.2, “Store assignment”, apply to TVi and SVi
                     as TARGET and VALUE, respectively.
         ii)      If TV is a <host parameter name>, then the General Rules of Subclause 9.1, “Retrieval assign-
                  ment”, are applied to TV and SV as TARGET and VALUE, respectively.
         iii)     If TV is an <embedded variable specification>, then the General Rules of Subclause 9.1, “Retrieval
                  assignment”, are applied to TV and SV as TARGET and VALUE, respectively.
         NOTE 358 — SQL parameters cannot have as their data types any row type.

8) If an exception condition occurs during the assignment of a value to a target, then the values of all targets
   are implementation-dependent and CR remains positioned on the current row.
    NOTE 359 — It is implementation-dependent whether CR remains positioned on the current row when an exception condition is
    raised during the derivation of any <derived column>.


Conformance Rules
1) Without Feature F431, “Read-only scrollable cursors”, a <fetch statement> shall not contain a <fetch ori-
   entation>.




©ISO/IEC 2003 – All rights reserved                                                               Data manipulation 821
ISO/IEC 9075-2:2003 (E)
14.4 <close statement>



14.4 <close statement>

Function
Close a cursor.


Format
<close statement> ::= CLOSE <cursor name>


Syntax Rules
    None.


Access Rules
    None.


General Rules
1) Let CR be the cursor identified by the <cursor name> immediately contained in the <close statement>.
2) If cursor CR is not in the open state, then an exception condition is raised: invalid cursor state.
3) Let RS be the result set of CR.
4) Cursor CR is placed in the closed state and the copy of the <cursor specification> of the <declare cursor>
   that specified CR is destroyed.
5) If RS was one of an ordered set of result sets RRS returned from an SQL-invoked procedure SIP, then:
    a) Let RTN be the number of result sets returned by SIP.
    b) Let RSN be the ordinal position of RS within RRS.
    c) Case:
        i)        If RSN = RTN, then a completion condition is raised: no data — no additional dynamic result
                  sets returned.
        ii)       Otherwise:
                  1) CR is opened on RS in ordinal position RSN + 1 and CR is positioned before the first row
                     of RS.
                  2) A completion condition is raised: warning — additional result sets returned.




822 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                      ISO/IEC 9075-2:2003 (E)
                                        14.4 <close statement>



Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved    Data manipulation 823
ISO/IEC 9075-2:2003 (E)
14.5 <select statement: single row>



14.5 <select statement: single row>

Function
Retrieve values from a specified row of a table.


Format
<select statement: single row> ::=
    SELECT [ <set quantifier> ] <select list>
    INTO <select target list>
    <table expression>

<select target list> ::=
    <target specification> [ { <comma> <target specification> }... ]


Syntax Rules
1) <select target list> shall not contain a <target specification> that specifies a <column reference>.
2) Let T be the table defined by the <table expression>.
3) Case:
    a) If the <select target list> contains a single <target specification> TS and the degree of table T is greater
       than 1 (one), then the declared type of TS shall be a row type.
        Case:
        i)      If TS is an <SQL parameter reference>, then the Syntax Rules of Subclause 9.2, “Store assign-
                ment”, apply to TS and the row type of table T as TARGET and VALUE, respectively.
        ii)     Otherwise, the Syntax Rules of Subclause 9.1, “Retrieval assignment”, apply to TS and the row
                type of table T as TARGET and VALUE, respectively.
    b) Otherwise:
        i)      The number of elements NOE in the <select list> shall be the same as the number of elements
                in the <select target list>. The i-th <target specification>, 1 (one) ≤ i ≤ NOE, in the <select target
                list> corresponds with the i-th element of the <select list>.
        ii)     For i varying from 1 (one) to NOE, let TSi be the i-th <target specification> in the <select target
                list> that is either an <SQL parameter reference> or a <target array element specification>, and
                let SLi be the i-th element of the <select list> that corresponds to the <target specification> in
                the <select target list>.
                Case:
                1) If <target array element specification> is specified, then the Syntax Rules of Subclause 9.2,
                   “Store assignment”, apply to an arbitrary site whose declared type is the declared type of
                   TSi and SLi as TARGET and VALUE, respectively.


824 Foundation (SQL/Foundation)                                                       ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                14.5 <select statement: single row>



                  2) Otherwise, the Syntax Rules of Subclause 9.2, “Store assignment”, apply to TSi and the
                     corresponding element of the <select list>, as TARGET and VALUE, respectively.
         iii)     For each <target specification> TS that is a <host parameter specification>, the Syntax Rules of
                  Subclause 9.1, “Retrieval assignment”, apply to TS and the corresponding element of the <select
                  list>, as TARGET and VALUE, respectively.
         iv)      For each <target specification> TS that is an <embedded variable specification>, the Syntax
                  Rules of Subclause 9.1, “Retrieval assignment”, apply to TS and the corresponding element of
                  the <select list>, as TARGET and VALUE, respectively.
4) Let S be a <query specification> whose <select list> and <table expression> are those specified in the
   <select statement: single row> and that specifies the <set quantifier> if it is specified in the <select statement:
   single row>. S shall be a valid <query specification>.
5) A column in the result of the <select statement: single row> is known not null if the corresponding column
   in the result of S is known not null.
6) The <select statement: single row> is possibly non-deterministic if S is possibly non-deterministic.


Access Rules
    None.


General Rules
1) Let Q be the result of <query specification> S.
2) Case:
    a) If the cardinality of Q is greater than 1 (one), then an exception condition is raised: cardinality violation.
       It is implementation-dependent whether or not SQL-data values are assigned to the targets identified
       by the <select target list>.
    b) If Q is empty, then no SQL-data values are assigned to any targets identified by the <select target list>,
       and a completion condition is raised: no data.
    c) Otherwise, values in the row of Q are assigned to their corresponding targets.
3) If a completion condition no data has been raised, then no further General Rules of this Subclause are
   applied.
4) Case:
    a) If the <select target list> contains a single <target specification> TS and the degree of table T is greater
       than 1 (one), then the current row is assigned to TS and
         Case:
         i)       If TS is an <SQL parameter reference>, then the General Rules of Subclause 9.2, “Store
                  assignment”, apply to TS and the current row as TARGET and VALUE, respectively.




©ISO/IEC 2003 – All rights reserved                                                         Data manipulation 825
ISO/IEC 9075-2:2003 (E)
14.5 <select statement: single row>



        ii)    Otherwise, the General Rules of Subclause 9.1, “Retrieval assignment”, are applied to TS and
               the current row as TARGET and VALUE, respectively.
    b) Otherwise:
        i)     Let NOE be the number of elements in the <select list>.
        ii)    For i varying from 1 (one) to NOE, let TSi be the i-th <target specification> in the <select target
               list> that is either an <SQL parameter reference> or a <target array element specification>, and
               let SLi denote the corresponding (i-th) value in the row of Q. The assignment of values to targets
               in the <select target list> is in an implementation-dependent order.
               Case:
               1) If <target array element specification> is specified, then
                   Case:
                   A) If the value of TSi, denoted by C, is null, then an exception condition is raised: data
                      exception — null value in array target.
                   B) Otherwise:
                       I)     Let N be the maximum cardinality of C.
                       II)    Let M be the cardinality of the value of C.
                       III)   Let I be the value of the <simple value specification> immediately contained in
                              TSi.

                       IV)    Let EDT be the element type of C.
                       V)     Case:
                              1) If I is greater than zero and less than or equal to M, then the value of C is
                                 replaced by an array A with element type EDT and cardinality M derived as
                                 follows:
                                  a) For j varying from 1 (one) to I–1 and from I+1 to M, the j-th element in
                                     A is the value of the j-th element in C.
                                  b) The I-th element of A is set to the value of SL, denoted by SLi, by
                                     applying the General Rules of Subclause 9.2, “Store assignment”, to the
                                     I-th element of A and SLi as TARGET and VALUE, respectively.

                              2) If I is greater than M and less than or equal to N, then the value of C is
                                 replaced by an array A with element type EDT and cardinality I derived as
                                 follows:
                                  a) For j varying from 1 (one) to M, the j-th element in A is the value of the
                                     j-th element in C.
                                  b) For j varying from M+1 to I, the j-th element in A is the null value.




826 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)
                                                                                 14.5 <select statement: single row>



                                          c) The I-th element of A is set to the value of SL, denoted by SLi, by
                                             applying the General Rules of Subclause 9.2, “Store assignment”, to the
                                             I-th element of A and SLi as TARGET and VALUE, respectively.

                                      3) Otherwise, an exception condition is raised: data exception — array element
                                         error.
                  2) Otherwise, the corresponding value SLi in the row of Q is assigned to TSi according to the
                     General Rules of Subclause 9.2, “Store assignment”, as VALUE and TARGET, respectively.
         iii)     For each <target specification> TS that is a <host parameter specification>, the corresponding
                  value in the row of Q is assigned to TS according to the General Rules of Subclause 9.1, “Retrieval
                  assignment”, as VALUE and TARGET, respectively. The assignment of values to targets in the
                  <select target list> is in an implementation-dependent order.
         iv)      For each <target specification> TS that is an <embedded variable specification>, the corresponding
                  value in the row of Q is assigned to TS according to the General Rules of Subclause 9.1, “Retrieval
                  assignment”, as VALUE and TARGET, respectively. The assignment of values to targets in the
                  <select target list> is in an implementation-dependent order.
5) If an exception condition is raised during the assignment of a value to a target, then the values of all targets
   are implementation-dependent.


Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved                                                          Data manipulation 827
ISO/IEC 9075-2:2003 (E)
14.6 <delete statement: positioned>



14.6 <delete statement: positioned>

Function
Delete a row of a table.


Format
<delete statement: positioned> ::=
    DELETE FROM <target table> [ [ AS ] <correlation name> ]
    WHERE CURRENT OF <cursor name>

<target table> ::=
    <table name>
  | ONLY <left paren> <table name> <right paren>


Syntax Rules
1) Let CR be the cursor denoted by the <cursor name>. CR shall be an updatable cursor.
2) Let TN be the <table name> contained in <target table>.
3) If <target table> TT immediately contains ONLY and the table identified by TN is not a typed table, then
   TT is equivalent to TN.
4) Let T be the simply underlying table of CR. T is the subject table of the <delete statement: positioned>.
   Let LUT be the leaf underlying table of T such that T is one-to-one with respect to LUT.
5) The subject table of a <delete statement: positioned> shall not identify an old transition table or a new
   transition table.
6) TN shall identify LUT.
7) <target table> shall specify ONLY if and only if the <table reference> contained in T that references LUT
   specifies ONLY.
8) The schema identified by the explicit or implicit qualifier of TN shall include the descriptor of LUT.
9) Case:
    a) If <correlation name> is specified, then let CN be that <correlation name>.
    b) Otherwise, let CN be the <table name> contained in <target table>. CN is an exposed <table or query
       name>.
    NOTE 360 — CN has no scope.


Access Rules
1) Case:




828 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                                 ISO/IEC 9075-2:2003 (E)
                                                                                       14.6 <delete statement: positioned>



    a) If <delete statement: positioned> is contained, without an intervening <SQL routine spec> that specifies
       SQL SECURITY INVOKER, in an <SQL schema statement>, then the applicable privileges for the
       owner of that schema shall include DELETE for TN.
    b) Otherwise, the current privileges shall include DELETE for TN.
    NOTE 361 — “current privileges” and “applicable privileges” are defined in Subclause 12.3, “<privileges>”.


General Rules
1) If the access mode of the current SQL-transaction or the access mode of the branch of the current SQL-
   transaction at the current SQL-connection is read-only, and not every leaf generally underlying table of
   CR is a temporary table, then an exception condition is raised: invalid transaction state — read-only SQL-
   transaction.
2) If there is any sensitive cursor SCR, other than CR, that is currently open in the SQL-transaction in which
   this SQL-statement is being executed, then
    Case:
    a) If SCR has not been held into a subsequent SQL-transaction, then either the change resulting from the
       successful execution of this statement is made visible to SCR or an exception condition is raised: cursor
       sensitivity exception — request failed.
    b) Otherwise, whether the change resulting from the successful execution of this SQL-statement is made
       visible to SCR is implementation-defined.
3) If there is any insensitive cursor ICR, other than CR, that is currently open, then either the change resulting
   from the successful execution of this statement is invisible to ICR, or an exception condition is raised:
   cursor sensitivity exception — request failed.
4) The extent to which an SQL-implementation may disallow independent changes that are not significant is
   implementation-defined.
5) If CR is not positioned on a row, then an exception condition is raised: invalid cursor state.
6) If CR is a holdable cursor and a <fetch statement> has not been issued against CR within the current SQL-
   transaction, then an exception condition is raised: invalid cursor state.
7) Let R be the current row of CR. Exactly one row R1 in LUT such that each field in R is identical to the
   corresponding field in R1 is identified for deletion from LUT.
    NOTE 362 — In case more than one row R1 satisfies the stated condition, it is implementation-dependent which one is identified
    for deletion.
    NOTE 363 — Identifying a row for deletion is an implementation-dependent mechanism.

8) The effect on CR is implementation-defined.
9) Case:
    a) If LUT is a base table, then
         Case:
         i)       If <target table> specifies ONLY, then LUT is identified for deletion processing without subtables.


©ISO/IEC 2003 – All rights reserved                                                                   Data manipulation 829
ISO/IEC 9075-2:2003 (E)
14.6 <delete statement: positioned>



        ii)     Otherwise, LUT is identified for deletion processing with subtables.
        NOTE 364 — Identifying a base table for deletion processing, with or without subtables, is an implementation-dependent
        mechanism.

    b) If LUT is a viewed table, then the General Rules of Subclause 14.18, “Effect of deleting some rows
       from a viewed table”, are applied with <target table> as VIEW NAME.
10) The General Rules of Subclause 14.16, “Effect of deleting rows from base tables”, are applied.
11) If, while CR is open, the row from which the current row of CR is derived has been marked for deletion
    by any <delete statement: searched>, marked for deletion by any <delete statement: positioned> that iden-
    tifies any cursor other than CR, updated by any <update statement: searched>, updated by any <update
    statement: positioned>, or updated by any <merge statement> that identifies any cursor other than CR, then
    a completion condition is raised: warning — cursor operation conflict.
12) If the <delete statement: positioned> deleted the last row of CR, then the position of CR is after the last
    row; otherwise, the position of CR is before the next row.


Conformance Rules
1) Without Feature S111, “ONLY in query expressions”, conforming SQL language shall not contain a <target
   table> that contains ONLY.




830 Foundation (SQL/Foundation)                                                              ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                              14.7 <delete statement: searched>



14.7 <delete statement: searched>

Function
Delete rows of a table.


Format
<delete statement: searched> ::=
    DELETE FROM <target table> [ [ AS ] <correlation name> ]
    [ WHERE <search condition> ]


Syntax Rules
1) Let TN be the <table name> contained in the <target table>. Let T be the table identified by TN.
2) T shall be an updatable table.
3) If the <delete statement: searched> is contained in a <triggered SQL statement>, then the <search condition>
   shall not contain a <value specification> that specifies a parameter reference.
4) T is the subject table of the <delete statement: searched>.
5) TN shall not identify an old transition table or a new transition table.
6) Case:
    a) If <correlation name> is specified, then let CN be that <correlation name>.
    b) Otherwise, let CN be the <table name> contained in <target table>. CN is an exposed <table or query
       name>.
7) The scope of CN is <search condition>.
8) If WHERE <search condition> is not specified, then WHERE TRUE is implicit.
9) The <search condition> shall not generally contain a <routine invocation> whose subject routine is an SQL-
   invoked routine that possibly modifies SQL-data.


Access Rules
1) Case:
    a) If <delete statement: searched> is contained, without an intervening <SQL routine spec> that specifies
       SQL SECURITY INVOKER, in an <SQL schema statement>, then let A be the <authorization identifier>
       that owns that schema.
         i)       The applicable privileges for A shall include DELETE for TN.
         ii)      If <target table> immediately contains ONLY, then the applicable privileges for A shall include
                  SELECT WITH HIERARCHY OPTION on at least one supertable of T.


©ISO/IEC 2003 – All rights reserved                                                      Data manipulation 831
ISO/IEC 9075-2:2003 (E)
14.7 <delete statement: searched>



    b) Otherwise,
        i)      The current privileges shall include DELETE for TN.
        ii)     If <target table> immediately contains ONLY, then the current privileges shall include SELECT
                WITH HIERARCHY OPTION on at least one supertable of T.
    NOTE 365 — “current privileges” and “applicable privileges” are defined in Subclause 12.3, “<privileges>”.


General Rules
1) If the access mode of the current SQL-transaction or the access mode of the branch of the current SQL-
   transaction at the current SQL-connection is read-only, and T is not a temporary table, then an exception
   condition is raised: invalid transaction state — read-only SQL-transaction.
2) If there is any sensitive cursor CR that is currently open in the SQL-transaction in which this SQL-statement
   is being executed, then
    Case:
    a) If CR has not been held into a subsequent SQL-transaction, then either the change resulting from the
       successful execution of this statement shall be made visible to CR or an exception condition is raised:
       cursor sensitivity exception — request failed.
    b) Otherwise, whether the change resulting from the successful execution of this SQL-statement is made
       visible to CR is implementation-defined.
3) If there is any cursor CR that is currently open and whose <declare cursor> contained INSENSITIVE, then
   either the change resulting from the successful execution of this statement shall be invisible to CR, or an
   exception condition is raised: cursor sensitivity exception — request failed.
4) The extent to which an SQL-implementation may disallow independent changes that are not significant is
   implementation-defined.
5) The <search condition> is applied to each row of T with the exposed <correlation name>s or <table or
   query name>s of the <table reference> bound to that row.
6) Case:
    a) If <target table> contains ONLY, then the rows for which the result of the <search condition> is True
       and for which there is no subrow in a proper subtable of T are identified for deletion from T.
    b) Otherwise, the rows for which the result of the <search condition> is True are identified for deletion
       from T.
    NOTE 366 — Identifying a row for deletion is an implementation-dependent mechanism.

7) Case:
    a) If T is a base table, then
        Case:
        i)      If <target table> specifies ONLY, then T is identified for deletion processing without subtables.
        ii)     Otherwise, T is identified for deletion processing with subtables.


832 Foundation (SQL/Foundation)                                                               ©ISO/IEC 2003 – All rights reserved
                                                                                                ISO/IEC 9075-2:2003 (E)
                                                                                        14.7 <delete statement: searched>



         NOTE 367 — Identifying a base table for deletion processing, with or without subtables, is an implementation-dependent
         mechanism.

    b) If T is a viewed table, then the General Rules of Subclause 14.18, “Effect of deleting some rows from
       a viewed table”, are applied with <target table> as VIEW NAME.
8) The General Rules of Subclause 14.16, “Effect of deleting rows from base tables”, are applied.
9) Each <subquery> in the <search condition> is effectively executed for each row of T and the results are
   used in the application of the <search condition> to the given row of T. If any executed <subquery> contains
   an outer reference to a column of T, then the reference is to the value of that column in the given row of T.
    NOTE 368 — “outer reference” is defined in Subclause 6.7, “<column reference>”.

10) If any row that is marked for deletion by the <delete statement: searched> has been marked for deletion
    by any <delete statement: positioned> that identifies some cursor CR that is still open or updated by any
    <update statement: positioned> that identifies some cursor CR that is still open, then a completion condition
    is raised: warning — cursor operation conflict.
11) All rows that are marked for deletion are effectively deleted at the end of the <delete statement: searched>,
    prior to the checking of any integrity constraints.
12) If <search condition> is specified, then the <search condition> is evaluated for each row of T prior to the
    invocation of any <triggered action> caused by the imminent or actual deletion of any row of T.
13) If no row is deleted, then a completion condition is raised: no data.


Conformance Rules
1) Without Feature F781, “Self-referencing operations”, conforming SQL language shall not contain a <delete
   statement: searched> in which a leaf generally underlying table of T is an underlying table of any <query
   expression> generally contained in the <search condition>.
2) Without Feature T111, “Updatable joins, unions, and columns”, conforming SQL language shall not contain
   a <delete statement: searched> that contains a <target table> that identifies a table that is not simply
   updatable.




©ISO/IEC 2003 – All rights reserved                                                                  Data manipulation 833
ISO/IEC 9075-2:2003 (E)
14.8 <insert statement>



14.8 <insert statement>

Function
Create new rows in a table.


Format
<insert statement> ::=
    INSERT INTO <insertion target> <insert columns and source>

<insertion target> ::= <table name>

<insert columns and source> ::=
    <from subquery>
  | <from constructor>
  | <from default>

<from subquery> ::=
    [ <left paren> <insert column list> <right paren> ]
    [ <override clause> ]
    <query expression>

<from constructor> ::=
    [ <left paren> <insert column list> <right paren> ]
    [ <override clause> ]
    <contextually typed table value constructor>

<override clause> ::=
    OVERRIDING USER VALUE
  | OVERRIDING SYSTEM VALUE

<from default> ::= DEFAULT VALUES

<insert column list> ::= <column name list>


Syntax Rules
1) Let TN be the <table name>; let T be the table identified by TN. If T is a view, then <target table> is
   effectively replaced by:
      ONLY ( TN )

2) T shall be insertable-into.
3) For each leaf generally underlying table of T whose descriptor includes a user-defined type name UDTN,
   the data type descriptor of the user-defined type UDT identified by UDTN shall indicate that UDT is
   instantiable.
4) A column identified by the <insert column list> is an object column.
5) T shall be an updatable table; each object column of T shall be an updatable column.


834 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                                                        14.8 <insert statement>



    NOTE 369 — The notion of updatable columns of base tables is defined in Subclause 4.14, “Tables”. The notion of updatable
    columns of viewed tables is defined in Subclause 11.22, “<view definition>”.

6) T is the subject table of the <insert statement>.
7) TN shall not identify an old transition table or a new transition table.
8) An <insert columns and source> that specifies DEFAULT VALUES is implicitly replaced by an <insert
   columns and source> that specifies a <contextually typed table value constructor> of the form
        VALUES (DEFAULT, DEFAULT, ..., DEFAULT)
    where the number of “DEFAULT” entries is equal to the number of columns of T.
9) Each <column name> in the <insert column list> shall identify an updatable column of T. No <column
   name> of T shall be identified more than once. If the <insert column list> is omitted, then an <insert column
   list> that identifies all columns of T in the ascending sequence of their ordinal positions within T is implicit.
10) If <contextually typed table value constructor> CTTVC is specified, then every <contextually typed row
    value constructor element> simply contained in CTTVC whose positionally corresponding <column name>
    in <insert column list> references a column of which some underlying column is a generated column shall
    be a <default specification>.
11) Case:
    a) If some underlying column of a column referenced by a <column name> contained in <insert column
       list> is a system-generated self-referencing column or a derived self-referencing column, then <override
       clause> shall be specified.
    b) If for some n, some underlying column of the column referenced by the <column name> CN contained
       in the n-th ordinal position in <insert column list> is an identity column, then
         Case:
         i)       If <from subquery> is specified, then <override clause> shall be specified.
         ii)      If any <contextually typed row value expression> simply contained in the <contextually typed
                  table value constructor> is a <row value special case>, then <override clause> shall be specified.
         iii)     If the n-th <contextually typed row value constructor element> simply contained in any <con-
                  textually typed row value constructor> simply contained in the <contextually typed table value
                  constructor> is not a <default specification>, then <override clause> shall be specified.
         NOTE 370 — The preceding subrules do not cover all possibilities of their parent subrule. The remaining possibilities are
         where <default clause> is specified for every identity column, in which case it is immaterial whether <override clause> is
         specified or not.

    c) Otherwise, <override clause> shall not be specified.
12) If <contextually typed table value constructor> CVC is specified, then the data type of every <contextually
    typed value specification> CVS specified in every <contextually typed row value expression> CRVS contained
    in CVC is the data type DT indicated in the column descriptor for the positionally corresponding column
    in the explicit or implicit <insert column list>. If CVS is an <empty specification> that specifies ARRAY,
    then DT shall be an array type. If CVS is an <empty specification> that specifies MULTISET, then DT
    shall be a multiset type.




©ISO/IEC 2003 – All rights reserved                                                                     Data manipulation 835
ISO/IEC 9075-2:2003 (E)
14.8 <insert statement>



13) Let QT be the table specified by the <query expression> or <contextually typed table value constructor>.
    The degree of QT shall be equal to the number of <column name>s in the <insert column list>. The column
    of table T identified by the i-th <column name> in the <insert column list> corresponds with the i-th column
    of QT.
14) The Syntax Rules of Subclause 9.2, “Store assignment”, apply to corresponding columns of T and QT as
    TARGET and VALUE, respectively.
15) If the <insert statement> is contained in a <triggered SQL statement>, then the insert value shall not contain
    a <value specification> that specifies a parameter reference.
16) A <query expression> simply contained in a <from subquery> shall not be a <table value constructor>.
    NOTE 371 — This rule removes a syntactic ambiguity; otherwise, “VALUES (1)” could be parsed either as
    <insert columns and source> ::=
       <from subquery> ::=
       <query expression> ::=
       <table value constructor> ::=
       VALUES (1)

    or
    <insert columns and source> ::=
       <from constructor> ::=
       <contextually typed table value constructor> ::=
       VALUES (1)


Access Rules
1) Case:
    a) If <insert statement> is contained in, without an intervening <SQL routine spec> that specifies SQL
       SECURITY INVOKER, an <SQL schema statement>, then let A be the <authorization identifier> that
       owns that schema. The applicable privileges for A for TN shall include INSERT for each object column.
    b) Otherwise, the current privileges for TN shall include INSERT for each object column.
    NOTE 372 — “current privileges” and “applicable privileges” are defined in Subclause 12.3, “<privileges>”.


General Rules
1) If the access mode of the current SQL-transaction or the access mode of the branch of the current SQL-
   transaction at the current SQL-connection is read-only, and T is not a temporary table, then an exception
   condition is raised: invalid transaction state — read-only SQL-transaction.
2) If there is any sensitive cursor CR that is currently open in the SQL-transaction in which this SQL-statement
   is being executed, then
    Case:
    a) If CR has not been held into a subsequent SQL-transaction, then either the change resulting from the
       successful execution of this statement shall be made visible to CR or an exception condition is raised:
       cursor sensitivity exception — request failed.




836 Foundation (SQL/Foundation)                                                               ©ISO/IEC 2003 – All rights reserved
                                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                                                     14.8 <insert statement>



    b) Otherwise, whether the change resulting from the successful execution of this SQL-statement is made
       visible to CR is implementation-defined.
3) If there is any cursor CR that is currently open and whose <declare cursor> contained INSENSITIVE, then
   either the change resulting from the successful execution of this statement shall be invisible to CR, or an
   exception condition is raised: cursor sensitivity exception — request failed.
4) The extent to which an SQL-implementation may disallow independent changes that are not significant is
   implementation-defined.
5) QT is effectively evaluated before insertion of any rows into T.
6) Let Q be the result of evaluating QT.
7) For each row R of Q:
    a) A candidate row of T is effectively created in which the value of each column is its default value, as
       specified in the General Rules of Subclause 11.5, “<default clause>”. The candidate row consists of
       every column of T.
    b) If T has a column RC of which some underlying column is a self-referencing column, then
         Case:
         i)       If RC is a system-generated self-referencing column, then the value of RC is effectively replaced
                  by the REF value of the candidate row.
         ii)      If RC is a derived self-referencing column, then the value of RC is effectively replaced by a
                  value derived from the columns in the candidate row that correspond to the list of attributes of
                  the derived representation of the reference type of RC in an implementation-dependent manner.
    c) For each object column in the candidate row, let Ci be the object column identified by the i-th <column
       name> in the <insert column list> and let SVi be the i-th value of R.

    d) For every Ci for which one of the following conditions is true:

         i)       Ci is not marked as unassigned and no underlying column of Ci is a self-referencing column.

         ii)      Some underlying column of Ci is a user-generated self-referencing column.

         iii)     Some underlying column of Ci is a self-referencing column and OVERRIDING SYSTEM
                  VALUE is specified.
         iv)      Some underlying column of Ci is an identity column and OVERRIDING SYSTEM VALUE is
                  specified.
         the General Rules of Subclause 9.2, “Store assignment”, are applied with Ci and SVi as TARGET and
         SOURCE, respectively.
    NOTE 373 — The data values allowable in the candidate row may be constrained by a WITH CHECK OPTION constraint. The
    effect of a WITH CHECK OPTION constraint is defined in the General Rules of Subclause 14.21, “Effect of inserting a table into
    a viewed table”.

8) Let S be the table consisting of the candidate rows.
    Case:


©ISO/IEC 2003 – All rights reserved                                                                   Data manipulation 837
ISO/IEC 9075-2:2003 (E)
14.8 <insert statement>



    a) If T is a base table, then T is identified for insertion of source table S.
        NOTE 374 — Identifying a base table for insertion of a source table is an implementation-dependent operation.

    b) If T is a viewed table, then the General Rules of Subclause 14.21, “Effect of inserting a table into a
       viewed table”, are applied with S as SOURCE and T as TARGET.
9) The General Rules of Subclause 14.19, “Effect of inserting tables into base tables”, are applied.
10) If Q is empty, then a completion condition is raised: no data.


Conformance Rules
1) Without Feature F781, “Self-referencing operations”, conforming SQL language shall not contain an <insert
   statement> in which the <table name> of a leaf generally underlying table of T is generally contained in
   the <from subquery> except as the table name of a qualifying table of a column reference.
2) Without Feature F222, “INSERT statement: DEFAULT VALUES clause”, conforming SQL language
   shall not contain a <from default>.
3) Without Feature S024, “Enhanced structured types”, in conforming SQL language, for each column C
   identified in the explicit or implicit <insert column list>, if the declared type of C is a structured type TY,
   then the declared type of the corresponding column of the <query expression> or <contextually typed table
   value constructor> shall be TY.
4) Without Feature S043, “Enhanced reference types”, conforming SQL language shall not contain an
   <override clause>.
5) Without Feature T111, “Updatable joins, unions, and columns”, conforming SQL language shall not contain
   an <insert statement> that contains an <insertion target> that identifies a table that is not simply updatable.




838 Foundation (SQL/Foundation)                                                               ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                                     14.9 <merge statement>



14.9 <merge statement>

Function
Conditionally update rows of a table, or insert new rows into a table, or both.


Format
<merge statement> ::=
    MERGE INTO <target table> [ [ AS ] <merge correlation name> ]
    USING <table reference>
    ON <search condition> <merge operation specification>

<merge correlation name> ::= <correlation name>

<merge operation specification> ::= <merge when clause>...

<merge when clause> ::=
    <merge when matched clause>
  | <merge when not matched clause>

<merge when matched clause> ::=
    WHEN MATCHED THEN <merge update specification>

<merge when not matched clause> ::=
    WHEN NOT MATCHED THEN <merge insert specification>

<merge update specification> ::= UPDATE SET <set clause list>

<merge insert specification> ::=
    INSERT [ <left paren> <insert column list> <right paren> ]
    [ <override clause> ]
    VALUES <merge insert value list>

<merge insert value list> ::=
    <left paren>
    <merge insert value element> [ { <comma> <merge insert value element> }... ]
    <right paren>

<merge insert value element> ::=
    <value expression>
  | <contextually typed value specification>


Syntax Rules
1) Neither <merge when matched clause> nor <merge when not matched clause> shall be specified more than
   once.
2) Let TN be the <table name> contained in <target table> and let T be the table identified by TN. T is the
   subject table of the <merge statement>.
3) T shall be insertable-into.



©ISO/IEC 2003 – All rights reserved                                                   Data manipulation 839
ISO/IEC 9075-2:2003 (E)
14.9 <merge statement>



4) T shall not be an old transition table or a new transition table.
5) For each leaf generally underlying table of T whose descriptor includes a user-defined type name UDTN,
   the data type descriptor of the user-defined type UDT identified by UDTN shall indicate that UDT is
   instantiable.
6) If T is a view, then <target table> is effectively replaced by:
       ONLY ( TN )

7) Case:
    a) If <merge correlation name> is specified, then let CN be the <correlation name> contained in <merge
       correlation name>.
    b) Otherwise, let CN be the <table name> contained in <target table>.
8) The scope of CN is <search condition> and <set clause list>.
9) Let TR be the <table reference> immediately contained in <merge statement>. TR shall not directly contain
   a <joined table>.
10) The <correlation name> or exposed <table name> that is exposed by TR shall not be equivalent to CN.
11) If the <insert column list> is omitted, then an <insert column list> that identifies all columns of T in the
    ascending sequence of their ordinal position within T is implicit.
12) Case:
    a) If T is a referenceable table or a table having an identity column whose descriptor includes an indication
       that values are always generated, then:
        i)      Let C be the self-referencing column or identity column of T.
        ii)     If C is an identity column, a system-generated self-referencing column or a derived self-refer-
                encing column and C is contained in <insert column list>, then <override clause> shall be
                specified; otherwise, <override clause> shall not be specified.
    b) Otherwise, <override clause> shall not be specified.
13) The <search condition> shall not generally contain a <routine invocation> whose subject routine is an SQL-
    invoked routine that possibly modifies SQL-data.
14) Each column identified by an <object column> in the <set clause list> is an update object column. Each
    column identified by a <column name> in the implicit or explicit <insert column list> is an insert object
    column. Each update object column and each insert object column is an object column.
15) Every object column shall identify an updatable column of T.
    NOTE 375 — The notion of updatable columns of base tables is defined in Subclause 4.14, “Tables”. The notion of updatable
    columns of viewed tables is defined in Subclause 11.22, “<view definition>”.

16) No <column name> of T shall be identified more than once in in an <insert column list>.
17) Let NI be the number of <merge insert value element>s contained in <merge insert value list>. Let EXP1,
    EXP2, ... , EXPNI be those <merge insert value element>s.



840 Foundation (SQL/Foundation)                                                              ©ISO/IEC 2003 – All rights reserved
                                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                                                    14.9 <merge statement>



18) The number of <column name>s in the <insert column list> shall be equal to NI.
19) The declared type of every <contextually typed value specification> CVS in a <merge insert value list> is
    the data type DT indicated in the column descriptor for the positionally corresponding column in the explicit
    or implicit <insert column list>. If CVS is an <empty specification> that specifies ARRAY, then DT shall
    be an array type. If CVS is an <empty specification> that specifies MULTISET, then DT shall be a multiset
    type.
20) Every <merge insert value element> whose positionally corresponding <column name> in <insert column
    list> references a column of which some underlying column is a generated column shall be a <default
    specification>.

21) For 1 (one) ≤ i NI, the Syntax Rules of Subclause 9.2, “Store assignment”, apply to the column of table T
    identified by the i-th <column name> in the <insert column list> and EXPi as TARGET and VALUE,
    respectively.


Access Rules
1) Case:
    a) If <merge statement> is contained, without an intervening <SQL routine spec> that specifies SQL
       SECURITY INVOKER, in an <SQL schema statement>, then let A be the <authorization identifier>
       that owns that schema.
         i)       The applicable privileges for A shall include UPDATE for each update object column.
         ii)      The applicable privileges for A shall include INSERT for each insert object column.
         iii)     If <target table> immediately contains ONLY, then the applicable privileges for A shall include
                  SELECT WITH HIERARCHY OPTION on at least one supertable of T.
    b) Otherwise,
         i)       The current privileges shall include UPDATE for each update object column.
         ii)      The current privileges shall include INSERT for each insert object column.
         iii)     If <target table> immediately contains ONLY, then the current privileges shall include SELECT
                  WITH HIERARCHY OPTION on at least one supertable of T.
                  NOTE 376 — “current privileges” and “applicable privileges” are defined in Subclause 12.3, “<privileges>”.


General Rules
1) If the access mode of the current SQL-transaction or the access mode of the branch of the current SQL-
   transaction at the current SQL-connection is read-only, and T is not a temporary table, then an exception
   condition is raised: invalid transaction state — read-only SQL-transaction.
2) If there is any sensitive cursor CR that is currently open in the SQL-transaction in which this SQL-statement
   is being executed, then
    Case:



©ISO/IEC 2003 – All rights reserved                                                                   Data manipulation 841
ISO/IEC 9075-2:2003 (E)
14.9 <merge statement>



    a) If CR has not been held into a subsequent SQL-transaction, then either the change resulting from the
       successful execution of this statement shall be made visible to CR or an exception condition is raised:
       cursor sensitivity exception — request failed.
    b) Otherwise, whether the change resulting from the successful execution of this SQL-statement is made
       visible to CR is implementation-defined.
3) If there is any cursor CR that is currently open and whose <declare cursor> contained INSENSITIVE, then
   either the change resulting from the successful execution of this statement shall be invisible to CR, or an
   exception condition is raised: cursor sensitivity exception — request failed.
4) The extent to which an SQL-implementation may disallow independent changes that are not significant is
   implementation-defined.
5) Let QT be the table specified by the <table reference>. QT is effectively evaluated before update or insertion
   of any rows in T. Let Q be the result of evaluating QT.
6) For each <merge when clause>,
    Case:
    a) If <merge when matched clause> is specified, then:
        i)     For each row R1 of T:
               1) The <search condition> is applied to R1 with the exposed <table name> of the <target table>
                  bound to R1 and to each row of Q with the exposed <correlation name>s or <table or query
                  name>s of the <table reference> bound to that row. The <search condition> is effectively
                  evaluated for R1 before updating any row of T and prior to the invocation of any <triggered
                  action> caused by the update of any row of T and before inserting any rows into T and prior
                  to the invocation of any <triggered action> caused by the insert of any row of T. Each
                  <subquery> in the <search condition> is effectively executed for R1 and for each row of Q
                  and the results used in the application of the <search condition> to R1 and the given row of
                  Q. If any executed <subquery> contains an outer reference to a column of T, then the refer-
                  ence is to the value of that column in the given row of T.
                   Case:
                   A) If <target table> contains ONLY, then R1 is a subject row if R1 has no subrow in a
                      proper subtable of T and the result of the <search condition> is True for some row R2
                      of Q. R2 is the matching row.
                   B) Otherwise, R1 is a subject row if the result of the <search condition> is True for some
                      row R2 of Q. R2 is the matching row.
                       NOTE 377 — “outer reference” is defined in Subclause 6.7, “<column reference>”.

               2) If R1 is a subject row, then:
                   A) Let M be the number of matching rows in Q for R1.
                   B) If M is greater than 1 (one), then an exception condition is raised: cardinality violation.
                   C) The <update source> of each <set clause> is effectively evaluated for R1 before any
                      row of T is updated and prior to the invocation of any <triggered action> caused by the
                      update of any row of T. The resulting value is the update value.


842 Foundation (SQL/Foundation)                                                         ©ISO/IEC 2003 – All rights reserved
                                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                                                       14.9 <merge statement>



                      D) A candidate new row is constructed by copying the subject row and updating it as
                         specified by each <set clause> by applying the General Rules of Subclause 14.12, “<set
                         clause list>”.
         ii)      If T is a base table, then each subject row is also an object row; otherwise, an object row is any
                  row of a leaf generally underlying table of T from which a subject row is derived.
                  NOTE 378 — The data values allowable in the object rows may be constrained by a WITH CHECK OPTION con-
                  straint. The effect of a WITH CHECK OPTION constraint is defined in the General Rules of Subclause 14.24, “Effect
                  of replacing some rows in a viewed table”.

         iii)     If any row in the set of object rows has been marked for deletion by any <delete statement:
                  positioned> that identifies some cursor CR that is still open or updated by any <update statement:
                  positioned> that identifies some cursor CR that is still open, then a completion condition is
                  raised: warning — cursor operation conflict.
         iv)      Let CL be the columns of T identified by the <object column>s contained in the <set clause
                  list>.
         v)       Each subject row SR is identified for replacement, by its corresponding candidate new row CNR,
                  in T. The set of (SR, CNR) pairs is the replacement set for T.
                  NOTE 379 — Identifying a row for replacement, associating a replacement row with an identified row, and associating
                  a replacement set with a table are implementation-dependent operations.

         vi)      Case:
                  1) If T is a base table, then
                      Case:
                      A) If <target table> specifies ONLY, then T is identified for replacement processing without
                         subtables with respect to object columns CL.
                      B) Otherwise, T is identified for replacement processing with subtables with respect to
                         object columns CL.
                           NOTE 380 — Identifying a base table for replacement processing, with or without subtables, is an imple-
                           mentation-dependent mechanism. In general, though not here, the list of object columns can be empty.

                  2) If T is a viewed table, then the General Rules of Subclause 14.24, “Effect of replacing some
                     rows in a viewed table”, are applied with <target table> as VIEW NAME.
         vii)     The General Rules of Subclause 14.22, “Effect of replacing rows in base tables”, are applied.
    b) If <merge when not matched clause> is specified, then:
         i)       Let TR1 be the <target table> immediately contained in <merge statement>, let TR2 be the <table
                  reference> immediately contained in <merge statement>, and let SC1 be the <search condition>
                  immediately contained in <merge statement>. If <merge correlation name> is specified, let MCN
                  be “AS <merge correlation name>”; otherwise, let MCN be a zero-length string. Let S1 be the
                  result of
                     SELECT *
                     FROM TR1 MCN, TR2
                     WHERE SC1




©ISO/IEC 2003 – All rights reserved                                                                     Data manipulation 843
ISO/IEC 9075-2:2003 (E)
14.9 <merge statement>



       ii)    Let S2 be the collection of rows of Q for which there exists in S1 some row that is the concate-
              nation of some row R1 of T and some row R2 of Q.
       iii)   Let S3 be the collection of rows of Q that are not in S2. Let SN3 be the effective distinct name
              for S3. Let EN be the exposed <correlation name> or <table or query name> of TR2.
       iv)    Let S4 be the result of:
                SELECT EXP1, EXP2, ... , EXPNI
                FROM SN3 AS EN


       v)     S4 is effectively evaluated before insertion of any rows into or update of any rows in T.
       vi)    For each row R of S4:
              1) A candidate row of T is effectively created in which the value of each column is its default
                 value, as specified in the General Rules of Subclause 11.5, “<default clause>”. The candidate
                 row consists of every column of T.
              2) If T has a column RC of which some underlying column is a self-referencing column, then
                  Case:
                  A) If RC is a system-generated self-referencing column, then the value of RC is effectively
                     replaced by the REF value of the candidate row.
                  B) If RC is a derived self-referencing column, then the value of RC is effectively replaced
                     by a value derived from the columns in the candidate row that correspond to the list of
                     attributes of the derived representation of the reference type of RC in an implementation-
                     dependent manner.
              3) For each object column in the candidate row, let Ci be the object column identified by the
                 i-th <column name> in the <insert column list> and let SVi be the i-th value of R.

              4) For every Ci for which one of the following conditions is true:

                  A) Ci is not marked as unassigned and no underlying column of Ci is a self-referencing
                     column.
                  B) Some underlying column of Ci is a user-generated self-referencing column.

                  C) Some underlying column of Ci is a self-referencing column and OVERRIDING SYSTEM
                     VALUE is specified.
                  D) Some underlying column of Ci is an identity column and OVERRIDING SYSTEM
                     VALUE is specified.
                  the General Rules of Subclause 9.2, “Store assignment”, are applied to Ci and SVi as TARGET
                  and SOURCE, respectively.
                  NOTE 381 — The data values allowable in the candidate row may be constrained by a WITH CHECK OPTION
                  constraint. The effect of a WITH CHECK OPTION constraint is defined in the General Rules of Subclause 14.21,
                  “Effect of inserting a table into a viewed table”.

       vii)   Let S be the table consisting of the candidate rows.


844 Foundation (SQL/Foundation)                                                            ©ISO/IEC 2003 – All rights reserved
                                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                                                     14.9 <merge statement>



                  Case:
                  1) If T is a base table, then T is identified for insertion of source table S.
                      NOTE 382 — Identifying a base table for insertion of a source table is an implementation-dependent operation.

                  2) If T is a viewed table, then the General Rules of Subclause 14.21, “Effect of inserting a table
                     into a viewed table”, are applied with S as SOURCE and T as TARGET.
         viii)    The General Rules of Subclause 14.19, “Effect of inserting tables into base tables”, are applied.
7) If Q is empty, then a completion condition is raised: no data.


Conformance Rules
1) Without Feature F781, “Self-referencing operations”, conforming SQL language shall not contain a <merge
   statement> in which a leaf generally underlying table of T is generally contained in a <query expression>
   immediately contained in the <table reference> except as the <table or query name> or <correlation name>
   of a column reference.
2) Without Feature F781, “Self-referencing operations”, conforming SQL language shall not contain a <merge
   statement> in which a leaf generally underlying table of T is an underlying table of any <query expression>
   generally contained in the <search condition>.
3) Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain a <merge
   statement> that does not satisfy the condition: for each column C identified in the explicit or implicit <insert
   column list>, if the declared type of C is a structured type TY, then the declared type of the corresponding
   column of the <query expression> or <contextually typed table value constructor> is TY.
4) Without Feature F312, “MERGE statement”, conforming SQL language shall not contain a <merge state-
   ment>.
5) Without Feature T111, “Updatable joins, unions, and columns”, conforming SQL language shall not contain
   a <merge statement> that contains an <target table> that identifies a table that is not simply updatable.




©ISO/IEC 2003 – All rights reserved                                                                   Data manipulation 845
ISO/IEC 9075-2:2003 (E)
14.10 <update statement: positioned>



14.10 <update statement: positioned>

Function
Update a row of a table.


Format
<update statement: positioned> ::=
    UPDATE <target table> [ [ AS ] <correlation name> ]
    SET <set clause list>
    WHERE CURRENT OF <cursor name>


Syntax Rules
1) Let CR be the cursor denoted by the <cursor name>. CR shall be an updatable cursor.
2) Let TU be the simply underlying table of CR. TU is the subject table of the <update statement: positioned>.
   Let LUT be the leaf underlying table T such that T is one-to-one with respect to LUT.
3) Let TN be the <table name> contained in <target table>. TN shall identify LUT.
4) <target table> shall specify ONLY if and only if the <table reference> contained in TU that references LUT
   specifies ONLY.
5) TN shall not identify an old transition table or a new transition table.
6) Let T be the table identified by TN.
7) Case:
    a) If <correlation name> is specified, then let CN be that <correlation name>.
    b) Otherwise, let CN be the <table name> contained in <target table>. CN is an exposed <table or query
       name>.
8) The scope of CN is <set clause list>.
9) If CR is an ordered cursor, then for each <object column> OC contained in <set clause list>, the <order by
   clause> of the defining <cursor specification> for CR shall not generally contain a <column reference>
   that references OC or an underlying column of the column identified by OC.
10) If the cursor identified by <cursor name> was specified using an explicit or implicit <updatability clause>
    of FOR UPDATE, then each <column name> specified as an <object column> shall identify a column in
    the explicit or implicit <column name list> associated with the <updatability clause>.


Access Rules
1) Case:




846 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                               ISO/IEC 9075-2:2003 (E)
                                                                                    14.10 <update statement: positioned>



    a) If <update statement: positioned> is contained, without an intervening <SQL routine spec> that specifies
       SQL SECURITY INVOKER, in an <SQL schema statement>, then let A be the <authorization identifier>
       that owns that schema. The applicable privileges for A shall include UPDATE for each <object column>.
    b) Otherwise, the current privileges shall include UPDATE for each <object column>.
    NOTE 383 — “current privileges” and “applicable privileges” are defined in Subclause 12.3, “<privileges>”.


General Rules
1) If the access mode of the current SQL-transaction or the access mode of the branch of the current SQL-
   transaction at the current SQL-connection is read-only and not every leaf generally underlying table of CR
   is a temporary table, then an exception condition is raised: invalid transaction state — read-only SQL-
   transaction.
2) If there is any sensitive cursor SCR, other than CR, that is currently open in the SQL-transaction in which
   this SQL-statement is being executed, then
    Case:
    a) If SCR has not been held into a subsequent SQL-transaction, then either the change resulting from the
       successful execution of this statement is made visible to CR or an exception condition is raised: cursor
       sensitivity exception — request failed.
    b) Otherwise, whether the change resulting from the successful execution of this SQL-statement is made
       visible to SCR is implementation-defined.
3) If there is any insensitive cursor ICR, other than CR, that is currently open, then either the change resulting
   from the successful execution of this statement is invisible to CR, or an exception condition is raised: cursor
   sensitivity exception — request failed.
4) The extent to which an SQL-implementation may disallow independent changes that are not significant is
   implementation-defined.
5) If CR is not positioned on a row, then an exception condition is raised: invalid cursor state.
6) If CR is a holdable cursor and a <fetch statement> has not been issued against CR within the current SQL-
   transaction, then an exception condition is raised: invalid cursor state.
7) An object row is any row of a base table from which the current row of CR is derived.
8) If, while CR is open, an object row has been marked for deletion by any <delete statement: searched>,
   marked for deletion by any <delete statement: positioned> that identifies any cursor other than CR, updated
   by any <update statement: searched>, updated by any <update statement: positioned>, or updated by any
   <merge statement> that identifies any cursor other than CR, then a completion condition is raised: warning
   — cursor operation conflict.
9) The value associated with DEFAULT is the default value for the <object column> in the containing <set
   clause>, as indicated in the General Rules of Subclause 11.5, “<default clause>”.
10) Each <update source> is effectively evaluated for the current row before any of the current row's object
    rows is updated.




©ISO/IEC 2003 – All rights reserved                                                                  Data manipulation 847
ISO/IEC 9075-2:2003 (E)
14.10 <update statement: positioned>



11) CR remains positioned on its current row, even if an exception condition is raised during evaluation of any
    <update source>.
12) A candidate new row is constructed by copying the current row of CR and updating it as specified by each
    <set clause> by applying the General Rules of Subclause 14.12, “<set clause list>”.
    NOTE 384 — The data values allowable in an object row may be constrainted by a WITH CHECK OPTION constraint. The effect
    of a WITH CHECK OPTION constraint is defined in the General Rules of Subclause 14.24, “Effect of replacing some rows in a
    viewed table”.

13) Let CL be the columns of T identified by the <object column>s contained in the <set clause list>.
14) Let R1 be the candidate new row and let R be the current row of CR. Exactly one row TR in T such that
    each field in R is identical to the corresponding field in TR is identified for replacement in T. The current
    row R of CR is replaced by R1. Let TR1 be a row consisting of the fields of R1 and the fields of TR that
    have no corresponding fields in R1, ordered according to the order of their corresponding columns in T.
    TR1 is the replacement row for TR and { ( TR, TR1 ) } is the replacement set for T.
    NOTE 385 — In case more than one row R1 satisfies the stated condition, it is implementation-dependent which one is identified
    for replacement.
    NOTE 386 — Identifying a row for replacement, associating a replacement row with an identified row, and associating a
    replacement set with a table are implementation-dependent mechanisms.

15) Case:
    a) If LUT is a base table, then
        Case:
        i)       If <target table> specifies ONLY, then LUT is identified for replacement processing without
                 subtables with respect to object columns CL.
        ii)      Otherwise, LUT is identified for replacement processing with subtables with respect to object
                 columns CL.
        NOTE 387 — Identifying a base table for replacement processing, with or without subtables, is an implementation-dependent
        mechanism. In general, though not here, the list of object columns can be empty.

    b) If LUT is a viewed table, then the General Rules of Subclause 14.24, “Effect of replacing some rows
       in a viewed table”, are applied with <target table> as VIEW NAME.
16) The General Rules of Subclause 14.22, “Effect of replacing rows in base tables”, are applied.


Conformance Rules
1) Without Feature F831, “Full cursor update”, conforming SQL language shall not contain an <update
   statement: positioned> in which CR identifies an ordered cursor.




848 Foundation (SQL/Foundation)                                                                ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                              14.11 <update statement: searched>



14.11 <update statement: searched>

Function
Update rows of a table.


Format
<update statement: searched> ::=
    UPDATE <target table> [ [ AS ] <correlation name> ]
    SET <set clause list>
    [ WHERE <search condition> ]


Syntax Rules
1) Let TN be the <table name> contained in <target table>; let T be the table identified by TN. T shall be an
   updatable table.
2) T is the subject table of the <update statement: searched>.
3) TN shall not identify an old transition table or a new transition table.
4) Case:
    a) If <correlation name> is specified, then let CN be that <correlation name>.
    b) Otherwise, let CN be the <table name> contained in <target table>. CN is an exposed <table or query
       name>.
5) The scope of CN is <set clause list> and <search condition>.
6) If the <update statement: searched> is contained in a <triggered SQL statement>, then the <search condition>
   shall not contain a <value specification> that specifies a parameter reference.
7) The <search condition> shall not generally contain a <routine invocation> whose subject routine is an SQL-
   invoked routine that possibly modifies SQL-data.


Access Rules
1) Case:
    a) If <update statement: searched> is contained, without an intervening <SQL routine spec> that specifies
       SQL SECURITY INVOKER, in an <SQL schema statement>, then let A be the <authorization identifier>
       that owns that schema.
         i)       The applicable privileges for A for TN shall include UPDATE for each <object column>.
         ii)      If <target table> immediately contains ONLY, then the applicable privileges for A shall include
                  SELECT WITH HIERARCHY OPTION on at least one supertable of T.
    b) Otherwise,


©ISO/IEC 2003 – All rights reserved                                                      Data manipulation 849
ISO/IEC 9075-2:2003 (E)
14.11 <update statement: searched>



        i)      The current privileges for TN shall include UPDATE for each <object column>.
        ii)     If <target table> immediately contains ONLY, then the current privileges shall include SELECT
                WITH HIERARCHY OPTION on at least one supertable of T.
    NOTE 388 — “current privileges” and “applicable privileges” are defined in Subclause 12.3, “<privileges>”.


General Rules
1) If the access mode of the current SQL-transaction or the access mode of the branch of the current SQL-
   transaction at the current SQL-connection is read-only and T is not a temporary table, then an exception
   condition is raised: invalid transaction state — read-only SQL-transaction.
2) If there is any sensitive cursor CR that is currently open in the SQL-transaction in which this SQL-statement
   is being executed, then
    Case:
    a) If CR has not been held into a subsequent SQL-transaction, then either the change resulting from the
       successful execution of this statement shall be made visible to CR or an exception condition is raised:
       cursor sensitivity exception — request failed.
    b) Otherwise, whether the change resulting from the successful execution of this SQL-statement is made
       visible to CR is implementation-defined.
3) If there is any cursor CR that is currently open and whose <declare cursor> contained INSENSITIVE, then
   either the change resulting from the successful execution of this statement shall be invisible to CR, or an
   exception condition is raised: cursor sensitivity exception — request failed.
4) The extent to which an SQL-implementation may disallow independent changes that are not significant is
   implementation-defined.
5) Case:
    a) If <target table> contains ONLY, then
        Case:
        i)      If a <search condition> is not specified, then all rows of T for which there is no subrow in a
                proper subtable of T are the subject rows.
        ii)     If a <search condition> is specified, then it is applied to each row of T with the exposed <corre-
                lation name>s or <table or query name>s of the <table reference> bound to that row, and the
                subject rows are those rows for which the result of the <search condition> is True and for which
                there is no subrow in a proper subtable of T. The <search condition> is effectively evaluated for
                each row of T before updating any row of T.
                Each <subquery> in the <search condition> is effectively executed for each row of T and the
                results used in the application of the <search condition> to the given row of T. If any executed
                <subquery> contains an outer reference to a column of T, then the reference is to the value of
                that column in the given row of T.
    b) Otherwise,
        Case:


850 Foundation (SQL/Foundation)                                                               ©ISO/IEC 2003 – All rights reserved
                                                                                                ISO/IEC 9075-2:2003 (E)
                                                                                      14.11 <update statement: searched>



         i)       If a <search condition> is not specified, then all rows of T are the subject rows.
         ii)      If a <search condition> is specified, then it is applied to each row of T with the exposed <table
                  name> of the <target table> bound to that row, and the subject rows are those rows for which
                  the result of the <search condition> is True. The <search condition> is effectively evaluated for
                  each row of T before any row of T is updated.
                  Each <subquery> in the <search condition> is effectively executed for each row of T and the
                  results used in the application of the <search condition> to the given row of T. If any executed
                  <subquery> contains an outer reference to a column of T, then the reference is to the value of
                  that column in the given row of T.
                  NOTE 389 — outer reference is defined in Subclause 6.7, “<column reference>”.

6) If T is a base table, then each subject row is also an object row; otherwise, an object row is any row of a
   leaf generally underlying table of T from which a subject row is derived.
7) If any row in the set of object rows has been marked for deletion by any <delete statement: positioned>
   that identifies some cursor CR that is still open or updated by any <update statement: positioned> that
   identifies some cursor CR that is still open, then a completion condition is raised: warning — cursor oper-
   ation conflict.
8) If a <search condition> is specified, then the <search condition> is evaluated for each row of T prior to the
   invocation of any <triggered action> caused by the update of any row of T.
9) The <update source> of each <set clause> is effectively evaluated for each row of T before any row of T
   is updated.
10) For each subject row, a candidate new row is constructed by copying the subject row and updating it as
    specified by each <set clause> by applying the General Rules of Subclause 14.12, “<set clause list>”.
    NOTE 390 — The data values allowable in the object rows may be constrained by a WITH CHECK OPTION constraint. The
    effect of a WITH CHECK OPTION constraint is defined in the General Rules of Subclause 14.24, “Effect of replacing some rows
    in a viewed table”.

11) Let CL be the columns of T identified by the <object column>s contained in the <set clause list>.
12) Each subject row SR is identified for replacement, by its corresponding candidate new row CNR, in T. The
    set of (SR, CNR) pairs is the replacement set for T.
    NOTE 391 — Identifying a row for replacement, associating a replacement row with an identified row, and associating a
    replacement set with a table are implementation-dependent operations.

13) Case:
    a) If T is a base table, then
         Case:
         i)       If <target table> specifies ONLY, then T is identified for replacement processing without subta-
                  bles with respect to object columns CL.
         ii)      Otherwise, T is identified for replacement processing with subtables with respect to object
                  columns CL.
         NOTE 392 — Identifying a base table for replacement processing, with or without subtables, is an implementation-dependent
         mechanism. In general, though not here, the list of object columns can be empty.




©ISO/IEC 2003 – All rights reserved                                                                   Data manipulation 851
ISO/IEC 9075-2:2003 (E)
14.11 <update statement: searched>



    b) If T is a viewed table, then the General Rules of Subclause 14.24, “Effect of replacing some rows in a
       viewed table”, are applied with <target table> as VIEW NAME.
14) The General Rules of Subclause 14.22, “Effect of replacing rows in base tables”, are applied.
15) If the set of object rows is empty, then a completion condition is raised: no data.


Conformance Rules
1) Without Feature F781, “Self-referencing operations”, conforming SQL language shall not contain an
   <update statement: positioned> in which a leaf generally underlying table of T is an underlying table of
   any <query expression> generally contained in the <search condition>.
2) Without Feature T111, “Updatable joins, unions, and columns”, conforming SQL language shall not contain
   an <update statement: searched> that contains a <target table> that identifies a table that is not simply
   updatable.




852 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                                  ISO/IEC 9075-2:2003 (E)
                                                                                                    14.12 <set clause list>



14.12 <set clause list>

Function
Specify a list of updates.


Format
<set clause list> ::= <set clause> [ { <comma> <set clause> }... ]

<set clause> ::=
    <multiple column assignment>
  | <set target> <equals operator> <update source>

<set target> ::=
    <update target>
  | <mutated set clause>

<multiple column assignment> ::=
    <set target list> <equals operator> <assigned row>

<set target list> ::=
    <left paren> <set target> [ { <comma> <set target> }... ] <right paren>

<assigned row> ::= <contextually typed row value expression>

<update target> ::=
    <object column>
  | <object column>
    <left bracket or trigraph> <simple value specification> <right bracket or trigraph>

<object column> ::= <column name>

<mutated set clause> ::= <mutated target> <period> <method name>

<mutated target> ::=
    <object column>
  | <mutated set clause>

<update source> ::=
    <value expression>
  | <contextually typed value specification>


Syntax Rules
1) Let T be the table identified by the <target table> contained in the containing <update statement: positioned>,
   <update statement: searched>, or <merge statement>.
2) Each <column name> specified as an <object column> shall identify an updatable column of T.
    NOTE 393 — The notion of updatable columns of base tables is defined in Subclause 4.14, “Tables”. The notion of updatable
    columns of viewed tables is defined in Subclause 11.22, “<view definition>”.




©ISO/IEC 2003 – All rights reserved                                                                 Data manipulation 853
ISO/IEC 9075-2:2003 (E)
14.12 <set clause list>



3) Each <set clause> SC that immediately contains a <multiple column assignment> is effectively replaced
   by a <set clause list> MSCL as follows:
    a) Let STN be the number of <set target>s contained in <set target list>.
    b) STN shall be equal to the degree of the <assigned row> AR contained in SC.

    c) Let STi, 1 (one) ≤ i ≤ STN, be the i-th <set target> contained in the <set target list> of SC and let DTi
       be the declared type of the i-th field of AR. The i-th <set clause> in MSCL is:
              STi = CAST ( AR AS ROW ( F1 DT1, F2 DT2, ..., FSTN DTSTN ) ).Fi
        NOTE 394 — “Fn” here stands for the <field name> consisting of the letter “F” followed, with no intervening <separator>
        by the decimal <digit> or <digit>s comprising a <literal> corresponding to the value n.

4) If <set clause> SC specifies an <object column> that references a column of which some underlying column
   is either a generated column or an identity column whose descriptor indicates that values are always gener-
   ated, then the <update source> specified in SC shall consist of a <default specification>.
5) A <value expression> simply contained in an <update source> in a <set clause> shall not directly contain
   a <set function specification>.
6) If the <set clause list> OSCL contains one or more <set clause>s that contain a <mutated set clause>, then:
    a) Let N be the number of <set clause>s in OSCL that contain a <mutated set clause>.

    b) For 1 (one) ≤ i ≤ N:
        i)      Let SCi be the i-th <set clause> that contains a <mutated set clause>.

        ii)     Let RCVEi be the <update source> immediately contained in SCi.

        iii)    Let MSCi be the <mutated set clause> immediately contained in the <set target> immediately
                contained in SCi.

        iv)     Let OCi be the <object column> contained in MSCi. The declared type of the column identified
                by OCi shall be a structured type.

        v)      Let Mi be the number of <method name>s contained in MSCi.

        vi)     For 1 (one) ≤ j ≤ Mi:

                1) If j = 1 (one), then
                    Case:
                    A) Let MTi,1 be the <mutated target> immediately contained in MSCi.

                    B) Let MNi,1 be the <method name> immediately contained in MSCi.

                    C) Let Vi,1 be:
                         MTi,1 . MNi,1 ( RCVEi )

                2) Otherwise:


854 Foundation (SQL/Foundation)                                                              ©ISO/IEC 2003 – All rights reserved
                                                                                                  ISO/IEC 9075-2:2003 (E)
                                                                                                    14.12 <set clause list>



                      A) Let MTi,j be the <mutated target> immediately contained in the <mutated set clause>
                         immediately contained in MTi,j-1.

                      B) Let MNi,j be the <method name> immediately contained in the <mutated set clause>
                         immediately contained in MTi,j-1.

                      C) Let Vi,j be
                           MTi,j . MNi,j ( Vi,j-1 )

    c) OSCL is equivalent to a <set clause list> NSCL derived as follows:
         i)       Let NSCL be a <set clause list> derived from OSCL by replacing every <set clause> SCa, 1 (one)
                  ≤ a ≤ N, that contains a <mutated set clause> with:
                  MTa,Ma = Va,Ma


         ii)      For 1 (one) ≤ b ≤ N, if there exists a c such that c < b and OCc is equivalent to OCb, then:

                  1) Every occurrence of OCb in Vb,Mb is replaced by Vc,Mc.

                  2) SCc is deleted from NSCL.

7) Equivalent <object column>s shall not appear more than once in a <set clause list>.
    NOTE 395 — Multiple occurrences of equivalent <object column>s within <mutated set clause>s are eliminated by the preceding
    Syntax Rule of this Subclause.

8) If the <update source> of <set clause> SC specifies a <contextually typed value specification> CVS, then
   the data type of CVS is the data type DT of the <update target> or <mutated set clause> specified in SC.
9) If CVS is an <empty specification>, then DT shall be a collection type. If CVS specifies ARRAY, then DT
   shall be an array type. If CVS specifies MULTISET, then DT shall be a multiset type.
10) For every <object column> in a <set clause>,
    Case:
    a) If the <update target> immediately contains <simple value specification>, then the declared type of
       the column of T identified by the <object column> shall be an array type. The Syntax Rules of
       Subclause 9.2, “Store assignment”, apply to an arbitrary site whose declared type is the element type
       of the column of T identified by the <object column> and the <update source> of the <set clause> as
       TARGET and VALUE, respectively.
    b) Otherwise, the Syntax Rules of Subclause 9.2, “Store assignment”, apply to the column of T identified
       by the <object column> and the <update source> of the <set clause> as TARGET and VALUE, respec-
       tively.


Access Rules
    None.




©ISO/IEC 2003 – All rights reserved                                                                Data manipulation 855
ISO/IEC 9075-2:2003 (E)
14.12 <set clause list>



General Rules
1) A <set clause> specifies one or more object columns and an update value. An object column is a column
   identified by an <object column> in the <set clause>. The update value is the value specified by the <update
   source> contained in the <set clause>.
2) The value of the i-th object column denoted by C, is replaced as follows:
    Case:
    a) If the i-th <set clause> contains an <update target> that immediately contains a <simple value specifi-
       cation>, then
        Case:
        i)      If the value of C is null, then an exception condition is raised: data exception — null value in
                array target.
        ii)     Otherwise:
                1) Let N be the maximum cardinality of C.
                2) Let M be the cardinality of the value of C.
                3) Let I be the value of the <simple value specification> immediately contained in <update
                   target>.
                4) Let EDT be the element type of C.
                5) Case:
                    A) If I is greater than zero and less than or equal to M, then the value of C is replaced by
                       an array A with element type EDT and cardinality M derived as follows:
                        I)     For j varying from 1 (one) to I–1 and from I+1 to M, the j-th element in A is the
                               value of the j-th element in C.
                        II)    The I-th element of A is set to the i-th update value, denoted by SV, by applying
                               the General Rules of Subclause 9.2, “Store assignment”, to the I-th element of A
                               and SV as TARGET and VALUE, respectively.
                    B) If I is greater than M and less than or equal to N, then the value of C is replaced by an
                       array A with element type EDT and cardinality I derived as follows:
                        I)     For j varying from 1 (one) to M, the j-th element in A is the value of the j-th ele-
                               ment in C.
                        II)    For j varying from M+1 to I–1, the j-th element in A is the null value.
                        III)   The I-th element of A is set to the i-th update value, denoted by SV, by applying
                               the General Rules of Subclause 9.2, “Store assignment”, to the I-th element of A
                               and SV as TARGET and VALUE, respectively.
                    C) Otherwise, an exception condition is raised: data exception — array element error.




856 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                                       14.12 <set clause list>



    b) Otherwise, the value of C is replaced by the i-th update value, denoted by SV. The General Rules of
       Subclause 9.2, “Store assignment”, are applied to C and SV as TARGET and VALUE, respectively.


Conformance Rules
1) Without Feature F781, “Self-referencing operations”, conforming SQL language shall not contain a <set
   clause> in which a leaf generally underlying table of T is an underlying table of any <query expression>
   generally contained in any <value expression> simply contained in an <update source> or <assigned row>
   immediately contained in the <set clause>.
2) Without Feature S091, “Basic array support”, conforming SQL language shall not contain an <update target>
   that immediately contains a <simple value specification>.
3) Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain a <set
   clause> in which the declared type of the <update target> in the <set clause> is a structured type TY and
   the declared type of the <update source> or corresponding field of the <assigned row> contained in the
   <set clause> is not TY.
4) Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain a <set
   clause> that contains a <mutated set clause> and in which the declared type of the last <method name>
   identifies a structured type TY, and the declared type of the <update source> contained in the <set clause>
   is not TY.
5) Without Feature T641, “Multiple column assignment”, conforming SQL language shall not contain a
   <multiple column assignment>.




©ISO/IEC 2003 – All rights reserved                                                   Data manipulation 857
ISO/IEC 9075-2:2003 (E)
14.13 <temporary table declaration>



14.13 <temporary table declaration>

Function
Declare a declared local temporary table.


Format
<temporary table declaration> ::=
    DECLARE LOCAL TEMPORARY TABLE <table name> <table element list>
    [ ON COMMIT <table commit action> ROWS ]


Syntax Rules
1) Let TN be the <table name> of a <temporary table declaration> TTD, and let T be the <qualified identifier>
   of TN.
2) TTD shall be contained in an <SQL-client module definition>.
3) Case:
    a) If TN contains a <local or schema qualifier> LSQ, then LSQ shall be “MODULE”.
    b) If TN does not contain a <local or schema qualifier>, then “MODULE” is implicit.
4) If a <temporary table declaration> is contained in an <SQL-client module definition> M, then the <qualified
   identifier> of TN shall not be equivalent to the <qualified identifier> of the <table name> of any other
   <temporary table declaration> that is contained in M.
5) The descriptor of the table defined by a <temporary table declaration> includes TN and the column
   descriptor specified by each <column definition>. The i-th column descriptor is given by the i-th <column
   definition>.
6) A <temporary table declaration> shall contain at least one <column definition>.
7) If ON COMMIT is not specified, then ON COMMIT DELETE ROWS is implicit.


Access Rules
    None.


General Rules
1) Let U be the implementation-dependent <schema name> that is effectively derived from the implementation-
   dependent SQL-session identifier associated with the SQL-session and an implementation-dependent name
   associated with the SQL-client module that contains the <temporary table declaration>.
2) Let UI be the current user identifier and let R be the current role name.



858 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                         14.13 <temporary table declaration>



    Case:
    a) If UI is not the null value, then let A be UI.
    b) Otherwise, let A be R.
3) The definition of T within an SQL-client module is effectively equivalent to the definition of a persistent
   base table U.T. Within the SQL-client module, any reference to MODULE.T is equivalent to a reference
   to U.T.
4) A set of privilege descriptors is created that define the privileges INSERT, SELECT, UPDATE, DELETE,
   and REFERENCES on this table and INSERT, SELECT, UPDATE, and REFERENCES for every <column
   definition> in the table definition to A. These privileges are not grantable. The grantor for each of these
   privilege descriptors is set to the special grantor value “_SYSTEM”. The grantee is “PUBLIC”.
5) The definition of a temporary table persists for the duration of the SQL-session. The termination of the
   SQL-session is effectively followed by the execution of the following <drop table statement> with the
   current authorization identifier A and current <schema name> U without further Access Rule checking:
        DROP TABLE T CASCADE

6) The definition of a declared local temporary table does not appear in any view of the Information Schema.
    NOTE 396 — The Information Schema is defined in ISO/IEC 9075-11.


Conformance Rules
1) Without Feature F531, “Temporary tables”, conforming SQL language shall not contain a <temporary table
   declaration>.




©ISO/IEC 2003 – All rights reserved                                                    Data manipulation 859
ISO/IEC 9075-2:2003 (E)
14.14 <free locator statement>



14.14 <free locator statement>

Function
Remove the association between a locator variable and the value that is represented by that locator.


Format
<free locator statement> ::=
    FREE LOCATOR <locator reference> [ { <comma> <locator reference> }... ]

<locator reference> ::=
    <host parameter name>
  | <embedded variable name>
  | <dynamic parameter specification>


Syntax Rules
1) Each host parameter identified by <host parameter name> immediately contained in <locator reference>
   shall be a binary large object locator parameter, a character large object locator parameter, an array locator
   parameter, a multiset locator parameter, or a user-defined type locator parameter.
2) Each host variable identified by the <embedded variable name> immediately contained in <locator reference>
   shall be a binary object locator variable, a character large object locator variable, an array locator variable,
   a multiset locator parameter, or a user-defined type locator variable.


Access Rules
    None.


General Rules
1) For every <locator reference> LR immediately contained in <free locator statement>, let L be the value of
   LR.
    Case:
    a) If L is not a valid locator value, then an exception condition is raised: locator exception — invalid
       specification.
    b) Otherwise, L is marked invalid.


Conformance Rules
1) Without Feature T561, “Holdable locators”, conforming SQL language shall not contain a <free locator
   statement>.




860 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                14.15 <hold locator statement>



14.15 <hold locator statement>

Function
Mark a locator variable as being holdable.


Format
<hold locator statement> ::=
    HOLD LOCATOR <locator reference> [ { <comma> <locator reference> }... ]


Syntax Rules
1) Each host parameter identified by <host parameter name> immediately contained in <locator reference>
   shall be a binary large object locator parameter, a character large object locator parameter, an array locator
   parameter, a multiset locator parameter, or a user-defined type locator parameter.


Access Rules
    None.


General Rules
1) For every <locator reference> LR immediately contained in <hold locator statement>, let L be the value of
   LR.
    Case:
    a) If L is not a valid locator value, then an exception condition is raised: locator exception — invalid
       specification.
    b) Otherwise, L is marked holdable.


Conformance Rules
1) Without Feature T561, “Holdable locators”, conforming SQL language shall not contain a <hold locator
   statement>.




©ISO/IEC 2003 – All rights reserved                                                     Data manipulation 861
ISO/IEC 9075-2:2003 (E)
14.16 Effect of deleting rows from base tables



14.16 Effect of deleting rows from base tables

Function
Specify the effect of deleting rows from one or more base tables.


Syntax Rules
    None.


Access Rules
    None.


General Rules
1) Let TT be the set consisting of every base table that is identified for deletion processing. Let S be the set
   consisting of every row identified for deletion in some table in TT.
2) For every row R in S, every row SR that is a subrow or a superrow of R is identified for deletion from the
   base table BT containing SR, and BT is identified for deletion processing.
3) The current trigger execution context CTEC, if any, is preserved, and new trigger execution context NTEC
   is created with an empty set of state changes SSC.
4) For every table T in TT, for every table ST that is a supertable of T or, unless T is identified for deletion
   processing without subtables, a subtable of T, a state change SC is added to SSC as follows:
    a) The set of transitions of SC consists of one copy each of every row of ST that is a subrow or superrow
       of a member of S.
    b) The trigger event of SC is DELETE.
    c) The subject table of SC is ST.
    d) The column list of SC is empty.
    e) The set of statement-level triggers for which SC is considered as executed is empty.
    f) The set of row-level triggers consists of each row-level trigger that is activated by SC, paired with the
       empty set (of rows considered as executed).
5) The Syntax Rules and General Rules of Subclause 14.25, “Execution of BEFORE triggers”, are applied
   with SSC as the SET OF STATE CHANGES.
6) Every row that is identified for deletion in some table identified for deletion processing is marked for
   deletion. These rows are no longer identified for deletion, nor are their containing tables identified for
   deletion processing.
    NOTE 397 — “Marking for deletion” is an implementation-dependent mechanism.




862 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                                  ISO/IEC 9075-2:2003 (E)
                                                                             14.16 Effect of deleting rows from base tables



7) For every referential constraint descriptor of a constraint whose mode is immediate, the General Rules of
   Subclause 11.8, “<referential constraint definition>”, are applied.
8) For every table T that is the subject table of some state change in SSC, each row that is marked for deletion
   from T is deleted from T.
    NOTE 398 — See Subclause 4.14.6, “Operations involving tables”, for the effect of deleting a row from a table.

9) The Syntax Rules and General Rules of Subclause 14.26, “Execution of AFTER triggers”, are applied with
   SSC as the SET OF STATE CHANGES.
    NOTE 399 — All constraints have already been checked for the deletion of the deleted rows of the subject table, including all
    referential constraints.

10) NTEC, together with all of its contents, is destroyed and CTEC, if present, is restored to become the current
    trigger execution context.


Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved                                                                    Data manipulation 863
ISO/IEC 9075-2:2003 (E)
14.17 Effect of deleting some rows from a derived table



14.17 Effect of deleting some rows from a derived table

Function
Specify the effect of deleting some rows from a derived table.


Syntax Rules
    None.


Access Rules
    None.


General Rules
1) Let QE be TABLE in the application of this Subclause and let T be the result of evaluating QE.
2) Case:
    a) If QE simply contains a <query primary> that immediately contains a <query expression body>, then
       let QEB be that <query expression body>. Apply the General Rules of Subclause 14.17, “Effect of
       deleting some rows from a derived table”, with the table identified by QEB as TABLE.
    b) If QE simply contains a <query expression body> QEB that specifies UNION ALL, then let LO and
       RO be the <query expression body> and the <query term>, respectively, that are immediately contained
       in QEB. Let T1 and T2 be the tables identified by LO and RO, respectively.
        i)     For every row R in T that has been identified for deletion, let RD be the row in either T1 or T2
               from which R has been derived and let TD be that table. Identify RD for deletion.
        ii)    The General Rules of Subclause 14.17, “Effect of deleting some rows from a derived table”, are
               applied with T1 as TABLE.
        iii)   The General Rules of Subclause 14.17, “Effect of deleting some rows from a derived table”, are
               applied with T2 as TABLE.
    c) Otherwise, let QS be the <query specification> simply contained in QE. Let TE be the <table expression>
       immediately contained in QS, and TREF be the <table reference>s simply contained in the <from
       clause> of TE.
        i)     Case:
               1) If TREF contains only one <table reference>, then let TR1 be that <table reference>, and let
                  m be 1 (one).
               2) Otherwise, let m be the number of <table reference>s that identify tables with respect to
                  which QS is one-to-one. Let TRi, 1 (one) ≤ i ≤ m, be those <table reference>s.




864 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                              ISO/IEC 9075-2:2003 (E)
                                                                14.17 Effect of deleting some rows from a derived table



                      NOTE 400 — The notion of one-to-one <query specification>s is defined in Subclause 7.12, “<query specifica-
                      tion>”.

         ii)      Let TTi, 1 (one) ≤ i ≤ m, be the table identified by TRi.

         iii)     For every row R of T that has been identified for deletion, and for i ranging from 1 (one) to m,
                  let RD be the row in TTi from which R has been derived. Identify that RD for deletion.

         iv)      For i ranging from 1 (one) to m,
                  Case:
                  1) If TTi is a base table, then

                      Case:
                      A) If TRi specifies ONLY, then TTi is identified for deletion processing without subtables.

                      B) Otherwise, TTi is identified for deletion processing with subtables.

                  2) If TTi is a viewed table, then the General Rules of Subclause 14.18, “Effect of deleting some
                     rows from a viewed table”, are applied with TRi as VIEW NAME.

                  3) Otherwise, the General Rules of Subclause 14.17, “Effect of deleting some rows from a
                     derived table”, are applied with TRi as TABLE.


Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved                                                                  Data manipulation 865
ISO/IEC 9075-2:2003 (E)
14.18 Effect of deleting some rows from a viewed table



14.18 Effect of deleting some rows from a viewed table

Function
Specify the effect of deleting some rows from a viewed table.


Syntax Rules
    None.


Access Rules
    None.


General Rules
1) Let VN be VIEW NAME in the application of this Subclause.
2) If VN specifies ONLY, then let QE be the original <query expression> included in the descriptor of the
   view V identified by VN; otherwise, let QE be the <query expression> contained in that descriptor. Let T
   be the result of evaluating QE.
3) For each row R of V that has been identified for deletion, let RD be the row in T from which R has been
   derived; identify that row for deletion.
4) The General Rules of Subclause 14.17, “Effect of deleting some rows from a derived table”, are applied
   with QE as TABLE.


Conformance Rules
    None.




866 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)
                                                                     14.19 Effect of inserting tables into base tables



14.19 Effect of inserting tables into base tables

Function
Specify the effect of inserting each of one or more given tables into its associated base table.


Syntax Rules
    None.


Access Rules
    None.


General Rules
1) The current trigger execution context CTEC, if any, is preserved, and a new trigger execution context NTEC
   is created with an empty set of state changes SSC.
2) For each base table T that is identified for insertion, let S be the source table for T.
    a) If some column IC of T is the identity column of T, then for each row in S whose site ICS corresponding
       to IC is marked as unassigned:
         i)       ICS is no longer marked as unassigned.
         ii)      Let NV be the result of applying the General Rules of Subclause 9.21, “Generation of the next
                  value of a sequence generator”, with the sequence descriptor included in the column descriptor
                  of IC as SEQUENCE.
                  Case:
                  1) If the declared type of IC is a distinct type DIST, then let ICNV be DIST(NV).
                  2) Otherwise, let ICNV be NV.
         iii)     The General Rules of Subclause 9.2, “Store assignment”, are applied with ICS as TARGET and
                  ICNV as VALUE.
    b) Every proper supertable ST of T is identified for insertion. A source table for insertion into each ST is
       constructed as follows:
         i)       Let S be the source table for the insertion into T. Let TVC be some <table value constructor>
                  whose value is S.
         ii)      Let n be the number of column descriptors included in the table descriptor of ST and let CDi, 1
                  (one) ≤ i ≤ n, be those column descriptors. Let SL be a <select list> containing n <select sublist>s
                  such that, for i ranging from 1 (one) to n, the i-th <select sublist> consists of the column name
                  included in CDi.



©ISO/IEC 2003 – All rights reserved                                                          Data manipulation 867
ISO/IEC 9075-2:2003 (E)
14.19 Effect of inserting tables into base tables



        iii)     The source table for insertion into ST consists of the rows in the result of the <query expression>:
                    SELECT SL FROM TVC

3) For every base table BT that is identified for insertion, a state change SC is added to SSC as follows:
    a) The set of transitions of SC consists of the rows in the source table for BT.
    b) The trigger event of SC is INSERT.
    c) The subject table of SC is BT.
    d) The column list of SC is empty.
    e) The set of statement-level triggers for which SC is considered as executed is empty.
    f) The set of row-level triggers consists of each row-level trigger that is activated by SC, paired with the
       empty set (of rows considered as executed).
4) The Syntax Rules and General Rules of Subclause 14.25, “Execution of BEFORE triggers”, are applied
   with SSC as the SET OF STATE CHANGES.
5) For every state change SC in SSC, let SOT be the set of transitions in SC and let BT be the subject table of
   SC.
    a) In each row R in SOT, for each site GCS in R corresponding to a generated column GC, let GCR be
       the result of evaluating, for R, the generation expression included in the column descriptor of GC. The
       General Rules of Subclause 9.2, “Store assignment”, are applied with GCS as TARGET and GCR as
       VALUE.
    b) Every row in SOT is inserted into BT and BT is no longer identified for insertion.
        NOTE 401 — See Subclause 4.14.6, “Operations involving tables”, for the effect of inserting a row into a table.

    c) For every referential constraint descriptor of a constraint whose mode is immediate, the General Rules
       of Subclause 11.8, “<referential constraint definition>”, are applied.
6) The Syntax Rules and General Rules of Subclause 14.26, “Execution of AFTER triggers”, are applied with
   SSC as the SET OF STATE CHANGES.
    NOTE 402 — All constraints have already been checked for the insertion of the inserted rows of the subject table, including all
    referential constraints.

7) NTEC, together with all of its contents, is destroyed and CTEC, if present, is restored to become the current
   trigger execution context.


Conformance Rules
    None.




868 Foundation (SQL/Foundation)                                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)
                                                                14.20 Effect of inserting a table into a derived table



14.20 Effect of inserting a table into a derived table

Function
Specify the effect of inserting a table into a derived table.


Syntax Rules
    None.


Access Rules
    None.


General Rules
1) Let Q and T be the SOURCE and TARGET, respectively, in the application of this Subclause.
2) Let QE be the <query expression> included in the descriptor of T.
    Case:
    a) If QE simply contains a <query primary> that immediately contains a <query expression body>, then
       let QEB be that <query expression body>. Apply the General Rules of Subclause 14.20, “Effect of
       inserting a table into a derived table”, with Q as SOURCE and the result of QEB as TARGET.
    b) Otherwise, let QS be the <query specification> simply contained in QE. Let TE be the <table expression>
       immediately contained in QS, and TREF be the <table reference>s simply contained in the <from
       clause> of TE. Let SL be the <select list> immediately contained in QS, and n the number of <value
       expression>s VEj, 1 (one) ≤ j ≤ n, simply contained in SL.

         i)       Case:
                  1) If TREF contains only one <table reference>, then let TR1 be that <table reference>, and let
                     m be 1 (one).
                  2) Otherwise, let m be the number of <table reference>s that identify tables with respect to
                     which QS is one-to-one. Let TRi, 1 (one) ≤ i ≤ m, be those <table reference>s.

         ii)      Let TTi, 1 (one) ≤ i ≤ m, be the table identified by TRi, and let Si be an initially empty table of
                  candidate rows for TTi.

         iii)     For every row R of Q, and for i ranging from 1 (one) to m:
                  1) A candidate row of TTi is effectively created in which the value of each column is its default
                     value, as specified the General Rules of Subclause 11.5, “<default clause>”. The candidate
                     row includes every column of TTi.



©ISO/IEC 2003 – All rights reserved                                                          Data manipulation 869
ISO/IEC 9075-2:2003 (E)
14.20 Effect of inserting a table into a derived table



               2) For j ranging from 1 (one) to n, let C be a column of some candidate row identified by VEj,
                  and let SV be the j-th value of R. The General Rules of Subclause 9.2, “Store assignment”,
                  are applied to C and SV as TARGET and SOURCE, respectively.
               3) The candidate row is added to the corresponding Si.

        iv)    For i ranging from 1 (one) to m,
               Case:
               1) If TTi is a base table, then TTi is identified for insertion of source table Si.

               2) If TTi is a viewed table, the General Rules of Subclause 14.21, “Effect of inserting a table
                  into a viewed table”, are applied with Si as SOURCE and TTi as TARGET.

               3) Otherwise, the General Rules of Subclause 14.20, “Effect of inserting a table into a derived
                  table”, are applied with Si as SOURCE and TTi as TARGET.


Conformance Rules
    None.




870 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                               14.21 Effect of inserting a table into a viewed table



14.21 Effect of inserting a table into a viewed table

Function
Specify the effect of inserting a table into a viewed table.


Syntax Rules
    None.


Access Rules
    None.


General Rules
1) Let S and T be the SOURCE and TARGET, respectively, in application of this Subclause. Let TD be the
   view descriptor of T. Let QE be the original <query expression> included in TD.
2) If TD indicates WITH CHECK OPTION, then:
    a) Case:
         i)       If TD specifies LOCAL, then let VD be a view descriptor derived from TD as follows:
                  1) The WITH CHECK OPTION indication is removed.
                  2) Every reference contained in QE to a leaf underlying table LUT of QE is replaced by a ref-
                     erence to a temporary table consisting of a copy of LUT.
         ii)      Otherwise, let VD be a view descriptor derived from TD as follows:
                  1) The WITH CHECK OPTION indication is removed.
                  2) Every reference contained in QE to an underlying table UV of QE that is a viewed table is
                     replaced by a reference to a view whose descriptor is identical to that of UV except that
                     WITH CASCADED CHECK OPTION is indicated.
                  3) Every reference contained in QE to a leaf underlying table LUT of QE that is a base table
                     is replaced by a reference to a temporary table consisting of a copy of LUT.
    b) The General Rules of this Subclause are applied with S as SOURCE and the view V described by VD
       as TARGET.
    c) If the result of
               EXISTS ( SELECT * FROM S
                        EXCEPT ALL
                        SELECT * FROM V )

         is True, then an exception condition is raised: with check option violation.


©ISO/IEC 2003 – All rights reserved                                                        Data manipulation 871
ISO/IEC 9075-2:2003 (E)
14.21 Effect of inserting a table into a viewed table



3) The General Rules of Subclause 14.20, “Effect of inserting a table into a derived table”, are applied, with
   S as SOURCE and QE as TARGET.


Conformance Rules
    None.




872 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                     14.22 Effect of replacing rows in base tables



14.22 Effect of replacing rows in base tables

Function
Specify the effect of replacing some of the rows in one or more base tables.


Syntax Rules
    None.


Access Rules
    None.


General Rules
1) Let TT be the set consisting of every base table that is identified for replacement processing. Let S be the
   set consisting of every row identified for replacement in every table in TT.
2) For every base table T in TT, let OC be the set consisting of every object column with respect to which T
   is identified for replacement processing and every generated column of T that depends on at least one of
   these object columns. Every table ST that is a subtable or supertable of T is identified for replacement
   processing with respect to the intersection (possibly empty) of OC and the columns of ST.
3) For every row R that is identified for replacement in some table T in TT, every row SR that is a subrow or
   a superrow of R is identified for replacement in the base table ST that contains SR. The replacement set
   RST for ST is derived from the replacement set RR for T as follows.
    Case:
    a) If ST is a subtable of T, each replacement row in RST is the corresponding replacement row in RR
       extended with those fields of the corresponding identified row in ST that have no corresponding column
       in T.
    b) If ST is a supertable of T, each replacement row in RST is the corresponding replacement row in RR
       minus those fields that have no corresponding column in ST.
4) The current trigger execution context CTEC, if any, is preserved and a new trigger execution context NTEC
   is created with an empty set of state changes SSC.
5) For every table T in TT, for every table ST that is a supertable of T or, unless T is identified for replacement
   processing without subtables, a subtable of T, let TL be the set consisting of the names of the columns of
   ST. For every subset STL of TL such that either STL is empty or the intersection of STL and OC is not
   empty:
    a) If some column IC of T is the identity column of ST, then for each row identified for replacement in
       ST whose site ICS corresponding to IC is marked as unassigned:




©ISO/IEC 2003 – All rights reserved                                                       Data manipulation 873
ISO/IEC 9075-2:2003 (E)
14.22 Effect of replacing rows in base tables



        i)       Let NV be the result of applying the General Rules of Subclause 9.21, “Generation of the next
                 value of a sequence generator”, with the sequence descriptor included in the column descriptor
                 of IC as SEQUENCE.
                 Case:
                 1) If the declared type of IC is a distinct type DIST, then let ICNV be DIST(NV).
                 2) Otherwise, let ICNV be NV.
        ii)      The General Rules of Subclause 9.2, “Store assignment”, are applied with ICS as TARGET and
                 ICNV as VALUE.
    b) All sites in ST that are marked as unassigned cease to be so marked.
    c) A state change SC is added to SSC as follows:
        i)       The set of transitions of SC consists of row pairs formed by pairing each row identified for
                 replacement in ST with its corresponding replacement row.
        ii)      The trigger event of SC is UPDATE.
        iii)     The subject table of SC is ST.
        iv)      The column list of SC is STL.
        v)       The set of statement-level triggers for which SC is considered as executed is empty.
        vi)      The set of row-level triggers consists of each row-level trigger that is activated by SC, paired
                 with the empty set (of rows considered as executed).
6) The Syntax Rules and General Rules of Subclause 14.25, “Execution of BEFORE triggers”, are applied
   with SSC as the SET OF STATE CHANGES.
7) For each set of transitions RST in each state change SC in SSC, in each row R in RST, for each site GCS in
   R corresponding to a generated column GC in the subject table of SC, let GCR be the result of evaluating,
   for R, the generation expression included in the column descriptor of GC. The General Rules of
   Subclause 9.2, “Store assignment”, are applied with GCS as TARGET and GCR as VALUE.
8) For every table T in TT, for every table ST that is a supertable or a subtable of T, for every row R that is
   identified for replacement in ST, R is replaced by its new transition variable. R is no longer identified for
   replacement. ST is no longer identified for replacement processing.
9) For every referential constraint descriptor of a constraint whose mode is immediate, the General Rules of
   Subclause 11.8, “<referential constraint definition>”, are applied.
10) The Syntax Rules and General Rules of Subclause 14.26, “Execution of AFTER triggers”, are applied with
    SSC as the SET OF STATE CHANGES.
    NOTE 403 — All constraints have already been checked for the update of the replaced rows of the identified tables, including all
    referential constraints.

11) NTEC, along with all of its contents, is destroyed and CTEC, if present, is restored to become the current
    trigger execution context.




874 Foundation (SQL/Foundation)                                                                 ©ISO/IEC 2003 – All rights reserved
                                                         ISO/IEC 9075-2:2003 (E)
                                      14.22 Effect of replacing rows in base tables



Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved                       Data manipulation 875
ISO/IEC 9075-2:2003 (E)
14.23 Effect of replacing some rows in a derived table



14.23 Effect of replacing some rows in a derived table

Function
Specify the effect of replacing some rows in a derived table.


Syntax Rules
    None.


Access Rules
    None.


General Rules
1) Let QE be the TABLE and RS the replacement for TABLE in the application of this Subclause.
2) Let T be the result of evaluating QE. Let CL be the object columns of QE.
3) Case:
    a) If QE simply contains a <query primary> that immediately contains a <query expression body>, then
       let QEB be that <query expression body>. Apply the General Rules of Subclause 14.23, “Effect of
       replacing some rows in a derived table”, with TR as the table identified by QEB, and with RS as the
       replacement set for TR.
    b) If QE simply contains a <query expression body> QEB that specifies UNION ALL, let LO and RO be
       the <query expression body> and the <query term>, respectively, that are immediately contained in
       QEB. Let T1 and T2 be the tables identified by LO and RO, respectively. Let the columns of T1 and
       T2 that are underlying columns of the object columns of CL be the object columns CL1 and CL2,
       respectively. Let RS1 and RS2 be the initially empty replacement sets for T1 and T2, respectively.
        i)     For every pair (SR, CNR) of RS:
               Case:
               1) If SR has been derived from a row of T1, then identify that row SR1 for replacement by
                  CNR; the pair (SR1, CNR) is effectively added to RS1.
               2) Otherwise, let SR2 be the row of T2 from which SR has been derived; identify that row for
                  replacement by CNR; the pair (SR2, CNR) is effectively added to RS2.
        ii)    The General Rules of Subclause 14.23, “Effect of replacing some rows in a derived table”, are
               applied with T1 as TABLE.
        iii)   The General rules of Subclause 14.23, “Effect of replacing some rows in a derived table”, are
               applied with T2 as TABLE.




876 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                             14.23 Effect of replacing some rows in a derived table



    c) Otherwise, let QS be the <query specification> simply contained in QE. Let TE be the <table expression>
       immediately contained in QS, and let TREF be the <table reference>s simply contained in the <from
       clause> of TE. Let SL be the <select list> immediately contained in QS, and let n be the number of
       <value expression>s VEj, 1 (one) ≤ j ≤ n, simply contained in SL.

         i)       Case:
                  1) If TREF contains only one <table reference>, then let TR1 be that <table reference>, and let
                     m be 1 (one).
                  2) Otherwise, let m be the number of <table reference>s that identify tables with respect to
                     which QS is one-to-one. Let TRi, 1 (one) ≤ i ≤ m, be those <table reference>s.

         ii)      Let TTi, 1 (one) ≤ i ≤ m, be the table identified by TRi, let RSi be an initially empty replacement
                  set for TTi, and let CLi be the object column list of TTi, such that every column of CLi is an
                  underlying column of CL.
         iii)     For every pair (SR, CNR) of RS, and for i ranging from 1 (one) to m:
                  1) Let SRTI be the row of TTi from which SR has been derived.

                  2) A candidate row CNRI of TTi is effectively created in which the value of each column is its
                     default value, as specified the General Rules of Subclause 11.5, “<default clause>”. The
                     candidate row includes every column of TTi.

                  3) For j ranging from 1 (one) to n, let C be a column of some candidate row identified by VEj,
                     and let SV be the j-th value of R. The General Rules of Subclause 9.2, “Store assignment”,
                     are applied to C and SV as TARGET and SOURCE, respectively.
                  4) Identify SRTI for replacement by CNRI; the pair (SRTI, CNRI) is effectively added to SRi.

         iv)      For i ranging from 1 (one) to m
                  Case:
                  1) If TTi is a base table, then

                      Case:
                      A) If TRi specifies ONLY, then TTi is identified for replacement processing without subta-
                         bles with respect to the object columns CLi.

                      B) Otherwise, TTi is identified for replacement processing with subtables with respect to
                         the object columns CLi.

                  2) If TTi is a viewed table, then the General rules of Subclause 14.24, “Effect of replacing some
                     rows in a viewed table”, are applied with TRi as VIEW NAME.

                  3) If TTi is a derived table, then the General rules of Subclause 14.23, “Effect of replacing
                     some rows in a derived table”, are applied with TRi as TABLE.




©ISO/IEC 2003 – All rights reserved                                                         Data manipulation 877
ISO/IEC 9075-2:2003 (E)
14.23 Effect of replacing some rows in a derived table



Conformance Rules
    None.




878 Foundation (SQL/Foundation)                          ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                            14.24 Effect of replacing some rows in a viewed table



14.24 Effect of replacing some rows in a viewed table

Function
Specify the effect of replacing some rows in a viewed table.


Syntax Rules
    None.


Access Rules
    None.


General Rules
1) Let T be the VIEW NAME and RS the replacement set for VIEW NAME in application of this Subclause.
   Let TD be the view descriptor of T. If VN specifies ONLY, then let QE be the original <query expression>
   included in TD; otherwise, let QE be the <query expression> included in TD.
2) If TD indicates WITH CHECK OPTION, then:
    a) Case:
         i)       If TD specifies LOCAL, then let VD be a view descriptor derived from TD as follows:
                  1) The WITH CHECK OPTION indication is removed.
                  2) Every reference contained in QE to a leaf underlying table LUT of QE is replaced by a ref-
                     erence to a temporary table consisting of a copy of LUT.
         ii)      Otherwise, let VD be a view descriptor derived from TD as follows.
                  1) The WITH CHECK OPTION indication is removed.
                  2) Every reference contained in QE to an underlying table UV of QE that is a viewed table is
                     replaced by a reference to a view whose descriptor is identical to that of UV except that
                     WITH CASCADED CHECK OPTION is indicated.
                  3) Every reference contained in QE to a leaf underlying table LUT of T that is a base table is
                     replaced by a reference to a temporary table consisting of a copy of LUT.
    b) The General Rules of this Subclause are applied with the view V described by VD as VIEW NAME and
       RS as the replacement set for V.
    c) Let S be the table consisting of the candidate new rows of RS. If the result of
               EXISTS ( SELECT * FROM S
                        EXCEPT ALL
                        SELECT * FROM V )




©ISO/IEC 2003 – All rights reserved                                                      Data manipulation 879
ISO/IEC 9075-2:2003 (E)
14.24 Effect of replacing some rows in a viewed table



        is True, then an exception condition is raised: with check option violation.
3) The General Rules of Subclause 14.23, “Effect of replacing some rows in a derived table”, are applied with
   QE as TABLE and RS as the replacement set for QE.


Conformance Rules
    None.




880 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                             ISO/IEC 9075-2:2003 (E)
                                                                                  14.25 Execution of BEFORE triggers



14.25 Execution of BEFORE triggers

Function
Define the execution of BEFORE triggers.


Syntax Rules
1) Let SSC be the SET OF STATE CHANGES specified in an application of this Subclause.
2) Let BT be the set of BEFORE triggers that are activated by some state change in SSC.
    NOTE 404 — Activation of triggers is defined in Subclause 4.38, “Triggers”.

3) Let NT be the number of triggers in BT and let TRk be the k-th such trigger, ordered according to their order
   of execution. Let SCk be the state change in SSC that activated TRk.
    NOTE 405 — Ordering of triggers is defined in Subclause 4.38, “Triggers”.


Access Rules
    None.


General Rules
1) For k ranging from 1 (one) to NT, apply the General Rules of Subclause 14.27, “Execution of triggers”,
   with TRk as TRIGGER and SCk as STATE CHANGE, respectively.


Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved                                                           Data manipulation 881
ISO/IEC 9075-2:2003 (E)
14.26 Execution of AFTER triggers



14.26 Execution of AFTER triggers

Function
Define the execution of AFTER triggers.


Syntax Rules
1) Let SSC be the SET OF STATE CHANGES specified in an application of this Subclause.
2) Let AT be the set of AFTER triggers that are activated by some state change in SSC.
    NOTE 406 — Activation of triggers is defined in Subclause 4.38, “Triggers”.

3) Let NT be the number of triggers in AT and let TRk be the k-th such trigger, ordered according to their order
   of execution. Let SCk be the state change in SSC that activated TRk.
    NOTE 407 — Ordering of triggers is defined in Subclause 4.38, “Triggers”.


Access Rules
    None.


General Rules
1) For k ranging from 1 (one) to NT, apply the General Rules of Subclause 14.27, “Execution of triggers”,
   with TRk as TRIGGER and SCk as STATE CHANGE, respectively.


Conformance Rules
    None.




882 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)
                                                                                        14.27 Execution of triggers



14.27 Execution of triggers

Function
Define the execution of triggers.


Syntax Rules
    None.


Access Rules
    None.


General Rules
1) Let TR and SC be respectively a TRIGGER and a STATE CHANGE in an application of this Subclause.
2) Let TA be the triggered action included in the trigger descriptor of TR. Let TSS be the <triggered SQL
   statement> contained in TA. Let TE be the trigger event of SC. Let ST be the set of transitions in SC.
3) TR is executed as follows.
    Case:
    a) If TR is a row-level trigger, then, for each transition T in SC for which TR is not considered as executed,
       TA is invoked and TR is considered as executed for T. The order in which the transitions in SC are
       taken is implementation-dependent.
    b) If TR is not considered as executed for SC, then TA is invoked once and TR is considered as executed
       for SC.
4) When TA is invoked:
    a) Case:
         i)       If TE is DELETE, then the old transition table for the invocation of TA is ST. If TR is a row-
                  level trigger, then the value of the old transition variable for the execution of TSS is T.
         ii)      If TE is INSERT, then the new transition table for the invocation of TA is ST. If TR is a row-
                  level trigger, then the value of the new transition variable for the invocation of TA is T.
         iii)     If TE is UPDATE, then the old transition table for the invocation of TA is the multiset formed
                  by taking the old rows of the transitions in in ST and the new transition table for the invocation
                  of TA is the multiset formed by taking the new rows of the transitions in ST. If TR is a row-level
                  trigger, then the value of the old transition variable for the invocation of TA is the old row of T
                  and the new transition variable for the invocation of TA is the new row of T.
    b) Case:



©ISO/IEC 2003 – All rights reserved                                                         Data manipulation 883
ISO/IEC 9075-2:2003 (E)
14.27 Execution of triggers



         i)      If TA contains a <search condition> TASC and the result of evaluating TASC is true, then TSS
                 is executed.
         ii)     If TA does not contain a <search condition>, then TSS is executed.
5) When TSS is executed:
    a) The General Rules of Subclause 22.2, “Pushing and popping the diagnostics area stack”, are applied
       with “PUSH” as OPERATION and the diagnostics area stack as STACK.
    b) The authorization identifier of the owner of the schema that includes the trigger descriptor of TR is
       pushed onto the authorization stack.
    c) A new savepoint level is established.
    d) Let N be the number of <SQL procedure statement>s simply contained in TSS. For i ranging from 1
       (one) to N:
         i)      Let Si be the i-th such <SQL procedure statement>.

         ii)     The General Rules of Subclause 13.5, “<SQL procedure statement>”, are evaluated with Si as
                 the executing statement.
    e) The <SQL procedure statement>s simply contained in TSS are effectively executed in the order in
       which they are specified in TSS.
    f) If, before the completion of the execution of any <SQL procedure statement> simply contained in TSS,
       an attempt is made to execute an SQL-schema statement, an SQL-dynamic statement, or an SQL-session
       statement then an exception condition is raised: prohibited statement encountered during trigger exe-
       cution.
    g) If TR is a BEFORE trigger and if, before the completion of the execution of any <SQL procedure
       statement> simply contained in TSS, an attempt is made to execute an SQL-data change statement or
       an SQL-invoked routine that possibly modifies SQL-data, then an exception condition is raised: pro-
       hibited statement encountered during trigger execution.
    h) The current savepoint level is destroyed.
         NOTE 408 — Destroying a savepoint level destroys all existing savepoints that are established at that level.

    i)   The General Rules of Subclause 22.2, “Pushing and popping the diagnostics area stack”, are applied
         with “POP” as OPERATION and the diagnostics area stack as STACK.
    j)   The top cell in the authorization stack is removed.
    k) If the execution of TSS is not successful, then an exception condition is raised: triggered action
       exception. The exception condition that caused TSS to fail is raised.
         NOTE 409 — Raising the exception condition that caused TSS to fail enters the exception information into the diagnostics
         area that was pushed prior to the execution of TSS.


Conformance Rules
    None.




884 Foundation (SQL/Foundation)                                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                                     15.1 <call statement>




15 Control statements


15.1 <call statement>

Function
Invoke an SQL-invoked routine.


Format
<call statement> ::= CALL <routine invocation>


Syntax Rules
1) Let RI be the <routine invocation> immediately contained in the <call statement>.
2) Let SR be the subject routine specified by applying the Syntax Rules of Subclause 10.4, “<routine invoca-
   tion>”, to RI.
3) SR shall be an SQL-invoked procedure.


Access Rules
    None.


General Rules
1) SR is effectively invoked according to the General Rules of Subclause 10.4, “<routine invocation>”, with
   RI and SR as the <routine invocation> and the subject routine, respectively.


Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved                                                 Control statements 885
ISO/IEC 9075-2:2003 (E)
15.2 <return statement>



15.2 <return statement>

Function
Return a value from an SQL function.


Format
<return statement> ::= RETURN <return value>

<return value> ::=
    <value expression>
  | NULL


Syntax Rules
1) <return statement> shall be contained in an SQL routine body that is simply contained in the <routine
   body> of an <SQL-invoked function> F. Let RDT be the <returns data type> of the <returns clause> of F.
2) The <return value> <null specification> is equivalent to the <value expression>:
      CAST (NULL AS RDT)

3) Let VE be the <value expression> of the <return value> immediately contained in <return statement>.
4) The declared type of VE shall be assignable to an item of the data type RDT, according to the Syntax Rules
   of Subclause 9.2, “Store assignment”, with RDT and VE as TARGET and VALUE, respectively.


Access Rules
    None.


General Rules
1) The value of VE is the returned value of the execution of the SQL routine body of F.
2) The execution of the SQL routine body of F is terminated immediately.


Conformance Rules
    None.




886 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                           16.1 <start transaction statement>




16 Transaction management


16.1 <start transaction statement>

Function
Start an SQL-transaction and set its characteristics.


Format
<start transaction statement> ::=
    START TRANSACTION
    [ <transaction mode> [ { <comma> <transaction mode> }... ] ]

<transaction mode> ::=
    <isolation level>
  | <transaction access mode>
  | <diagnostics size>

<transaction access mode> ::=
    READ ONLY
  | READ WRITE

<isolation level> ::= ISOLATION LEVEL <level of isolation>

<level of isolation> ::=
    READ UNCOMMITTED
  | READ COMMITTED
  | REPEATABLE READ
  | SERIALIZABLE

<diagnostics size> ::= DIAGNOSTICS SIZE <number of conditions>

<number of conditions> ::= <simple value specification>


Syntax Rules
1) None of <isolation level>, <transaction access mode>, and <diagnostics size> shall be specified more than
   once in a single <start transaction statement>.
2) If <start transaction statement> contains at least one <transaction mode>, then:
    a) If an <isolation level> is not specified, then a <level of isolation> of SERIALIZABLE is implicit.
    b) If READ WRITE is specified, then the <level of isolation> shall not be READ UNCOMMITTED.




©ISO/IEC 2003 – All rights reserved                                            Transaction management 887
ISO/IEC 9075-2:2003 (E)
16.1 <start transaction statement>



    c) If a <transaction access mode> is not specified and a <level of isolation> of READ UNCOMMITTED
       is specified, then READ ONLY is implicit. Otherwise, READ WRITE is implicit.
    d) If <number of conditions> is not specified, then an implementation-dependent value not less than 1
       (one) is implicit for <number of conditions>.
3) The declared type of <number of conditions> shall be exact numeric with scale 0 (zero).


Access Rules
    None.


General Rules
1) If a <start transaction statement> statement is executed when an SQL-transaction is currently active, then
   an exception condition is raised: invalid transaction state — active SQL-transaction.
2) Let TXN be the SQL-transaction that will be started after successful execution of <start transaction state-
   ment>.
3) If <start transaction statement> contains no <transaction mode>, then:
    a) The isolation level of TXN is set to the enduring transaction characteristic of isolation level.
    b) The transaction access mode level of TXN is set to the enduring transaction characteristic of access
       mode.
    c) The number of conditions of TXN is set to the enduring transaction characteristic of diagnostics size.
4) If <number of conditions> is specified and is less than 1 (one), then an exception condition is raised: invalid
   condition number.
5) If READ ONLY is specified, then the access mode of TXN is set to read-only. If READ WRITE is specified,
   then the access mode of TXN is set to read-write.
6) The isolation level of TXN is set to an implementation-defined isolation level that will not exhibit any of
   the phenomena that the explicit or implicit <level of isolation> would not exhibit, as specified in Table 8,
   “SQL-transaction isolation levels and the three phenomena”.
7) If <number of conditions> is specified, then the condition area limit of TXN is set to <number of conditions>.
    NOTE 410 — The characteristics of a transaction begun by a <start transaction statement> are as specified in these General Rules
    regardless of the characteristics specified by any preceding <set transaction statement>. That is, even if one or more characteristics
    are omitted by the <start transaction statement>, the defaults specified in the Syntax Rules of this Subclause are effective and are
    not affected by any (preceding) <set transaction statement>.

8) TXN is started.


Conformance Rules
1) Without Feature T241, “START TRANSACTION statement”, conforming SQL language shall not contain
   a <start transaction statement>.



888 Foundation (SQL/Foundation)                                                                     ©ISO/IEC 2003 – All rights reserved
                                                                               ISO/IEC 9075-2:2003 (E)
                                                                      16.1 <start transaction statement>



2) Without Feature F111, “Isolation levels other than SERIALIZABLE”, conforming SQL language shall not
   contain an <isolation level> that contains a <level of isolation> other than SERIALIZABLE.
3) Without Feature F121, “Basic diagnostics management”, conforming SQL language shall not contain a
   <diagnostics size>.




©ISO/IEC 2003 – All rights reserved                                       Transaction management 889
ISO/IEC 9075-2:2003 (E)
16.2 <set transaction statement>



16.2 <set transaction statement>

Function
Set the characteristics of the next SQL-transaction for the SQL-agent.
NOTE 411 — This statement has no effect on any SQL-transactions subsequent to the next SQL-transaction.


Format
<set transaction statement> ::=
    SET [ LOCAL ] <transaction characteristics>

<transaction characteristics> ::=
    TRANSACTION <transaction mode> [ { <comma> <transaction mode> }... ]


Syntax Rules
1) None of <isolation level>, <transaction access mode>, and <diagnostics size> shall be specified more than
   once in a single <transaction characteristics>.
2) If LOCAL is specified, then <number of conditions> shall not be specified.


Access Rules
    None.


General Rules
1) Case:
    a) If a <set transaction statement> that does not specify LOCAL is executed, then
         Case:
         i)      If an SQL-transaction is currently active, then an exception condition is raised: invalid transaction
                 state — active SQL-transaction.
         ii)     If an SQL-transaction is not currently active, then if there are any holdable cursors remaining
                 open from the previous SQL-transaction and the isolation level of the previous SQL-transaction
                 is not the same as the isolation level determined by the <level of isolation>, then an exception
                 condition is raised: invalid transaction state — held cursor requires same isolation level.
    b) If a <set transaction statement> that specifies LOCAL is executed, then:
         i)      If the SQL-implementation does not support SQL-transactions that affect more than one SQL-
                 server, then an exception condition is raised: feature not supported — multiple server transactions.
         ii)     If there is no SQL-transaction that is currently active, then an exception condition is raised:
                 invalid transaction state — no active SQL-transaction for branch transaction.


890 Foundation (SQL/Foundation)                                                             ©ISO/IEC 2003 – All rights reserved
                                                                                               ISO/IEC 9075-2:2003 (E)
                                                                                        16.2 <set transaction statement>



         iii)     If there is an active SQL-transaction and there has been a transaction-initiating SQL-statement
                  executed at the current SQL-connection in the context of the active SQL-transaction, then an
                  exception condition is raised: invalid transaction state — branch transaction already active.
         iv)      If the transaction access mode of the SQL-transaction is read-only and <transaction access
                  mode> specifies READ WRITE, then an exception condition is raised: invalid transaction state
                  — inappropriate access mode for branch transaction.
         v)       If the isolation level of the SQL-transaction is SERIALIZABLE and <level of isolation> specifies
                  anything except SERIALIZABLE, then an exception condition is raised: invalid transaction
                  state — inappropriate isolation level for branch transaction.
         vi)      If the isolation level of the SQL-transaction is REPEATABLE READ and <level of isolation>
                  specifies anything except REPEATABLE READ or SERIALIZABLE, then an exception condition
                  is raised: invalid transaction state — inappropriate isolation level for branch transaction.
         vii)     If the isolation level of the SQL-transaction is READ COMMITTED and <level of isolation>
                  specifies READ UNCOMMITTED, then an exception condition is raised: invalid transaction
                  state — inappropriate isolation level for branch transaction.
                  NOTE 412 — If the isolation level of the SQL-transaction is READ UNCOMMITTED, then any <level of isolation>
                  is permissible.

2) If <number of conditions> is specified and is less than 1 (one), then an exception condition is raised: invalid
   condition number.
3) Case:
    a) If LOCAL is not specified, then let TXN be the next SQL-transaction for the SQL-agent.
    b) Otherwise, let TXN be the branch of the active SQL-transaction at the current SQL-connection.
4) If READ ONLY is specified, then the access mode of TXN is set to read-only. If READ WRITE is specified,
   then the access mode of TXN is set to read-write.
5) The isolation level of TXN is set to an implementation-defined isolation level that will not exhibit any of
   the phenomena that the explicit or implicit <level of isolation> would not exhibit, as specified in Table 8,
   “SQL-transaction isolation levels and the three phenomena”.
6) If <number of conditions> is specified, then the condition area limit of TXN is set to <number of conditions>.
7) If <number of conditions> is not specified, then the condition area limit of TXN is set to an implementation-
   dependent value not less than 1 (one).


Conformance Rules
1) Without Feature T251, “SET TRANSACTION statement: LOCAL option”, conforming SQL language
   shall not contain a <set transaction statement> that immediately contains LOCAL.




©ISO/IEC 2003 – All rights reserved                                                        Transaction management 891
ISO/IEC 9075-2:2003 (E)
16.3 <set constraints mode statement>



16.3 <set constraints mode statement>

Function
If an SQL-transaction is currently active, then set the constraint mode for that SQL-transaction in the current
SQL-session. If no SQL-transaction is currently active, then set the constraint mode for the next SQL-transaction
in the current SQL-session for the SQL-agent.
NOTE 413 — This statement has no effect on any SQL-transactions subsequent to this SQL-transaction.


Format
<set constraints mode statement> ::=
    SET CONSTRAINTS <constraint name list> { DEFERRED | IMMEDIATE }

<constraint name list> ::=
    ALL
  | <constraint name> [ { <comma> <constraint name> }... ]


Syntax Rules
1) If a <constraint name> is specified, then it shall identify a constraint.
2) The constraint identified by <constraint name> shall be DEFERRABLE.


Access Rules
    None.


General Rules
1) If an SQL-transaction is currently active, then let TXN be the currently active SQL-transaction. Otherwise,
   let TXN be the next SQL-transaction for the SQL-agent.
2) If IMMEDIATE is specified, then
    Case:
    a) If ALL is specified, then the constraint mode in TXN of all constraints that are DEFERRABLE is set
       to immediate.
    b) Otherwise, the constraint mode in TXN for the constraints identified by the <constraint name>s in the
       <constraint name list> is set to immediate.
3) If DEFERRED is specified, then
    Case:
    a) If ALL is specified, then the constraint mode in TXN of all constraints that are DEFERRABLE is set
       to deferred.


892 Foundation (SQL/Foundation)                                                             ©ISO/IEC 2003 – All rights reserved
                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                      16.3 <set constraints mode statement>



    b) Otherwise, the constraint mode in TXN for the constraints identified by the <constraint name>s in the
       <constraint name list> is set to deferred.


Conformance Rules
1) Without Feature F721, “Deferrable constraints”, conforming SQL language shall not contain a <set con-
   straints mode statement>.




©ISO/IEC 2003 – All rights reserved                                           Transaction management 893
ISO/IEC 9075-2:2003 (E)
16.4 <savepoint statement>



16.4 <savepoint statement>

Function
Establish a savepoint.


Format
<savepoint statement> ::= SAVEPOINT <savepoint specifier>

<savepoint specifier> ::= <savepoint name>


Syntax Rules
    None.


Access Rules
    None.


General Rules
1) Let S be the <savepoint name>.
2) If S identifies an existing savepoint established within the current savepoint level, then that savepoint is
   destroyed.
3) If the number of savepoints that now exist within the current SQL-transaction is equal to the implementation-
   defined maximum number of savepoints per SQL-transaction, then an exception condition is raised: savepoint
   exception — too many.
4) A savepoint is established in the current savepoint level and at the current point in the current SQL-trans-
   action. S is assigned as the identifier of that savepoint.


Conformance Rules
1) Without Feature T271, “Savepoints”, conforming SQL language shall not contain a <savepoint statement>.




894 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                            16.5 <release savepoint statement>



16.5 <release savepoint statement>

Function
Destroy a savepoint.


Format
<release savepoint statement> ::= RELEASE SAVEPOINT <savepoint specifier>


Syntax Rules
    None.


Access Rules
    None.


General Rules
1) Let S be the <savepoint name>.
2) If S does not identify a savepoint established in the current savepoint level, then an exception condition is
   raised: savepoint exception — invalid specification.
3) The savepoint identified by S and all savepoints established in the current savepoint level subsequent to
   the establishment of S are destroyed.


Conformance Rules
1) Without Feature T271, “Savepoints”, conforming SQL language shall not contain a <release savepoint
   statement>.




©ISO/IEC 2003 – All rights reserved                                              Transaction management 895
ISO/IEC 9075-2:2003 (E)
16.6 <commit statement>



16.6 <commit statement>

Function
Terminate the current SQL-transaction with commit.


Format
<commit statement> ::= COMMIT [ WORK ] [ AND [ NO ] CHAIN ]


Syntax Rules
1) If neither AND CHAIN nor AND NO CHAIN is specified, then AND NO CHAIN is implicit.


Access Rules
    None.


General Rules
1) If the current SQL-transaction is part of an encompassing transaction that is controlled by an agent other
   than the SQL-agent, then an exception condition is raised: invalid transaction termination.
2) If an atomic execution context is active, then an exception condition is raised: invalid transaction termination.
3) For every open cursor that is not a holdable cursor CR in any SQL-client module associated with the current
   SQL-transaction, the following statement is implicitly executed:
       CLOSE CR

4) For every temporary table in any SQL-client module associated with the current SQL-transaction that
   specifies the ON COMMIT DELETE option and that was updated by the current SQL-transaction, the
   execution of the <commit statement> is effectively preceded by the execution of a <delete statement:
   searched> that specifies DELETE FROM T, where T is the <table name> of that temporary table.
5) The effects specified in the General Rules of Subclause 16.3, “<set constraints mode statement>” occur as
   if the statement SET CONSTRAINTS ALL IMMEDIATE were executed for each active SQL-connection.
6) Case:
    a) If any constraint is not satisfied, then any changes to SQL-data or schemas that were made by the current
       SQL-transaction are canceled and an exception condition is raised: transaction rollback — integrity
       constraint violation.
    b) If the execution of any <triggered SQL statement> is unsuccessful, then any changes to SQL-data or
       schemas that were made by the current SQL-transaction are canceled and an exception condition is
       raised: transaction rollback — triggered action exception.



896 Foundation (SQL/Foundation)                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                                     16.6 <commit statement>



    c) If any other error preventing commitment of the SQL-transaction has occurred, then any changes to
       SQL-data or schemas that were made by the current SQL-transaction are canceled and an exception
       condition is raised: transaction rollback with an implementation-defined subclass value.
    d) Otherwise, any changes to SQL-data or schemas that were made by the current SQL-transaction are
       eligible to be perceived by all concurrent and subsequent SQL-transactions.
7) All savepoint levels are destroyed and a new savepoint level is established.
    NOTE 414 — Destroying a savepoint level destroys all existing savepoints that are established at that level.

8) Every valid non-holdable locator value is marked invalid.
9) The current SQL-transaction is terminated. If AND CHAIN was specified, then a new SQL-transaction is
   initiated with the same access mode, isolation level, and diagnostics area limit as the SQL-transaction just
   terminated. Any branch transactions of the SQL-transaction are initiated with the same access mode, isolation
   level, and diagnostics area limit as the corresponding branch of the SQL-transaction just terminated.
10) The <statement name> or <extended statement name> of every held cursor remains valid.


Conformance Rules
1) Without Feature T261, “Chained transactions”, conforming SQL language shall not contain a <commit
   statement> that immediately contains CHAIN.




©ISO/IEC 2003 – All rights reserved                                                             Transaction management 897
ISO/IEC 9075-2:2003 (E)
16.7 <rollback statement>



16.7 <rollback statement>

Function
Terminate the current SQL-transaction with rollback, or rollback all actions affecting SQL-data and/or schemas
since the establishment of a savepoint.


Format
<rollback statement> ::= ROLLBACK [ WORK ] [ AND [ NO ] CHAIN ] [ <savepoint clause> ]

<savepoint clause> ::= TO SAVEPOINT <savepoint specifier>


Syntax Rules
1) If AND CHAIN is specified, then <savepoint clause> shall not be specified.
2) If neither AND CHAIN nor AND NO CHAIN is specified, then AND NO CHAIN is implicit.


Access Rules
    None.


General Rules
1) If the current SQL-transaction is part of an encompassing transaction that is controlled by an agent other
   than the SQL-agent and the <rollback statement> is not being implicitly executed, then an exception con-
   dition is raised: invalid transaction termination.
2) If a <savepoint clause> is not specified, then:
    a) If an atomic execution context is active, then an exception condition is raised: invalid transaction ter-
       mination.
    b) All changes to SQL-data or schemas that were made by the current SQL-transaction are canceled.
    c) All savepoint levels are destroyed and a new savepoint level is established.
        NOTE 415 — Destroying a savepoint level destroys all existing savepoints that are established at that level.

    d) Every valid locator is marked invalid.
    e) All open cursors in any SQL-client module associated with the current SQL-transaction are closed.
    f) The current SQL-transaction is terminated. If AND CHAIN was specified, then a new SQL-transaction
       is initiated with the same access mode, isolation level, and diagnostics area limit as the SQL-transaction
       just terminated. Any branch transactions of the SQL-transaction are initiated with the same access
       mode, isolation level, and diagnostics area limit as the corresponding branch of the SQL-transaction
       just terminated.



898 Foundation (SQL/Foundation)                                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                                    16.7 <rollback statement>



3) If a <savepoint clause> is specified, then:
    a) Let S be the <savepoint name>.
    b) If S does not specify a savepoint established within the current savepoint level, then an exception con-
       dition is raised: savepoint exception — invalid specification.
    c) If an atomic execution context is active, and S specifies a savepoint established before the beginning
       of the most recent atomic execution context, then an exception condition is raised: savepoint exception
       — invalid specification.
    d) All changes to SQL-data or schemas that were made by the current SQL-transaction subsequent to the
       establishment of S are canceled.
    e) All savepoints established by the current SQL-transaction subsequent to the establishment of S are
       destroyed.
         NOTE 416 — Destroying a savepoint level destroys all existing savepoints that are established at that level.

    f) Every valid locator that was generated in the current SQL-transaction subsequent to the establishment
       of S is marked invalid.
    g) For every open cursor CR in any SQL-client module associated with the current SQL-transaction that
       was opened subsequent to the establishment of S, the following statement is implicitly executed:
             CLOSE CR

    h) The status of any open cursors in any SQL-client module associated with the current SQL-transaction
       that were opened by the current SQL-transaction before the establishment of S is implementation-
       defined.
         NOTE 417 — The current SQL-transaction is not terminated, and there is no other effect on the SQL-data or schemas.


Conformance Rules
1) Without Feature T271, “Savepoints”, conforming SQL language shall not contain a <savepoint clause>.
2) Without Feature T261, “Chained transactions”, conforming SQL language shall not contain a <rollback
   statement> that immediately contains CHAIN.




©ISO/IEC 2003 – All rights reserved                                                             Transaction management 899
ISO/IEC 9075-2:2003 (E)




                                  This page intentionally left blank.




900 Foundation (SQL/Foundation)                                         ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                                    17.1 <connect statement>




17 Connection management


17.1 <connect statement>

Function
Establish an SQL-session.


Format
<connect statement> ::= CONNECT TO <connection target>

<connection target> ::=
    <SQL-server name> [ AS <connection name> ] [ USER <connection user name> ]
  | DEFAULT


Syntax Rules
1) If <connection user name> is not specified, then an implementation-defined <connection user name> for
   the SQL-connection is implicit.


Access Rules
    None.


General Rules
1) If a <connect statement> is executed after the first transaction-initiating SQL-statement executed by the
   current SQL-transaction and the SQL-implementation does not support transactions that affect more than
   one SQL-server, then an exception condition is raised: feature not supported — multiple server transactions.
2) If <connection user name> is specified, then let S be <connection user name> and let V be the character
   string that is the value of
        TRIM ( BOTH ' ' FROM S )

3) If V does not conform to the Format and Syntax Rules of a <user identifier>, then an exception condition
   is raised: invalid authorization specification.
4) If the SQL-client module that contains the <externally-invoked procedure> that contains the <connect
   statement> specifies a <module authorization identifier>, then whether or not <connection user name>
   shall be identical to that <module authorization identifier> is implementation-defined, as are any other



©ISO/IEC 2003 – All rights reserved                                              Connection management 901
ISO/IEC 9075-2:2003 (E)
17.1 <connect statement>



    restrictions on the value of <connection user name>. Otherwise, any restrictions on the value of <connection
    user name> are implementation-defined.
5) If the value of <connection user name> does not conform to the implementation-defined restrictions, then
   an exception condition is raised: invalid authorization specification.
6) If <connection name> was specified, then let CV be <simple value specification> immediately contained
   in <connection name>. If neither DEFAULT nor <connection name> were specified, then let CV be <SQL-
   server name>. Let CN be the result of
       TRIM ( BOTH ' ' FROM CV )
    If CN does not conform to the Format and Syntax Rules of an <identifier>, then an exception condition is
    raised: invalid connection name.
7) If an SQL-connection with name CN has already been established by the current SQL-agent and has not
   been disconnected, or if DEFAULT is specified and a default SQL-connection has already been established
   by the current SQL-agent and has not been disconnected, then an exception condition is raised: connection
   exception — connection name in use.
8) Case:
    a) If DEFAULT is specified, then the default SQL-session is initiated and associated with the default
       SQL-server. The method by which the default SQL-server is determined is implementation-defined.
    b) Otherwise, an SQL-session is initiated and associated with the SQL-server identified by <SQL-server
       name>. The method by which <SQL-server name> is used to determine the appropriate SQL-server is
       implementation-defined.
9) If the <connect statement> successfully initiates an SQL-session, then:
    a) The current SQL-connection CC and current SQL-session, if any, become a dormant SQL-connection
       and a dormant SQL-session, respectively. The SQL-session context for CC is preserved and is not
       affected in any way by operations performed over the initiated SQL-connection.
        NOTE 418 — The SQL-session context is defined in Subclause 4.37, “SQL-sessions”.

    b) The SQL-session initiated by the <connect statement> becomes the current SQL-session and the SQL-
       connection established to that SQL-session becomes the current SQL-connection.
    NOTE 419 — If the <connect statement> fails to initiate an SQL-session, then the current SQL-connection and current SQL-session,
    if any, remain unchanged.

10) If the SQL-client cannot establish the SQL-connection, then an exception condition is raised: connection
    exception — SQL-client unable to establish SQL-connection.
11) If the SQL-server rejects the establishment of the SQL-connection, then an exception condition is raised:
    connection exception — SQL-server rejected establishment of SQL-connection.
12) The SQL-server for the subsequent execution of <externally-invoked procedure>s in any SQL-client
    modules associated with the SQL-agent is set to the SQL-server identified by <SQL-server name>.
13) In the context of the newly established SQL-session, the authorization stack is initialized with a single cell
    containing the user identifier <connection user name>.
14) A new savepoint level is established.



902 Foundation (SQL/Foundation)                                                                 ©ISO/IEC 2003 – All rights reserved
                                                                               ISO/IEC 9075-2:2003 (E)
                                                                              17.1 <connect statement>



Conformance Rules
1) Without Feature F771, “Connection management”, conforming SQL language shall not contain a <connect
   statement>.




©ISO/IEC 2003 – All rights reserved                                       Connection management 903
ISO/IEC 9075-2:2003 (E)
17.2 <set connection statement>



17.2 <set connection statement>

Function
Select an SQL-connection from the available SQL-connections.


Format
<set connection statement> ::= SET CONNECTION <connection object>

<connection object> ::=
    DEFAULT
  | <connection name>


Syntax Rules
    None.


Access Rules
    None.


General Rules
1) If a <set connection statement> is executed after the first transaction-initiating SQL-statement executed by
   the current SQL-transaction and the SQL-implementation does not support transactions that affect more
   than one SQL-server, then an exception condition is raised: feature not supported — multiple server
   transactions.
2) Case:
    a) If DEFAULT is specified and there is no default SQL-connection that is current or dormant for the
       current SQL-agent, then an exception condition is raised: connection exception — connection does not
       exist.
    b) Otherwise, if <connection name> does not identify an SQL-session that is current or dormant for the
       current SQL-agent, then an exception condition is raised: connection exception — connection does not
       exist.
3) If the SQL-connection identified by <connection object> cannot be selected, then an exception condition
   is raised: connection exception — connection failure.
4) The current SQL-connection and current SQL-session become a dormant SQL-connection and a dormant
   SQL-session, respectively. The SQL-session context information is preserved and is not affected in any
   way by operations performed over the selected SQL-connection.
    NOTE 420 — The SQL-session context information is defined in Subclause 4.37, “SQL-sessions”.




904 Foundation (SQL/Foundation)                                                           ©ISO/IEC 2003 – All rights reserved
                                                                                              ISO/IEC 9075-2:2003 (E)
                                                                                       17.2 <set connection statement>



5) The SQL-connection identified by <connection object> becomes the current SQL-connection and the SQL-
   session associated with that SQL-connection becomes the current SQL-session. All SQL-session context
   information is restored to the same state as at the time the SQL-connection became dormant.
    NOTE 421 — The SQL-session context information is defined in Subclause 4.37, “SQL-sessions”.

6) The SQL-server for the subsequent execution of <externally-invoked procedure>s in any SQL-client
   modules associated with the SQL-agent are set to that of the current SQL-connection.


Conformance Rules
1) Without Feature F771, “Connection management”, conforming SQL language shall not contain a <set
   connection statement>.




©ISO/IEC 2003 – All rights reserved                                                       Connection management 905
ISO/IEC 9075-2:2003 (E)
17.3 <disconnect statement>



17.3 <disconnect statement>

Function
Terminate an SQL-connection.


Format
<disconnect statement> ::= DISCONNECT <disconnect object>

<disconnect object> ::=
    <connection object>
  | ALL
  | CURRENT


Syntax Rules
    None.


Access Rules
    None.


General Rules
1) If <connection name> is specified and <connection name> does not identify an SQL-connection that is
   current or dormant for the current SQL-agent, then an exception condition is raised: connection exception
   — connection does not exist.
2) If DEFAULT is specified and there is no default SQL-connection that is current or dormant for the current
   SQL-agent, then an exception condition is raised: connection exception — connection does not exist.
3) If CURRENT is specified and there is no current SQL-connection for the current SQL-agent, then an
   exception condition is raised: connection exception — connection does not exist.
4) Let C be the current SQL-connection.
5) Let L be a list of SQL-connections. If a <connection name> is specified, then L is that SQL-connection. If
   CURRENT is specified, then L is the current SQL-connection. If ALL is specified, then L is a list representing
   every SQL-connection that is current or dormant for the current SQL-agent, in an implementation-dependent
   order. If DEFAULT is specified, then L is the default SQL-connection.
6) If any SQL-connection in L is active, then an exception condition is raised: invalid transaction state —
   active SQL-transaction.
7) For every SQL-connection C1 in L, treating the SQL-session S1 identified by C1 as the current SQL-session,
   all of the actions that are required after the last call of a <externally-invoked procedure> by an SQL-agent,




906 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                                 ISO/IEC 9075-2:2003 (E)
                                                                                             17.3 <disconnect statement>



    except for the execution of a <rollback statement> or a <commit statement>, are performed. C1 is terminated,
    regardless of any exception condition that might occur during the disconnection process.
    NOTE 422 — See the General Rules of Subclause 13.1, “<SQL-client module definition>”, for the actions to be performed after
    the last call of a <externally-invoked procedure> by an SQL-agent.

8) If any error is detected during execution of a <disconnect statement>, then a completion condition is raised:
   warning — disconnect error.
9) If C is contained in L, then there is no current SQL-connection following the execution of the <disconnect
   statement>. Otherwise, C remains the current SQL-connection.


Conformance Rules
1) Without Feature F771, “Connection management”, conforming SQL language shall not contain a <disconnect
   statement>.




©ISO/IEC 2003 – All rights reserved                                                         Connection management 907
ISO/IEC 9075-2:2003 (E)




                                  This page intentionally left blank.




908 Foundation (SQL/Foundation)                                         ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                       18.1 <set session characteristics statement>




18 Session management


18.1 <set session characteristics statement>

Function
Set one or more characteristics for the current SQL-session.


Format
<set session characteristics statement> ::=
    SET SESSION CHARACTERISTICS AS <session characteristic list>

<session characteristic list> ::=
    <session characteristic> [ { <comma> <session characteristic> }... ]

<session characteristic> ::= <transaction characteristics>


Syntax Rules
1) None of <isolation level>, <transaction access mode>, and <diagnostics size> shall be specified more than
   once in a single <session characteristic list>.


Access Rules
    None.


General Rules
1) For each <transaction characteristics> contained in the <session characteristic list>, the enduring transaction
   characteristics of the SQL-session are set to the values explicitly specified in the <transaction characteristics>;
   enduring characteristics corresponding to <transaction characteristics> values not explicitly specified are
   unchanged.


Conformance Rules
1) Without Feature F761, “Session management”, conforming SQL language shall not contain a <set session
   characteristics statement>.
2) Without Feature F111, “Isolation levels other than SERIALIZABLE”, conforming SQL language shall not
   contain a <set session characteristics statement> that contains a <level of isolation> other than SERIALIZ-
   ABLE.


©ISO/IEC 2003 – All rights reserved                                                       Session management 909
ISO/IEC 9075-2:2003 (E)
18.1 <set session characteristics statement>



18.2 <set session user identifier statement>

Function
Set the SQL-session user identifier and the current user identifier of the current SQL-session context.


Format
<set session user identifier statement> ::=
    SET SESSION AUTHORIZATION <value specification>


Syntax Rules
1) The declared type of the <value specification> shall be a character string type.


Access Rules
    None.


General Rules
1) If a <set session user identifier statement> is executed and an SQL-transaction is currently active, then an
   exception condition is raised: invalid transaction state — active SQL-transaction.
2) Let S be <value specification> and let V be the character string that is the value of
       TRIM ( BOTH ' ' FROM S )

3) If V does not conform to the Format and Syntax Rules of an <authorization identifier>, then an exception
   condition is raised: invalid authorization specification.
4) Whether or not the SQL-session user identifier can be set to a different <user identifier> is implementation-
   defined, as are any restrictions pertaining to such changes.
5) If the current user identifier and the current role name are restricted from setting the user identifier to V,
   then an exception condition is raised: invalid authorization specification.
6) The SQL-session user identifier of the current SQL-session context is set to V.
7) The current user identifier is set to V.
8) The SQL-session role name and the current role name are removed.


Conformance Rules
1) Without Feature F321, “User authorization”, conforming SQL language shall not contain a <set session
   user identifier statement>.



910 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                             ISO/IEC 9075-2:2003 (E)
                                                                                            18.3 <set role statement>



18.3 <set role statement>

Function
Set the current role name for the current SQL-session context.


Format
<set role statement> ::= SET ROLE <role specification>

<role specification> ::=
    <value specification>
  | NONE


Syntax Rules
1) The declared type of the <value specification> shall be a character string type.


Access Rules
    None.


General Rules
1) If a <set role statement> is executed and an SQL-transaction is currently active, then an exception condition
   is raised: invalid transaction state — active SQL-transaction.
2) Let S be <value specification> and let V be the character string that is the value of
        TRIM ( BOTH ' ' FROM S )

3) If V does not conform to the Format and Syntax Rules of a <role name>, then an exception condition is
   raised: invalid role specification.
4) If no role authorization descriptor exists that indicates that the role identified by V has been granted to
   either the current user identifier or to PUBLIC, then an exception condition is raised: invalid role specifi-
   cation.
5) Case:
    a) If NONE is specified, then
         Case:
         i)       If there is no current user identifier, then an exception condition is raised: invalid role specifica-
                  tion.
         ii)      Otherwise, the current role name is removed.



©ISO/IEC 2003 – All rights reserved                                                         Session management 911
ISO/IEC 9075-2:2003 (E)
18.3 <set role statement>



    b) Otherwise, the current role name is set to V.


Conformance Rules
1) Without Feature T331, “Basic roles”, conforming SQL language shall not contain a <set role statement>.




912 Foundation (SQL/Foundation)                                              ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                            18.4 <set local time zone statement>



18.4 <set local time zone statement>

Function
Set the current default time zone displacement for the current SQL-session.


Format
<set local time zone statement> ::= SET TIME ZONE <set time zone value>

<set time zone value> ::=
    <interval value expression>
  | LOCAL


Syntax Rules
1) The declared type of the <interval value expression> immediately contained in the <set time zone value>
   shall be INTERVAL HOUR TO MINUTE.


Access Rules
    None.


General Rules
1) Case:
    a) If LOCAL is specified, then the current default time zone displacement of the current SQL-session is
       set to the original time zone displacement of the current SQL-session.
    b) Otherwise,
         Case:
         i)       If the value of the <interval value expression> is not the null value and is between INTERVAL
                  –'12:59' and INTERVAL +'14:00', then the current default time zone displacement of the current
                  SQL-session is set to the value of the <interval value expression>.
         ii)      Otherwise, an exception condition is raised: data exception — invalid time zone displacement
                  value.


Conformance Rules
1) Without Feature F411, “Time zone specification”, conforming SQL language shall not contain a <set local
   time zone statement>.




©ISO/IEC 2003 – All rights reserved                                                   Session management 913
ISO/IEC 9075-2:2003 (E)
18.5 <set catalog statement>



18.5 <set catalog statement>

Function
Set the default catalog name for unqualified <schema name>s in <preparable statement>s that are prepared in
the current SQL-session by an <execute immediate statement> or a <prepare statement> and in <direct SQL
statement>s that are invoked directly.


Format
<set catalog statement> ::= SET <catalog name characteristic>

<catalog name characteristic> ::= CATALOG <value specification>


Syntax Rules
1) The declared type of the <value specification> shall be a character string type.


Access Rules
    None.


General Rules
1) Let S be <value specification> and let V be the character string that is the value of
      TRIM ( BOTH ' ' FROM S )

2) If V does not conform to the Format and Syntax Rules of a <catalog name>, then an exception condition
   is raised: invalid catalog name.
3) The default catalog name of the current SQL-session is set to V.


Conformance Rules
1) Without Feature F651, “Catalog name qualifiers”, conforming SQL language shall not contain a <set catalog
   statement>.
2) Without Feature F761, “Session management”, conforming SQL language shall not contain a <set catalog
   statement>.




914 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                  18.6 <set schema statement>



18.6 <set schema statement>

Function
Set the default schema name for unqualified <schema qualified name>s in <preparable statement>s that are
prepared in the current SQL-session by an <execute immediate statement> or a <prepare statement> and in
<direct SQL statement>s that are invoked directly.


Format
<set schema statement> ::= SET <schema name characteristic>

<schema name characteristic> ::= SCHEMA <value specification>


Syntax Rules
1) The declared type of the <value specification> shall be a character string type.


Access Rules
    None.


General Rules
1) Let S be <value specification> and let V be the character string that is the value of
        TRIM ( BOTH ' ' FROM S )

2) If V does not conform to the Format and Syntax Rules of a <schema name>, then an exception condition
   is raised: invalid schema name.
3) Case:
    a) If V conforms to the Format and Syntax Rules for a <schema name> that contains a <catalog name>,
       then let X be the <catalog name> part and let Y be the <unqualified schema name> part of V. The fol-
       lowing statement is implicitly executed:
             SET CATALOG 'X'
         and the <set schema statement> is effectively replaced by:
             SET SCHEMA 'Y'

    b) Otherwise, the default unqualified schema name of the current SQL-session is set to V.




©ISO/IEC 2003 – All rights reserved                                                   Session management 915
ISO/IEC 9075-2:2003 (E)
18.6 <set schema statement>



Conformance Rules
1) Without Feature F761, “Session management”, conforming SQL language shall not contain a <set schema
   statement>.




916 Foundation (SQL/Foundation)                                           ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                   18.7 <set names statement>



18.7 <set names statement>

Function
Set the default character set name for <character string literal>s in <preparable statement>s that are prepared
in the current SQL-session by an <execute immediate statement> or a <prepare statement> and in <direct SQL
statement>s that are invoked directly.


Format
<set names statement> ::= SET <character set name characteristic>

<character set name characteristic> ::= NAMES <value specification>


Syntax Rules
1) The declared type of the <value specification> shall be a character string type.


Access Rules
    None.


General Rules
1) Let S be <value specification> and let V be the character string that is the value of
        TRIM ( BOTH ' ' FROM S )

2) If V does not conform to the Format and Syntax Rules of a <character set name>, then an exception condition
   is raised: invalid character set name.
3) The default character set name of the current SQL-session is set to V.


Conformance Rules
1) Without and Feature F461, “Named character sets”, conforming SQL language shall not contain a <set
   names statement>.
2) Without Feature F761, “Session management”, conforming SQL language shall not contain a <set names
   statement>.




©ISO/IEC 2003 – All rights reserved                                                   Session management 917
ISO/IEC 9075-2:2003 (E)
18.8 <set path statement>



18.8 <set path statement>

Function
Set the SQL-path used to determine the subject routine of <routine invocation>s with unqualified <routine
name>s in <preparable statement>s that are prepared in the current SQL-session by an <execute immediate
statement> or a <prepare statement> and in <direct SQL statement>s, respectively, that are invoked directly.
The SQL-path remains the current SQL-path of the SQL-session until another SQL-path is successfully set.


Format
<set path statement> ::= SET <SQL-path characteristic>

<SQL-path characteristic> ::= PATH <value specification>


Syntax Rules
1) The declared type of the <value specification> shall be a character string type.


Access Rules
    None.


General Rules
1) Let S be <value specification> and let V be the character string that is the value of
       TRIM ( BOTH ' ' FROM S )
    a) If V does not conform to the Format and Syntax Rules of a <schema name list>, then an exception
       condition is raised: invalid schema name list specification.
    b) The SQL-path of the current SQL-session is set to V.
    NOTE 423 — A <set path statement> that is executed between a <prepare statement> and an <execute statement> has no effect
    on the prepared statement.


Conformance Rules
1) Without Feature S071, “SQL paths in function and type name resolution”, Conforming SQL language shall
   not contain a <set path statement>.




918 Foundation (SQL/Foundation)                                                             ©ISO/IEC 2003 – All rights reserved
                                                                                                ISO/IEC 9075-2:2003 (E)
                                                                                   18.9 <set transform group statement>



18.9 <set transform group statement>

Function
Set the group name that identifies the group of transform functions for mapping values of user-defined types
to predefined data types.


Format
<set transform group statement> ::= SET <transform group characteristic>

<transform group characteristic> ::=
    DEFAULT TRANSFORM GROUP <value specification>
  | TRANSFORM GROUP FOR TYPE <path-resolved user-defined type name> <value specification>


Syntax Rules
1) The declared type of the <value specification> shall be a character string type.
2) If <path-resolved user-defined type name> is specified, then let UDT be the user-defined type identified
   by that <path-resolved user-defined type name>.


Access Rules
    None.


General Rules
1) Let S be <value specification> and let V be the character string that is the value of
        TRIM ( BOTH ' ' FROM S )
    a) If V does not conform to the Format and Syntax Rules of a <group name>, then an exception condition
       is raised: invalid transform group name specification.
    b) Case:
         i)       If <path-resolved user-defined type name> is specified, then the transform group name corre-
                  sponding to all subtypes of UDT for the current SQL-session is set to V.
         ii)      Otherwise, the default transform group name for the current SQL-session is set to V.
    NOTE 424 — A <set transform group statement> that is executed after a <prepare statement> has no effect on the prepared
    statement.


Conformance Rules
1) Without Feature S241, “Transform functions”, conforming SQL language shall not contain a <set transform
   group statement>.


©ISO/IEC 2003 – All rights reserved                                                               Session management 919
ISO/IEC 9075-2:2003 (E)
18.9 <set transform group statement>



18.10 <set session collation statement>

Function
Set the SQL-session collation of the SQL-session for one or more character sets. An SQL-session collation
remains effective until another SQL-session collation for the same character set is successfully set.


Format
<set session collation statement> ::=
    SET COLLATION <collation specification> [ FOR <character set specification list> ]
  | SET NO COLLATION [ FOR <character set specification list> ]

<collation specification> ::= <value specification>


Syntax Rules
1) The declared type of the <value specification> shall be a character string type.


Access Rules
    None.


General Rules
1) Let S be <value specification> and let V be the character string that is the value of
    TRIM ( BOTH ' ' FROM S )

    a) If V does not conform to the Format and Syntax Rules of a <collation name>, then an exception condition
       is raised: invalid collation name.
    b) Let CO be the collation identified by the <collation name> contained in V.
        Case:
        i)      If <character set specification list> is specified, then
                Case:
                1) If the collation specified by CO is not applicable to any character set identified by a <char-
                   acter set specification>, then an exception condition is raised: invalid collation name.
                2) Otherwise, for each character set specified, the SQL-session collation for that character set
                   in the current SQL-session is set to CO.
        ii)     Otherwise, the character sets for which the SQL-session collations are set to CO are implemen-
                tation-defined.
2) If SET NO COLLATION is specified, then



920 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                          18.10 <set session collation statement>



    Case:
    a) If <character set specification list> is specified, then, for each character set specified, the SQL-session
       collation for that character set in the current SQL-session is set to none.
    b) Otherwise, the SQL-session collation for every character set in the current SQL-session is set to none.


Conformance Rules
1) Without Feature F693, “SQL-session and client module collations”, conforming SQL language shall not
   contain a <set session collation statement>.




©ISO/IEC 2003 – All rights reserved                                                    Session management 921
ISO/IEC 9075-2:2003 (E)




                                  This page intentionally left blank.




922 Foundation (SQL/Foundation)                                         ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                     19.1 Description of SQL descriptor areas




19 Dynamic SQL


19.1 Description of SQL descriptor areas

Function
Specify the identifiers, data types, and codes used in SQL item descriptor areas.


Syntax Rules
1) An SQL item descriptor area comprises the items specified in Table 24, “Data types of <key word>s used
   in SQL item descriptor areas”.
2) An SQL descriptor area comprises the items specified in Table 23, “Data types of <key word>s used in the
   header of SQL descriptor areas”, and one or more occurrences of an SQL item descriptor area.
3) Given an SQL item descriptor area IDA in which the value of LEVEL is N, the immediately subordinate
   descriptor areas of IDA are those SQL item descriptor areas in which the value of LEVEL is N+1 and
   whose position in the SQL descriptor area follows that of IDA and precedes that of any SQL item descriptor
   area in which the value of LEVEL is less than N+1.
    The subordinate descriptor areas of IDA are those SQL item descriptor areas that are immediately subor-
    dinate descriptor areas of IDA or that are subordinate descriptor areas of an SQL item descriptor area that
    is immediately subordinate to IDA.
4) Given a data type DT and its descriptor DE, the immediately subordinate descriptors of DE are defined to
   be:
    Case:
    a) If DT is a row type, then the field descriptors of the fields of DT. The i-th immediately subordinate
       descriptor is the descriptor of the i-th field of DT.
    b) If DT is a collection type, then the descriptor of the associated element type of DT.
    The subordinate descriptors of DE are those descriptors that are immediately subordinate descriptors of
    DE or that are subordinate descriptors of a descriptor that is immediately subordinate to DE.
5) Given a descriptor DE, let SDEj represent its j-th immediately subordinate descriptor. There is an implied
   ordering of the subordinate descriptors of DE, such that:
    a) SDE1 is in the first ordinal position.

    b) The ordinal position of SDEj+1 is K+NS+1, where K is the ordinal position of SDEj and NS is the
       number of subordinate descriptors of SDEj. The implicitly ordered subordinate descriptors of SDEj
       occupy contiguous ordinal positions starting at position K+1.



©ISO/IEC 2003 – All rights reserved                                                        Dynamic SQL 923
ISO/IEC 9075-2:2003 (E)
19.1 Description of SQL descriptor areas



6) An item descriptor area IDA is valid if and only if TYPE indicates a code defined in Table 25, “Codes used
   for SQL data types in Dynamic SQL”, and one of the following is true:
    Case:
    a) TYPE indicates CHARACTER, CHARACTER VARYING, or CHARACTER LARGE OBJECT,
       LENGTH is a valid length value for TYPE, and CHARACTER_SET_CATALOG, CHARAC-
       TER_SET_SCHEMA, and CHARACTER_SET_NAME are the fully qualified name of a character
       set that is valid for TYPE.
    b) TYPE indicates CHARACTER LARGE OBJECT LOCATOR.
    c) TYPE indicates BINARY LARGE OBJECT and LENGTH is a valid length value for the BINARY
       LARGE OBJECT data type.
    d) TYPE indicates BINARY LARGE OBJECT LOCATOR.
    e) TYPE indicates NUMERIC and PRECISION and SCALE are valid precision and scale values for the
       NUMERIC data type.
    f) TYPE indicates DECIMAL and PRECISION and SCALE are valid precision and scale values for the
       DECIMAL data type.
    g) TYPE indicates SMALLINT, INTEGER, BIGINT, REAL, or DOUBLE PRECISION.
    h) TYPE indicates FLOAT and PRECISION is a valid precision value for the FLOAT data type.
    i)   TYPE indicates BOOLEAN.
    j)   TYPE indicates a <datetime type>, DATETIME_INTERVAL_CODE is a code specified in Table 26,
         “Codes associated with datetime data types in Dynamic SQL”, and PRECISION is a valid value for
         the <time precision> or <timestamp precision> of the indicated datetime data type.
    k) TYPE indicates an <interval type>, DATETIME_INTERVAL_CODE is a code specified in Table 27,
       “Codes used for <interval qualifier>s in Dynamic SQL”, and DATETIME_INTERVAL_PRECISION
       and PRECISION are valid values for <interval leading field precision> and <interval fractional seconds
       precision> for an <interval qualifier>.
    l)   TYPE indicates USER-DEFINED TYPE LOCATOR and USER_DEFINED_TYPE_CATALOG,
         USER_DEFINED_TYPE_SCHEMA, and USER_DEFINED_TYPE_NAME are the fully qualified
         name of a valid user-defined type.
    m) TYPE indicates REF, LENGTH is the length in octets for the REF type, and
       USER_DEFINED_TYPE_CATALOG, USER_DEFINED_TYPE_SCHEMA, and
       USER_DEFINED_TYPE_NAME are a valid qualified user-defined type name, and SCOPE_CATALOG,
       SCOPE_SCHEMA, and SCOPE_NAME are a valid qualified table name.
    n) TYPE indicates ROW, the value N of DEGREE is a valid value for the degree of a row type, there are
       exactly N immediately subordinate descriptor areas of IDA and those SQL item descriptor areas are
       valid.
    o) TYPE indicates ARRAY or ARRAY LOCATOR, the value of CARDINALITY is a valid value for
       the cardinality of an array, there is exactly one immediately subordinate descriptor area of IDA, and
       that SQL item descriptor area is valid.



924 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                        19.1 Description of SQL descriptor areas



    p) TYPE indicates MULTISET or MULTISET LOCATOR, there is exactly one immediately subordinate
       descriptor area of IDA, and that SQL item descriptor area is valid.
    q) TYPE indicates an implementation-defined data type.
7) The declared type T of a <simple value specification> or a <simple target specification> SVT is said to
   match the data type specified by a valid item descriptor area IDA if and only if one of the following conditions
   is true.
    Case:
    a) TYPE indicates CHARACTER and T is specified by CHARACTER(L), where L is the value of
       LENGTH and the <character set specification> formed by the values of CHARACTER_SET_CATA-
       LOG, CHARACTER_SET_SCHEMA, and CHARACTER_SET_NAME identifies the character set
       of SVT.
    b) Either TYPE indicates CHARACTER VARYING and T is specified by CHARACTER VARYING(L)
       or type indicates CHARACTER LARGE OBJECT and T is specified by CHARACTER LARGE
       OBJECT(L), where the <character set specification> formed by the values of CHARACTER_SET_CAT-
       ALOG, CHARACTER_SET_SCHEMA, and CHARACTER_SET_NAME identifies the character set
       of SVT and
         Case:
         i)       SVT is a <simple value specification> and L is the value of LENGTH.
         ii)      SVT is a <simple target specification> and L is not less than the value of LENGTH.
    c) TYPE indicates CHARACTER LARGE OBJECT LOCATOR and T is specified by CHARACTER
       LARGE OBJECT LOCATOR.
    d) TYPE indicates BINARY LARGE OBJECT and T is specified by BINARY LARGE OBJECT(L) and
         Case:
         i)       STV is a <simple value specification> and L is the value of LENGTH.
         ii)      STV is a <simple target specification> and L is not less than the value of LENGTH.
    e) TYPE indicates BINARY LARGE OBJECT LOCATOR and T is specified by BINARY LARGE
       OBJECT LOCATOR.
    f) TYPE indicates NUMERIC and T is specified by NUMERIC(P,S), where P is the value of PRECISION
       and S is the value of SCALE.
    g) TYPE indicates DECIMAL and T is specified by DECIMAL(P,S), where P is the value of PRECISION
       and S is the value of SCALE.
    h) TYPE indicates SMALLINT and T is specified by SMALLINT.
    i)   TYPE indicates INTEGER and T is specified by INTEGER.
    j)   TYPE indicates BIGINT and T is specified by BIGINT.
    k) TYPE indicates FLOAT and T is specified by FLOAT(P), where P is the value of PRECISION.
    l)   TYPE indicates REAL and T is specified by REAL.


©ISO/IEC 2003 – All rights reserved                                                            Dynamic SQL 925
ISO/IEC 9075-2:2003 (E)
19.1 Description of SQL descriptor areas



    m) TYPE indicates DOUBLE PRECISION and T is specified by DOUBLE PRECISION.
    n) TYPE indicates BOOLEAN and T is specified by BOOLEAN.
    o) TYPE indicates USER-DEFINED TYPE and T is specified by USER-DEFINED TYPE LOCATOR,
       where the values of USER_DEFINED_TYPE_CATALOG, USER_DEFINED_TYPE_SCHEMA, and
       USER_DEFINED_TYPE_NAME are the fully qualified name of the associated user-defined type of
       SVT.
    p) TYPE indicates REF and T is specified by REF, where the <user-defined type name> formed by the
       values of USER_DEFINED_TYPE_CATALOG, USER_DEFINED_TYPE_SCHEMA, and
       USER_DEFINED_TYPE_NAME identifies the row type of SVT, and SCOPE_CATALOG,
       SCOPE_SCHEMA, and SCOPE_NAME identify the scope of the reference type.
    q) TYPE indicates ROW, and T is a row type with degree D, where D is the value of DEGREE, and the
       data type of the i-th field of SVT matches the data type specified by the i-th immediately subordinate
       descriptor area of IDA.
    r) TYPE indicates ARRAY and T is an array type with maximum cardinality C and the data type of the
       element type of T matches the immediately subordinate descriptor area of IDA, and
         Case:
         i)      SVT is a <simple value specification> and C is the value of CARDINALITY.
         ii)     SVT is a <simple target specification> and C is not less than the value of CARDINALITY.
    s) TYPE indicates ARRAY LOCATOR and T is an array locator type whose associated array type has
       maximum cardinality C and the data type of the element type of the associated array type of T matches
       the immediately subordinate descriptor area of IDA, and
         Case:
         i)      SVT is a <simple value specification> and C is the value of CARDINALITY.
         ii)     SVT is a <simple target specification> and C is not less than the value of CARDINALITY.
    t)   TYPE indicates MULTISET and T is a multiset type and the data type of the element type of T matches
         the immediately subordinate descriptor area of IDA.
    u) TYPE indicates MULTISET LOCATOR and T is a multiset locator type and the data type of the element
       type of T matches the immediately subordinate descriptor area of IDA.
    v) TYPE indicates a data type from Table 25, “Codes used for SQL data types in Dynamic SQL”, other
       than an implementation-defined data type and T satisfies the implementation-defined rules for matching
       that data type.
    w) TYPE indicates an implementation-defined data type and T satisfies the implementation-defined rules
       for matching that data type.
8) A data type DT is said to be represented by an SQL item descriptor area if a <simple value specification>
   of type DT matches the SQL item descriptor area.




926 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                     19.1 Description of SQL descriptor areas




                    Table 23 — Data types of <key word>s used in the header of SQL descriptor areas


      <key word>                               Data Type

      COUNT                                    exact numeric with scale 0 (zero)

      DYNAMIC_FUNCTION                         character string with character set SQL_IDENTIFIER and length
                                               not less than 128 characters

      DYNAMIC_FUNCTION_CODE                    exact numeric with scale 0 (zero)

      KEY_TYPE                                 exact numeric with scale 0 (zero)

      TOP_LEVEL_COUNT                          exact numeric with scale 0 (zero)


                          Table 24 — Data types of <key word>s used in SQL item descriptor areas


      <key word>                               Data Type

      CARDINALITY                              exact numeric with scale 0 (zero)

      CHARACTER_SET_CATALOG                    character string with character set SQL_IDENTIFIER and length
                                               not less than 128 characters

      CHARACTER_SET_NAME                       character string with character set SQL_IDENTIFIER and length
                                               not less than 128 characters

      CHARACTER_SET_SCHEMA                     character string with character set SQL_IDENTIFIER and length
                                               not less than 128 characters

      COLLATION_CATALOG                        character string with character set SQL_IDENTIFIER and length
                                               not less than 128 characters

      COLLATION_NAME                           character string with character set SQL_IDENTIFIER and length
                                               not less than 128 characters

      COLLATION_SCHEMA                         character string with character set SQL_IDENTIFIER and length
                                               not less than 128 characters

      DATA                                     matches the data type represented by the SQL item descriptor
                                               area

      DATETIME_INTERVAL_CODE                   exact numeric with scale 0 (zero)

      DATETIME_INTERVAL_PRECI-                 exact numeric with scale 0 (zero)
      SION



©ISO/IEC 2003 – All rights reserved                                                       Dynamic SQL 927
ISO/IEC 9075-2:2003 (E)
19.1 Description of SQL descriptor areas



     <key word>                            Data Type

     DEGREE                                exact numeric with scale 0 (zero)

     INDICATOR                             exact numeric with scale 0 (zero)

     KEY_MEMBER                            exact numeric with scale 0 (zero)

     LENGTH                                exact numeric with scale 0 (zero)

     LEVEL                                 exact numeric with scale 0 (zero)

     NAME                                  character string with character set SQL_IDENTIFIER and length
                                           not less than 128 characters

     NULLABLE                              exact numeric with scale 0 (zero)

     OCTET_LENGTH                          exact numeric with scale 0 (zero)

     PARAMETER_MODE                        exact numeric with scale 0 (zero)

     PARAMETER_ORDINAL_POSITION exact numeric with scale 0 (zero)

     PARAMETER_SPECIFIC_CATALOG character string with character set SQL_IDENTIFIER and length
                                not less than 128 characters

     PARAMETER_SPECIFIC_NAME               character string with character set SQL_IDENTIFIER and length
                                           not less than 128 characters

     PARAMETER_SPECIFIC_SCHEMA character string with character set SQL_IDENTIFIER and length
                               not less than 128 characters

     PRECISION                             exact numeric with scale 0 (zero)

     RETURNED_CARDINALITY                  exact numeric with scale 0 (zero)

     RETURNED_LENGTH                       exact numeric with scale 0 (zero)

     RETURNED_OCTET_LENGTH                 exact numeric with scale 0 (zero)

     SCALE                                 exact numeric with scale 0 (zero)

     SCOPE_CATALOG                         character string with character set SQL_IDENTIFIER and length
                                           not less than 128 characters

     SCOPE_NAME                            character string with character set SQL_IDENTIFIER and length
                                           not less than 128 characters

     SCOPE_SCHEMA                          character string with character set SQL_IDENTIFIER and length
                                           not less than 128 characters



928 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                               ISO/IEC 9075-2:2003 (E)
                                                                                19.1 Description of SQL descriptor areas



      <key word>                                     Data Type

      TYPE                                           exact numeric with scale 0 (zero)

      UNNAMED                                        exact numeric with scale 0 (zero)

      USER_DEFINED_TYPE_CATALOG character string with character set SQL_IDENTIFIER and length
                                not less than 128 characters

      USER_DEFINED_TYPE_NAME                         character string with character set SQL_IDENTIFIER and length
                                                     not less than 128 characters

      USER_DEFINED_TYPE_SCHEMA                       character string with character set SQL_IDENTIFIER and length
                                                     not less than 128 characters

      USER_DEFINED_TYPE_CODE                         exact numeric with scale 0 (zero)

    NOTE 425 — “Matches” and “represented by”, as applied to the relationship between a data type and an SQL item descriptor area
    are defined in the Syntax Rules of this Subclause.


Access Rules
    None.


General Rules
1) Table 25, “Codes used for SQL data types in Dynamic SQL”, specifies the codes associated with the SQL
   data types.

                                  Table 25 — Codes used for SQL data types in Dynamic SQL


      Data Type                                            Code

      Implementation-defined data types                    < 0 (zero)

      ARRAY                                                50

      ARRAY LOCATOR                                        51

      BIGINT                                               25

      BLOB                                                 30

      BLOB LOCATOR                                         31

      BOOLEAN                                              16




©ISO/IEC 2003 – All rights reserved                                                                       Dynamic SQL 929
ISO/IEC 9075-2:2003 (E)
19.1 Description of SQL descriptor areas



     Data Type                                   Code

     CHARACTER                                   1 (one)

     CHARACTER VARYING                           12

     CLOB                                        40

     CLOB LOCATOR                                41

     DATE, TIME WITHOUT TIME ZONE,   9
     TIME WITH TIME ZONE, TIMESTAMP
     WITHOUT TIME ZONE, or TIMESTAMP
     WITH TIME ZONE

     DECIMAL                                     3

     DOUBLE PRECISION                            8

     FLOAT                                       6

     INTEGER                                     4

     INTERVAL                                    10

     MULTISET                                    55

     MULTISET LOCATOR                            56

     NUMERIC                                     2

     REAL                                        7

     SMALLINT                                    5

     USER-DEFINED TYPE LOCATOR                   18

     ROW TYPE                                    19

     REF                                         20

     User-defined types                          17

2) Table 26, “Codes associated with datetime data types in Dynamic SQL”, specifies the codes associated
   with the datetime data types.




930 Foundation (SQL/Foundation)                                              ©ISO/IEC 2003 – All rights reserved
                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                    19.1 Description of SQL descriptor areas




                           Table 26 — Codes associated with datetime data types in Dynamic SQL


      Datetime Data Type                             Code

      DATE                                           1 (one)

      TIME WITH TIME ZONE                            4

      TIME WITHOUT TIME ZONE                         2

      TIMESTAMP WITH TIME ZONE                       5

      TIMESTAMP WITHOUT TIME ZONE                    3

3) Table 27, “Codes used for <interval qualifier>s in Dynamic SQL”, specifies the codes associated with
   <interval qualifier>s for interval data types.

                               Table 27 — Codes used for <interval qualifier>s in Dynamic SQL


      Datetime Qualifier                             Code

      DAY                                            3

      DAY TO HOUR                                    8

      DAY TO MINUTE                                  9

      DAY TO SECOND                                  10

      HOUR                                           4

      HOUR TO MINUTE                                 11

      HOUR TO SECOND                                 12

      MINUTE                                         5

      MINUTE TO SECOND                               13

      MONTH                                          2

      SECOND                                         6

      YEAR                                           1 (one)

      YEAR TO MONTH                                  7




©ISO/IEC 2003 – All rights reserved                                                      Dynamic SQL 931
ISO/IEC 9075-2:2003 (E)
19.1 Description of SQL descriptor areas



4) The value of DYNAMIC_FUNCTION is a character string that identifies the type of the prepared or executed
   SQL-statement. Table 31, “SQL-statement codes”, specifies the identifier of the SQL-statements.
5) The value of DYNAMIC_FUNCTION_CODE is a number that identifies the type of the prepared or executed
   SQL-statement. Table 31, “SQL-statement codes”, specifies the identifier of the SQL-statements.
6) Table 28, “Codes used for input/output SQL parameter modes in Dynamic SQL”, specifies the codes used
   for the PARAMETER_MODE item descriptor field when describing a <call statement>.

                 Table 28 — Codes used for input/output SQL parameter modes in Dynamic SQL


     Parameter mode                              Code

     PARAMETER_MODE_IN                           1 (one)

     PARAMETER_MODE_INOUT                        2

     PARAMETER_MODE_OUT                          4

7) Table 29, “Codes associated with user-defined types in Dynamic SQL”, specifies the codes associated with
   user-defined types.

                      Table 29 — Codes associated with user-defined types in Dynamic SQL


     User-Defined Type            Code

     DISTINCT                     1 (one)

     STRUCTURED                   2



Conformance Rules
    None.




932 Foundation (SQL/Foundation)                                               ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                         19.2 <allocate descriptor statement>



19.2 <allocate descriptor statement>

Function
Allocate an SQL descriptor area.


Format
<allocate descriptor statement> ::=
    ALLOCATE [ SQL ] DESCRIPTOR <descriptor name> [ WITH MAX <occurrences> ]

<occurrences> ::= <simple value specification>


Syntax Rules
1) The declared type of <occurrences> shall be exact numeric with scale 0 (zero).
2) If WITH MAX <occurrences> is not specified, then an implementation-defined default value for <occur-
   rences> that is greater than 0 (zero) is implicit.


Access Rules
    None.


General Rules
1) Let S be the <simple value specification> that is immediately contained in <descriptor name> and let V be
   the character string that is the result of
        TRIM ( BOTH ' ' FROM S )
    If V does not conform to the Format and Syntax Rules of an <identifier>, then an exception condition is
    raised: invalid SQL descriptor name.
2) Case:
    a) If an SQL descriptor area whose name is V and whose scope is specified by the <scope option>
       immediately contained in a <descriptor name> is currently allocated, then an exception condition is
       raised: invalid SQL descriptor name.
    b) Otherwise, the <allocate descriptor statement> allocates an SQL descriptor area whose name is V and
       whose scope is specified by the <scope option> immediately contained in a <descriptor name>. The
       SQL descriptor area will have at least <occurrences> number of SQL item descriptor areas. The value
       of LEVEL in each of the item descriptor areas is set to 0 (zero). The values of all other fields in the
       SQL descriptor area are initially undefined.
3) If <occurrences> is less than 1 (one) or is greater than an implementation-defined maximum value, then
   an exception condition is raised: dynamic SQL error — invalid descriptor index. The maximum number
   of SQL descriptor areas that can be allocated at one time is implementation-defined.


©ISO/IEC 2003 – All rights reserved                                                       Dynamic SQL 933
ISO/IEC 9075-2:2003 (E)
19.2 <allocate descriptor statement>



Conformance Rules
1) Without Feature B032, “Extended dynamic SQL”, conforming SQL language shall not contain an
   <occurrences> that is not a <literal>.
2) Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain an <allocate
   descriptor statement>.




934 Foundation (SQL/Foundation)                                           ©ISO/IEC 2003 – All rights reserved
                                                                                  ISO/IEC 9075-2:2003 (E)
                                                                     19.3 <deallocate descriptor statement>



19.3 <deallocate descriptor statement>

Function
Deallocate an SQL descriptor area.


Format
<deallocate descriptor statement> ::=
    DEALLOCATE [ SQL ] DESCRIPTOR <descriptor name>


Syntax Rules
    None.


Access Rules
    None.


General Rules
1) Case:
    a) If an SQL descriptor area is not currently allocated whose name is the value of the <simple value
       specification> immediately contained in <descriptor name> and whose scope is specified by the <scope
       option> immediately contained in <descriptor name>, then an exception condition is raised: invalid
       SQL descriptor name.
    b) Otherwise, the <deallocate descriptor statement> deallocates an SQL descriptor area whose name is
       the value of the <simple value specification> immediately contained in <descriptor name> and whose
       scope is specified by the <scope option> immediately contained in <descriptor name>.


Conformance Rules
1) Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain a <deallocate
   descriptor statement>.




©ISO/IEC 2003 – All rights reserved                                                     Dynamic SQL 935
ISO/IEC 9075-2:2003 (E)
19.4 <get descriptor statement>



19.4 <get descriptor statement>

Function
Get information from an SQL descriptor area.


Format
<get descriptor statement> ::=
    GET [ SQL ] DESCRIPTOR <descriptor name> <get descriptor information>

<get descriptor    information> ::=
    <get header    information> [ { <comma> <get header information> }... ]
  | VALUE <item    number> <get item information>
    [ { <comma>    <get item information> }... ]

<get header information> ::=
    <simple target specification 1> <equals operator> <header item name>

<header item name> ::=
    COUNT
  | KEY_TYPE
  | DYNAMIC_FUNCTION
  | DYNAMIC_FUNCTION_CODE
  | TOP_LEVEL_COUNT

<get item information> ::=
    <simple target specification 2> <equals operator> <descriptor item name>

<item number> ::= <simple value specification>

<simple target specification 1> ::= <simple target specification>

<simple target specification 2> ::= <simple target specification>

<descriptor item name> ::=
    CARDINALITY
  | CHARACTER_SET_CATALOG
  | CHARACTER_SET_NAME
  | CHARACTER_SET_SCHEMA
  | COLLATION_CATALOG
  | COLLATION_NAME
  | COLLATION_SCHEMA
  | DATA
  | DATETIME_INTERVAL_CODE
  | DATETIME_INTERVAL_PRECISION
  | DEGREE
  | INDICATOR
  | KEY_MEMBER
  | LENGTH
  | LEVEL
  | NAME
  | NULLABLE
  | OCTET_LENGTH



936 Foundation (SQL/Foundation)                                     ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                              19.4 <get descriptor statement>



  |   PARAMETER_MODE
  |   PARAMETER_ORDINAL_POSITION
  |   PARAMETER_SPECIFIC_CATALOG
  |   PARAMETER_SPECIFIC_NAME
  |   PARAMETER_SPECIFIC_SCHEMA
  |   PRECISION
  |   RETURNED_CARDINALITY
  |   RETURNED_LENGTH
  |   RETURNED_OCTET_LENGTH
  |   SCALE
  |   SCOPE_CATALOG
  |   SCOPE_NAME
  |   SCOPE_SCHEMA
  |   TYPE
  |   UNNAMED
  |   USER_DEFINED_TYPE_CATALOG
  |   USER_DEFINED_TYPE_NAME
  |   USER_DEFINED_TYPE_SCHEMA
  |   USER_DEFINED_TYPE_CODE


Syntax Rules
1) The declared type of <item number> shall be exact numeric with scale 0 (zero).
2) For each <get header information>, the declared type of <simple target specification 1> shall be that shown
   in the Data Type column of the row in Table 23, “Data types of <key word>s used in the header of SQL
   descriptor areas”, whose <key word> column value is equivalent to <header item name>.
3) For each <get item information>, the declared type of <simple target specification 2> shall be that shown
   in the Data Type column of the row in Table 24, “Data types of <key word>s used in SQL item descriptor
   areas”, whose <key word> column value is equivalent to <descriptor item name>.


Access Rules
      None.


General Rules
1) If <descriptor name> identifies an SQL descriptor area that is not currently allocated whose name is the
   value of the <simple value specification> immediately contained in <descriptor name> and whose scope
   is specified by the <scope option> immediately contained in <descriptor name>, then an exception condition
   is raised: invalid SQL descriptor name.
2) If the <item number> specified in a <get descriptor statement> is greater than the value of <occurrences>
   specified when the <descriptor name> was allocated or less than 1 (one), then an exception condition is
   raised: dynamic SQL error — invalid descriptor index.
3) If the <item number> specified in a <get descriptor statement> is greater than the value of COUNT, then
   a completion condition is raised: no data.




©ISO/IEC 2003 – All rights reserved                                                       Dynamic SQL 937
ISO/IEC 9075-2:2003 (E)
19.4 <get descriptor statement>



4) If the declared type of the <simple target specification> associated with the keyword DATA does not match
   the data type represented by the item descriptor area, then an exception condition is raised: data exception
   — error in assignment.
    NOTE 426 — “Match” and “represented by” are defined in the Syntax Rules of Subclause 19.1, “Description of SQL descriptor
    areas”.

5) Let i be the value of the <item number> contained in <get descriptor information>. Let IDA be the i-th item
   descriptor area. If a <get item information> specifies DATA, then:
    a) If IDA is subordinate to an item descriptor area whose TYPE field indicates ARRAY, ARRAY
       LOCATOR, MULTISET, or MULTISET LOCATOR, then an exception condition is raised: dynamic
       SQL error — undefined DATA value.
    b) If the value of TYPE in IDA indicates ROW, then an exception condition is raised: dynamic SQL error
       — undefined DATA value.
    c) If the value of INDICATOR is negative and no <get item information> specifies INDICATOR, then
       an exception condition is raised: data exception — null value, no indicator parameter.
6) If an exception condition is raised in a <get descriptor statement>, then the values of all targets specified
   by <simple target specification 1> and <simple target specification 2> are implementation-dependent.
7) A <get descriptor statement> retrieves values from the SQL descriptor area and item specified by
   <descriptor name>. For each item, the value that is retrieved is the one established by the most recently
   executed <allocate descriptor statement>, <set descriptor statement>, or <describe statement> that references
   the specified SQL descriptor area and item. The value retrieved by a <get descriptor statement> for any
   field whose value is undefined is implementation-dependent.
    Case:
    a) If <get descriptor information> contains one or more <get header information>s, then for each <get
       header information> specified, the value of <simple target specification 1> is set to the value V in the
       SQL descriptor area of the field identified by the <header item name> by applying the General Rules
       of Subclause 9.2, “Store assignment”, to <simple target specification 1> and V as TARGET and VALUE,
       respectively.
    b) If <get descriptor information> contains one or more <get item information>s, then:
        i)      Let i be the value of the <item number> contained in the <get descriptor information>.
        ii)     For each <get item information> specified, the value of <simple target specification 2> is set to
                the value V in the i-th SQL item descriptor area of the field identified by the <descriptor item
                name> by applying the General Rules of Subclause 9.2, “Store assignment”, to <simple target
                specification 2> and V as TARGET and VALUE, respectively.


Conformance Rules
1) Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain a <get
   descriptor statement>.
2) Without Feature T301, “Functional dependencies”, conforming SQL language shall not contain a
   <descriptor item name> that contains KEY_MEMBER.



938 Foundation (SQL/Foundation)                                                            ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                              19.5 <set descriptor statement>



19.5 <set descriptor statement>

Function
Set information in an SQL descriptor area.


Format
<set descriptor statement> ::=
    SET [ SQL ] DESCRIPTOR <descriptor name> <set descriptor information>

<set descriptor        information> ::=
    <set header        information> [ { <comma> <set header information> }... ]
  | VALUE <item        number> <set item information>
    [ { <comma>        <set item information> }... ]

<set header information> ::=
    <header item name> <equals operator> <simple value specification 1>

<set item information> ::=
    <descriptor item name> <equals operator> <simple value specification 2>

<simple value specification 1> ::= <simple value specification>

<simple value specification 2> ::= <simple value specification>


Syntax Rules
1) For each <set header information>, <header item name> shall not be KEY_TYPE, TOP_LEVEL_COUNT,
   DYNAMIC_FUNCTION, or DYNAMIC_FUNCTION_CODE, and the declared type of <simple value
   specification 1> shall be that in the Data Type column of the row of Table 23, “Data types of <key word>s
   used in the header of SQL descriptor areas”, whose <key word> column value is equivalent to <header
   item name>.
2) For each <set item information>, the value of <descriptor item name> shall not be RETURNED_LENGTH,
   RETURNED_OCTET_LENGTH, RETURNED_CARDINALITY, OCTET_LENGTH, NULLABLE,
   KEY_MEMBER, COLLATION_CATALOG, COLLATION_SCHEMA, COLLATION_NAME, NAME,
   UNNAMED, PARAMETER_MODE, PARAMETER_ORDINAL_POSITION, PARAMETER_SPE-
   CIFIC_CATALOG, PARAMETER_SPECIFIC_SCHEMA, PARAMETER_SPECIFIC_NAME, or
   USER_DEFINED_TYPE_CODE. Other alternatives for <descriptor item name> shall not be specified
   more than once in a <set descriptor statement>. The declared type of <simple value specification 2> shall
   be that shown in the Data Type column of the row in Table 24, “Data types of <key word>s used in SQL
   item descriptor areas”, whose <key word> column value is equivalent to <descriptor item name>.
3) If the <descriptor item name> specifies DATA, then <simple value specification 2> shall not be a <literal>.


Access Rules
    None.



©ISO/IEC 2003 – All rights reserved                                                       Dynamic SQL 939
ISO/IEC 9075-2:2003 (E)
19.5 <set descriptor statement>



General Rules
1) If <descriptor name> identifies an SQL descriptor area that is not currently allocated whose name is the
   value of the <simple value specification> immediately contained in <descriptor name> and whose scope
   is specified by the <scope option> immediately contained in <descriptor name>, then an exception condition
   is raised: invalid SQL descriptor name.
2) If the <item number> specified in a <set descriptor statement> is greater than the value of <occurrences>
   specified when the <descriptor name> was allocated or less than 1 (one), then an exception condition is
   raised: dynamic SQL error — invalid descriptor index.
3) When more than one value is set in a single <set descriptor statement>, the values are effectively assigned
   in the following order: LEVEL, TYPE, DATETIME_INTERVAL_CODE, DATETIME_INTERVAL_PRE-
   CISION, PRECISION, SCALE, CHARACTER_SET_CATALOG, CHARACTER_SET_SCHEMA,
   CHARACTER_SET_NAME, USER_DEFINED_TYPE_CATALOG, USER_DEFINED_TYPE_SCHEMA,
   USER_DEFINED_TYPE_NAME, SCOPE_CATALOG, SCOPE_SCHEMA, SCOPE_NAME, LENGTH,
   INDICATOR, DEGREE, CARDINALITY, and DATA.
    When any value other than DATA is set, the value of DATA becomes undefined.
4) For every <set item information> specified, let DIN be the <descriptor item name>, let V be the value of
   the <simple value specification 2>, let N be the value of <item number>, and let IDA be the N-th item
   descriptor area.
    Case:
    a) If DIN is DATA, then:
        i)     If IDA is subordinate to an item descriptor area whose TYPE field indicates ARRAY, ARRAY
               LOCATOR, MULTISET, or MULTISET LOCATOR, then an exception condition is raised:
               dynamic SQL error — invalid DATA target.
        ii)    If TYPE in IDA indicates ROW, then an exception condition is raised: dynamic SQL error —
               invalid DATA target.
        iii)   If the most specific type of V does not match the data type specified by the item descriptor area,
               then an exception condition is raised: data exception — error in assignment.
               NOTE 427 — “Match” is defined in the Syntax Rules of Subclause 19.1, “Description of SQL descriptor areas”.

        iv)    The value of DATA in IDA is set to V.
    b) If DIN is LEVEL, then:
        i)     If N is 1 (one) and V is not 0 (zero), then an exception condition is raised: dynamic SQL error
               — invalid LEVEL value.
        ii)    If N is greater than 1 (one), then let PIDA be IDA's immediately preceding item descriptor area
               and let K be its LEVEL value.
               1) If V = K+1 and TYPE in PIDA does not indicate ROW, ARRAY, ARRAY LOCATOR,
                  MULTISET, MULTISET LOCATOR, then an exception condition is raised: dynamic SQL
                  error — invalid LEVEL value.




940 Foundation (SQL/Foundation)                                                           ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                  19.5 <set descriptor statement>



                  2) If V > K+1, then an exception condition is raised: dynamic SQL error — invalid LEVEL
                     value.
                  3) If V < K+1, then let OIDAi be the i-th item descriptor area to which PIDA is subordinate
                     and whose TYPE field indicates ROW, let NSi be the number of immediately subordinate
                     descriptor areas of OIDAi between OIDAi and IDA and let Di be the value of DEGREE in
                     OIDAi.

                      A) For each OIDAi whose LEVEL value is greater than V, if Di is not equal to NSi, then
                         an exception condition is raised: dynamic SQL error — invalid LEVEL value.
                      B) If K is not 0 (zero), then let OIDAj be the OIDAi whose LEVEL value is K. If there
                         exists no such OIDAj or Dj is not greater than NSj, then an exception condition is raised:
                         dynamic SQL error — invalid LEVEL value.
         iii)     The value of LEVEL in IDA is set to V.
    c) If DIN is TYPE, then:
         i)       The value of TYPE in IDA is set to V.
         ii)      The value of all fields other than TYPE and LEVEL in IDA are set to implementation-dependent
                  values.
         iii)     Case:
                  1) If V indicates CHARACTER, CHARACTER VARYING, or CHARACTER LARGE
                     OBJECT, then CHARACTER_SET_CATALOG, CHARACTER_SET_SCHEMA and
                     CHARACTER_SET_NAME in IDA are set to the values for the default character set name
                     for the SQL-session and LENGTH in IDA is set to 1 (one).
                  2) If V indicates CHARACTER LARGE OBJECT LOCATOR, then LENGTH in IDA is set
                     to 1 (one).
                  3) If V indicates BINARY LARGE OBJECT, then LENGTH in IDA is set to 1 (one).
                  4) If V indicates BINARY LARGE OBJECT LOCATOR, then LENGTH in IDA is set to 1
                     (one).
                  5) If V indicates DATETIME, then PRECISION in IDA is set to 0 (zero).
                  6) If V indicates INTERVAL, then DATETIME_INTERVAL_PRECISION in IDA is set to
                     2.
                  7) If V indicates NUMERIC or DECIMAL, then SCALE in IDA is set to 0 (zero) and PRECI-
                     SION in IDA is set to the implementation-defined default value for the precision of
                     NUMERIC or DECIMAL data types, respectively.
                  8) If V indicates FLOAT, then PRECISION in IDA is set to the implementation-defined default
                     value for the precision of the FLOAT data type.
    d) If DIN is DATETIME_INTERVAL_CODE, then
         Case:



©ISO/IEC 2003 – All rights reserved                                                            Dynamic SQL 941
ISO/IEC 9075-2:2003 (E)
19.5 <set descriptor statement>



        i)     If TYPE in IDA indicates DATETIME, then
               Case:
               1) If V indicates DATE, TIME, or TIME WITH TIME ZONE, then PRECISION in IDA is set
                  to 0 (zero) and DATETIME_INTERVAL_CODE in IDA is set to V.
               2) If V indicates TIMESTAMP or TIMESTAMP WITH TIME ZONE, then PRECISION in
                  IDA is set to 6 and DATETIME_INTERVAL_CODE in IDA is set to V.
               3) Otherwise, an exception condition is raised: dynamic SQL error — invalid DATE-
                  TIME_INTERVAL_CODE.
        ii)    If TYPE in IDA indicates INTERVAL, then
               Case:
               1) If V indicates DAY TO SECOND, HOUR TO SECOND, MINUTE TO SECOND, or
                  SECOND, then PRECISION in IDA is set to 6, DATETIME_INTERVAL_PRECISION in
                  IDA is set to 2 and DATETIME_INTERVAL_CODE in IDA is set to V.
               2) If V indicates YEAR, MONTH, DAY, HOUR, MINUTE, YEAR TO MONTH, DAY TO
                  HOUR, DAY TO MINUTE, or HOUR TO MINUTE, then PRECISION in IDA is set to 0
                  (zero), DATETIME_INTERVAL_PRECISION in IDA is set to 2 and DATETIME_INTER-
                  VAL_CODE in IDA is set to V.
               3) Otherwise, an exception condition is raised: dynamic SQL error — invalid DATE-
                  TIME_INTERVAL_CODE.
        iii)   Otherwise, an exception condition is raised: dynamic SQL error — invalid DATETIME_INTER-
               VAL_CODE.
    e) Otherwise, the value of DIN in IDA is set to V by applying the General Rules of Subclause 9.2, “Store
       assignment”, to the field of IDA identified by DIN and V as TARGET and VALUE, respectively. .
5) For each <set header information> specified, the value of the field identified by <header item name> is set
   to the value V of <simple value specification 1> by applying the General Rules of Subclause 9.2, “Store
   assignment”, to the field identified by the <header item name> and V as TARGET and VALUE, respectively.
6) If an exception condition is raised in a <set descriptor statement>, then the values of all elements of the
   item descriptor area specified in the <set descriptor statement> are implementation-dependent.
7) Restrictions on changing TYPE, LENGTH, PRECISION, SCALE, DATETIME_INTERVAL_CODE,
   DATETIME_INTERVAL_PRECISION, CHARACTER_SET_CATALOG, CHARACTER_SET_SCHEMA,
   CHARACTER_SET_NAME, USER_DEFINED_TYPE_CATALOG, USER_DEFINED_TYPE_SCHEMA,
   USER_DEFINED_TYPE_NAME, SCOPE_CATALOG, SCOPE_SCHEMA, and SCOPE_NAME values
   resulting from the execution of a <describe statement> before execution of an <execute statement>, <dynamic
   open statement>, or <dynamic fetch statement> are implementation-defined.


Conformance Rules
1) Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain a <set descriptor
   statement>.



942 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                  ISO/IEC 9075-2:2003 (E)
                                                                                 19.6 <prepare statement>



19.6 <prepare statement>

Function
Prepare a statement for execution.


Format
<prepare statement> ::=
    PREPARE <SQL statement name> [ <attributes specification> ]
    FROM <SQL statement variable>

<attributes specification> ::= ATTRIBUTES <attributes variable>

<attributes variable> ::= <simple value specification>

<SQL statement variable> ::= <simple value specification>

<preparable statement> ::=
    <preparable SQL data statement>
  | <preparable SQL schema statement>
  | <preparable SQL transaction statement>
  | <preparable SQL control statement>
  | <preparable SQL session statement>
  | <preparable implementation-defined statement>

<preparable SQL data statement> ::=
    <delete statement: searched>
  | <dynamic single row select statement>
  | <insert statement>
  | <dynamic select statement>
  | <update statement: searched>
  | <merge statement>
  | <preparable dynamic delete statement: positioned>
  | <preparable dynamic update statement: positioned>
  | <hold locator statement>
  | <free locator statement>

<preparable SQL schema statement> ::= <SQL schema statement>

<preparable SQL transaction statement> ::= <SQL transaction statement>

<preparable SQL control statement> ::= <SQL control statement>

<preparable SQL session statement> ::= <SQL session statement>

<dynamic select statement> ::= <cursor specification>

<preparable implementation-defined statement> ::= !! See the Syntax Rules.


Syntax Rules
1) The <simple value specification> of <SQL statement variable> shall not be a <literal>.


©ISO/IEC 2003 – All rights reserved                                                     Dynamic SQL 943
ISO/IEC 9075-2:2003 (E)
19.6 <prepare statement>



2) The declared types of each of <SQL statement variable> and <attributes variable> shall be character string.
3) The Format and Syntax Rules for <preparable implementation-defined statement> are implementation-
   defined.
4) A <preparable SQL control statement> shall not contain an <SQL procedure statement> that is not a
   <preparable statement>, nor shall it contain a <dynamic single row select statement> or a <dynamic select
   statement>.


Access Rules
    None.


General Rules
1) Let P be the contents of the <SQL statement variable>. If P is an <SQL control statement>, then let PS be
   an <SQL procedure statement> contained in P.
2) Two subfields SF1 and SF2 of row types RT1 and RT2 are corresponding subfields if either SF1 or SF2
   are positionally corresponding fields of RT1 and RT2, respectively, or SF1 and SF2 are positionally corre-
   sponding fields of RT1SF1 and RT2SF2 and RT1SF1 and RT2SF2 are the declared types of corresponding
   subfields of RT1 and RT2 respectively.
3) If P does not conform to the Format, Syntax Rules, and Access Rules of a <preparable statement>, or if P
   contains a <simple comment> then an exception condition is raised: syntax error or access rule violation.
4) Let DTGN be the default transform group name and let TFL be the list of {user-defined type name —
   transform group name} pairs used to identify the group of transform functions for every user-defined type
   that is referenced in P. DTGN and TFL are not affected by the execution of a <set transform group statement>
   after P is prepared.
5) Let DPV be a <value expression> that is either a <dynamic parameter specification> or a <dynamic
   parameter specification> immediately contained in any number of <left paren> <right paren> pairs. Initially,
   the declared type of such a <value expression> is, by definition, undefined. A data type is undefined if it
   is neither a data type defined in this standard nor a data type defined by the implementation.
6) Let MP be the implementation-defined maximum value of <precision> for the NUMERIC data type. Let
   ML be the implementation-defined maximum value of <length> for the CHARACTER VARYING data
   type. For each <value expression> DP in P or PS that meets the criteria for DPV let DT denote its declared
   type. The syntactic substitutions specified in Subclause 14.12, “<set clause list>”, shall not be applied until
   the data types of <dynamic parameter specification>s are determined by this General Rule.
    a) Case:
        i)     If DP is immediately followed by an <interval qualifier> IQ, then DT is INTERVAL IQ.
        ii)    If DP is the <numeric value expression> simply contained in an <array element reference>, then
               DT is NUMERIC (MP, 0).
        iii)   If DP is the <string value expression> simply contained in a <char length expression> or an
               <octet length expression>, then DT is CHARACTER VARYING(ML) with an implementation-
               defined character set.


944 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                     19.6 <prepare statement>



         iv)      If DP is either the <numeric value expression dividend> X1 or the <numeric value expression
                  divisor> X2 simply contained in a <modulus expression>, then if DP is X1 (X2), then DT is the
                  declared type of X2 (X1).
         v)       If DP is either X1 or X2 in a <position expression> of the form “POSITION <left paren> X1 IN
                  X2 <right paren>”, and if DP is X1 (X2), then
                  Case:
                  1) If the declared type of X2 (X1) is CHARACTER or CHARACTER VARYING with character
                     set CS, then DT is CHARACTER VARYING (ML) with character set CS.
                  2) Otherwise, DT is the declared type of X2 (X1).
         vi)      If DP is either X2 or X3 in a <string value function> of the form “SUBSTRING <left paren>
                  X1 FROM X2 FOR X3 <right paren>” or “SUBSTRING <left paren> X1 FROM X2 <right
                  paren>”, then DT is NUMERIC (MP, 0).
         vii)     If DP is either X1, X2, or X3 in a <string value function> of the form “SUBSTRING (X1 SIMI-
                  LAR X2 ESCAPE X3 )”, then
                  1) Case:
                      A) If the declared type of X1 is CHARACTER, CHARACTER VARYING, or CHARAC-
                         TER LARGE OBJECT, then let CS be the character set of X1.
                      B) If the declared type of X2 is CHARACTER, CHARACTER VARYING, or CHARAC-
                         TER LARGE OBJECT, then let CS be the character set of X1.
                      C) If the declared type of X3 is CHARACTER, CHARACTER VARYING, or CHARAC-
                         TER LARGE OBJECT, then let CS be the character set of X1.
                      D) Otherwise, the character set of CS is undefined.
                  2) If CS is defined, then:
                      A) If DP is X1 or X2, then DT is CHARACTER VARYING(ML) with character set CS.
                      B) If DP is X3, then DT is CHARACTER(1) with character set CS.
         viii)    If DP is any of X1, X2, X3, or X4 in a <string value function> of the form “OVERLAY <left
                  paren> X1 PLACING X2 FROM X3 FOR X4 <right paren>” or “OVERLAY <left paren> X1
                  PLACING X2 FROM X3 <right paren>”, then
                  Case:
                  1) If DP is X1 (X2), then
                      Case:
                      A) If the declared type of X2 (X1) is CHARACTER or CHARACTER VARYING with
                         character set CS, DT is CHARACTER VARYING (ML) with character set CS.
                      B) Otherwise, DT is the declared type of X2 (X1).
                  2) Otherwise, DT is NUMERIC (MP, 0).



©ISO/IEC 2003 – All rights reserved                                                         Dynamic SQL 945
ISO/IEC 9075-2:2003 (E)
19.6 <prepare statement>



       ix)     If DP is either X1 or X2 in a <value expression> of the form “X1 <concatenation operator> X2”
               and DP is X1 (X2), then
               Case:
               1) If the declared type of X2 (X1) is CHARACTER or CHARACTER VARYING with character
                  set CS, then DT is CHARACTER VARYING (ML) with character set CS.
               2) Otherwise, DT is the declared type of X2 (X1).
       x)      If DP is either X1 or X2 in a <value expression> of the form “X1 <asterisk> X2” or “X1 <solidus>
               X2” and DP is X1 (X2), then
               Case:
               1) If DP is X1, then DT is the declared type of X2.
               2) Otherwise,
                   Case:
                   A) If the declared type of X1 is an interval type, then DT is NUMERIC (MP, 0).
                   B) Otherwise, DT is the declared type of X2 (X1).
       xi)     If DP is either X1 or X2 in a <value expression> of the form “X1 <plus sign> X2” or “X1 <minus
               sign> X2”, then
               Case:
               1) If DP is X1 in an expression of the form "X1 <minus sign> X2", then DT is the declared
                  type of X2.
               2) Otherwise, if DP is X1 (X2), then
                   Case:
                   A) If the declared type of X2 (X1) is date, then DT is INTERVAL YEAR (PR) TO MONTH,
                      where PR is the implementation-defined maximum <interval leading field precision>.
                   B) If the declared type of X2 (X1) is time or timestamp, then DT is INTERVAL DAY (PR)
                      TO SECOND(FR), where PR and FR are the implementation-defined maximum
                      <interval leading field precision> and maximum <interval fractional seconds precision>,
                      respectively.
                   C) Otherwise, DT is the declared type of X2 (X1).
       xii)    If DP is the <value expression primary> simply contained in a <boolean primary>, then DT is
               BOOLEAN.
       xiii)   If DP is an <array element> simply contained in an <array element list> AEL or DP represents
               the value of a subfield SF of the declared type of an <array element> simply contained in an
               <array element list> AEL, then let ET be the result of applying the Syntax Rules of Subclause 9.3,
               “Data types of results of aggregations”, to the declared types of the <array element>s simply
               contained in AEL.
               Case:


946 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                       19.6 <prepare statement>



                  1) If DP is an <array element> of AEL, then DT is ET.
                  2) Otherwise, DT is the declared type of the subfield of ET that corresponds to SF.
         xiv)     If DP is a <multiset element> simply contained in a <multiset element list> MEL or DP represents
                  the value of a subfield SF of the declared type of a <multiset element> simply contained in a
                  <multiset element list> MEL, then let ET be the result of applying the Syntax Rules of
                  Subclause 9.3, “Data types of results of aggregations”, to the declared types of the <multiset
                  element>s simply contained in MEL.
                  Case:
                  1) If DP is a <multiset element> of MEL, then DT is ET.
                  2) Otherwise, DT is the declared type of the subfield of ET that corresponds to SF.
         xv)      If DP is the <cast operand> simply contained in a <cast specification> CS or DP represents the
                  value of a subfield SF of the declared type of the <cast operand> simply contained in a <cast
                  specification> CS, then let CT be the simply contained <cast target> of CS.
                  Case:
                  1) Let RT be a data type determined as follows:
                      Case:
                      A) If CT immediately contains ARRAY or MULTISET, then RT is undefined.
                      B) If CT immediately contains <data type>, then RT is that data type.
                      C) If CT simply contains <domain name> D, then RT is the declared type of the domain
                         identified by D.
                  2) Case:
                      A) If DP is the <cast operand> of CS, DT is RT.
                      B) Otherwise, DT is the declared type of the subfield of RT that corresponds to SF.
         xvi)     If DP is a <value expression> simply contained in a <case abbreviation> CA or DP represents
                  the value of a subfield SF of the declared type of such a <value expression>, then let RT be the
                  result of applying the Syntax Rules of Subclause 9.3, “Data types of results of aggregations”,
                  to the declared types of the <value expression>s simply contained in CA.
                  Case:
                  1) If DP is a <value expression> simply contained in CA, then DT is RT.
                  2) Otherwise, DT is the declared type of the subfield of RT that corresponds to SF.
         xvii) If DP is a <result expression> simply contained in a <case specification> CE or DP represents
               the value of a subfield SF of the declared type of such a <result expression>, then let RT be the
               result of applying the Syntax Rules of Subclause 9.3, “Data types of results of aggregations”,
               to the declared types of the <result expression>s simply contained in CE.
                  Case:



©ISO/IEC 2003 – All rights reserved                                                           Dynamic SQL 947
ISO/IEC 9075-2:2003 (E)
19.6 <prepare statement>



              1) If DP is a <result expression> simply contained in CE, then DT is RT.
              2) Otherwise, DT is the declared type of the subfield of RT that corresponds to SF.
       xviii) If DP is a <case operand> or <when operand> simply contained in a <simple case> CE or DP
              represents the value of a subfield SF of the declared type of such a <case operand> or <when
              operand>, then RT is the result of applying the Syntax Rules of Subclause 9.3, “Data types of
              results of aggregations”, to the declared types of the <case operand> and <when operand>s
              simply contained in CE.
              Case:
              1) If DP is a <case operand> or <when operand> simply contained in CE, then DT is RT.
              2) Otherwise, DT is the declared type of the subfield of RT that corresponds to SF.
       xix)   If DP is a <row value expression> or <contextually typed row value expression> simply contained
              in a <table value constructor> or <contextually typed table value constructor> TVC, or if DP
              represents the value of a subfield SF of the declared type of such a <row value expression> or
              <contextually typed row value expression>, then
              Case:
              1) Let RT be a data type determined as follows.
                  Case:
                  A) If TVC is simply contained in a <query expression> that is simply contained in an <insert
                     statement> IS or if TVC is immediately contained in the <insert columns and source>
                     of an <insert statement> IS, then RT is a row type in which the declared type of the i-th
                     field is the declared type of the i-th column in the explicit or implicit <insert column
                     list> of IS and the degree of RT is equal to the number of columns in the explicit or
                     implicit <insert column list> of IS.
                  B) Otherwise, RT is the result of applying the Syntax Rules of Subclause 9.3, “Data types
                     of results of aggregations”, to the declared types of the <row value expression>s or
                     <contextually typed row value expression>s simply contained in TVC.
              2) Case:
                  A) If DP is a <row value expression> or <contextually typed row value expression> simply
                     contained in TVC, then DT is RT.
                  B) Otherwise, DT is the declared type of the subfield of RT that corresponds to SF.
       xx)    If DP is the <value expression> simply contained in an <merge insert value list> of an <merge
              insert specification> MIS of a <merge statement> or if DP represents the value of a subfield SF
              of the declared type of such a <value expression>, then let RT be the data type indicated in the
              column descriptor for the positionally corresponding column in the explicit or implicit <insert
              column list> contained in MIS.
              Case:
              1) If DP is the <value expression> simply contained in MIS, then DT is RT.
              2) Otherwise, DT is the declared type of the subfield of RT that corresponds to SF.


948 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                         19.6 <prepare statement>



         xxi)     If DP is a <row value predicand> simply contained in a <comparison predicate>, <distinct
                  predicate> or <between predicate> PR or if DP represents the value of a subfield SF of the
                  declared type of such a <row value predicand>, then let RT be the result of applying the Syntax
                  Rules of Subclause 9.3, “Data types of results of aggregations”, to the declared types of the <row
                  value predicand>s simply contained in PR.
                  Case:
                  1) If DP is a <row value predicand> simply contained in PR, then DT is RT.
                  2) Otherwise, DT is the declared type of the subfield of RT that corresponds to SF.
         xxii) If DP is a <row value predicand> simply contained in a <quantified comparison predicate> or
               <match predicate> PR or DP represents the value of a subfield SF of the declared type of such
               a <row value predicand>, then let RT be the declared type of the <table subquery> simply con-
               tained in PR.
                  Case:
                  1) If DP is a <row value predicand> simply contained in PR, then DT is RT.
                  2) Otherwise, DT is the declared type of the subfield of RT that corresponds to SF.
         xxiii) If DP is a <row value predicand> simply contained in an <in predicate> PR or if DP represents
                the value of a subfield SF of the declared type of such a <row value predicand>, then let RT be
                the result of applying the Syntax Rules of Subclause 9.3, “Data types of results of aggregations”,
                to the declared types of the <row value predicand>s simply contained in PR and the declared
                row type of the <table subquery> (if any) simply contained in PR.
                  Case:
                  1) If DP is a <row value predicand> simply contained in PR, then DT is RT.
                  2) Otherwise, DT is the declared type of the subfield of RT that corresponds to SF.
         xxiv) If DP is the first <row value constructor element> simply contained in either <row value predicand
               1> RV1 or <row value predicand 2> RV2 in an <overlaps predicate> PR, then
                  Case:
                  1) If both RV1 and RV2 simply contain a <row value constructor predicand> whose first <row
                     value constructor element> meets the criteria for DPV, then DT is TIMESTAMP WITH
                     TIME ZONE.
                  2) Otherwise, if DP is simply contained in RV1 (RV2), then DT is the declared type of the first
                     field of RV2 (RV1).
         xxv) If DP is simply contained in a <character like predicate>, <octet like predicate>, or <similar
              predicate> PR, then let X1 represent the <row value predicand> immediately contained in PR,
              let X2 represent the <character pattern>, the <octet pattern> or the <similar pattern>, and let X3
              represent the <escape character> or the <escape octet>.
                  Case:
                  1) If all X1, X2 and X3 meet the criteria for DPV, then DT is CHARACTER VARYING (ML)
                     with an implementation-defined character set.


©ISO/IEC 2003 – All rights reserved                                                             Dynamic SQL 949
ISO/IEC 9075-2:2003 (E)
19.6 <prepare statement>



              2) Otherwise, let RT be the result of applying the Syntax Rules of Subclause 9.3, “Data types
                 of results of aggregations”, to the declared types of X1, X2 and X3.
                  Case:
                  A) If RT is CHARACTER or CHARACTER VARYING with character set CS, then DT
                     is CHARACTER VARYING(ML) with character set CS.
                  B) Otherwise, DT is RT.
       xxvi) If DP is the <value expression> simply contained in an <update source> of a <set clause> SC
             or if DP represents the value of a subfield SF of the declared type of such a <value expression>,
             then let RT be the declared type of the <update target> or <mutated set clause> specified in SC.
              Case:
              1) If DP is the <value expression> simply contained in SC, then DT is RT.
              2) Otherwise, DT is the declared type of the subfield of RT that corresponds to SF.
       xxvii) If DP is a <contextually typed row value expression> simply contained in a <multiple column
              assignment> MCA of a <set clause> SC or if DP represents the value of a subfield SF of the
              declared type of such a <contextually typed row value expression>, then let RT be a row type
              in which the declared type of the i-th field is the declared type of the <update target> or <mutated
              set clause> immediately contained in the i-th <set target> contained in the <set target list> of
              MCA.
              Case:
              1) If DP is a <contextually typed row value expression> simply contained in MCA, then DT
                 is RT.
              2) Otherwise, DT is the declared type of the subfield of RT that corresponds to SF.
       xxviii) If DP is the <value specification> immediately contained in a <catalog name characteristic>,
               <schema name characteristic>, <character set name characteristic>, <SQL-path characteristic>,
               <transform group characteristic>, <role specification> or <set session user identifier statement>,
               then DT is CHARACTER VARYING (ML) with an implementation-defined character set.
       xxix) If DP is the <interval value expression> immediately contained in a <set local time zone state-
             ment>, then DT is INTERVAL HOUR TO MINUTE.
       xxx) If DP is an <SQL argument> of a <routine invocation> RI or if DP is the value of a subfield SF
            of the declared type of a <value expression> immediately contained in such an <SQL argument>,
            and if DP is the i-th <SQL argument> of RI or is contained in the i-th <SQL argument> of RI,
            then let RT denote the declared type of the i-th SQL parameter of the subject routine of RI
            determined by applying the Syntax Rules of Subclause 10.4, “<routine invocation>”, to RI.
              Case:
              1) If DP is the i-th <SQL argument> of RI, then DT is RT.
              2) Otherwise, DT is the declared type of the subfield of RT that corresponds to SF.
       xxxi) If DP is contained in a <window frame preceding> or a <window frame following> contained
             in a <window specification> WS, then


950 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                                        19.6 <prepare statement>



                  Case:
                  1) If WS specifies ROWS, then DT is NUMERIC (MP, 0).
                  2) Otherwise, let SDT be the data type of the single <sort key> contained in WS.
                      Case:
                      A) If SDT is a numeric type, then DT is SDT.
                      B) If SDT is DATE, then DT is INTERVAL DAY.
                      C) If SDT is TIME(P) WITHOUT TIME ZONE or TIME(P) WITH TIME ZONE, then
                         DT is INTERVAL HOUR TO SECOND(P).
                      D) If SDT is TIMESTAMP(P) WITHOUT TIME ZONE or TIMESTAMP(P) WITH TIME
                         ZONE, then DT is INTERVAL DAY TO SECOND(P).
                      E) If SDT is an interval type, then DT is SDT.
         xxxii) If DP is a <locator reference> simply contained in a <hold locator statement> or a <free locator
                statement>, then DT is INTEGER.
    b) If DT is undefined, then an exception condition is raised: syntax error or access rule violation.
7) Whether a <dynamic parameter specification> is an input argument, an output argument, or both an input
   and an output argument is determined as follows.
    Case:
    a) If P is a <call statement>, then:
         i)       Let SR be the subject routine of the <routine invocation> RI immediately contained in P. Let n
                  be the number of <SQL argument>s in the <SQL argument list> immediately contained in RI.

         ii)      Let Ay, 1 (one) ≤ y ≤ n, be the y-th <SQL argument> of the <SQL argument list> immediately
                  contained in RI.
         iii)     For each <dynamic parameter specification> D contained in some <SQL argument> Ak, 1 (one)
                  ≤ k ≤n:
                  1) D is an input <dynamic parameter specification> if the <parameter mode> of the k-th SQL
                     parameter of SR of SR is IN or INOUT.
                  2) D is an output <dynamic parameter specification> if the <parameter mode> of the k-th SQL
                     parameter of SR is OUT or INOUT.
    b) Otherwise:
         i)       If a <dynamic parameter specification> is contained in a <target specification>, then it is an
                  output <dynamic parameter specification>.
         ii)      If a <dynamic parameter specification> is contained in a <value specification>, then it is an
                  input <dynamic parameter specification>.




©ISO/IEC 2003 – All rights reserved                                                            Dynamic SQL 951
ISO/IEC 9075-2:2003 (E)
19.6 <prepare statement>



8) If P or PS is a <preparable dynamic delete statement: positioned> or a <preparable dynamic update statement:
   positioned>, then let CN be the <cursor name> contained in P or PS, respectively.
    Case:
    a) If P or PS contains a <scope option> that specifies GLOBAL, then
        Case:
        i)      If there exists an extended dynamic cursor EDC with an <extended cursor name> having a global
                scope and a <cursor name> that is equivalent to CN, then EDC is the cursor referenced by P or
                PS.
        ii)     Otherwise, an exception condition is raised: invalid cursor name.
    b) If P or PS contains a <scope option> that specifies LOCAL, or if no <scope option> is specified, then
       the potentially referenced cursors of P or PS include every declared dynamic cursor whose <cursor
       name> is equivalent to CN and whose scope is the containing module and every extended dynamic
       cursor having an <extended cursor name> that has a scope of the containing module and whose <cursor
       name> is equivalent to CN.
        Case:
        i)      If the number of potentially referenced cursors is greater than 1 (one), then an exception condition
                is raised: ambiguous cursor name.
        ii)     If the number of potentially referenced cursors is less than 1 (one), then an exception condition
                is raised: invalid cursor name.
        iii)    Otherwise, CN refers to the single potentially referenced cursor of P.
9) If <extended statement name> is specified for the <SQL statement name>, then let S be <simple value
   specification> and let V be the character string that is the result of
      TRIM ( BOTH ' ' FROM S )
    If V does not conform to the Format and Syntax Rules of an <identifier>, then an exception condition is
    raised: invalid SQL statement identifier.
10) If <statement name> is specified for the <SQL statement name>, P is not a <cursor specification>, and
    <statement name> is associated with a cursor C through a <dynamic declare cursor>, then an exception
    condition is raised: dynamic SQL error — prepared statement not a cursor specification.
11) If the value of the <SQL statement name> identifies an existing prepared statement, then an implicit
      DEALLOCATE PREPARE SSN
    is executed, where SSN is the value of the <SQL statement name>.
12) P is prepared for execution, resulting in a prepared statement PRP.
    Case:
    a) If the <prepare statement> is contained in an <SQL routine> R, then
        Case:



952 Foundation (SQL/Foundation)                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                                                   19.6 <prepare statement>



         i)       If the security characteristic of R is DEFINER, then the owner of PRP is set to the owner of R.
         ii)      Otherwise, PRP has no owner.
    b) If the <prepare statement> is contained in a triggered action, then the owner of PRP is set to the owner
       of the trigger.
    c) Otherwise,
         NOTE 428 — If the <prepare statement> is in neither of the above, then it must necessarily be immediately contained in an
         externally-invoked procedure.

         Case:
         i)       If the SQL-client module that includes the <prepare statement> has a <module authorization
                  identifier> MAI and FOR STATIC ONLY was not specified in the <SQL-client module defini-
                  tion>, then the owner of PRP is MAI.
         ii)      Otherwise, PRP has no owner.
13) Case:
    a) If <extended statement name> is specified for the <SQL statement name>, then the value of the
       <extended statement name> is associated with the prepared statement. This value and explicit or implied
       <scope option> shall be specified for each <execute statement> or <allocate cursor statement> that is
       to be associated with this prepared statement.
    b) If <statement name> is specified for the <SQL statement name>, then:
         i)       If <statement name> is not associated with a cursor and either P is not a <cursor specification>
                  or P is a <cursor specification> that conforms to the Format and Syntax Rules of a <dynamic
                  single row select statement>, then an equivalent <statement name> shall be specified for each
                  <execute statement> that is to be associated with this prepared statement.
         ii)      If P is a <cursor specification> and <statement name> is associated with a cursor C through a
                  <dynamic declare cursor>, then an association is made between C and P. The association is
                  preserved until the prepared statement is destroyed.
14) The validity of an <extended statement name> value or a <statement name> that does not identify a held
    cursor in an SQL-transaction different from the one in which the statement was prepared is implementation-
    dependent.
15) If <attributes specification> is specified, then let ATV be the contents of the <attributes variable>. If ATV
    is not a zero-length character string, then
    a) If ATV does not conform to the Format and Syntax Rules of Subclause 19.7, “<cursor attributes>”,
       then an exception condition is raised: syntax error or access rule violation.
    b) Let N be the number of <dynamic declare cursor>s in the containing <SQL-client module definition>
       whose <statement name> is equivalent to the <statement name> of the <prepare statement>.

    c) If N > 0 (zero), then let CRi, 1 (one) ≤ i ≤ N, be the cursor specified by the i-th <dynamic declare cursor>
         in the containing <SQL-client module definition>. For 1 (one) ≤ i ≤ N:
         i)       If ATV includes <cursor sensitivity> CS, then the sensitivity of CRi is set to CS.



©ISO/IEC 2003 – All rights reserved                                                                        Dynamic SQL 953
ISO/IEC 9075-2:2003 (E)
19.6 <prepare statement>



       ii)    If ATV includes <cursor scrollability> CL, then the scrollability of CRi is set to CL.

       iii)   If ATV includes <cursor holdability> CH, then the holdability of CRi is set to CH.

       iv)    If ATV includes <cursor returnability> CR, then the returnability of CRi is set to CR.


Conformance Rules
1) Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain a <prepare
   statement>.
2) Without Feature B034, “Dynamic specification of cursor attributes”, conforming SQL language shall not
   contain an <attributes specification>.




954 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                                     19.7 <cursor attributes>



19.7 <cursor attributes>

Function
Specify a list of cursor attributes.


Format
<cursor attributes> ::= <cursor attribute>...

<cursor attribute> ::=
    <cursor sensitivity>
  | <cursor scrollability>
  | <cursor holdability>
  | <cursor returnability>


Syntax Rules
1) Each of <cursor sensitivity>, <cursor scrollability>, <cursor holdability> and <cursor returnability> shall
   be specified at most once.


Access Rules
    None.


General Rules
    None.


Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved                                                        Dynamic SQL 955
ISO/IEC 9075-2:2003 (E)
19.8 <deallocate prepared statement>



19.8 <deallocate prepared statement>

Function
Deallocate SQL-statements that have been prepared with a <prepare statement>.


Format
<deallocate prepared statement> ::= DEALLOCATE PREPARE <SQL statement name>


Syntax Rules
1) If <SQL statement name> is a <statement name>, then the containing <SQL-client module definition>
   shall contain a <prepare statement> whose <statement name> is equivalent to the <statement name> of the
   <deallocate prepared statement>.


Access Rules
    None.


General Rules
1) If the <SQL statement name> does not identify a statement prepared in the scope of the <SQL statement
   name>, then an exception condition is raised: invalid SQL statement name.
2) If the value of <SQL statement name> identifies an existing prepared statement that is the <cursor specifi-
   cation> of an open cursor, then an exception condition is raised: invalid cursor state.
3) The prepared statement identified by the <SQL statement name> is destroyed. Any cursor that was allocated
   with an <allocate cursor statement> that is associated with the prepared statement identified by the <SQL
   statement name> is destroyed. If the value of the <SQL statement name> identifies an existing prepared
   statement that is a <cursor specification>, then any prepared statements that reference that cursor are
   destroyed.


Conformance Rules
1) Without Feature B032, “Extended dynamic SQL”, conforming SQL language shall not contain a <deallocate
   prepared statement>.




956 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                                     19.9 <describe statement>



19.9 <describe statement>

Function
Obtain information about the <select list> columns or <dynamic parameter specification>s contained in a prepared
statement or about the columns of the result set associated with a cursor.


Format
<describe statement> ::=
    <describe input statement>
  | <describe output statement>

<describe input statement> ::=
    DESCRIBE INPUT <SQL statement name> <using descriptor> [ <nesting option> ]

<describe output statement> ::=
    DESCRIBE [ OUTPUT ] <described object> <using descriptor> [ <nesting option> ]

<nesting option> ::=
    WITH NESTING
  | WITHOUT NESTING

<using descriptor> ::= USING [ SQL ] DESCRIPTOR <descriptor name>

<described object> ::=
    <SQL statement name>
  | CURSOR <extended cursor name> STRUCTURE


Syntax Rules
1) If <SQL statement name> is a <statement name>, then the containing <SQL-client module definition>
   shall contain a <prepare statement> whose <statement name> is equivalent to the <statement name> of the
   <describe statement>.
2) If <nesting option> is not specified, then WITHOUT NESTING is implicit.


Access Rules
    None.


General Rules
1) If <describe input statement> is executed and the value of the <SQL statement name> does not identify a
   statement prepared in the scope of the <SQL statement name>, then an exception condition is invalid SQL
   statement name.




©ISO/IEC 2003 – All rights reserved                                                         Dynamic SQL 957
ISO/IEC 9075-2:2003 (E)
19.9 <describe statement>



2) If <describe output statement> is executed, <SQL statement name> is specified, and the value of the <SQL
   statement name> does not identify a statement prepared in the scope of the <SQL statement name>, then
   an exception condition is invalid SQL statement name.
3) If <describe output statement> is executed, <extended cursor name> is specified, and the value of the
   <extended cursor name> does not identify a known allocated cursor, then an exception condition is invalid
   cursor name.
4) If an SQL system descriptor area is not currently allocated whose name is the value of the <simple value
   specification> immediately contained in <descriptor name> and whose scope is specified by the <scope
   option> immediately contained in <descriptor name>, then an exception condition is raised: invalid SQL
   descriptor name.
5) Let DA be the descriptor area identified by <descriptor name>. Let N be the <occurrences> specified when
   DA was allocated.
6) Case:
    a) If the statement being executed is a <describe input statement>, then a descriptor for the input <dynamic
       parameter specification>s for the prepared statement is stored in DA. Let D be the number of input
       <dynamic parameter specification>s in the prepared statement. If WITH NESTING is specified, then
       let NSi, 1 (one) ≤ i ≤ D, be the number of subordinate descriptors of the descriptor for the i-th input
       dynamic parameter; otherwise, let NSi be 0 (zero).

    b) If the statement being executed is a <describe output statement> and the prepared statement that is
       being described is a <dynamic select statement> or a <dynamic single row select statement>, then a
       descriptor for the <select list> columns for the prepared statement is stored in DA. Let T be the table
       defined by the prepared statement and let D be the degree of T. If WITH NESTING is specified, then
       let NSi, 1 (one) ≤ i ≤ D, be the number of subordinate descriptors of the descriptor for the i-th column
       of T; otherwise, let NSi be 0 (zero).

    c) Otherwise, a descriptor for the output <dynamic parameter specification>s for the prepared statement
       is stored in DA. Let D be the number of output <dynamic parameter specification>s in the prepared
       statement. If WITH NESTING is specified, then let NSi, 1 (one) ≤ i ≤ D, be the number of subordinate
       descriptors of the descriptor for the i-th output dynamic parameter; otherwise, let NSi be 0 (zero).

7) DA is set as follows:
    a) Let TD be the value of D+NS1+NS2+...+NSD. COUNT is set to TD.

    b) TOP_LEVEL_COUNT is set to D.
    c) DYNAMIC_FUNCTION and DYNAMIC_FUNCTION_CODE are set to the identifier and code,
       respectively, for the prepared statement as shown in Table 31, “SQL-statement codes”.
    d) If the statement being executed is a <describe output statement> and the prepared statement that is
       being described is a <dynamic select statement> or a <dynamic single row select statement>:
        Case:
        i)      If some subset of the columns of T is the primary key of T, then KEY_TYPE is set to 1 (one).




958 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                                 ISO/IEC 9075-2:2003 (E)
                                                                                               19.9 <describe statement>



         ii)      If some subset of the columns of T is the preferred candidate key of T, then KEY_TYPE is set
                  to 2.
         iii)     Otherwise, KEY_TYPE is set to 0 (zero).
         NOTE 429 — Primary keys and preferred candidate keys are defined in Subclause 4.18, “Functional dependencies”.

    e) If TD is greater than N, then a completion condition is raised: warning — insufficient item descriptor
       areas.
    f) If TD is 0 (zero) or TD is greater than N, then no item descriptor areas are set. Otherwise:
         i)       The first TD item descriptor areas are set with values from the descriptors and, optionally, sub-
                  ordinate descriptors for
                  Case:
                  1) If the statement being executed is a <describe input statement>, then the input <dynamic
                     parameter specification>s.
                  2) If the statement being executed is a <describe output statement> and the statement being
                     described is a <dynamic select statement> or a <dynamic single row select statement>, then
                     the columns of T.
                  3) Otherwise, the output <dynamic parameter specification>s.
         ii)      The descriptor for the first such column or <dynamic parameter specification> is assigned to
                  the first item descriptor area.
         iii)     If the descriptor for the j-th column or <dynamic parameter specification> is assigned to the
                  k-th item descriptor area, then:
                  1) The descriptor for the (j+1)-th column or <dynamic parameter specification> is assigned to
                     the (k+NSj+1)-th item descriptor area.

                  2) If WITH NESTING is specified, then the implicitly ordered subordinate descriptors for the
                     j-th column or <dynamic parameter specification> are assigned to contiguous item descriptor
                     areas starting at the (k+1)-th item descriptor area.
8) An SQL item descriptor area, if set, consists of values for LEVEL, TYPE, NULLABLE, NAME,
   UNNAMED, PARAMETER_ORDINAL_POSITION, PARAMETER_SPECIFIC_CATALOG,
   PARAMETER_SPECIFIC_SCHEMA, PARAMETER_SPECIFIC_NAME, and other fields depending on
   the value of TYPE as described below. The DATA and INDICATOR fields are not relevant. Those fields
   and fields that are not applicable for a particular value of TYPE are set to implementation-dependent values.
    a) If the SQL item descriptor area is set to a descriptor that is immediately subordinate to another whose
       LEVEL value is K, then LEVEL is set to K+1; otherwise, LEVEL is set to 0 (zero).
    b) TYPE is set to a code, as shown in Table 25, “Codes used for SQL data types in Dynamic SQL”,
       indicating the declared type of the column, <dynamic parameter specification>, or subordinate
       descriptor.
    c) Case:
         i)       If the value of LEVEL is 0 (zero) and the item descriptor area describes a column, then:



©ISO/IEC 2003 – All rights reserved                                                                     Dynamic SQL 959
ISO/IEC 9075-2:2003 (E)
19.9 <describe statement>



              1) If the column is possibly nullable, then NULLABLE is set to 1 (one); otherwise, NULLABLE
                 is set to 0 (zero).
              2) If the column name is implementation-dependent, then NAME is set to the implementation-
                 dependent name of the column and UNNAMED is set to 1 (one); otherwise, NAME is set
                 to the <derived column> name for the column and UNNAMED is set to 0 (zero).
              3) If the column is a member of the primary key of T and KEY_TYPE was set to 1 (one) or if
                 the column is a member of the preferred candidate key of T and KEY_TYPE was set to 2,
                 then KEY_MEMBER is set to 1 (one); otherwise, KEY_MEMBER is set to 0 (zero).
       ii)    If the value of LEVEL is 0 (zero) and the item descriptor area describes a <dynamic parameter
              specification>, then:
              1) NULLABLE is set to 1 (one).
                  NOTE 430 — This indicates that the <dynamic parameter specification> can have the null value.

              2) UNNAMED is set to 1 (one) and NAME is set to an implementation-dependent value.
              3) KEY_MEMBER is set to 0 (zero).
       iii)   Otherwise:
              1) NULLABLE is set to 1 (one).
              2) Case:
                  A) If the item descriptor area describes a field of a row, then
                      Case:
                      I)      If the name of the field is implementation-dependent, then NAME is set to the
                              implementation-dependent name of the field and UNNAMED is set to 1 (one).
                      II)     Otherwise, NAME is set to the name of the field and UNNAMED is set to 0
                              (zero).
                  B) Otherwise, UNNAMED is set to 1 (one) and NAME is set to an implementation-defined
                     value.
              3) KEY_MEMBER is set to 0 (zero).
   d) Case:
       i)     If TYPE indicates a <character string type>, then:
              1) LENGTH is set to the length or maximum length in characters of the character string type.
              2) OCTET_LENGTH is set to the maximum possible length in octets of the character string
                 type.
              3) CHARACTER_SET_CATALOG, CHARACTER_SET_SCHEMA, and CHARAC-
                 TER_SET_NAME are set to the the fully qualified name of the character string type's
                 character set.




960 Foundation (SQL/Foundation)                                                          ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)
                                                                                        19.9 <describe statement>



                  4) COLLATION_CATALOG, COLLATION_SCHEMA and COLLATION_NAME are set
                     to the fully qualified name of the character string type's declared type collation, if any, and
                     otherwise to the empty string.
                  If the subject <language clause> specifies C, then the lengths specified in LENGTH and
                  OCTET_LENGTH do not include the implementation-defined null character that terminates a
                  C character string.
         ii)      If TYPE indicates a <binary large object string type>, then LENGTH is set to the length or
                  maximum length in octets of the binary string and OCTET_LENGTH is set to the maximum
                  possible length in octets of the binary string.
         iii)     If TYPE indicates an <exact numeric type>, then PRECISION and SCALE are set to the precision
                  and scale of the exact numeric.
         iv)      If TYPE indicates an <approximate numeric type>, then PRECISION is set to the precision of
                  the approximate numeric.
         v)       If TYPE indicates a <datetime type>, then LENGTH is set to the length in positions of the
                  datetime type, DATETIME_INTERVAL_CODE is set to a code as specified in Table 26, “Codes
                  associated with datetime data types in Dynamic SQL”, to indicate the specific datetime data
                  type and PRECISION is set to the <time precision> or <timestamp precision>, if either is
                  applicable.
         vi)      If TYPE indicates an <interval type>, then LENGTH is set to the length in positions of the
                  interval type, DATETIME_INTERVAL_CODE is set to a code as specified in Table 27, “Codes
                  used for <interval qualifier>s in Dynamic SQL”, to indicate the <interval qualifier> of the
                  interval data type, DATETIME_INTERVAL_PRECISION is set to the <interval leading field
                  precision> and PRECISION is set to the <interval fractional seconds precision>, if applicable.
         vii)     If TYPE indicates a user-defined type, then USER_DEFINED_TYPE_CATALOG,
                  USER_DEFINED_TYPE_SCHEMA, and USER_DEFINED_TYPE_NAME are set to the fully
                  qualified name of the user-defined type, and USER_DEFINED_TYPE_CODE is set to a code
                  as specified in Table 29, “Codes associated with user-defined types in Dynamic SQL”, to indicate
                  the category of the user-defined type.
         viii)    If TYPE indicates a <reference type>, then:
                  1) USER_DEFINED_TYPE_CATALOG, USER_DEFINED_TYPE_SCHEMA, and
                     USER_DEFINED_TYPE_NAME are set to the fully qualified name of the referenced type.
                  2) SCOPE_CATALOG, SCOPE_SCHEMA, and SCOPE_NAME are set to the fully qualified
                     name of the referenceable base table.
                  3) LENGTH and OCTET_LENGTH are set to the length in octets of the <reference type>.
         ix)      If TYPE indicates ROW, then DEGREE is set to the degree of the row type.
         x)       If TYPE indicates ARRAY, then CARDINALITY is set to the maximum cardinality of the array
                  type.
    e) If LEVEL is 0 (zero) and the prepared statement is a <call statement>, then:
         i)       Let SR be the subject routine for the <routine invocation> of the <call statement>.



©ISO/IEC 2003 – All rights reserved                                                             Dynamic SQL 961
ISO/IEC 9075-2:2003 (E)
19.9 <describe statement>



       ii)    Let Dx be the x-th <dynamic parameter specification> simply contained in an SQL argument
              Ay of the <call statement>.

       iii)   Let Py be the y-th SQL parameter of SR.
              NOTE 431 — A P whose <parameter mode> is IN can be a <value expression> that contains zero, one, or more
              <dynamic parameter specification>s. Thus:
              —   Every Dx maps to one and only one Py.

              —   Several Dx instances can map to the same Py.

              —   There can be Py instances that have no Dx instances that map to them.

       iv)    The PARAMETER_MODE value in the descriptor for each Dx is set to the value from Table 28,
              “Codes used for input/output SQL parameter modes in Dynamic SQL”, that indicates the
              <parameter mode> of Py.

       v)     The PARAMETER_ORDINAL_POSITION value in the descriptor for each Dx is set to the
              ordinal position of Py.

       vi)    The PARAMETER_SPECIFIC_CATALOG, PARAMETER_SPECIFIC_SCHEMA, and
              PARAMETER_SPECIFIC_NAME values in the descriptor for each Dx are set to the values
              that identify the catalog, schema, and specific name of SR.


Conformance Rules
1) Without Feature B032, “Extended dynamic SQL”, conforming SQL language shall not contain a <describe
   input statement>.
2) Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain a <describe
   output statement>.




962 Foundation (SQL/Foundation)                                                           ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                                   19.10 <input using clause>



19.10 <input using clause>

Function
Supply input values for an <SQL dynamic statement>.


Format
<input using clause> ::=
    <using arguments>
  | <using input descriptor>

<using arguments> ::= USING <using argument> [ { <comma> <using argument> }... ]

<using argument> ::= <general value specification>

<using input descriptor> ::= <using descriptor>


Syntax Rules
1) The <general value specification> immediately contained in <using argument> shall be either a <host
   parameter specification> or an <embedded variable specification>.


Access Rules
    None.


General Rules
1) If <using input descriptor> is specified and an SQL descriptor area is not currently allocated whose name
   is the value of the <simple value specification> immediately contained in <descriptor name> and whose
   scope is specified by the <scope option> immediately contained in <descriptor name>, then an exception
   condition is raised: invalid SQL descriptor name.
2) When an <input using clause> is used in a <dynamic open statement> or as the <parameter using clause>
   in an <execute statement>, the <input using clause> describes the input <dynamic parameter specification>
   values for the <dynamic open statement> or the <execute statement>, respectively. Let PS be the prepared
   <dynamic select statement> referenced by the <dynamic open statement> or the prepared statement refer-
   enced by the <execute statement>, respectively.
3) Let D be the number of input <dynamic parameter specification>s in PS.
4) If <using arguments> is specified and the number of <using argument>s is not D, then an exception condition
   is raised: dynamic SQL error — using clause does not match dynamic parameter specifications.
5) If <using input descriptor> is specified, then:
    a) Let N be the value of COUNT.



©ISO/IEC 2003 – All rights reserved                                                       Dynamic SQL 963
ISO/IEC 9075-2:2003 (E)
19.10 <input using clause>



   b) If N is greater than the value of <occurrences> specified when the SQL descriptor area identified by
      <descriptor name> was allocated or is less than zero, then an exception condition is raised: dynamic
      SQL error — invalid descriptor count.
   c) If the first N item descriptor areas are not valid as specified in Subclause 19.1, “Description of SQL
      descriptor areas”, then an exception condition is raised: dynamic SQL error — using clause does not
      match dynamic parameter specifications.
   d) In the first N item descriptor areas:
       i)      If the number of item descriptor areas in which the value of LEVEL is 0 (zero) is not D, then
               an exception condition is raised: dynamic SQL error — using clause does not match dynamic
               parameter specifications.
       ii)     If the value of INDICATOR is not negative, TYPE does not indicate ROW, and the item
               descriptor area is not subordinate to an item descriptor area whose INDICATOR value is negative
               or whose TYPE field indicates ARRAY, ARRAY LOCATOR, MULTISET, or MULTISET
               LOCATOR, and if the value of DATA is not a valid value of the data type represented by the
               item descriptor area, then an exception condition is raised: dynamic SQL error — using clause
               does not match dynamic parameter specifications.

6) For 1 (one) ≤ i ≤ D:
   a) Let TDT be the effective declared type of the i-th input <dynamic parameter specification>, defined to
      be the type represented by the item descriptor area and its subordinate descriptor areas that would be
      set by a <describe input statement> to reflect the description of the i-th input <dynamic parameter
      specification> of PS.
       NOTE 432 — See the General Rules of Subclause 19.9, “<describe statement>”.
       NOTE 433 — “Represented by”, as applied to the relationship between a data type and an item descriptor area, is defined in
       the Syntax Rules of Subclause 19.1, “Description of SQL descriptor areas”.

   b) Case:
       i)      If <using input descriptor> is specified, then:
               1) Let IDA be the i-th item descriptor area whose LEVEL value is 0 (zero).
               2) Let SDT be the effective declared type represented by IDA.
                    NOTE 434 — “Represented by”, as applied to the relationship between a data type and an item descriptor area,
                    is defined in the Syntax Rules of Subclause 19.1, “Description of SQL descriptor areas”.

               3) Let SV be the associated value of IDA.
                    Case:
                    A) If the value of INDICATOR is negative, then SV is the null value.
                    B) Otherwise,
                         Case:
                         I)      If TYPE indicates ROW, then SV is a row whose type is SDT and whose field
                                 values are the associated values of the immediately subordinate descriptor areas
                                 of IDA.


964 Foundation (SQL/Foundation)                                                              ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                                       19.10 <input using clause>



                           II)        Otherwise, SV is the value of DATA with data type SDT.
         ii)      If <using arguments> is specified, then let SDT and SV be the declared type and value, respec-
                  tively, of the i-th <using argument>.
    c) Case:
         i)       If SDT is a locator type, then
                  Case:
                  1) If SV is not the null value, then let the value of the i-th dynamic parameter be the value of
                     SV.
                  2) Otherwise, let the value of the i-th dynamic parameter be the null value.
         ii)      If SDT and TDT are predefined data types, then
                  Case:
                  1) If the <cast specification>
                          CAST ( IV AS TDT )
                      does not conform to the Syntax Rules of Subclause 6.12, “<cast specification>”, and there
                      is an implementation-defined conversion from type STD to type TDT, then that implemen-
                      tation-defined conversion is effectively performed, converting IV to type TDT, and the result
                      is the value TV of the i-th input dynamic parameter.
                  2) Otherwise:
                      A) If the <cast specification>
                                 CAST ( IV AS TDT )
                           does not conform to the Syntax Rules of Subclause 6.12, “<cast specification>”, then
                           an exception condition is raised: dynamic SQL error — restricted data type attribute
                           violation.
                      B) If the <cast specification>
                                 CAST ( IV AS TDT )
                           does not conform to the General Rules of Subclause 6.12, “<cast specification>”, then
                           an exception condition is raised in accordance with the General Rules of Subclause 6.12,
                           “<cast specification>”.
                      C) The <cast specification>
                                 CAST ( IV AS TDT )
                           is effectively performed and is the value of the i-th input dynamic parameter.
         iii)     If SDT is a predefined data type and TDT is a user-defined type, then:
                  1) Let DT be the data type identified by TDT.




©ISO/IEC 2003 – All rights reserved                                                            Dynamic SQL 965
ISO/IEC 9075-2:2003 (E)
19.10 <input using clause>



              2) If the current SQL-session has a group name corresponding to the user-defined name of DT,
                 then let GN be that group name; Otherwise, let GN be the default transform group name
                 associated with the current SQL-session.
              3) The Syntax Rules of Subclause 9.19, “Determination of a to-sql function”, are applied with
                 DT and GN as TYPE and GROUP, respectively.
                  Case:
                  A) If there is an applicable to-sql function, then let TSF be that to-sql function. If TSF is
                     an SQL-invoked method, then let TSFPT be the declared type of the second SQL
                     parameter of TSF; otherwise, let TSFPT be the declared type of the first SQL parameter
                     of TSF.
                      Case:
                      I)      If TSFPT is compatible with SDT, then
                              Case:
                              1) If TSF is an SQL-invoked method, then TSF is effectively invoked with the
                                 value returned by the function invocation:
                                      DT()
                                  as the first parameter and SV as the second parameter. The <return value> is
                                  the value of the i-th input dynamic parameter.
                              2) Otherwise, TSF is effectively invoked with SV as the first parameter. The
                                 <return value> is the value of the i-th input dynamic parameter.
                      II)     Otherwise, an exception condition is raised: dynamic SQL error — restricted
                              data type attribute violation.
                  B) Otherwise, an exception condition is raised: dynamic SQL error — data type transform
                     function violation.


Conformance Rules
1) Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain an <input using
   clause>.




966 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                                 19.11 <output using clause>



19.11 <output using clause>

Function
Supply output variables for an <SQL dynamic statement>.


Format
<output using clause> ::=
    <into arguments>
  | <into descriptor>

<into arguments> ::= INTO <into argument> [ { <comma> <into argument> }... ]

<into argument> ::= <target specification>

<into descriptor> ::= INTO [ SQL ] DESCRIPTOR <descriptor name>


Syntax Rules
1) The <target specification> immediately contained in <into argument> shall be either a <host parameter
   specification> or an <embedded variable specification>.


Access Rules
    None.


General Rules
1) If <into descriptor> is specified and an SQL descriptor area is not currently allocated whose name is the
   value of the <simple value specification> immediately contained in <descriptor name> and whose scope
   is specified by the <scope option> immediately contained in <descriptor name>, then an exception condition
   is raised: invalid SQL descriptor name.
2) When an <output using clause> is used in a <dynamic fetch statement> or as the <result using clause> of
   an <execute statement>, let PS be the prepared <dynamic select statement> referenced by the <dynamic
   fetch statement> or the prepared <dynamic single row select statement> referenced by the <execute state-
   ment>, respectively.
3) Case:
    a) If PS is a <dynamic select statement> or a <dynamic single row select statement>, then the <output
       using clause> describes the <target specification>s for the <dynamic fetch statement> or the <execute
       statement>. Let D be the degree of the table specified by PS.
    b) Otherwise, the <output using clause> describes the <target specification>s for the output <dynamic
       parameter specification>s contained in PS. Let D be the number of such output <dynamic parameter
       specification>s.



©ISO/IEC 2003 – All rights reserved                                                       Dynamic SQL 967
ISO/IEC 9075-2:2003 (E)
19.11 <output using clause>



4) If <into arguments> is specified and the number of <into argument>s is not D, then an exception condition
   is raised: dynamic SQL error — using clause does not match target specifications.
5) If <into descriptor> is specified, then:
    a) Let N be the value of COUNT.
    b) If N is greater than the value of <occurrences> specified when the SQL descriptor area identified by
       <descriptor name> was allocated or less than zero, then an exception condition is raised: dynamic SQL
       error — invalid descriptor count.
    c) If the first N item descriptor areas are not valid as specified in Subclause 19.1, “Description of SQL
       descriptor areas”, then an exception condition is raised: dynamic SQL error — using clause does not
       match target specifications.
    d) In the first N item descriptor areas, if the number of item descriptor areas in which the value of LEVEL
       is 0 (zero) is not D, then an exception condition is raised: dynamic SQL error — using clause does not
       match target specifications.

6) For 1 (one) ≤ i ≤ D:
    a) Let SDT be the effective declared type of the i-th <select list> column or output <dynamic parameter
       specification>, defined to be the type represented by the item descriptor area and its subordinate
       descriptor areas that would be set by
        Case:
        i)      If PS is a <dynamic select statement> or a <dynamic single row select statement>, then a
                <describe output statement> to reflect the description of the i-th <select list> column; let SV be
                the value of that <select list> column, with data type SDT.
        ii)     Otherwise, a <describe output statement> to reflect the description of the i-th output <dynamic
                parameter specification>; let SV be the value of that <dynamic parameter specification>, with
                data type SDT.
        NOTE 435 — “Represented by”, as applied to the relationship between a data type and an item descriptor area, is defined in
        the Syntax Rules of Subclause 19.1, “Description of SQL descriptor areas”.

    b) Case:
        i)      If <into descriptor> is specified, then let TDT be the declared type of the i-th <target specification>
                as represented by the i-th item descriptor area IDA whose LEVEL value is 0 (zero).
                NOTE 436 — “Represented by”, as applied to the relationship between a data type and an item descriptor area, is
                defined in the Syntax Rules of Subclause 19.1, “Description of SQL descriptor areas”.

        ii)     If <into arguments> is specified, then let TDT be the data type of the i-th <into argument>.
    c) If the <output using clause> is used in a <dynamic fetch statement>, then let LTDT be the data type on
       the most recently executed <dynamic fetch statement>, if any, for the cursor CR. It is implementation-
       defined whether or not an exception condition is raised: dynamic SQL error — restricted data type
       attribute violation if any of the following are true:
        i)      LTDT and TDT both identify a binary large object type and only one of LTDT and TDT is a
                binary large object locator.



968 Foundation (SQL/Foundation)                                                               ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)
                                                                                       19.11 <output using clause>



         ii)      LTDT and TDT both identify a character large object type and only one of LTDT and TDT is a
                  character large object locator.
         iii)     LTDT and TDT both identify an array type and only one of LTDT and TDT is an array locator.
         iv)      LTDT and TDT both identify a multiset type and only one of LTDT and TDT is a multiset locator.
         v)       LTDT and TDT both identify a user-defined type and only one of LTDT and TDT is a user-defined
                  type locator.
    d) Case:
         i)       If TDT is a locator type, then
                  Case:
                  1) If SV is not the null value, then a locator L that uniquely identifies SV is generated and is
                     the value TV of the i-th <target specification>.
                  2) Otherwise, the value TV of the i-th <target specification> is the null value.
         ii)      If STD and TDT are predefined data types, then
                  Case:
                  1) If the <cast specification>
                          CAST ( SV AS TDT )
                      does not conform to the Syntax Rules of Subclause 6.12, “<cast specification>”, and there
                      is an implementation-defined conversion of type STD to type TDT, then that implementation-
                      defined conversion is effectively performed, converting SV to type TDT, and the result is
                      the value TV of the i-th <target specification>.
                  2) Otherwise:
                      A) If the <cast specification>
                               CAST ( SV AS TDT )
                           does not conform to the Syntax Rules of Subclause 6.12, “<cast specification>”, then
                           an exception condition is raised: dynamic SQL error — restricted data type attribute
                           violation.
                      B) If the <cast specification>
                               CAST ( SV AS TDT )
                           does not conform to the General Rules of Subclause 6.12, “<cast specification>”, then
                           an exception condition is raised in accordance with the General Rules of Subclause 6.12,
                           “<cast specification>”.
                      C) The <cast specification>
                               CAST ( SV AS TDT )
                           is effectively performed, and is the value TV of the i-th <target specification>.



©ISO/IEC 2003 – All rights reserved                                                             Dynamic SQL 969
ISO/IEC 9075-2:2003 (E)
19.11 <output using clause>



       iii)   If SDT is a user-defined type and TDT is a predefined data type, then:
              1) Let DT be the data type identified by SDT.
              2) If the current SQL-session has a group name corresponding to the user-defined type name
                 of DT, then let GN be that group name; otherwise, let GN be the default transform group
                 name associated with the current SQL-session.
              3) Apply the Syntax Rules of Subclause 9.17, “Determination of a from-sql function”, with
                 DT and GN as TYPE and GROUP, respectively.
                  Case:
                  A) If there is an applicable from-sql function, then let FSF be that from-sql function and
                     let FSFRT be the <returns data type> of FSF.
                      Case:
                      I)      If FSFRT is compatible with TDT, then the from-sql function FSF is effectively
                              invoked with SV as its input SQL parameter and the <return value> is the value
                              TV of the i-th <target specification>.
                      II)     Otherwise, an exception condition is raised: dynamic SQL error — restricted
                              data type attribute violation.
                  B) Otherwise, an exception condition is raised: dynamic SQL error — data type transform
                     function violation.
   e) Case:
       i)     If <into descriptor> is specified, then IDA is set to reflect the value of TV as follows:
              Case:
              1) If TYPE indicates ROW, then
                  Case:
                  A) If TV is the null value, then the value of INDICATOR in IDA and in all subordinate
                     descriptor areas of IDA that are not subordinate to an item descriptor area whose TYPE
                     indicates ARRAY, ARRAY LOCATOR, MULTISET, or MULTISET LOCATOR is
                     set to –1.
                  B) Otherwise, the i-th subordinate descriptor area of IDA is set to reflect the value of the
                     i-th field of TV by applying this subrule (beginning with the outermost 'Case') to the i-th
                     subordinate descriptor area of IDA as IDA, the value of the i-th field of TV as TV, the
                     value of the i-th field of SV as SV, and the data type of the i-th field of SV as SDT.
              2) Otherwise,
                  Case:
                  A) If TV is the null value, then the value of INDICATOR is set to –1.
                  B) If TV is not the null value, then:
                      I)      The value of INDICATOR is set to 0 (zero).


970 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                              ISO/IEC 9075-2:2003 (E)
                                                                                          19.11 <output using clause>



                           II)        Case:
                                      1) If TYPE indicates a locator type, then a locator L that uniquely identifies TV
                                         is generated and the value of DATA is set to an implementation-dependent
                                         four-octet value that represents L.
                                      2) Otherwise, the value of DATA is set to TV.
                           III)       Case:
                                      1) If TYPE indicates CHARACTER VARYING or BINARY LARGE OBJECT,
                                         then RETURNED_LENGTH is set to the length in characters or octets,
                                         respectively, of TV, and RETURNED_OCTET_LENGTH is set to the length
                                         in octets of TV.
                                      2) If SDT is CHARACTER VARYING or BINARY LARGE OBJECT, then
                                         RETURNED_LENGTH is set to the length in characters or octets, respec-
                                         tively, of SV, and RETURNED_OCTET_LENGTH is set to the length in
                                         octets of SV.
                                      3) If TYPE indicates ARRAY, ARRAY LOCATOR, MULTISET, or MULTI-
                                         SET LOCATOR, then RETURNED_CARDINALITY is set to the cardinality
                                         of TV.
         ii)      If <into arguments> is specified, then the Rules in Subclause 9.1, “Retrieval assignment”, are
                  applied to TV and the i-th <into argument> as VALUE and TARGET, respectively.
         NOTE 437 — All other values of the SQL descriptor area are unchanged.


Conformance Rules
1) Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain an <output
   using clause>.




©ISO/IEC 2003 – All rights reserved                                                                Dynamic SQL 971
ISO/IEC 9075-2:2003 (E)
19.12 <execute statement>



19.12 <execute statement>

Function
Associate input SQL parameters and output targets with a prepared statement and execute the statement.


Format
<execute statement> ::=
    EXECUTE <SQL statement name> [ <result using clause> ] [ <parameter using clause> ]

<result using clause> ::= <output using clause>

<parameter using clause> ::= <input using clause>


Syntax Rules
1) If <SQL statement name> is a <statement name>, then the containing <SQL-client module definition>
   shall contain a <prepare statement> whose <statement name> is equivalent to the <statement name> of the
   <execute statement>.


Access Rules
    None.


General Rules
1) When the <execute statement> is executed, if the <SQL statement name> does not identify a prepared
   statement P, then an exception condition is raised: invalid SQL statement name.
2) Let PS be the statement previously prepared using <SQL statement name>.
3) If PS is a <dynamic select statement> that does not conform to the Format and Syntax Rules of a <dynamic
   single row select statement>, then an exception condition is raised: dynamic SQL error — cursor specification
   cannot be executed.
4) If PS contains the <table name> of a created or declared local temporary table and if the <execute statement>
   is not in the same <SQL-client module definition> as the <prepare statement> that prepared the prepared
   statement, then an exception condition is raised: syntax error or access rule violation.
5) If PS contains input <dynamic parameter specification>s and a <parameter using clause> is not specified,
   then an exception condition is raised: dynamic SQL error — using clause required for dynamic parameters.
6) If PS is a <dynamic single row select statement> or it contains output <dynamic parameter specification>s
   and a <result using clause> is not specified, then an exception condition is raised: dynamic SQL error —
   using clause required for result fields.
7) If a <parameter using clause> is specified, then the General Rules specified in Subclause 19.10, “<input
   using clause>”, for a <parameter using clause> in an <execute statement> are applied.


972 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)
                                                                                    19.12 <execute statement>



8) A copy of the top cell is pushed onto the authorization stack. If PS has an owner, then the top cell of the
   authorization stack is set to contain only the authorization identifier of the owner of PS.
9) The General Rules of Subclause 13.5, “<SQL procedure statement>”, are evaluated with PS as the executing
   statement.
10) If PS is a <preparable dynamic delete statement: positioned>, then when it is executed all General Rules
    in Subclause 19.22, “<preparable dynamic delete statement: positioned>”, apply to the <preparable state-
    ment>.
11) If PS is a <preparable dynamic update statement: positioned>, then when it is executed, all General Rules
    in Subclause 19.23, “<preparable dynamic update statement: positioned>”, apply to the <preparable state-
    ment>.
12) If a <result using clause> is specified, then the General Rules specified in Subclause 19.11, “<output using
    clause>”, for a <result using clause> in an <execute statement> are applied.
13) Upon completion of execution, the top cell in the authorization stack is removed.


Conformance Rules
1) Without Feature B032, “Extended dynamic SQL”, conforming SQL language shall not contain a <result
   using clause>.
2) Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain an <execute
   statement>.




©ISO/IEC 2003 – All rights reserved                                                         Dynamic SQL 973
ISO/IEC 9075-2:2003 (E)
19.13 <execute immediate statement>



19.13 <execute immediate statement>

Function
Dynamically prepare and execute a preparable statement.


Format
<execute immediate statement> ::=
    EXECUTE IMMEDIATE <SQL statement variable>


Syntax Rules
1) The declared type of <SQL statement variable> shall be character string.


Access Rules
    None.


General Rules
1) Let P be the contents of the <SQL statement variable>.
2) If one or more of the following are true, then an exception condition is raised: syntax error or access rule
   violation.
    a) P is a <dynamic select statement> or a <dynamic single row select statement>.
    b) P contains a <dynamic parameter specification>.
3) Let SV be <SQL statement variable>. <execute immediate statement> is equivalent to the following:
       PREPARE IMMEDIATE_STMT FROM SV ;
       EXECUTE IMMEDIATE_STMT ;
       DEALLOCATE PREPARE IMMEDIATE_STMT ;

    where IMMEDIATE_STMT is an implementation-defined <statement name> that is not equivalent to any
    other <statement name> in the containing <SQL-client module definition>.
    NOTE 438 — Exception condition or completion condition information resulting from the PREPARE or EXECUTE is reflected
    in the diagnostics area.


Conformance Rules
1) Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain an <execute
   immediate statement>.




974 Foundation (SQL/Foundation)                                                         ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                             19.14 <dynamic declare cursor>



19.14 <dynamic declare cursor>

Function
Declare a cursor to be associated with a <statement name>, which may in turn be associated with a <cursor
specification>.


Format
<dynamic declare cursor> ::=
    DECLARE <cursor name> [ <cursor sensitivity> ] [ <cursor scrollability> ] CURSOR
    [ <cursor holdability> ]
    [ <cursor returnability> ]
    FOR <statement name>


Syntax Rules
1) The <cursor name> shall not be identical to the <cursor name> specified in any other <declare cursor> or
   <dynamic declare cursor> in the same <SQL-client module definition>.
2) The containing <SQL-client module definition> shall contain a <prepare statement> whose <statement
   name> is equivalent to the <statement name> of the <dynamic declare cursor>.
3) If <cursor scrollability> is not specified, then NO SCROLL is implicit.
4) If <cursor holdability> is not specified, then WITHOUT HOLD is implicit.
5) If <cursor returnability> is not specified, then WITHOUT RETURN is implicit.


Access Rules
    None.


General Rules
1) All General Rules of Subclause 14.1, “<declare cursor>”, apply to <dynamic declare cursor>, replacing
   “<cursor specification>” with “prepared statement”.


Conformance Rules
1) Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain a <dynamic
   declare cursor>.




©ISO/IEC 2003 – All rights reserved                                                      Dynamic SQL 975
ISO/IEC 9075-2:2003 (E)
19.15 <allocate cursor statement>



19.15 <allocate cursor statement>

Function
Define a cursor based on a prepared statement for a <cursor specification> or assign a cursor to the ordered set
of result sets returned from an SQL-invoked procedure.


Format
<allocate cursor statement> ::=
    ALLOCATE <extended cursor name> <cursor intent>

<cursor intent> ::=
    <statement cursor>
  | <result set cursor>

<statement cursor> ::=
    [ <cursor sensitivity> ] [ <cursor scrollability> ] CURSOR
    [ <cursor holdability> ]
    [ <cursor returnability> ]
    FOR <extended statement name>

<result set cursor> ::= FOR PROCEDURE <specific routine designator>


Syntax Rules
1) If <result set cursor> is specified, then the SQL-invoked routine identified by <specific routine designator>
   shall be an SQL-invoked procedure.


Access Rules
    None.


General Rules
1) Let S be the <simple value specification> immediately contained in <extended cursor name>. Let V be the
   character string that is the result of
      TRIM ( BOTH ' ' FROM S )
    If V does not conform to the Format and Syntax Rules of an <identifier>, then an exception condition is
    raised: invalid cursor name.
2) If the value of the <extended cursor name> is identical to the value of the <extended cursor name> of any
   other cursor allocated in the scope of the <extended cursor name>, then an exception condition is raised:
   invalid cursor name.
3) If <statement cursor> is specified, then:



976 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                19.15 <allocate cursor statement>



    a) When the <allocate cursor statement> is executed, if the value of the <extended statement name> does
       not identify a statement previously prepared in the scope of the <extended statement name>, then an
       exception condition is raised: invalid SQL statement name.
    b) If the prepared statement associated with the <extended statement name> is not a <cursor specification>,
       then an exception condition is raised: dynamic SQL error — prepared statement not a cursor specifi-
       cation.
    c) All General Rules of Subclause 14.1, “<declare cursor>”, apply to <allocate cursor statement>,
       replacing “<open statement>” with “<dynamic open statement>” and “<cursor specification>” with
       “prepared statement”.
    d) An association is made between the value of the <extended cursor name> and the prepared statement
       in the scope of the <extended cursor name>. The association is preserved until the prepared statement
       is destroyed, at which time the cursor identified by <extended cursor name> is also destroyed.
4) If <result set cursor> is specified, then:
    a) When the <allocate cursor statement> is executed, if the <specific routine designator> does not identify
       an SQL-invoked procedure P that has been previously invoked during the current SQL-session, an
       exception condition is raised: invalid SQL-invoked procedure reference.
    b) If P did not return any result sets, then an exception condition is raised: no data — no additional dynamic
       result sets returned.
    c) Let RRS be the ordered set of result sets returned by P.
    d) When the <allocate cursor statement> is executed, an association is made between the <extended cursor
       name> and the first result set FRS in RRS. The definition of FRS is the definition of the <cursor speci-
       fication> CS in P that created FRS. Let CR be the cursor declared by the <declare cursor> that contains
       CS.
    e) Let T be the table specified by CS. T is the first result set returned from P.
    f) A table descriptor for T is effectively created.
    g) Cursor CR is placed in the open state.
         Case:
         i)       If CR is scrollable, then let CRCN be the <cursor name> of CR in P. The position of CR in T is
                  before the row that would be retrieved if the following SQL-statement were executed in P:
                     FETCH NEXT FROM CRCNi INTO...

         ii)      Otherwise, the position of CR is before the first row of T.


Conformance Rules
1) Without Feature B032, “Extended dynamic SQL”, conforming SQL language shall not contain an <allocate
   cursor statement>.




©ISO/IEC 2003 – All rights reserved                                                           Dynamic SQL 977
ISO/IEC 9075-2:2003 (E)
19.16 <dynamic open statement>



19.16 <dynamic open statement>

Function
Associate input dynamic parameters with a <cursor specification> and open the cursor.


Format
<dynamic open statement> ::= OPEN <dynamic cursor name> [ <input using clause> ]


Syntax Rules
1) If <dynamic cursor name> DCN is a <cursor name> CN, then the containing <SQL-client module definition>
   shall contain a <dynamic declare cursor> whose <cursor name> is CN.


Access Rules
1) The Access Rules for the <query expression> simply contained in the prepared statement associated with
   the <dynamic cursor name> are applied.


General Rules
1) If <dynamic cursor name> is a <cursor name> and the <statement name> of the associated <dynamic
   declare cursor> is not associated with a prepared statement, then an exception condition is raised: invalid
   SQL statement name.
2) If <dynamic cursor name> is an <extended cursor name> whose value does not identify a cursor allocated
   in the scope of the <extended cursor name>, then an exception condition is raised: invalid cursor name.
3) If the prepared statement associated with the <dynamic cursor name> contains <dynamic parameter speci-
   fication>s and an <input using clause> is not specified, then an exception condition is raised: dynamic SQL
   error — using clause required for dynamic parameters.
4) The cursor specified by <dynamic cursor name> is updatable if and only if the associated <cursor specifi-
   cation> specified an updatable cursor.
    NOTE 439 — “updatable cursor” is defined in Subclause 14.1, “<declare cursor>”.

5) If an <input using clause> is specified, then the General Rules specified in Subclause 19.10, “<input using
   clause>”, for <dynamic open statement> are applied.
6) All General Rules of Subclause 14.2, “<open statement>”, apply to the <dynamic open statement>.


Conformance Rules
1) Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain a <dynamic
   open statement>.



978 Foundation (SQL/Foundation)                                                       ©ISO/IEC 2003 – All rights reserved
                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                            19.17 <dynamic fetch statement>



19.17 <dynamic fetch statement>

Function
Fetch a row for a cursor declared with a <dynamic declare cursor>.


Format
<dynamic fetch statement> ::=
    FETCH [ [ <fetch orientation> ] FROM ] <dynamic cursor name> <output using clause>


Syntax Rules
1) If <fetch orientation> is omitted, then NEXT is implicit.
2) If <dynamic cursor name> DCN is a <cursor name> CN, then the containing <SQL-client module definition>
   shall contain a <dynamic declare cursor> whose <cursor name> is CN.
3) Let CR be the cursor identified by DCN.
4) If the implicit or explicit <fetch orientation> is not NEXT, then the <dynamic declare cursor> or <allocate
   cursor statement> associated with CR shall specify SCROLL.


Access Rules
    None.


General Rules
1) All General Rules of Subclause 14.3, “<fetch statement>”, are applied to cursor CR, <fetch orientation>,
   and an empty <fetch target list>.
2) The General Rules of Subclause 19.11, “<output using clause>”, are applied to the <dynamic fetch statement>
   and the current row of CR as the retrieved row.


Conformance Rules
1) Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain a <dynamic
   fetch statement>.




©ISO/IEC 2003 – All rights reserved                                                       Dynamic SQL 979
ISO/IEC 9075-2:2003 (E)
19.18 <dynamic single row select statement>



19.18 <dynamic single row select statement>

Function
Retrieve values from a dynamically-specified row of a table.


Format
<dynamic single row select statement> ::= <query specification>


Syntax Rules
    None.


Access Rules
    None.


General Rules
1) Let Q be the result of the <query specification>.
2) Case:
    a) If the cardinality of Q is greater than 1 (one), then an exception condition is raised: cardinality violation.
    b) If Q is empty, then a completion condition is raised: no data.


Conformance Rules
1) Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain a <dynamic
   single row select statement>.




980 Foundation (SQL/Foundation)                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                ISO/IEC 9075-2:2003 (E)
                                                                         19.19 <dynamic close statement>



19.19 <dynamic close statement>

Function
Close a cursor.


Format
<dynamic close statement> ::= CLOSE <dynamic cursor name>


Syntax Rules
1) If <dynamic cursor name> DCN is a <cursor name> CN, then the containing <SQL-client module definition>
   shall contain a <dynamic declare cursor> whose <cursor name> is CN.


Access Rules
    None.


General Rules
1) All General Rules of Subclause 14.4, “<close statement>”, apply to the <dynamic close statement>.


Conformance Rules
1) Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain a <dynamic
   close statement>.




©ISO/IEC 2003 – All rights reserved                                                    Dynamic SQL 981
ISO/IEC 9075-2:2003 (E)
19.20 <dynamic delete statement: positioned>



19.20 <dynamic delete statement: positioned>

Function
Delete a row of a table.


Format
<dynamic delete statement: positioned> ::=
    DELETE FROM <target table> WHERE CURRENT OF <dynamic cursor name>


Syntax Rules
1) If <dynamic cursor name> DCN is a <cursor name> CN, then the containing <SQL-client module definition>
   shall contain a <dynamic declare cursor> whose <cursor name> is CN.


Access Rules
1) All Access Rules of Subclause 14.6, “<delete statement: positioned>”, apply to the <dynamic delete state-
   ment: positioned>.


General Rules
1) If DCN is a <cursor name> and the <statement name> of the associated <dynamic declare cursor> is not
   associated with a prepared statement, then an exception condition is raised: invalid SQL statement name.
2) If DCN is an <extended cursor name> whose value does not identify a cursor allocated in the scope of the
   <extended cursor name>, then an exception condition is raised: invalid cursor name.
3) Let CR be the cursor identified by DCN.
4) If CR is not an updatable cursor, then an exception condition is raised: invalid cursor name.
5) Let T be the simply underlying table of CR. T is the subject table of the <dynamic delete statement: posi-
   tioned>. Let LUT be the leaf underlying table of T such that T is one-to-one with LUT. Let LUTN be a
   <table name> that identifies LUT.
6) Let TN be the <table name> contained in <target table>. If TN does not identify LUTN, or if ONLY is
   specified and the <table reference> in T that references LUT does not specify ONLY, or if ONLY is not
   specified and the <table reference> in T that references LUT does specify ONLY, then an exception condition
   is raised: target table disagrees with cursor specification.
7) All General Rules of Subclause 14.6, “<delete statement: positioned>”, apply to the <dynamic delete
   statement: positioned>, replacing “<delete statement: positioned>” with “<dynamic delete statement:
   positioned>”.




982 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                             ISO/IEC 9075-2:2003 (E)
                                                          19.20 <dynamic delete statement: positioned>



Conformance Rules
1) Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain a <dynamic
   delete statement: positioned>.




©ISO/IEC 2003 – All rights reserved                                                Dynamic SQL 983
ISO/IEC 9075-2:2003 (E)
19.21 <dynamic update statement: positioned>



19.21 <dynamic update statement: positioned>

Function
Update a row of a table.


Format
<dynamic update statement: positioned> ::=
    UPDATE <target table> SET <set clause list>
    WHERE CURRENT OF <dynamic cursor name>


Syntax Rules
1) If <dynamic cursor name> DCN is a <cursor name> CN, then the containing <SQL-client module definition>
   shall contain a <dynamic declare cursor> whose <cursor name> is CN.
2) The scope of the <table name> is the entire <dynamic update statement: positioned>.


Access Rules
1) All Access Rules of Subclause 14.10, “<update statement: positioned>”, apply to the <dynamic update
   statement: positioned>.


General Rules
1) If DCN is a <cursor name> and the <statement name> of the associated <dynamic declare cursor> is not
   associated with a prepared statement, then an exception condition is raised: invalid SQL statement name.
2) If DCN is an <extended cursor name> whose value does not identify a cursor allocated in the scope of the
   <extended cursor name>, then an exception condition is raised: invalid cursor name.
3) Let CR be the cursor identified by DCN.
4) If CR is not an updatable cursor, then an exception condition is raised: invalid cursor name.
5) Let T be the simply underlying table of CR. T is the subject table of the <dynamic update statement: posi-
   tioned>. Let LUT be the leaf underlying table of T such that T is one-to-one with LUT. Let LUTN be a
   <table name> that identifies LUT.
6) Let TN be the <table name> contained in <target table>. If TN does not identify LUTN, or if ONLY is
   specified and the <table reference> in T that references LUT does not specify ONLY, or if ONLY is not
   specified and the <table reference> in T that references LUT does specify ONLY, then an exception condition
   is raised: target table disagrees with cursor specification.
7) If any object column is directly or indirectly referenced in the <order by clause> of the <cursor specification>
   for CR, then an exception condition is raised: attempt to assign to ordering column.




984 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                 19.21 <dynamic update statement: positioned>



8) If any object column identifies a column that is not identified by a <column name> contained in the explicit
   or implicit <column name list> of the explicit or implicit <updatability clause> of the <cursor specification>
   for CR, then an exception condition is raised: attempt to assign to non-updatable column.
9) All General Rules of Subclause 14.10, “<update statement: positioned>”, apply to the <dynamic update
   statement: positioned>, replacing “<cursor name>” with “<dynamic cursor name>” and “<update statement:
   positioned>” with “<dynamic update statement: positioned>”.


Conformance Rules
1) Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain a <dynamic
   update statement: positioned>.




©ISO/IEC 2003 – All rights reserved                                                          Dynamic SQL 985
ISO/IEC 9075-2:2003 (E)
19.22 <preparable dynamic delete statement: positioned>



19.22 <preparable dynamic delete statement: positioned>

Function
Delete a row of a table through a dynamic cursor.


Format
<preparable dynamic delete statement: positioned> ::=
    DELETE [ FROM <target table> ]
    WHERE CURRENT OF [ <scope option> ] <cursor name>


Syntax Rules
1) If <target table> is not specified, then let QE be the <query expression> simply contained in the <cursor
   specification> identified by <cursor name>. Let LUT be the leaf underlying table of QE such that QE is
   one-to-one with respect to QE. Let TN be the name of LUT.
    Case:
    a) If the <table reference> that references LUT specifies ONLY, then the <target table>
            ONLY ( TN )
        is implicit.
    b) Otherwise, the <target table>
            TN
        is implicit.
2) All Syntax Rules of Subclause 14.6, “<delete statement: positioned>”, apply to the <preparable dynamic
   delete statement: positioned>, replacing “<declare cursor>” with “<dynamic declare cursor> or <allocate
   cursor statement>” and “<delete statement: positioned>” with “<preparable dynamic delete statement:
   positioned>”.


Access Rules
1) All Access Rules of Subclause 14.6, “<delete statement: positioned>”, apply to the <preparable dynamic
   delete statement: positioned>.


General Rules
1) All General Rules of Subclause 14.6, “<delete statement: positioned>”, apply to the <preparable dynamic
   delete statement: positioned>, replacing “<delete statement: positioned>” with “<preparable dynamic delete
   statement: positioned>”.




986 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                              ISO/IEC 9075-2:2003 (E)
                                                19.22 <preparable dynamic delete statement: positioned>



Conformance Rules
1) Without Feature B032, “Extended dynamic SQL”, conforming SQL language shall not contain a
   <preparable dynamic delete statement: positioned>.




©ISO/IEC 2003 – All rights reserved                                                 Dynamic SQL 987
ISO/IEC 9075-2:2003 (E)
19.23 <preparable dynamic update statement: positioned>



19.23 <preparable dynamic update statement: positioned>

Function
Update a row of a table through a dynamic cursor.


Format
<preparable dynamic update statement: positioned> ::=
    UPDATE [ <target table> ] SET <set clause list>
    WHERE CURRENT OF [ <scope option> ] <cursor name>


Syntax Rules
1) If <target table> is not specified, then let QE be the <query expression> simply contained in the <cursor
   specification> identified by <cursor name>. Let LUT be the leaf underlying table of QE such that QE is
   one-to-one with respect to LUT. Let TN be the name of LUT.
    Case:
    a) If the <table reference> that references LUT specifies ONLY, then the <target table>
            ONLY ( TN )
        is implicit.
    b) Otherwise, the <target table>
            TN
        is implicit.
2) All Syntax Rules of Subclause 14.10, “<update statement: positioned>”, apply to the <preparable dynamic
   update statement: positioned>, replacing “<declare cursor>” with “<dynamic declare cursor> or <allocate
   cursor statement>” and “<update statement: positioned>” with “<preparable dynamic update statement:
   positioned>”.


Access Rules
1) All Access Rules of Subclause 14.10, “<update statement: positioned>”, apply to the <preparable dynamic
   update statement: positioned>.


General Rules
1) All General Rules of Subclause 14.10, “<update statement: positioned>”, apply to the <preparable dynamic
   update statement: positioned>, replacing “<update statement: positioned>” with “<preparable dynamic
   update statement: positioned>”.




988 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                             ISO/IEC 9075-2:2003 (E)
                                               19.23 <preparable dynamic update statement: positioned>



Conformance Rules
1) Without Feature B032, “Extended dynamic SQL”, conforming SQL language shall not contain a
   <preparable dynamic update statement: positioned>.




©ISO/IEC 2003 – All rights reserved                                                Dynamic SQL 989
ISO/IEC 9075-2:2003 (E)




                                  This page intentionally left blank.




990 Foundation (SQL/Foundation)                                         ©ISO/IEC 2003 – All rights reserved
                                                                    ISO/IEC 9075-2:2003 (E)
                                                          20.1 <embedded SQL host program>




20 Embedded SQL


20.1 <embedded SQL host program>

Function
Specify an <embedded SQL host program>.


Format
<embedded SQL       host program> ::=
    <embedded       SQL Ada program>
  | <embedded       SQL C program>
  | <embedded       SQL COBOL program>
  | <embedded       SQL Fortran program>
  | <embedded       SQL MUMPS program>
  | <embedded       SQL Pascal program>
  | <embedded       SQL PL/I program>

<embedded SQL statement> ::=
    <SQL prefix> <statement or declaration> [ <SQL terminator> ]

<statement or declaration> ::=
    <declare cursor>
  | <dynamic declare cursor>
  | <temporary table declaration>
  | <embedded authorization declaration>
  | <embedded path specification>
  | <embedded transform group specification>
  | <embedded collation specification>
  | <embedded exception declaration>
  | <SQL procedure statement>

<SQL prefix> ::=
    EXEC SQL
  | <ampersand>SQL<left paren>

<SQL terminator> ::=
    END-EXEC
  | <semicolon>
  | <right paren>

<embedded authorization declaration> ::= DECLARE <embedded authorization clause>

<embedded authorization clause> ::=
    SCHEMA <schema name>
  | AUTHORIZATION <embedded authorization identifier>
    [ FOR STATIC { ONLY | AND DYNAMIC } ]




©ISO/IEC 2003 – All rights reserved                                     Embedded SQL 991
ISO/IEC 9075-2:2003 (E)
20.1 <embedded SQL host program>



  | SCHEMA <schema name> AUTHORIZATION <embedded authorization identifier>
    [ FOR STATIC { ONLY | AND DYNAMIC } ]

<embedded authorization identifier> ::=
    <module authorization identifier>

<embedded path specification> ::= <path specification>

<embedded transform group specification> ::=
    <transform group specification>

<embedded collation specification> ::= <module collations>

<embedded SQL declare section> ::=
    <embedded SQL begin declare>
    [ <embedded character set declaration> ]
    [ <host variable definition>... ]
    <embedded SQL end declare>
  | <embedded SQL MUMPS declare>

<embedded character set declaration> ::=
    SQL NAMES ARE <character set specification>

<embedded SQL begin declare> ::=
    <SQL prefix> BEGIN DECLARE SECTION [ <SQL terminator> ]

<embedded SQL end declare> ::=
    <SQL prefix> END DECLARE SECTION [ <SQL terminator> ]

<embedded SQL MUMPS declare> ::=
    <SQL prefix>
    BEGIN DECLARE SECTION
    [ <embedded character set declaration> ]
    [ <host variable definition>... ]
    END DECLARE SECTION
    <SQL terminator>

<host variable definition> ::=
    <Ada variable definition>
  | <C variable definition>
  | <COBOL variable definition>
  | <Fortran variable definition>
  | <MUMPS variable definition>
  | <Pascal variable definition>
  | <PL/I variable definition>

<embedded variable name> ::= <colon><host identifier>

<host identifier> ::=
    <Ada host identifier>
  | <C host identifier>
  | <COBOL host identifier>
  | <Fortran host identifier>
  | <MUMPS host identifier>
  | <Pascal host identifier>
  | <PL/I host identifier>




992 Foundation (SQL/Foundation)                                  ©ISO/IEC 2003 – All rights reserved
                                                                                            ISO/IEC 9075-2:2003 (E)
                                                                                  20.1 <embedded SQL host program>



Syntax Rules
1) An <embedded SQL host program> is a compilation unit that consists of programming language text and
   SQL text. The programming language text shall conform to the requirements of a specific standard program-
   ming language. The SQL text shall consist of one or more <embedded SQL statement>s and, optionally,
   one or more <embedded SQL declare section>s, as defined in this International Standard.
    NOTE 440 — “Compilation unit” is defined in Subclause 4.22, “SQL-client modules”.

2) Case:
    a) An <embedded SQL statement> or <embedded SQL MUMPS declare> that is contained in an
       <embedded SQL MUMPS program> shall contain an <SQL prefix> that is “<ampersand>SQL<left
       paren>”. There shall be no <separator> between the <ampersand> and “SQL” nor between “SQL” and
       the <left paren>.
    b) An <embedded SQL statement>, <embedded SQL begin declare>, or <embedded SQL end declare>
       that is not contained in an <embedded SQL MUMPS program> shall contain an <SQL prefix> that is
       “EXEC SQL”.
3) Case:
    a) An <embedded SQL statement>, <embedded SQL begin declare>, or <embedded SQL end declare>
       contained in an <embedded SQL COBOL program> shall contain an <SQL terminator> that is
       END-EXEC.
    b) An <embedded SQL statement>, <embedded SQL begin declare>, or <embedded SQL end declare>
       contained in an <embedded SQL Fortran program> shall not contain an <SQL terminator>.
    c) An <embedded SQL statement>, <embedded SQL begin declare>, or <embedded SQL end declare>
       contained in an <embedded SQL Ada program>, <embedded SQL C program>, <embedded SQL
       Pascal program>, or <embedded SQL PL/I program> shall contain an <SQL terminator> that is a
       <semicolon>.
    d) An <embedded SQL statement> or <embedded SQL MUMPS declare> that is contained in an
       <embedded SQL MUMPS program> shall contain an <SQL terminator> that is a <right paren>.
4) Case:
    a) An <embedded SQL declare section> that is contained in an <embedded SQL MUMPS program> shall
       be an <embedded SQL MUMPS declare>.
    b) An <embedded SQL declare section> that is not contained in an <embedded SQL MUMPS program>
       shall not be an <embedded SQL MUMPS declare>.
    NOTE 441 — There is no restriction on the number of <embedded SQL declare section>s that may be contained in an <embedded
    SQL host program>.

5) The <token>s comprising an <SQL prefix>, <embedded SQL begin declare>, or <embedded SQL end
   declare> shall be separated by <space> characters and shall be specified on one line. Otherwise, the rules
   for the continuation of lines and tokens from one line to the next and for the placement of host language
   comments are those of the programming language of the containing <embedded SQL host program>.
6) If an <embedded authorization declaration> appears in an <embedded SQL host program>, then it shall be
   contained in the first <embedded SQL statement> of that <embedded SQL host program>.



©ISO/IEC 2003 – All rights reserved                                                                  Embedded SQL 993
ISO/IEC 9075-2:2003 (E)
20.1 <embedded SQL host program>



7) An <embedded SQL host program> shall not contain more than one <embedded path specification>.
8) An <embedded SQL host program> shall not contain more than one <embedded transform group specifi-
   cation>.
9) An <embedded SQL host program> shall not contain more than one <embedded collation specification>.
10) Case:
    a) If <embedded transform group specification> is not specified, then an <embedded transform group
       specification> containing a <multiple group specification> with a <group specification> GS for each
       <host variable definition> that has an associated user-defined type UDT, but is not a user-defined
       locator variable is implicit. The <group name> of GS is implementation-defined and its <path-resolved
       user-defined type name> is the <user-defined type name> of UDT.
    b) If <embedded transform group specification> contains a <single group specification> with a <group
       name> GN, then an <embedded transform group specification> containing a <multiple group specifi-
       cation> with a <group specification> GS for each <host variable definition> that has an associated
       user-defined type UDT, but is not a user-defined type locator variable is implicit. The <group name>
       of GS is GN and its <path-resolved user-defined type name> is the <user-defined type name> of UDT.
    c) If <embedded transform group specification> contains a <multiple group specification> MGS, then an
       <embedded transform group specification> containing a <multiple group specification> that contains
       MGS extended with a <group specification> GS for each <host variable definition> that has an associated
       user-defined type UDT, but is not a user-defined locator variable and no equivalent of UDT is contained
       in any <group specification> contained in MGS is implicit. The <group name> of GS is implementation-
       defined and its <path-resolved user-defined type name> is the <user-defined type name> of UDT.
11) In the text of the <embedded SQL host program>, the implicit or explicit <embedded transform group
    specification> shall precede every <host variable definition>.
12) An <embedded SQL host program> shall contain no more than one <embedded character set declaration>.
    If an <embedded character set declaration> is not specified, then an <embedded character set declaration>
    that specifies an implementation-defined character set that contains at least every character that is in <SQL
    language character> is implicit.
13) A <temporary table declaration> that is contained in an <embedded SQL host program> shall precede in
    the text of that <embedded SQL host program> any SQL-statement or <declare cursor> that references the
    <table name> of the <temporary table declaration>.
14) A <declare cursor> that is contained in an <embedded SQL host program> shall precede in the text of that
    <embedded SQL host program> any SQL-statement that references the <cursor name> of the <declare
    cursor>.
15) A <dynamic declare cursor> that is contained in an <embedded SQL host program> shall precede in the
    text of that <embedded SQL host program> any SQL-statement that references the <cursor name> of the
    <dynamic declare cursor>.
16) Any <host identifier> that is contained in an <embedded SQL statement> in an <embedded SQL host
    program> shall be defined in exactly one <host variable definition> contained in that <embedded SQL host
    program>. In programming languages that support <host variable definition>s in subprograms, two <host
    variable definition>s with different, non-overlapping scope in the host language are to be regarded as
    defining different host variables, even if they specify the same variable name. That <host variable definition>
    shall appear in the text of the <embedded SQL host program> prior to any <embedded SQL statement>


994 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                               20.1 <embedded SQL host program>



    that references the <host identifier>. The <host variable definition> shall be such that a host language ref-
    erence to the <host identifier> is valid at every <embedded SQL statement> that contains the <host identi-
    fier>.
17) A <host variable definition> defines the host language data type of the <host identifier>. For every such
    host language data type an equivalent SQL <data type> is specified in Subclause 20.3, “<embedded SQL
    Ada program>”, Subclause 20.4, “<embedded SQL C program>”, Subclause 20.5, “<embedded SQL
    COBOL program>”, Subclause 20.6, “<embedded SQL Fortran program>”, Subclause 20.7, “<embedded
    SQL MUMPS program>”, Subclause 20.8, “<embedded SQL Pascal program>”, and Subclause 20.9,
    “<embedded SQL PL/I program>”.
18) An <embedded SQL host program> shall contain a <host variable definition> that specifies SQLSTATE.
19) If one or more <host variable definition>s that specify SQLSTATE appear in an <embedded SQL host
    program>, then the <host variable definition>s shall be such that a host language reference to SQLSTATE
    is valid at every <embedded SQL statement>, including <embedded SQL statement>s that appear in any
    subprograms contained in that <embedded SQL host program>. The first such <host variable definition>
    of SQLSTATE shall appear in the text of the <embedded SQL host program> prior to any <embedded SQL
    statement>.
20) Given an <embedded SQL host program> H, there is an implied standard-conforming <SQL-client module
    definition> M and an implied standard-conforming host program P derived from H. The derivation of the
    implied program P and the implied <SQL-client module definition> M of an <embedded SQL host program>
    H effectively precedes the processing of any host language program text manipulation commands such as
    inclusion or copying of text.
    NOTE 442 — Before H can be executed, M is processed by an implementation-defined mechanism to produce an SQL-client
    module. An SQL-implementation may combine this mechanism with the processing of the <embedded SQL host program>, in
    which the existence of M is pure hypothetical.

    Given an <embedded SQL host program> H with an implied <SQL-client module definition> M and an
    implied program P defined as above:
    a) The implied <SQL-client module definition> M of H shall be a standard-conforming <SQL-client
       module definition>.
    b) If H is an <embedded SQL Ada program>, an <embedded SQL C program>, an <embedded SQL
       COBOL program>, an <embedded SQL Fortran program>, an <embedded SQL MUMPS program>,
       an <embedded SQL Pascal program>, or an <embedded SQL PL/I program>, then the implied program
       P shall be a standard-conforming Ada program, a standard-conforming C program, a standard-conforming
       COBOL program, a standard-conforming Fortran program, a standard-conforming M program, a
       standard-conforming Pascal program, or standard-conforming PL/I program, respectively.
21) M is derived from H as follows:
    a) M contains a <module name clause> whose <SQL-client module name> is either implementation-
       dependent or is omitted.
    b) M contains a <module character set specification> that is identical to the explicit or implicit <embedded
       character set declaration> with the keyword “SQL” removed.
    c) M contains a <language clause> that specifies either ADA, C, COBOL, FORTRAN, M, PASCAL, or
       PLI, where H is respectively an <embedded SQL Ada program>, an <embedded SQL C program>, an




©ISO/IEC 2003 – All rights reserved                                                              Embedded SQL 995
ISO/IEC 9075-2:2003 (E)
20.1 <embedded SQL host program>



       <embedded SQL COBOL program>, an <embedded SQL Fortran program>, an <embedded SQL
       MUMPS program>, an <embedded SQL Pascal program>, or an <embedded SQL PL/I program>.
   d) Case:
       i)     If H contains an <embedded authorization declaration> EAD, then let EAC be the <embedded
              authorization clause>contained in EAD; M contains a <module authorization clause> that spec-
              ifies EAC.
       ii)    Otherwise, let SN be an implementation-defined <schema name>; M contains a <module
              authorization clause> that specifies “SCHEMA SN”.
   e) Case:
       i)     If H contains an <embedded path specification> EPS, then M contains the <module path speci-
              fication> EPS.
       ii)    Otherwise, M contains an implementation-defined <module path specification>.
   f) M contains a <module transform group specification> that is identical to the explicit or implicit
      <embedded transform group specification>.
   g) If an <embedded collation specification> ECS is specified, then M contains a <module collations> that
      is identical to the <module collations> contained in ECS.
   h) For every <declare cursor> EC contained in H, M contains one <declare cursor> PC and one <externally-
      invoked procedure> PS that contains an <open statement> that references PC.
       i)     The <procedure name> of PS is implementation-dependent. PS contains a <host parameter
              declaration> PD for each distinct <embedded variable name> EVN contained in PC with an
              implementation-dependent <host parameter name> PN and the <host parameter data type> PT,
              determined as follows:
              Case:
              1) If EVN identifies a binary large object locator variable, then PT is BLOB AS LOCATOR.
              2) If EVN identifies a character large object locator variable, then PT is CLOB AS LOCATOR.
              3) If EVN identifies an array locator variable, then PT is AAT AS LOCATOR, where AAT is
                 the associated array type of V.
              4) If EVN identifies a multiset locator variable, then PT is AMT AS LOCATOR, where AMT
                 is the associated multiset type of V.
              5) If EVN identifies a user-defined type locator variable, then PT is UDT AS LOCATOR,
                 where UDT is the associated user-defined type of V.
              6) Otherwise, PT is the SQL data type that corresponds to the host language data type of EVN
                 as specified in Subclause 13.6, “Data type correspondences”.
       ii)    PS contains a <host parameter declaration> that specifies SQLSTATE. The order of <host
              parameter declaration>s in PS is implementation-dependent. PC is a copy of EC in which each
              EVN has been replaced as follows:
              Case:


996 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                             20.1 <embedded SQL host program>



                  1) If EVN does not identify user-defined type locator variable, but EVN identifies a host variable
                     that has an associated user-defined type UT, then:
                      A) Let GN be the <group name> corresponding to the <user-defined type name> of UT
                         contained in <group specification> contained in <embedded transform group specifica-
                         tion>.
                      B) Apply the Syntax Rules of Subclause 9.19, “Determination of a to-sql function”, with
                         DT and GN as TYPE and GROUP, respectively. There shall be an applicable to-sql
                         function TSF.
                      C) Let the declared type of the single SQL parameter of TSF be TPT. PT shall be assignable
                         to TPT.
                      D) EVN is replaced by:
                               TSFN(CAST(PN AS TPT))

                  2) Otherwise, EVN is replaced by:
                          PN

    i)   For every <dynamic declare cursor> EC in H, M contains one <dynamic declare cursor> PC that is a
         copy of EC.
    j)   M contains one <temporary table declaration> for each <temporary table declaration> contained in H.
         Each <temporary table declaration> of M is a copy of the corresponding <temporary table declaration>
         of H.
    k) M contains one <embedded exception declaration> for each <embedded exception declaration> contained
       in H. Each <embedded exception declaration> of M is a copy of the corresponding <embedded
       exception declaration> of H.
    l)   M contains an <externally-invoked procedure> for each <SQL procedure statement> contained in H.
         The <externally-invoked procedure> PS of M corresponding with an <SQL procedure statement> ES
         of H is defined as follows.
         Case:
         i)       If ES is not an <open statement>, then:
                  1) The <procedure name> of PS is implementation-dependent.
                  2) Let n be the number of distinct <embedded variable name>s contained in ES. Let HVNi, 1
                      (one) ≤ i ≤ n, be the i-th such <embedded variable name> and let HVi be the host variable
                      identified by HVNi.

                  3) For each HVNi, 1 (one) ≤ i ≤ n, PS contains a <host parameter declaration> PDi defining a
                     host parameter Pi such that:

                      A) The <host parameter name> PNi of PDi is implementation-dependent.

                      B) The <host parameter data type> PTi of PDi is determined as follows.


©ISO/IEC 2003 – All rights reserved                                                           Embedded SQL 997
ISO/IEC 9075-2:2003 (E)
20.1 <embedded SQL host program>



                     Case:
                     I)      If HVi is a binary large object locator variable, then PTi is BLOB AS LOCATOR.

                     II)     If HVi is a character large object locator variable, then PTi is CLOB AS LOCA-
                             TOR.
                     III)    If HVi is an array locator variable, then PTi is AAT AS LOCATOR, where AAT
                             is the associated array type of HVi.

                     IV)     If HVi is a multiset locator variable, then PTi is AMT AS LOCATOR, where AMT
                             is the associated multiset type of HVi.

                     V)      If HVi is user-defined type locator variable, then PTi is UDT AS LOCATOR,
                             where UDT is the associated user-defined type of HVi.

                     VI)     Otherwise, PTi is the SQL data type that corresponds to the host language data
                             type of HVi as specified in Subclause 13.6, “Data type correspondences”.

             4) PS contains a <host parameter declaration> that specifies SQLSTATE.

             5) The order of the <host parameter declaration>s PDi, 1 (one) ≤ i ≤ n, is implementation-
                dependent.

             6) For each HVNi, 1 (one) ≤ i ≤ n, that identifies some HVi that has an associated user-defined
                type, but is not a user-defined type locator variable, apply the Syntax Rules of Subclause 9.6,
                “Host parameter mode determination”, with the PDi corresponding to HVNi and ES as <host
                parameter declaration> and <SQL procedure statement>, respectively, to determine whether
                the corresponding Pi is an input host parameter, an output host parameter, or both an input
                host parameter and an output host parameter.

                 A) Among Pi, 1 (one) ≤ i ≤ n, let a be the number of input host parameters, b be the number
                    of output host parameters, and let c be the number of host parameters that are both input
                    host parameters and output host parameters.

                 B) Among Pi, 1 (one) ≤ i ≤ n, let PIj, 1 (one) ≤ j ≤ a, be the input host parameters, let POk,
                    1 (one) ≤ k ≤ b, be the output host parameters, and let PIOl, 1 (one) ≤ l ≤ c, be the host
                    parameters that are both input host parameters and output host parameters.

                 C) Let PNIj, 1 (one) ≤ j ≤ a, be the <host parameter name> of PIj. Let PNOk, 1 (one) ≤ k
                     ≤ b, be the <host parameter name> of POk. Let PNIOl, 1 (one) ≤ l ≤ c, be the <host
                     parameter name> of PIOl.

                 D) Let HVIj, 1 (one) ≤ j ≤ a, be the host variable corresponding to PIj. Let HVOk, 1 (one)
                     ≤ k ≤ b, be the host variable corresponding to POk. Let HVIOl, 1 (one) ≤ l ≤ c, be the
                     host variable corresponding to PIOl.




998 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                             20.1 <embedded SQL host program>



                      E) Let TSIj, 1 (one) ≤ j ≤ a, be the associated SQL data type of HVIj. Let TSOk, 1 (one) ≤
                           k ≤ b, be the associated SQL data type of HVOk. Let TSIOl, 1 (one) ≤ l ≤ c, be the
                           associated SQL data type of HVIOl.

                      F) Let TUIj, 1 (one) ≤ j ≤ a, be the associated user-defined type of HVIj. Let TUOk, 1 (one)
                           ≤ k ≤ b, be the associated user-defined type of HVOk. Let TUIOl, 1 (one) ≤ l ≤ c, be the
                           associated user-defined type of HVIOl.

                      G) Let GNIj, 1 (one) ≤ j ≤ a, be the <group name> corresponding to the <user-defined type
                         name> of TUIj contained in the <group specification> contained in <embedded transform
                           group specification>. Let GNOk, 1 (one) ≤ k ≤ b, be the <group name> corresponding
                           to the <user-defined type name> of TUOk contained in the <group specification> con-
                           tained in <embedded transform group specification>. Let GNIOl, 1 (one) ≤ l ≤ c, be the
                           <group name> corresponding to the <user-defined type name> of TUIOl contained in
                           the <group specification> contained in <embedded transform group specification>.

                      H) For every j, 1 (one) ≤ j ≤ a, apply the Syntax Rules of Subclause 9.19, “Determination
                         of a to-sql function”, with TUIj and GNIj as TYPE and GROUP, respectively. There
                         shall be an applicable to-sql function TSFIj identified by <routine name> TSINj. Let
                         TTIj be the data type of the single SQL parameter of TSFIj. TSIj shall be assignable to
                         TTIj.

                      I) For every l, 1 (one) ≤ l ≤ c, apply the Syntax Rules of Subclause 9.19, “Determination
                         of a to-sql function”, with TUIOl and GNIOl as TYPE and GROUP, respectively. There
                         shall be an applicable to-sql function TSFIOl identified by <routine name> TSIONl. Let
                         TTIOl be the data type of the single SQL parameter of TSFIOl. TSIOl shall be assignable
                         to TTIOl.

                      J) For every k, 1 (one) ≤ k ≤ b, apply the Syntax Rules of Subclause 9.17, “Determination
                         of a from-sql function”, with TUOk and GNOk as TYPE and GROUP, respectively.
                         There shall be an applicable from-sql function FSFOk identified by <routine name>
                         FSONk. Let TROk be the result data type of FSFOk. TSOk shall be assignable to TROk.

                      K) For every l, 1 (one) ≤ l ≤ c, apply the Syntax Rules of Subclause 9.17, “Determination
                         of a from-sql function”, with TUIOl and GNIOl as TYPE and GROUP, respectively.
                         There shall be an applicable from-sql function FSFIOl identified by <routine name>
                         FSIONl. Let TRIOl be the result data type of FSFIOl. TSIOl shall be assignable to TRIOl.

                      L) Let SVIj, 1 (one) ≤ j ≤ a, SVOk, 1 (one) ≤ k ≤ b, and SVIOl, 1 (one) ≤ l ≤ c, be implemen-
                         tation-dependent <SQL variable name>s, each of which is not equivalent to any other
                         <SQL variable name> contained in ES, to any <SQL parameter name> contained in ES,
                         or to any <column name> contained in ES.




©ISO/IEC 2003 – All rights reserved                                                          Embedded SQL 999
ISO/IEC 9075-2:2003 (E)
20.1 <embedded SQL host program>



             7) Let NES be an <SQL procedure statement> that is a copy of ES in which every HVNi, 1
                (one) ≤ i ≤ n, is replaced as follows.
                Case:
                A) If HVi has an associated user-defined type but is not a user-defined type locator variable,
                   then
                    Case:

                    I)      If Pi is an input host parameter, then let PIj, 1 (one) ≤ j ≤ a, be the input host
                            parameter that corresponds to Pi; HVNi is replaced by SVIj.

                    II)     If Pi is an output host parameter, then let POk, 1 (one) ≤ k ≤ b, be the output host
                            parameter that corresponds to Pi; HVNi is replaced by SVOk.

                    III)    Otherwise, let PIOl, 1 (one) ≤ l ≤ c, be the input host parameter and the output
                            host parameter that corresponds to Pi; HVNi is replaced by SVIOl.

                B) Otherwise, HVNi is replaced by PNi.

             8) The <SQL procedure statement> of PS is:
                   BEGIN ATOMIC
                       DECLARE SVI1 TUI1;
                        ...
                       DECLARE SVIa TUIa;
                       DECLARE SVO1 TUO1;
                        ...
                       DECLARE SVOb TUOb;
                       DECLARE SVIO1 TUIO1;
                        ...
                       DECLARE SVIOc TUIOc;
                       SET SVI1 = TSIN1 (CAST (PNI1 AS TTI1));
                        ...
                       SET SVIa = TSINa (CAST (PNIa AS TTIa));
                       SET SVIO1 = TSION1 (CAST (PNIO1 AS TTIO1));
                        ...
                       SET SVIOc = TSIONc (CAST (PNIOc AS TTIOc));
                       NES;
                       SET PNO1 = CAST ( FSON1 (SVO1) AS TSO1);
                        ...
                       SET PNOb = CAST ( FSONb (SVOb) AS TSOb);
                       SET PNIO1 = CAST ( FSION1 (SVIO1) AS TSIO1);
                        ...
                       SET PNIOc = CAST ( FSIONc (SVIOc) AS TSIOc);
                   END;




1000 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)
                                                                                 20.1 <embedded SQL host program>



                  9) Whether one <externally-invoked procedure> of M can correspond to more than one <SQL
                     procedure statement> of H is implementation-dependent.
         ii)      If ES is an <open statement>, then:
                  1) Let EC be the <declare cursor> in H referenced by ES.
                  2) PS is the <externally-invoked procedure> in M that contains an <open statement> that ref-
                     erences the <declare cursor> in M corresponding to EC.
22) P is derived from H as follows:
    a) Each <embedded SQL begin declare>, <embedded SQL end declare>, and <embedded character set
       declaration> has been deleted. If the embedded host language is M, then each <embedded SQL MUMPS
       declare> has been deleted.
    b) Each <host variable definition> in an <embedded SQL declare section> has been replaced by a valid
       data definition in the target host language according to the Syntax Rules specified in an <embedded
       SQL Ada program>, <embedded SQL C program>, <embedded SQL COBOL program>, <embedded
       SQL Fortran program>, <embedded SQL Pascal program>, or an <embedded SQL PL/I program>
       clause.
    c) Each <embedded SQL statement> that contains a <declare cursor>, a <dynamic declare cursor>, an
       <SQL-invoked routine>, or a <temporary table declaration> has been deleted, and every <embedded
       SQL statement> that contains an <embedded exception declaration> has been replaced with statements
       of the host language that will have the effect specified by the General Rules of Subclause 20.2,
       “<embedded exception declaration>”.
    d) Each <embedded SQL statement> that contains an <SQL procedure statement> has been replaced by
       host language statements that perform the following actions:
         i)       A host language procedure or subroutine call of the <externally-invoked procedure> of the
                  implied <SQL-client module definition> M of H that corresponds with the <SQL procedure
                  statement>.
                  If the <SQL procedure statement> is not an <open statement>, then the arguments of the call
                  include each distinct <host identifier> contained in the <SQL procedure statement> together
                  with the SQLSTATE <host identifier>. If the <SQL procedure statement> is an <open statement>,
                  then the arguments of the call include each distinct <host identifier> contained in the correspond-
                  ing <declare cursor> of H together with the SQLSTATE <host identifier>.
                  The order of the arguments in the call corresponds with the order of the corresponding <host
                  parameter declaration>s in the corresponding <externally-invoked procedure>.
                  NOTE 443 — In an <embedded SQL Fortran program>, the “SQLSTATE” variable may be abbreviated to “SQLSTA”.
                  See the Syntax Rules of Subclause 20.6, “<embedded SQL Fortran program>”.

         ii)      Exception actions, as specified in Subclause 20.2, “<embedded exception declaration>”.
    e) Each <statement or declaration> that contains an <embedded authorization declaration> is deleted.




©ISO/IEC 2003 – All rights reserved                                                              Embedded SQL 1001
ISO/IEC 9075-2:2003 (E)
20.1 <embedded SQL host program>



Access Rules
1) For every host variable whose <embedded variable name> is contained in <statement or declaration> and
   has an associated user-defined type, the current privileges shall include EXECUTE privilege on all from-
   sql functions (if any) and all to-sql functions (if any) referenced in the corresponding SQL-client module.


General Rules
1) The interpretation of an <embedded SQL host program> H is defined to be equivalent to the interpretation
   of the implied program P of H and the implied <SQL-client module definition> M of H.


Conformance Rules
1) Without Feature B051, “Enhanced execution rights”, conforming SQL language shall not contain an
   <embedded authorization declaration>.
2) Without Feature F461, “Named character sets”, conforming SQL language shall not contain an <embedded
   character set declaration>.
3) Without Feature F361, “Subprogram support”, conforming SQL language shall not contain two <host
   variable definition>s that specify the same variable name.
4) Without Feature S071, “SQL paths in function and type name resolution”, conforming SQL language shall
   not contain an <embedded path specification>.
5) Without Feature S241, “Transform functions”, conforming SQL language shall not contain a <embedded
   transform group specification>.




1002 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                  ISO/IEC 9075-2:2003 (E)
                                                                      20.2 <embedded exception declaration>



20.2 <embedded exception declaration>

Function
Specify the action to be taken when an SQL-statement causes a specific class of condition to be raised.


Format
<embedded exception declaration> ::= WHENEVER <condition> <condition action>

<condition> ::= <SQL condition>

<SQL condition> ::=
    <major category>
  | SQLSTATE ( <SQLSTATE class value> [ , <SQLSTATE subclass value> ] )
  | CONSTRAINT <constraint name>

<major category> ::=
    SQLEXCEPTION
  | SQLWARNING
  | NOT FOUND

<SQLSTATE class value> ::=
    <SQLSTATE char><SQLSTATE char> !! See the Syntax Rules.

<SQLSTATE subclass value> ::=
    <SQLSTATE char><SQLSTATE char><SQLSTATE char> !! See the Syntax Rules.

<SQLSTATE char> ::=
    <simple Latin upper case letter>
  | <digit>

<condition action> ::=
    CONTINUE
  | <go to>

<go to> ::= { GOTO | GO TO } <goto target>

<goto target> ::=
    <host label identifier>
  | <unsigned integer>
  | <host PL/I label variable>

<host label identifier> ::= !! See the Syntax Rules.

<host PL/I label variable> ::= !! See the Syntax Rules.


Syntax Rules
1) SQLWARNING, NOT FOUND, and SQLEXCEPTION correspond to SQLSTATE class values correspond-
   ing to categories W, N, and X in Table 32, “SQLSTATE class and subclass values”, respectively.




©ISO/IEC 2003 – All rights reserved                                                    Embedded SQL 1003
ISO/IEC 9075-2:2003 (E)
20.2 <embedded exception declaration>



2) An <embedded exception declaration> contained in an <embedded SQL host program> applies to an <SQL
   procedure statement> contained in that <embedded SQL host program> if and only if the <SQL procedure
   statement> appears after the <embedded exception declaration> that has condition C in the text sequence
   of the <embedded SQL host program> and no other <embedded exception declaration> E that satisfies one
   of the following conditions appears between the <embedded exception declaration> and the <SQL procedure
   statement> in the text sequence of the <embedded SQL host program>.
    Let D be the <condition> contained in E.
    a) D is the same as C.
    b) D is a <major category> and belongs to the same class to which C belongs.
    c) D contains an <SQLSTATE class value>, but does not contain an <SQLSTATE subclass value>, and
       E contains the same <SQLSTATE class value> that C contains.
    d) D contains the <SQLSTATE class value> that corresponds to integrity constraint violation and C
       contains CONSTRAINT.
3) In the values of <SQLSTATE class value> and <SQLSTATE subclass value>, there shall be no <separator>
   between the <SQLSTATE char>s.
4) The values of <SQLSTATE class value> and <SQLSTATE subclass value> shall correspond to class values
   and subclass values, respectively, specified in Table 32, “SQLSTATE class and subclass values”.
5) If an <embedded exception declaration> specifies a <go to>, then the <host label identifier>, <host PL/I
   label variable>, or <unsigned integer> of the <go to> shall be such that a host language GO TO statement
   specifying that <host label identifier>, <host PL/I label variable>, or <unsigned integer> is valid at every
   <SQL procedure statement> to which the <embedded exception declaration> applies.
    NOTE 444 —
      If an <embedded exception declaration> is contained in an <embedded SQL Ada program>, then the <goto target> of a <go
      to> should specify a <host label identifier> that is a label_name in the containing <embedded SQL Ada program>.
      If an <embedded exception declaration> is contained in an <embedded SQL C program>, then the <goto target> of a <go to>
      should specify a <host label identifier> that is a label in the containing <embedded SQL C program>.
      If an <embedded exception declaration> is contained in an <embedded SQL COBOL program>, then the <goto target> of a
      <go to> should specify a <host label identifier> that is a section-name or an unqualified paragraph-name in the containing
      <embedded SQL COBOL program>.
      If an <embedded exception declaration> is contained in an <embedded SQL Fortran program>, then the <goto target> of a <go
      to> should be an <unsigned integer> that is the statement label of an executable statement that appears in the same program
      unit as the <go to>.
      If an <embedded exception declaration> is contained in an <embedded SQL MUMPS program>, then the <goto target> of a
      <go to> should be a gotoargument that is the statement label of an executable statement that appears in the same <embedded
      SQL MUMPS program>.
      If an <embedded exception declaration> is contained in an <embedded SQL Pascal program>, then the <goto target> of a <go
      to> should be an <unsigned integer> that is a label.
      If an <embedded exception declaration> is contained in an <embedded SQL PL/I program>, then the <goto target> of a <go
      to> should specify either a <host label identifier> or a <host PL/I label variable>.
      Case:
      —    If <host label identifier> is specified, then the <host label identifier> should be a label constant in the containing
           <embedded SQL PL/I program>.



1004 Foundation (SQL/Foundation)                                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                                         20.2 <embedded exception declaration>



        —      If <host PL/I label variable> is specified, then the <host PL/I label variable> should be a PL/I label variable declared in
               the containing <embedded SQL PL/I program>.



Access Rules
    None.


General Rules
1) Immediately after the execution of an <SQL procedure statement> STMT in an <embedded SQL host pro-
   gram> that returns an SQLSTATE value other than successful completion:
    a) Let E be the set of <embedded exception declaration>s that are contained in the <embedded SQL host
       program> containing STMT, that applies to STMT, and that specifies a <condition action> that is <go
       to>.
    b) Let CV and SCV be respectively the values of the class and subclass of the SQLSTATE value that
       indicates the result of the <SQL procedure statement>.
    c) If the execution of the <SQL procedure statement> caused the violation of one or more constraints or
       assertions, then:
         i)         Let ECN be the set of <embedded exception declaration>s in E that specify CONSTRAINT and
                    the <constraint name> of a constraint that was violated by execution of STMT.
         ii)        If ECN contains more than one <embedded exception declaration>, then an implementation-
                    dependent <embedded exception declaration> is chosen from ECN; otherwise, the single
                    <embedded exception declaration> in ECN is chosen.
         iii)       A GO TO statement of the host language is performed, specifying the <host label identifier>,
                    <host PL/I label variable>, or <unsigned integer> of the <go to> specified in the <embedded
                    exception declaration> chosen from ECN.
    d) Otherwise:
         i)         Let ECS be the set of <embedded exception declaration>s in E that specify SQLSTATE, an
                    <SQLSTATE class value>, and an <SQLSTATE subclass value>.
         ii)        If ECS contains an <embedded exception declaration> EY that specifies an <SQLSTATE class
                    value> identical to CV and an <SQLSTATE subclass value> identical to SCV, then a GO TO
                    statement of the host language is performed, specifying the <host label identifier>, <host PL/I
                    label variable>, or <unsigned integer> of the <go to> specified in the <embedded exception
                    declaration> EY.
         iii)       Otherwise:
                    1) Let EC be the set of <embedded exception declaration>s in E that specify SQLSTATE and
                       an <SQLSTATE class value> without an <SQLSTATE subclass value>.
                    2) If EC contains an <embedded exception declaration> EY that specifies an <SQLSTATE
                       class value> identical to CV, then a GO TO statement of the host language is performed,



©ISO/IEC 2003 – All rights reserved                                                                            Embedded SQL 1005
ISO/IEC 9075-2:2003 (E)
20.2 <embedded exception declaration>



                 specifying the <host label identifier>, <host PL/I label variable>, or <unsigned integer> of
                 the <go to> specified in the <embedded exception declaration> EY.
              3) Otherwise:
                 A) Let EX be the set of <embedded exception declaration>s in E that specify SQLEXCEP-
                    TION.
                 B) If EX contains an <embedded exception declaration> EY and CV belongs to Category
                    X in Table 32, “SQLSTATE class and subclass values”, then a GO TO statement of the
                    host language is performed, specifying the <host label identifier>, <host PL/I label
                    variable>, or <unsigned integer> of the <go to> specified in the <embedded exception
                    declaration> EY.
                 C) Otherwise:
                     I)     Let EW be the set of <embedded exception declaration>s in E that specify SQL-
                            WARNING.
                     II)    If EW contains an <embedded exception declaration> EY and CV belongs to
                            Category W in Table 32, “SQLSTATE class and subclass values”, then a GO
                            TO statement of the host language is performed, specifying the <host label
                            identifier>, <host PL/I label variable>, or <unsigned integer> of the <go to>
                            specified in the <embedded exception declaration> EY.
                     III)   Otherwise, let ENF be the set of <embedded exception declaration>s in E that
                            specify NOT FOUND. If ENF contains an <embedded exception declaration>
                            EY and CV belongs to Category N in Table 32, “SQLSTATE class and subclass
                            values”, then a GO TO statement of the host language is performed, specifying
                            the <host label identifier>, <host PL/I label variable>, or <unsigned integer> of
                            the <go to> specified in the <embedded exception declaration> EY.


Conformance Rules
1) Without Feature B041, “Extensions to embedded SQL exception declarations”, conforming SQL language
   shall not contain an <SQL condition> that contains either SQLSTATE or CONSTRAINT.
2) Without Feature F491, “Constraint management”, conforming SQL language shall not contain an <SQL
   condition> that contains a <constraint name>.




1006 Foundation (SQL/Foundation)                                               ©ISO/IEC 2003 – All rights reserved
                                                                       ISO/IEC 9075-2:2003 (E)
                                                             20.3 <embedded SQL Ada program>



20.3 <embedded SQL Ada program>

Function
Specify an <embedded SQL Ada program>.


Format
<embedded SQL Ada program> ::= !! See the Syntax Rules.

<Ada variable definition> ::=
    <Ada host identifier> [ { <comma> <Ada host identifier> }... ] <colon>
    <Ada type specification> [ <Ada initial value> ]

<Ada initial value> ::=
    <Ada assignment operator> <character representation>...

<Ada assignment operator> ::= <colon><equals operator>

<Ada host identifier> ::= !! See the Syntax Rules.

<Ada type specification> ::=
    <Ada qualified type specification>
  | <Ada unqualified type specification>
  | <Ada derived type specification>

<Ada qualified type specification> ::=
    Interfaces.SQL <period> CHAR
    [ CHARACTER SET [ IS ] <character set specification> ]
    <left paren> 1 <double period> <length> <right paren>
  | Interfaces.SQL <period> SMALLINT
  | Interfaces.SQL <period> INT
  | Interfaces.SQL <period> BIGINT
  | Interfaces.SQL <period> REAL
  | Interfaces.SQL <period> DOUBLE_PRECISION
  | Interfaces.SQL <period> BOOLEAN
  | Interfaces.SQL <period> SQLSTATE_TYPE
  | Interfaces.SQL <period> INDICATOR_TYPE

<Ada unqualified type specification> ::=
    CHAR <left paren> 1 <double period> <length> <right paren>
  | SMALLINT
  | INT
  | BIGINT
  | REAL
  | DOUBLE_PRECISION
  | BOOLEAN
  | SQLSTATE_TYPE
  | INDICATOR_TYPE

<Ada derived type specification> ::=
    <Ada CLOB variable>
  | <Ada CLOB locator variable>
  | <Ada BLOB variable>



©ISO/IEC 2003 – All rights reserved                                       Embedded SQL 1007
ISO/IEC 9075-2:2003 (E)
20.3 <embedded SQL Ada program>



  |   <Ada   BLOB locator variable>
  |   <Ada   user-defined type variable>
  |   <Ada   user-defined type locator variable>
  |   <Ada   REF variable>
  |   <Ada   array locator variable>
  |   <Ada   multiset locator variable>

<Ada CLOB variable> ::=
    SQL TYPE IS CLOB <left paren> <large object length> <right paren>
    [ CHARACTER SET [ IS ] <character set specification> ]

<Ada CLOB locator variable> ::= SQL TYPE IS CLOB AS LOCATOR

<Ada BLOB variable> ::=
    SQL TYPE IS BLOB <left paren> <large object length> <right paren>

<Ada BLOB locator variable> ::= SQL TYPE IS BLOB AS LOCATOR

<Ada user-defined type variable> ::=
    SQL TYPE IS <path-resolved user-defined type name> AS <predefined type>

<Ada user-defined type locator variable> ::=
    SQL TYPE IS <path-resolved user-defined type name> AS LOCATOR

<Ada REF variable> ::= SQL TYPE IS <reference type>

<Ada array locator variable> ::= SQL TYPE IS <array type> AS LOCATOR

<Ada multiset locator variable> ::= SQL TYPE IS <multiset type> AS LOCATOR


Syntax Rules
1) An <embedded SQL Ada program> is a compilation unit that consists of Ada text and SQL text. The Ada
   text shall conform to [ISO8652]. The SQL text shall consist of one or more <embedded SQL statement>s
   and, optionally, one or more <embedded SQL declare section>s.
2) An <embedded SQL statement> may be specified wherever an Ada statement may be specified. An
   <embedded SQL statement> may be prefixed by an Ada label.
3) An <Ada host identifier> is any valid Ada identifier. An <Ada host identifier> shall be contained in an
   <embedded SQL Ada program>.
4) An <Ada variable definition> defines one or more host variables.
5) An <Ada variable definition> shall be modified as follows before it is placed into the program derived
   from the <embedded SQL Ada program> (see the Syntax Rules of Subclause 20.1, “<embedded SQL host
   program>”):
      a) Any optional CHARACTER SET specification shall be removed from an <Ada qualified type specifi-
         cation> and <Ada derived type specification>.
      b) The <length> specified in a CHAR declaration of any <Ada qualified type specification> or <Ada
         derived type specification> that contains a CHARACTER SET specification shall be replaced by a
         length equal to the length in octets of PN, where PN is the <Ada host identifier> specified in the con-
         taining <Ada variable definition>.



1008 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                          20.3 <embedded SQL Ada program>



    c) The syntax
             SQL TYPE IS CLOB ( L )
         and the syntax
             SQL TYPE IS BLOB ( L )
         for a given <Ada host identifier> HVN shall be replaced by
             TYPE HVN IS RECORD
               HVN_RESERVED : Interfaces.SQL.INT;
               HVN_LENGTH : Interfaces.SQL.INT;
               HVN_DATA : Interfaces.SQL.CHAR(1..L);
             END RECORD;

         in any <Ada CLOB variable> or <Ada BLOB variable>, where L is the numeric value of <large object
         length> as specified in Subclause 5.2, “<token> and <separator>”.
    d) The syntax
             SQL TYPE IS UDTN AS PDT
         shall be replaced by
             ADT
         in any <Ada user-defined type variable>, where ADT is the data type listed in the “Ada data type”
         column corresponding to the row for SQL data type PDT in Table 16, “Data type correspondences for
         Ada”. ADT shall not be “none”. The data type identified by UDTN is called the associated user-defined
         type of the host variable and the data type identified by PDT is called the associated SQL data type of
         the host variable.
    e) The syntax
             SQL TYPE IS BLOB AS LOCATOR
         shall be replaced by
             Interfaces.SQL.INT
         in any <Ada BLOB locator variable>. The host variable defined by <Ada BLOB locator variable> is
         called a binary large object locator variable.
    f) The syntax
             SQL TYPE IS CLOB AS LOCATOR
         shall be replaced by
             Interfaces.SQL.INT
         in any <Ada CLOB locator variable>. The host variable defined by <Ada CLOB locator variable> is
         called a character large object locator variable.
    g) The syntax
             SQL TYPE IS <path-resolved user-defined type name> AS LOCATOR


©ISO/IEC 2003 – All rights reserved                                                      Embedded SQL 1009
ISO/IEC 9075-2:2003 (E)
20.3 <embedded SQL Ada program>



         shall be replaced by
           Interfaces.SQL.INT
         in any <Ada user-defined type locator variable>. The host variable defined by <Ada user-defined type
         locator variable> is called a user-defined type locator variable. The data type identified by <path-
         resolved user-defined type name> is called the associated user-defined type of the host variable.
    h) The syntax
           SQL TYPE IS <array type> AS LOCATOR
         shall be replaced by
           Interfaces.SQL.INT
         in any <Ada array locator variable>. The host variable defined by <Ada array locator variable> is called
         an array locator variable. The data type identified by <array type> is called the associated array type
         of the host variable.
    i)   The syntax
           SQL TYPE IS <multiset type> AS LOCATOR
         shall be replaced by
           Interfaces.SQL.INT
         in any <Ada multiset locator variable>. The host variable defined by <Ada multiset locator variable>
         is called a multiset locator variable. The data type identified by <multiset type> is called the associated
         multiset type of the host variable.
    j)   The syntax
           SQL TYPE IS <reference type>
         for a given <Ada host identifier> RTV shall be replaced by
           RTV : Interfaces.SQL.CHAR(1..<length>)
         in any <Ada REF variable>, where <length> is the length in octets of the reference type.
    The modified <Ada variable definition> shall be a valid Ada object-declaration in the program derived
    from the <embedded SQL Ada program>.
6) The reference type identified by <reference type> contained in an <Ada REF variable> is called the refer-
   enced type of the reference.
7) An <Ada variable definition> shall be specified within the scope of Ada with and use clauses that specify
   the following:

    with Interfaces.SQL;

    use Interfaces.SQL;

    use Interfaces.SQL.CHARACTER_SET;




1010 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                          20.3 <embedded SQL Ada program>



8) The <character representation> sequence in an <Ada initial value> specifies an initial value to be assigned
   to the Ada variable. It shall be a valid Ada specification of an initial value.
9) CHAR describes a character string variable whose equivalent SQL data type is CHARACTER with the
   same length and character set specified by <character set specification>. If <character set specification> is
   not specified, then an implementation-defined <character set specification> is implicit.
10) SMALLINT, INT, and BIGINT describe exact numeric variables. The equivalent SQL data types are
    SMALLINT, INTEGER, and BIGINT, respectively.
11) REAL and DOUBLE_PRECISION describe approximate numeric variables. The equivalent SQL data
    types are REAL and DOUBLE PRECISION, respectively.
12) BOOLEAN describes a boolean variable. The equivalent SQL data type is BOOLEAN.
13) SQLSTATE_TYPE describes a character string variable whose length is the length of the SQLSTATE
    parameter, five characters.
14) INDICATOR_TYPE describes an exact numeric variable whose specific data type is any <exact numeric
    type> with a scale of 0 (zero).


Access Rules
    None.


General Rules
1) See Subclause 20.1, “<embedded SQL host program>”.


Conformance Rules
1) Without Feature B011, “Embedded Ada”, conforming SQL language shall not contain an <embedded SQL
   Ada program>.
2) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain an
   <Ada BLOB variable>.
3) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain an
   <Ada CLOB variable>.
4) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain an
   <Ada BLOB locator variable>.
5) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain an
   <Ada CLOB locator variable>.
6) Without Feature T071, “BIGINT data type”, conforming SQL language shall not contain an <Ada qualified
   type specification> that contains Interfaces.SQL.BIGINT.
7) Without Feature T071, “BIGINT data type”, conforming SQL language shall not contain an <Ada
   unqualified type specification> that contains BIGINT.



©ISO/IEC 2003 – All rights reserved                                                      Embedded SQL 1011
ISO/IEC 9075-2:2003 (E)
20.3 <embedded SQL Ada program>



8) Without Feature S241, “Transform functions”, conforming SQL language shall not contain an <Ada user-
   defined type variable>.
9) Without Feature S041, “Basic reference types”, conforming SQL language shall not contain an <Ada REF
   variable>.
10) Without Feature S232, “Array locators”, conforming SQL language shall not contain an <Ada array locator
    variable>.
11) Without Feature S233, “Multiset locators”, conforming SQL language shall not contain an <Ada multiset
    locator variable>.
12) Without Feature S231, “Structured type locators”, conforming SQL language shall not contain a <path-
    resolved user-defined type name> simply contained in an <Ada user-defined type locator variable> that
    identifies a structured type.




1012 Foundation (SQL/Foundation)                                              ©ISO/IEC 2003 – All rights reserved
                                                                    ISO/IEC 9075-2:2003 (E)
                                                            20.4 <embedded SQL C program>



20.4 <embedded SQL C program>

Function
Specify an <embedded SQL C program>.


Format
<embedded SQL C program> ::= !! See the Syntax Rules.

<C variable definition> ::=
    [ <C storage class> ] [ <C class modifier> ]
    <C variable specification> <semicolon>

<C variable specification> ::=
    <C numeric variable>
  | <C character variable>
  | <C derived variable>

<C storage class> ::=
    auto
  | extern
  | static

<C class modifier> ::=
    const
  | volatile

<C numeric variable> ::=
    { long long | long | short | float | double }
    <C host identifier> [ <C initial value> ]
    [ { <comma> <C host identifier> [ <C initial value> ] }... ]

<C character variable> ::=
    <C character type> [ CHARACTER SET [ IS ] <character set specification> ]
    <C host identifier> <C array specification> [ <C initial value> ]
    [ { <comma> <C host identifier> <C array specification>
    [ <C initial value> ] }... ]

<C character type> ::=
    char
  | unsigned char
  | unsigned short

<C array specification> ::= <left bracket> <length> <right bracket>

<C host identifier> ::= !! See the Syntax Rules.

<C derived variable> ::=
    <C VARCHAR variable>
  | <C NCHAR variable>
  | <C NCHAR VARYING variable>
  | <C CLOB variable>
  | <C NCLOB variable>



©ISO/IEC 2003 – All rights reserved                                    Embedded SQL 1013
ISO/IEC 9075-2:2003 (E)
20.4 <embedded SQL C program>



  |   <C   BLOB variable>
  |   <C   user-defined type variable>
  |   <C   CLOB locator variable>
  |   <C   BLOB locator variable>
  |   <C   array locator variable>
  |   <C   multiset locator variable>
  |   <C   user-defined type locator variable>
  |   <C   REF variable>

<C VARCHAR variable> ::=
    VARCHAR [ CHARACTER SET [ IS ] <character set specification> ]
    <C host identifier> <C array specification> [ <C initial value> ]
    [ { <comma> <C host identifier> <C array specification> [
    <C initial value> ] }... ]

<C NCHAR variable> ::=
    NCHAR [ CHARACTER SET [ IS ] <character set specification> ]
    <C host identifier> <C array specification> [ <C initial value> ]
    [ { <comma> <C host identifier> <C array specification>
    [ <C initial value> ] } ... ]

<C NCHAR VARYING variable> ::=
    NCHAR VARYING [ CHARACTER SET [ IS ] <character set specification> ]
    <C host identifier> <C array specification> [ <C initial value> ]
    [ { <comma> <C host identifier> <C array specification> [
    <C initial value> ] } ... ]

<C CLOB variable> ::=
    SQL TYPE IS CLOB <left paren> <large object length> <right paren>
    [ CHARACTER SET [ IS ] <character set specification> ]
    <C host identifier> [ <C initial value> ] [ { <comma> <C host identifier> [
    <C initial value> ] }... ]

<C NCLOB variable> ::=
    SQL TYPE IS NCLOB <left paren> <large object length> <right paren>
    [ CHARACTER SET [ IS ] <character set specification> ]
    <C host identifier> [ <C initial value> ] [ { <comma> <C host identifier>
    [ <C initial value> ] }... ]

<C user-defined type variable> ::=
    SQL TYPE IS <path-resolved user-defined type name> AS <predefined type>
    <C host identifier> [ <C initial value> ]
    [ { <comma> <C host identifier> [
    <C initial value> ] } ... ]

<C BLOB variable> ::=
    SQL TYPE IS BLOB <left paren> <large object length> <right paren>
    <C host identifier> [ <C initial value> ]
    [ { <comma> <C host identifier> [
    <C initial value> ] } ... ]

<C CLOB locator variable> ::=
    SQL TYPE IS CLOB AS LOCATOR
    <C host identifier> [ <C initial value> ]
    [ { <comma> <C host identifier> [
    <C initial value> ] } ... ]




1014 Foundation (SQL/Foundation)                                 ©ISO/IEC 2003 – All rights reserved
                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                           20.4 <embedded SQL C program>



<C BLOB locator variable> ::=
    SQL TYPE IS BLOB AS LOCATOR
    <C host identifier> [ <C initial value> ]
    [ { <comma> <C host identifier> [
    <C initial value> ] } ... ]

<C array locator variable> ::=
    SQL TYPE IS <array type> AS LOCATOR
    <C host identifier> [ <C initial value> ]
    [ { <comma> <C host identifier> [
    <C initial value> ] } ... ]

<C multiset locator variable> ::=
    SQL TYPE IS <multiset type> AS LOCATOR
    <C host identifier> [ <C initial value> ]
    [ { <comma> <C host identifier> [
    <C initial value> ] } ... ]

<C user-defined type locator variable> ::=
    SQL TYPE IS <path-resolved user-defined type name> AS LOCATOR
    <C host identifier> [ <C initial value> ]
    [ { <comma> <C host identifier> [
    <C initial value> ] }... ]

<C REF variable> ::=
    SQL TYPE IS <reference type> <C host identifier> [ <C initial value> ]
    [ { <comma> <C host identifier> [ <C initial value> ] }... ]

<C initial value> ::=
    <equals operator> <character representation>...


Syntax Rules
1) An <embedded SQL C program> is a compilation unit that consists of C text and SQL text. The C text
   shall conform to [ISO9899]. The SQL text shall consist of one or more <embedded SQL statement>s and,
   optionally, one or more <embedded SQL declare section>s.
2) An <embedded SQL statement> may be specified wherever a C statement may be specified within a function
   block. If the C statement could include a label prefix, then the <embedded SQL statement> may be imme-
   diately preceded by a label prefix.
3) A <C host identifier> is any valid C variable identifier. A <C host identifier> shall be contained in an
   <embedded SQL C program>.
4) A <C variable definition> defines one or more host variables.
5) A <C variable definition> shall be modified as follows before it is placed into the program derived from
   the <embedded SQL C program> (see the Syntax Rules of Subclause 20.1, “<embedded SQL host pro-
   gram>”):
    a) Any optional CHARACTER SET specification shall be removed from a <C VARCHAR variable>, a
       <C character variable>, a <C CLOB variable>, a <C NCHAR variable>, <C NCHAR VARYING
       variable>, or a <C NCLOB variable>.
    b) The syntax “VARCHAR” shall be replaced by “char” in any <C VARCHAR variable>.


©ISO/IEC 2003 – All rights reserved                                                     Embedded SQL 1015
ISO/IEC 9075-2:2003 (E)
20.4 <embedded SQL C program>



   c) The <length> specified in a <C array specification> in any <C character variable> whose <C character
      type> specifies “char” or “unsigned char”, in any <C VARCHAR variable>, in any <C NCHAR
      variable>, or in any <C NCHAR VARYING variable>, and the <large object length> specified in a
      <C CLOB variable> that contains a CHARACTER SET specification or <C NCLOB variable> shall
      be replaced by a length equal to the length in octets of PN, where PN is the <C host identifier> specified
      in the containing <C variable definition>.
       NOTE 445 — The <length> does not have to be adjusted for <C character type>s that specify “unsigned short” because
       the units of <length> are already the same units as used by the underlying character set.

   d) The syntax “NCHAR” in any <C NCHAR variable> and the syntax “NCHAR VARYING” in any <C
      NCHAR VARYING variable> shall be replaced by “char”.
   e) The syntax
          SQL TYPE IS NCLOB ( L )
       for a given <C host identifier> hvn shall be replaced by
          struct {
            long          hvn_reserved;
            unsigned long hvn_length;
            char          hvn_data[L];
            } hvn

       in any <C NCLOB variable>, where L is the numeric value of <large object length> as specified in
       Subclause 5.2, “<token> and <separator>”.
   f) The syntax
          SQL TYPE IS CLOB ( L )
       or the syntax
          SQL TYPE IS BLOB ( L )
       for a given <C host identifier> hvn shall be replaced by:
          struct {
            long          hvn_reserved;
            unsigned long hvn_length;
            char          hvn_data[L];
            } hvn

       in any <C CLOB variable> or <C BLOB variable>, where L is the numeric value of <large object
       length> as specified in Subclause 5.2, “<token> and <separator>”.
   g) The syntax
          SQL TYPE IS UDTN AS PDT
       shall be replaced by
          ADT
       in any <C user-defined type variable>, where ADT is the data type listed in the “C data type” column
       corresponding to the row for SQL data type PDT in Table 17, “Data type correspondences for C”. ADT


1016 Foundation (SQL/Foundation)                                                        ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                             20.4 <embedded SQL C program>



         shall not be “none”. The data type identified by UDTN is called the associated user-defined type of the
         host variable and the data type identified by PDT is called the associated SQL data type of the host
         variable.
    h) The syntax
             SQL TYPE IS BLOB AS LOCATOR
         shall be replaced by
             unsigned long
         in any <C BLOB locator variable>. The host variable defined by <C BLOB locator variable> is called
         a binary large object locator variable.
    i)   The syntax
             SQL TYPE IS CLOB AS LOCATOR
         shall be replaced by
             unsigned long
         in any <C CLOB locator variable>. The host variable defined by <C CLOB locator variable> is called
         a character large object locator variable.
    j)   The syntax
             SQL TYPE IS <array type> AS LOCATOR
         shall be replaced by
             unsigned long
         in any <C array locator variable>. The host variable defined by <C array locator variable> is called an
         array locator variable. The data type identified by <array type> is called the associated array type of
         the host variable.
    k) The syntax
             SQL TYPE IS <multiset type> AS LOCATOR
         shall be replaced by
             unsigned long
         in any <C multiset locator variable>. The host variable defined by <C multiset locator variable> is
         called a multiset locator variable. The data type identified by <multiset type> is called the associated
         multiset type of the host variable.
    l)   The syntax
             SQL TYPE IS <path-resolved user-defined type name> AS LOCATOR
         shall be replaced by
             unsigned long



©ISO/IEC 2003 – All rights reserved                                                       Embedded SQL 1017
ISO/IEC 9075-2:2003 (E)
20.4 <embedded SQL C program>



        in any <C user-defined type locator variable>. The host variable defined by <C user-defined type
        locator variable> is called a user-defined type locator variable. The data type identified by <path-
        resolved user-defined type name> is called the associated user-defined type of the host variable.
    m) The syntax
           SQL TYPE IS <reference type>
        for a given <C host identifier> hvn shall be replaced by
           unsigned char hvn[L]
        in any <C REF variable>, where L is the length in octets of the reference type.
    The modified <C variable definition> shall be a valid C data declaration in the program derived from the
    <embedded SQL C program>.
6) The reference type identified by <reference type> contained in a <C REF variable> is called the referenced
   type of the reference.
7) The <character representation> sequence contained in a <C initial value> specifies an initial value to be
   assigned to the C variable. It shall be a valid C specification of an initial value.
8) Except for array specifications for character strings, a <C variable definition> shall specify a scalar type.
9) In a <C variable definition>, the words “VARCHAR”, “CHARACTER”, “SET”, “IS”, “VARYING”,
   “BLOB”, “CLOB”, “NCHAR”, “NCLOB”, “AS”, “LOCATOR”, and “REF” may be specified in any
   combination of upper-case and lower-case letters (see the Syntax Rules of Subclause 5.2, “<token> and
   <separator>”.
10) In a <C character variable>, a <C VARCHAR variable>, or a <C CLOB variable>, if a <character set
    specification> is specified, then the equivalent SQL data type is CHARACTER, CHARACTER VARYING,
    or CHARACTER LARGE OBJECT whose character set is the same as the character set specified by the
    <character set specification>. In a <C NCHAR variable>, a <C NCHAR VARYING variable>, or a <C
    NCLOB variable>, if a <character set specification> is specified, then the equivalent SQL data type is
    NATIONAL CHARACTER, NATIONAL CHARACTER VARYING, or NATIONAL CHARACTER
    LARGE OBJECT whose character set is the same as the character set specified by the <character set
    specification>. If <character set specification> is not specified, then an implementation-defined <character
    set specification> is implicit.
11) Each <C host identifier> specified in a <C character variable> or a <C NCHAR variable> describes a fixed-
    length character string. The length is specified by the <length> of the <C array specification>. The value
    in the host variable is terminated by a null character and the position occupied by this null character is
    included in the length of the host variable. The equivalent SQL data type is CHARACTER or NATIONAL
    CHARACTER, respectively, whose length is one less than the <length> of the <C array specification> and
    whose value does not include the terminating null character. The <length> shall be greater than 1 (one).
12) Each <C host identifier> specified in a <C VARCHAR variable> or a <C NCHAR VARYING variable>
    describes a variable-length character string. The maximum length is specified by the <length> of the <C
    array specification>. The value in the host variable is terminated by a null character and the position
    occupied by this null character is included in the maximum length of the host variable. The equivalent SQL
    data type is CHARACTER VARYING or NATIONAL CHARACTER VARYING, respectively, whose
    maximum length is 1 (one) less than the <length> of the <C array specification> and whose value does not
    include the terminating null character. The <length> shall be greater than 1 (one).


1018 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                 ISO/IEC 9075-2:2003 (E)
                                                                         20.4 <embedded SQL C program>



13) “short” describes an exact numeric variable. The equivalent SQL data type is SMALLINT.
14) “long” describes an exact numeric variable. The equivalent SQL data type is INTEGER or BOOLEAN.
15) “long long” describes an exact numeric variable. The equivalent SQL data type is BIGINT.
16) “float” describes an approximate numeric variable. The equivalent SQL data type is REAL.
17) “double” describes an approximate numeric variable. The equivalent SQL data type is DOUBLE PRECI-
    SION.


Access Rules
    None.


General Rules
1) See Subclause 20.1, “<embedded SQL host program>”.


Conformance Rules
1) Without Feature B012, “Embedded C”, conforming SQL language shall not contain an <embedded SQL
   C program>.
2) Without Feature S041, “Basic reference types”, conforming SQL language shall not contain a <C REF
   variable>.
3) Without Feature S241, “Transform functions”, conforming SQL language shall not contain a <C user-
   defined type variable>.
4) Without Feature S232, “Array locators”, conforming SQL language shall not contain an <C array locator
   variable>.
5) Without Feature S233, “Multiset locators”, conforming SQL language shall not contain a <C multiset
   locator variable>.
6) Without Feature S231, “Structured type locators”, conforming SQL language shall not contain a <path-
   resolved user-defined type name> simply contained in a <C user-defined type locator variable> that iden-
   tifies a structured type.
7) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain a <C
   BLOB variable>.
8) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain a <C
   CLOB variable>.
9) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain a <C
   BLOB locator variable>.
10) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain a <C
    CLOB locator variable>.



©ISO/IEC 2003 – All rights reserved                                                  Embedded SQL 1019
ISO/IEC 9075-2:2003 (E)
20.4 <embedded SQL C program>



11) Without Feature T071, “BIGINT data type”, conforming SQL language shall not contain a <C numeric
    variable> that contains long long.




1020 Foundation (SQL/Foundation)                                          ©ISO/IEC 2003 – All rights reserved
                                                                     ISO/IEC 9075-2:2003 (E)
                                                       20.5 <embedded SQL COBOL program>



20.5 <embedded SQL COBOL program>

Function
Specify an <embedded SQL COBOL program>.


Format
<embedded SQL COBOL program> ::= !! See the Syntax Rules.

<COBOL variable definition> ::=
    { 01 |77 } <COBOL host identifier>
    <COBOL type specification> [ <character representation>... ] <period>

<COBOL host identifier> ::= !! See the Syntax Rules.

<COBOL type specification> ::=
    <COBOL character type>
  | <COBOL national character type>
  | <COBOL numeric type>
  | <COBOL integer type>
  | <COBOL derived type specification>

<COBOL derived type specification> ::=
    <COBOL CLOB variable>
  | <COBOL NCLOB variable>
  | <COBOL BLOB variable>
  | <COBOL user-defined type variable>
  | <COBOL CLOB locator variable>
  | <COBOL BLOB locator variable>
  | <COBOL array locator variable>
  | <COBOL multiset locator variable>
  | <COBOL user-defined type locator variable>
  | <COBOL REF variable>

<COBOL character type> ::=
    [ CHARACTER SET [ IS ] <character set specification> ]
    { PIC | PICTURE } [ IS ] { X [ <left paren> <length> <right paren> ] }...

<COBOL national character type> ::=
    [ CHARACTER SET [ IS ] <character set specification> ]
    { PIC | PICTURE } [ IS ] { N [ <left paren> <length> <right paren> ] }...

<COBOL CLOB variable> ::=
    [ USAGE [ IS ] ] SQL TYPE IS CLOB <left paren> <large object length> <right paren>
    [ CHARACTER SET [ IS ] <character set specification> ]

<COBOL NCLOB variable> ::=
    [ USAGE [ IS ] ] SQL TYPE IS NCLOB <left paren> <large object length> <right paren>
    [ CHARACTER SET [ IS ] <character set specification> ]

<COBOL BLOB variable> ::=
    [ USAGE [ IS ] ] SQL TYPE IS BLOB <left paren> <large object length> <right paren>




©ISO/IEC 2003 – All rights reserved                                     Embedded SQL 1021
ISO/IEC 9075-2:2003 (E)
20.5 <embedded SQL COBOL program>



<COBOL user-defined type variable> ::=
    [ USAGE [ IS ] ] SQL TYPE IS <path-resolved user-defined type name>
    AS <predefined type>

<COBOL CLOB locator variable> ::=
    [ USAGE [ IS ] ] SQL TYPE IS CLOB AS LOCATOR

<COBOL BLOB locator variable> ::=
    [ USAGE [ IS ] ] SQL TYPE IS BLOB AS LOCATOR

<COBOL array locator variable> ::=
    [ USAGE [ IS ] ] SQL TYPE IS <array type> AS LOCATOR

<COBOL multiset locator variable> ::=
    [ USAGE [ IS ] ] SQL TYPE IS <multiset type> AS LOCATOR

<COBOL user-defined type locator variable> ::=
    [ USAGE [ IS ] ] SQL TYPE IS <path-resolved user-defined type name> AS LOCATOR

<COBOL REF variable> ::=
    [ USAGE [ IS ] ] SQL TYPE IS <reference type>

<COBOL numeric type> ::=
    { PIC | PICTURE } [ IS ] S <COBOL nines specification>
    [ USAGE [ IS ] ] DISPLAY SIGN LEADING SEPARATE

<COBOL nines specification> ::=
    <COBOL nines> [ V [ <COBOL nines> ] ]
  | V <COBOL nines>

<COBOL integer type> ::= <COBOL binary integer>

<COBOL binary integer> ::=
    { PIC | PICTURE } [ IS ] S<COBOL nines>
    [ USAGE [ IS ] ] BINARY

<COBOL nines> ::= { 9 [ <left paren> <length> <right paren> ] }...
NOTE 446 — The syntax “N(L)” is not part of the current COBOL standard, so its use is merely a recommendation; therefore, the
production <COBOL national character type> is not normative in this edition of ISO/IEC 9075.


Syntax Rules
1) An <embedded SQL COBOL program> is a compilation unit that consists of COBOL text and SQL text.
   The COBOL text shall conform to [ISO1989]. The SQL text shall consist of one or more <embedded SQL
   statement>s and, optionally, one or more <embedded SQL declare section>s.
2) An <embedded SQL statement> in an <embedded SQL COBOL program> may be specified wherever a
   COBOL statement may be specified in the Procedure Division of the <embedded SQL COBOL program>.
   If the COBOL statement could be immediately preceded by a paragraph-name, then the <embedded SQL
   statement> may be immediately preceded by a paragraph-name.
3) A <COBOL host identifier> is any valid COBOL data-name. A <COBOL host identifier> shall be contained
   in an <embedded SQL COBOL program>.




1022 Foundation (SQL/Foundation)                                                              ©ISO/IEC 2003 – All rights reserved
                                                                                              ISO/IEC 9075-2:2003 (E)
                                                                                20.5 <embedded SQL COBOL program>



4) A <COBOL variable definition> is a restricted form of COBOL data description entry that defines a host
   variable.
5) A <COBOL variable definition> shall be modified as follows before it is placed into the program derived
   from the <embedded SQL COBOL program> (see the Syntax Rules of Subclause 20.1, “<embedded SQL
   host program>”).
    a) Any optional CHARACTER SET specification shall be removed from a <COBOL character type>, a
       <COBOL national character type>, a <COBOL CLOB variable>, and a <COBOL NCLOB variable>.
    b) The <length> specified in any <COBOL character type> and the <large object length> specified in any
       <COBOL CLOB variable> or <COBOL NCLOB variable> that contains a CHARACTER SET speci-
       fication shall be replaced by a length equal to the length in octets of PN, where PN is the <COBOL
       host identifier> specified in the containing <COBOL variable definition>.
         NOTE 447 — The <length> specified in a <COBOL national character type> does not have to be adjusted, because the units
         of <length> are already the same units as used by the underlying character set.
         NOTE 448 — The syntax “N(L)” is not part of the current COBOL standard, so its use is merely a recommendation; therefore,
         the production <COBOL national character type> is not normative in ISO/IEC 9075.

    c) The syntax
             SQL TYPE IS CLOB ( L )
         or the syntax
             SQL TYPE IS NCLOB ( L )
         or the syntax
             SQL TYPE IS BLOB ( L )
         for a given <COBOL host identifier> HVN shall be replaced by:
             49 HVN-RESERVED PIC S9(9) USAGE IS BINARY.
             49 HVN-LENGTH PIC S9(9) USAGE IS BINARY.
             49 HVN-DATA PIC X(L).

         in any <COBOL CLOB variable> or <COBOL BLOB variable>.
    d) The syntax
             SQL TYPE IS UDTN AS PDT
         shall be replaced by
             ADT
         in any <COBOL user-defined type variable>, where ADT is the data type listed in the “COBOL data
         type” column corresponding to the row for SQL data type PDT in Table 18, “Data type correspondences
         for COBOL”. ADT shall not be “none”. The data type identified by UDTN is called the associated
         user-defined type of the host variable and the data type identified by PDT is called the associated SQL
         data type of the host variable.
    e) The syntax
             SQL TYPE IS BLOB AS LOCATOR


©ISO/IEC 2003 – All rights reserved                                                                    Embedded SQL 1023
ISO/IEC 9075-2:2003 (E)
20.5 <embedded SQL COBOL program>



        shall be replaced by
          PIC S9(9) USAGE IS BINARY
        in any <COBOL BLOB locator variable>. The host variable defined by <COBOL BLOB locator
        variable> is called a binary large object locator variable.
   f) The syntax
          SQL TYPE IS CLOB AS LOCATOR
        shall be replaced by
          PIC S9(9) USAGE IS BINARY
        in any <COBOL CLOB locator variable>. The host variable defined by <COBOL CLOB locator
        variable> is called a character large object locator variable.
   g) The syntax
          SQL TYPE IS <array type> AS LOCATOR
        shall be replaced by
          PIC S9(9) USAGE IS BINARY
        in any <COBOL array locator variable>. The host variable defined by <COBOL array locator variable>
        is called an array locator variable. The data type identified by <array type> is called the associated
        array type of the host variable.
   h) The syntax
          SQL TYPE IS <multiset type> AS LOCATOR
        shall be replaced by
          PIC S9(9) USAGE IS BINARY
        in any <COBOL multiset locator variable>. The host variable defined by <COBOL multiset locator
        variable> is called a multiset locator variable. The data type identified by <multiset type> is called the
        associated multiset type of the host variable.
   i)   The syntax
          SQL TYPE IS <path-resolved user-defined type name> AS LOCATOR
        shall be replaced by
          PIC S9(9) USAGE IS BINARY
        in any <COBOL user-defined type locator variable>. The host variable defined by <COBOL user-
        defined type locator variable> is called a user-defined type locator variable. The data type identified
        by <path-resolved user-defined type name> is called the associated user-defined type of the host variable.
   j)   The syntax
          SQL TYPE IS <reference type>



1024 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                 ISO/IEC 9075-2:2003 (E)
                                                                   20.5 <embedded SQL COBOL program>



         for a given <COBOL host identifier> HVN shall be replaced by
             01 HVN PICTURE X(L)
         in any <COBOL REF variable>, where L is the length in octets of the reference type.
    The modified <COBOL variable definition> shall be a valid data description entry in the Data Division of
    the program derived from the <embedded SQL COBOL program>.
6) The reference type identified by <reference type> contained in a <COBOL REF variable> is called the
   referenced type of the reference.
7) The optional <character representation> sequence in a <COBOL variable definition> may specify a VALUE
   clause. Whether other clauses may be specified is implementation-defined. The <character representation>
   sequence shall be such that the <COBOL variable definition> is a valid COBOL data description entry.
8) A <COBOL character type> describes a character string variable whose equivalent SQL data type is
   CHARACTER with the same length and character set specified by <character set specification>. If <char-
   acter set specification> is not specified, then an implementation-defined <character set specification> is
   implicit.
9) A <COBOL numeric type> describes an exact numeric variable. The equivalent SQL data type is NUMERIC
   of the same precision and scale.
10) A <COBOL binary integer> describes an exact numeric variable. The equivalent SQL data type is
    SMALLINT, INTEGER, or BIGINT.


Access Rules
    None.


General Rules
1) See Subclause 20.1, “<embedded SQL host program>”.


Conformance Rules
1) Without Feature B013, “Embedded COBOL”, conforming SQL language shall not contain an <embedded
   SQL COBOL program>.
2) Without Feature S041, “Basic reference types”, conforming SQL language shall not contain a <COBOL
   REF variable>.
3) Without Feature S241, “Transform functions”, conforming SQL language shall not contain a <COBOL
   user-defined type variable>.
4) Without Feature S232, “Array locators”, conforming SQL language shall not contain a <COBOL array
   locator variable>.
5) Without Feature S233, “Multiset locators”, conforming SQL language shall not contain a <COBOL multiset
   locator variable>.



©ISO/IEC 2003 – All rights reserved                                                    Embedded SQL 1025
ISO/IEC 9075-2:2003 (E)
20.5 <embedded SQL COBOL program>



6) Without Feature S231, “Structured type locators”, conforming SQL language shall not contain a <path-
   resolved user-defined type name> simply contained in a <COBOL user-defined type locator variable> that
   identifies a structured type.
7) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain a
   <COBOL BLOB variable>.
8) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain a
   <COBOL CLOB variable>.
9) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain a
   <COBOL BLOB locator variable>.
10) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain a
    <COBOL CLOB locator variable>.




1026 Foundation (SQL/Foundation)                                             ©ISO/IEC 2003 – All rights reserved
                                                                      ISO/IEC 9075-2:2003 (E)
                                                         20.6 <embedded SQL Fortran program>



20.6 <embedded SQL Fortran program>

Function
Specify an <embedded SQL Fortran program>.


Format
<embedded SQL Fortran program> ::= !! See the Syntax Rules.

<Fortran variable definition> ::=
    <Fortran type specification> <Fortran host identifier>
    [ { <comma> <Fortran host identifier> }... ]

<Fortran host identifier> ::= !! See the Syntax Rules.

<Fortran type specification> ::=
    CHARACTER [ <asterisk> <length> ] [ CHARACTER SET
    [ IS ] <character set specification> ]
  | CHARACTER KIND = n [ <asterisk> <length> ]
    [ CHARACTER SET [ IS ] <character set specification> ]
  | INTEGER
  | REAL
  | DOUBLE PRECISION
  | LOGICAL
  | <Fortran derived type specification>

<Fortran derived type specification> ::=
    <Fortran CLOB variable>
  | <Fortran BLOB variable>
  | <Fortran user-defined type variable>
  | <Fortran CLOB locator variable>
  | <Fortran BLOB locator variable>
  | <Fortran user-defined type locator variable>
  | <Fortran array locator variable>
  | <Fortran multiset locator variable>
  | <Fortran REF variable>

<Fortran CLOB variable> ::=
    SQL TYPE IS CLOB <left paren> <large object length> <right paren>
    [ CHARACTER SET [ IS ] <character set specification> ]

<Fortran BLOB variable> ::=
    SQL TYPE IS BLOB <left paren> <large object length> <right paren>

<Fortran user-defined type variable> ::=
    SQL TYPE IS <path-resolved user-defined type name> AS <predefined type>

<Fortran CLOB locator variable> ::=
    SQL TYPE IS CLOB AS LOCATOR

<Fortran BLOB locator variable> ::=
    SQL TYPE IS BLOB AS LOCATOR




©ISO/IEC 2003 – All rights reserved                                      Embedded SQL 1027
ISO/IEC 9075-2:2003 (E)
20.6 <embedded SQL Fortran program>



<Fortran user-defined type locator variable> ::=
    SQL TYPE IS <path-resolved user-defined type name> AS LOCATOR

<Fortran array locator variable> ::=
    SQL TYPE IS <array type> AS LOCATOR

<Fortran multiset locator variable> ::=
    SQL TYPE IS <multiset type> AS LOCATOR

<Fortran REF variable> ::=
    SQL TYPE IS <reference type>


Syntax Rules
1) An <embedded SQL Fortran program> is a compilation unit that consists of Fortran text and SQL text.
   The Fortran text shall conform to [ISO1539]. The SQL text shall consist of one or more <embedded SQL
   statement>s and, optionally, one or more <embedded SQL declare section>s.
2) An <embedded SQL statement> may be specified wherever an executable Fortran statement may be spec-
   ified. An <embedded SQL statement> that precedes any executable Fortran statement in the containing
   <embedded SQL Fortran program> shall not have a Fortran statement number. Otherwise, if the Fortran
   statement could have a statement number then the <embedded SQL statement> can have a statement
   number.
3) Blanks are significant in <embedded SQL statement>s. The rules for <separator>s in an <embedded SQL
   statement> are as specified in Subclause 5.2, “<token> and <separator>”.
4) A <Fortran host identifier> is any valid Fortran variable name with all <space> characters removed. A
   <Fortran host identifier> shall be contained in an <embedded SQL Fortran program>.
5) A <Fortran variable definition> is a restricted form of Fortran type-statement that defines one or more host
   variables.
6) A <Fortran variable definition> shall be modified as follows before it is placed into the program derived
   from the <embedded SQL Fortran program> (see the Syntax Rules Subclause 20.1, “<embedded SQL host
   program>”).
    a) Any optional CHARACTER SET specification shall be removed from the CHARACTER and the
       CHARACTER KIND=n alternatives in a <Fortran type specification>.
    b) The <length> specified in the CHARACTER alternative of any <Fortran type specification> and the
       <large object length> specified in any <Fortran CLOB variable> that contains a CHARACTER SET
       specification shall be replaced by a length equal to the length in octets of PN, where PN is the <Fortran
       host identifier> specified in the containing <Fortran variable definition>.
        NOTE 449 — The <length> does not have to be adjusted for CHARACTER KIND=n alternatives of any <Fortran type
        specification>, because the units of <length> are already the same units as used by the underlying character set.

    c) The syntax
           SQL TYPE IS CLOB ( L )
        and the syntax
           SQL TYPE IS BLOB ( L )


1028 Foundation (SQL/Foundation)                                                           ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                       20.6 <embedded SQL Fortran program>



         for a given <Fortran host identifier> HVN shall be replaced by
             INTEGER HVN_RESERVED
             INTEGER HVN_LENGTH
             CHARACTER HVN_DATA [ <asterisk> L ]

         in any <Fortran CLOB variable> or <Fortran BLOB variable>, where L is the numeric value of <large
         object length> as specified in Subclause 5.2, “<token> and <separator>”.
    d) The syntax
             SQL TYPE IS UDTN AS PDT
         shall be replaced by
             ADT
         in any <Fortran user-defined type variable>, where ADT is the data type listed in the “Fortran data
         type” column corresponding to the row for SQL data type PDT in Table 19, “Data type correspondences
         for Fortran”. ADT shall not be “none”. The data type identified by UDTN is called the associated user-
         defined type of the host variable and the data type identified by PDT is called the associated SQL data
         type of the host variable.
    e) The syntax
             SQL TYPE IS BLOB AS LOCATOR
         shall be replaced by
             INTEGER
         in any <Fortran BLOB locator variable>. The host variable defined by <Fortran BLOB locator variable>
         is called a binary large object locator variable.
    f) The syntax
             SQL TYPE IS CLOB AS LOCATOR
         shall be replaced by
             INTEGER
         in any <Fortran CLOB locator variable>. The host variable defined by <Fortran CLOB locator variable>
         is called a character large object locator variable.
    g) The syntax
             SQL TYPE IS <path-resolved user-defined type name> AS LOCATOR
         shall be replaced by
             INTEGER
         in any <Fortran user-defined type locator variable>. The host variable defined by <Fortran user-defined
         type locator variable> is called a user-defined type locator variable. The data type identified by <path-
         resolved user-defined type name> is called the associated user-defined type of the host variable.



©ISO/IEC 2003 – All rights reserved                                                        Embedded SQL 1029
ISO/IEC 9075-2:2003 (E)
20.6 <embedded SQL Fortran program>



    h) The syntax
           SQL TYPE IS <array type> AS LOCATOR
         shall be replaced by
           INTEGER
         in any <Fortran array locator variable>. The host variable defined by <Fortran array locator variable>
         is called an array locator variable. The data type identified by <array type> is called the associated
         array type of the host variable.
    i)   The syntax
           SQL TYPE IS <multiset type> AS LOCATOR
         shall be replaced by
           INTEGER
         in any <Fortran multiset locator variable>. The host variable defined by <Fortran multiset locator
         variable> is called a multiset locator variable. The data type identified by <multiset type> is called the
         associated multiset type of the host variable.
    j)   The syntax
           SQL TYPE IS <reference type>
         for a given <Fortran host identifier> HVN shall be replaced by
           CHARACTER HVN * <length>
         in any <Fortran REF variable>, where <length> is the length in octets of the reference type.
    The modified <Fortran variable definition> shall be a valid Fortran type-statement in the program derived
    from the <embedded SQL Fortran program>.
7) The reference type identified by <reference type> contained in an <Fortran REF variable> is called the
   referenced type of the reference.
8) CHARACTER without “KIND=n” describes a character string variable whose equivalent SQL data type
   is CHARACTER with the same length and character set specified by <character set specification>. If
   <character set specification> is not specified, then an implementation-defined <character set specification>
   is implicit.
9) CHARACTER KIND=n describes a character string variable whose equivalent SQL data type is either
   CHARACTER or NATIONAL CHARACTER with the same length and character set specified by <char-
   acter set specification>. If <character set specification> is not specified, then an implementation-defined
   <character set specification> is implicit. The value of n determines implementation-defined characteristics
   of the Fortran variable; values of n are implementation-defined.
10) INTEGER describes an exact numeric variable. The equivalent SQL data type is INTEGER.
11) REAL describes an approximate numeric variable. The equivalent SQL data type is REAL.
12) DOUBLE PRECISION describes an approximate numeric variable. The equivalent SQL data type is
    DOUBLE PRECISION.


1030 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                ISO/IEC 9075-2:2003 (E)
                                                                   20.6 <embedded SQL Fortran program>



13) LOGICAL describes a boolean variable. The equivalent SQL data type is BOOLEAN.


Access Rules
    None.


General Rules
1) See Subclause 20.1, “<embedded SQL host program>”.


Conformance Rules
1) Without Feature B014, “Embedded Fortran”, conforming SQL language shall not contain an <embedded
   SQL Fortran program>.
2) Without Feature S041, “Basic reference types”, conforming SQL language shall not contain a <Fortran
   REF variable>.
3) Without Feature S241, “Transform functions”, conforming SQL language shall not contain a <Fortran user-
   defined type variable>.
4) Without Feature S232, “Array locators”, conforming SQL language shall not contain a <Fortran array
   locator variable>.
5) Without Feature S233, “Multiset locators”, conforming SQL language shall not contain a <Fortran multiset
   locator variable>.
6) Without Feature S231, “Structured type locators”, conforming SQL language shall not contain a <path-
   resolved user-defined type name> simply contained in a <Fortran user-defined type locator variable> that
   identifies a structured type.
7) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain a
   <Fortran BLOB variable>.
8) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain a
   <Fortran CLOB variable>.
9) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain a
   <Fortran BLOB locator variable>.
10) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain a
    <Fortran CLOB locator variable>.




©ISO/IEC 2003 – All rights reserved                                                  Embedded SQL 1031
ISO/IEC 9075-2:2003 (E)
20.7 <embedded SQL MUMPS program>



20.7 <embedded SQL MUMPS program>

Function
Specify an <embedded SQL MUMPS program>.


Format
<embedded SQL MUMPS program> ::= !! See the Syntax Rules.

<MUMPS variable definition> ::=
    <MUMPS numeric variable> <semicolon>
  | <MUMPS character variable> <semicolon>
  | <MUMPS derived type specification> <semicolon>

<MUMPS character variable> ::=
    VARCHAR <MUMPS host identifier> <MUMPS length specification>
    [ { <comma> <MUMPS host identifier> <MUMPS length specification> }... ]

<MUMPS host identifier> ::= !! See the Syntax Rules.

<MUMPS length specification> ::= <left paren> <length> <right paren>

<MUMPS numeric variable> ::=
    <MUMPS type specification> <MUMPS host identifier>
    [ { <comma> <MUMPS host identifier> }... ]

<MUMPS type specification> ::=
    INT
  | DEC [ <left paren> <precision> [ <comma> <scale> ] <right paren> ]
  | REAL

<MUMPS derived type specification> ::=
    <MUMPS CLOB variable>
  | <MUMPS BLOB variable>
  | <MUMPS user-defined type variable>
  | <MUMPS CLOB locator variable>
  | <MUMPS BLOB locator variable>
  | <MUMPS user-defined type locator variable>
  | <MUMPS array locator variable>
  | <MUMPS multiset locator variable>
  | <MUMPS REF variable>

<MUMPS CLOB variable> ::=
    SQL TYPE IS CLOB <left paren> <large object length> <right paren>
    [ CHARACTER SET [ IS ] <character set specification> ]

<MUMPS BLOB variable> ::=
    SQL TYPE IS BLOB <left paren> <large object length> <right paren>

<MUMPS user-defined type variable> ::=
    SQL TYPE IS <path-resolved user-defined type name> AS <predefined type>

<MUMPS CLOB locator variable> ::=




1032 Foundation (SQL/Foundation)                                 ©ISO/IEC 2003 – All rights reserved
                                                                               ISO/IEC 9075-2:2003 (E)
                                                                 20.7 <embedded SQL MUMPS program>



     SQL TYPE IS CLOB AS LOCATOR

<MUMPS BLOB locator variable> ::=
    SQL TYPE IS BLOB AS LOCATOR

<MUMPS user-defined type locator variable> ::=
    SQL TYPE IS <path-resolved user-defined type name> AS LOCATOR

<MUMPS array locator variable> ::=
    SQL TYPE IS <array type> AS LOCATOR

<MUMPS multiset locator variable> ::=
    SQL TYPE IS <multiset type> AS LOCATOR

<MUMPS REF variable> ::=
    SQL TYPE IS <reference type>


Syntax Rules
1) An <embedded SQL MUMPS program> is a compilation unit that consists of M text and SQL text. The
   M text shall conform to [ISO11756]. The SQL text shall consist of one or more <embedded SQL statement>s
   and, optionally, one or more <embedded SQL declare section>s.
2) A <MUMPS host identifier> is any valid M variable name. A <MUMPS host identifier> shall be contained
   in an <embedded SQL MUMPS program>.
3) An <embedded SQL statement> may be specified wherever an M command may be specified.
4) A <MUMPS variable definition> defines one or more host variables.
5) The <MUMPS character variable> describes a variable-length character string. The equivalent SQL data
   type is CHARACTER VARYING whose maximum length is the <length> of the <MUMPS length speci-
   fication> and whose character set is implementation-defined.
6) INT describes an exact numeric variable. The equivalent SQL data type is INTEGER.
7) DEC describes an exact numeric variable. The <scale> shall not be greater than the <precision>. The
   equivalent SQL data type is DECIMAL with the same <precision> and <scale>.
8) REAL describes an approximate numeric variable. The equivalent SQL data type is REAL.
9) A <MUMPS derived type specification> shall be modified as follows before it is placed into the program
   derived from the <embedded SQL MUMPS program> (see the Syntax Rules of Subclause 20.1,
   “<embedded SQL host program>”).
    a) Any optional CHARACTER SET specification shall be removed from a <MUMPS CLOB variable>.
    b) The syntax
             SQL TYPE IS CLOB ( L )
         and the syntax
             SQL TYPE IS BLOB ( L )
         for a given <MUMPS host identifier> HVN shall be replaced by


©ISO/IEC 2003 – All rights reserved                                                  Embedded SQL 1033
ISO/IEC 9075-2:2003 (E)
20.7 <embedded SQL MUMPS program>



         INT HVN_RESERVED
         INT HVN_LENGTH
         VARCHAR HVN_DATA L

       in any <MUMPS CLOB variable> or <MUMPS BLOB variable>, where L is the numeric value of
       <large object length> as specified in Subclause 5.2, “<token> and <separator>”.
   c) The syntax
         SQL TYPE IS UDTN AS PDT
       shall be replaced by
         ADT
       in any <MUMPS user-defined type variable>, where ADT is the data type listed in the “MUMPS data
       type” column corresponding to the row for SQL data type PDT in Table 20, “Data type correspondences
       for M”, ADT shall not be “none”. The data type identified by UDTN is called the associated user-
       defined type of the host variable and the data type identified by PDT is called the associated SQL data
       type of the host variable.
   d) The syntax
         SQL TYPE IS BLOB AS LOCATOR
       shall be replaced by
         INT
       in any or <MUMPS BLOB locator variable>. The host variable defined by <MUMPS BLOB locator
       variable> is called a binary large object locator variable.
   e) The syntax
         SQL TYPE IS CLOB AS LOCATOR
       shall be replaced by
         INT
       in any <MUMPS CLOB locator variable>. The host variable defined by <MUMPS CLOB locator
       variable> is called a character large object locator variable.
   f) The syntax
         SQL TYPE IS <path-resolved user-defined type name> AS LOCATOR
       shall be replaced by
         INT
       in any <MUMPS user-defined type locator variable>. The host variable defined by <MUMPS user-
       defined type locator variable> is called a user-defined type locator variable. The data type identified
       by <path-resolved user-defined type name> is called the associated user-defined type of the host variable.
   g) The syntax



1034 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                       20.7 <embedded SQL MUMPS program>



             SQL TYPE IS <array type> AS LOCATOR
         shall be replaced by
             INT
         in any <MUMPS array locator variable>. The host variable defined by <MUMPS array locator variable>
         is called an array locator variable. The data type identified by <array type> is called the associated
         array type of the host variable.
    h) The syntax
             SQL TYPE IS <multiset type> AS LOCATOR
         shall be replaced by
             INT
         in any <MUMPS multiset locator variable>. The host variable defined by <MUMPS multiset locator
         variable> is called a multiset locator variable. The data type identified by <multiset type> is called the
         associated multiset type of the host variable.
    i)   The syntax
             SQL TYPE IS <reference type>
         for a given <MUMPS host identifier> HVN shall be replaced by
             VARCHAR HVN L
         in any <MUMPS REF variable>, where L is the length in octets of the reference type.
    The modified <MUMPS variable definition> shall be a valid M variable in the program derived from the
    <embedded SQL MUMPS program>.
10) The reference type identified by <reference type> contained in an <MUMPS REF variable> is called the
    referenced type of the reference.


Access Rules
    None.


General Rules
1) See Subclause 20.1, “<embedded SQL host program>”.


Conformance Rules
1) Without Feature B015, “Embedded MUMPS”, conforming SQL language shall not contain an <embedded
   SQL MUMPS program>.
2) Without Feature S041, “Basic reference types”, conforming SQL language shall not contain a <MUMPS
   REF variable>.


©ISO/IEC 2003 – All rights reserved                                                         Embedded SQL 1035
ISO/IEC 9075-2:2003 (E)
20.7 <embedded SQL MUMPS program>



3) Without Feature S241, “Transform functions”, conforming SQL language shall not contain a <MUMPS
   user-defined type variable>.
4) Without Feature S232, “Array locators”, conforming SQL language shall not contain a <MUMPS array
   locator variable>.
5) Without Feature S233, “Multiset locators”, conforming SQL language shall not contain a <MUMPS mul-
   tiset locator variable>.
6) Without Feature S231, “Structured type locators”, conforming SQL language shall not contain a <path-
   resolved user-defined type name> simply contained in a <MUMPS user-defined type locator variable> that
   identifies a structured type.
7) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain a
   <MUMPS BLOB variable>.
8) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain a
   <MUMPS CLOB variable>.
9) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain a
   <MUMPS BLOB locator variable>.
10) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain a and
    <MUMPS CLOB locator variable>.




1036 Foundation (SQL/Foundation)                                             ©ISO/IEC 2003 – All rights reserved
                                                                     ISO/IEC 9075-2:2003 (E)
                                                         20.8 <embedded SQL Pascal program>



20.8 <embedded SQL Pascal program>

Function
Specify an <embedded SQL Pascal program>.


Format
<embedded SQL Pascal program> ::= !! See the Syntax Rules.

<Pascal variable definition> ::=
    <Pascal host identifier> [ { <comma> <Pascal host identifier> }... ] <colon>
    <Pascal type specification> <semicolon>

<Pascal host identifier> ::= !! See the Syntax Rules.

<Pascal type specification> ::=
    PACKED ARRAY <left bracket> 1 <double period> <length> <right bracket>
    OF CHAR [ CHARACTER SET [ IS ] <character set specification> ]
  | INTEGER
  | REAL
  | CHAR [ CHARACTER SET [ IS ] <character set specification> ]
  | BOOLEAN
  | <Pascal derived type specification>

<Pascal derived type specification> ::=
    <Pascal CLOB variable>
  | <Pascal BLOB variable>
  | <Pascal user-defined type variable>
  | <Pascal CLOB locator variable>
  | <Pascal BLOB locator variable>
  | <Pascal user-defined type locator variable>
  | <Pascal array locator variable>
  | <Pascal multiset locator variable>
  | <Pascal REF variable>

<Pascal CLOB variable> ::=
    SQL TYPE IS CLOB <left paren> <large object length> <right paren>
    [ CHARACTER SET [ IS ] <character set specification> ]

<Pascal BLOB variable> ::=
    SQL TYPE IS BLOB <left paren> <large object length> <right paren>

<Pascal CLOB locator variable> ::=
    SQL TYPE IS CLOB AS LOCATOR

<Pascal user-defined type variable> ::=
    SQL TYPE IS <path-resolved user-defined type name> AS <predefined type>

<Pascal BLOB locator variable> ::=
    SQL TYPE IS BLOB AS LOCATOR

<Pascal user-defined type locator variable> ::=
    SQL TYPE IS <path-resolved user-defined type name> AS LOCATOR



©ISO/IEC 2003 – All rights reserved                                     Embedded SQL 1037
ISO/IEC 9075-2:2003 (E)
20.8 <embedded SQL Pascal program>



<Pascal array locator variable> ::=
    SQL TYPE IS <array type> AS LOCATOR

<Pascal multiset locator variable> ::=
    SQL TYPE IS <multiset type> AS LOCATOR

<Pascal REF variable> ::=
    SQL TYPE IS <reference type>


Syntax Rules
1) An <embedded SQL Pascal program> is a compilation unit that consists of Pascal text and SQL text. The
   Pascal text shall conform to one of [ISO7185] or [ISO10206]. The SQL text shall consist of one or more
   <embedded SQL statement>s and, optionally, one or more <embedded SQL declare section>s.
2) An <embedded SQL statement> may be specified wherever a Pascal statement may be specified. An
   <embedded SQL statement> may be prefixed by a Pascal label.
3) A <Pascal host identifier> is a Pascal variable-identifier whose applied instance denotes a defining instance
   within an <embedded SQL begin declare> and an <embedded SQL end declare>.
4) A <Pascal variable definition> defines one or more <Pascal host identifier>s.
5) A <Pascal variable definition> shall be modified as follows before it is placed into the program derived
   from the <embedded SQL Pascal program> (see the Syntax Rules of Subclause 20.1, “<embedded SQL
   host program>”).
    a) Any optional CHARACTER SET specification shall be removed from the PACKED ARRAY OF
       CHAR or CHAR alternatives of a <Pascal type specification> and a <Pascal CLOB variable>.
    b) The <length> specified in the PACKED ARRAY OF CHAR alternative of any <Pascal type specifica-
       tion> that contains a CHARACTER SET specification and the <large object length> specified in a
       <Pascal CLOB variable> that contains a CHARACTER SET specification shall be replaced by a length
       equal to the length in octets of PN, where PN is the <Pascal host identifier> specified in the containing
       <Pascal variable definition>.
    c) If any <Pascal type specification> specifies the syntax “CHAR” and contains a CHARACTER SET
       specification, then let L be a length equal to the length in octets of PN and PN be the <Pascal host
       identifier> specified in the containing <Pascal variable definition>. If L is greater than 1 (one), then
       “CHAR” shall be replaced by “PACKED ARRAY [1..L] OF CHAR”.
    d) The syntax
           SQL TYPE IS CLOB ( L )
        and the syntax
           SQL TYPE IS BLOB ( L )
        for a given <Pascal host identifier> HVN shall be replaced by
           VAR HVN = RECORD
             HVN_RESERVED : INTEGER;
             HVN_LENGTH : INTEGER;




1038 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                         20.8 <embedded SQL Pascal program>



               HVN_DATA : PACKED ARRAY [ 1..L ] OF CHAR;
             END;

         in any <Pascal CLOB variable> or <Pascal BLOB variable>, where L is the numeric value of <large
         object length> as specified in Subclause 5.2, “<token> and <separator>”.
    e) The syntax
             SQL TYPE IS UDTN AS PDT
         shall be replaced by
             ADT
         in any <Pascal user-defined type variable>, where ADT is the data type listed in the “Pascal data type”
         column corresponding to the row for SQL data type PDT in Table 21, “Data type correspondences for
         Pascal”. ADT shall not be “none”. The data type identified by UDTN is called the associated user-
         defined type of the host variable and the data type identified by PDT is called the associated SQL data
         type of the host variable.
    f) The syntax
             SQL TYPE IS BLOB AS LOCATOR
         shall be replaced by
             INTEGER
         in any <Pascal BLOB locator variable>. The host variable defined by <Pascal BLOB locator variable>
         is called a binary large object locator variable.
    g) The syntax
             SQL TYPE IS CLOB AS LOCATOR
         shall be replaced by
             INTEGER
         in any <Pascal CLOB locator variable>. The host variable defined by <Pascal CLOB locator variable>
         is called a character large object locator variable.
    h) The syntax
             SQL TYPE IS <path-resolved user-defined type name> AS LOCATOR
         shall be replaced by
             INTEGER
         in any <Pascal user-defined type locator variable>. The host variable defined by <Pascal user-defined
         type locator variable> is called a user-defined type locator variable. The data type identified by <path-
         resolved user-defined type name> is called the associated user-defined type of the host variable.
    i)   The syntax
             SQL TYPE IS <array type> AS LOCATOR



©ISO/IEC 2003 – All rights reserved                                                        Embedded SQL 1039
ISO/IEC 9075-2:2003 (E)
20.8 <embedded SQL Pascal program>



         shall be replaced by
            INTEGER
         in any <Pascal array locator variable>. The host variable defined by <Pascal array locator variable> is
         called an array locator variable. The data type identified by <array type> is called the associated array
         type of the host variable.
    j)   The syntax
            SQL TYPE IS <multiset type> AS LOCATOR
         shall be replaced by
            INTEGER
         in any <Pascal multiset locator variable>. The host variable defined by <Pascal multiset locator variable>
         is called a multiset locator variable. The data type identified by <multiset type> is called the associated
         multiset type of the host variable.
    k) The syntax
            SQL TYPE IS <reference type>
         for a given <Pascal host identifier> HVN shall be replaced by
            HVN : PACKED ARRAY [1..<length>] OF CHAR
         in any <Pascal REF variable>, where <length> is the length in octets of the reference type.
    The modified <Pascal variable definition> shall be a valid Pascal variable-declaration in the program
    derived from the <embedded SQL Pascal program>.
6) The reference type identified by <reference type> contained in an <Pascal REF variable> is called the ref-
   erenced type of the reference.
7) CHAR specified without a CHARACTER SET specification is the ordinal-type-identifier of PASCAL.
   The equivalent SQL data type is CHARACTER with length 1 (one).
8) PACKED ARRAY [1..<length>] OF CHAR describes a character string having 2 or more components of
   the simple type CHAR. The equivalent SQL data type is CHARACTER with the same length and character
   set specified by <character set specification>. If <character set specification> is not specified, then an
   implementation-defined <character set specification> is implicit.
9) INTEGER describes an exact numeric variable. The equivalent SQL data type is INTEGER.
10) REAL describes an approximate numeric variable. The equivalent SQL data type is REAL.
11) BOOLEAN describes a boolean variable. The equivalent SQL data type is BOOLEAN.


Access Rules
    None.




1040 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                ISO/IEC 9075-2:2003 (E)
                                                                    20.8 <embedded SQL Pascal program>



General Rules
1) See Subclause 20.1, “<embedded SQL host program>”.


Conformance Rules
1) Without Feature B016, “Embedded Pascal”, conforming SQL language shall not contain an <embedded
   SQL Pascal program>.
2) Without Feature S041, “Basic reference types”, conforming SQL language shall not contain a <Pascal REF
   variable>.
3) Without Feature S241, “Transform functions”, conforming SQL language shall not contain a <Pascal user-
   defined type variable>.
4) Without Feature S232, “Array locators”, conforming SQL language shall not contain a <Pascal array
   locator variable>.
5) Without Feature S233, “Multiset locators”, conforming SQL language shall not contain a <Pascal multiset
   locator variable>.
6) Without Feature S231, “Structured type locators”, conforming SQL language shall not contain a <path-
   resolved user-defined type name> simply contained in a <Pascal user-defined type locator variable> that
   identifies a structured type.
7) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain a
   <Pascal BLOB variable>.
8) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain a
   <Pascal CLOB variable>.
9) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain a
   <Pascal BLOB locator variable>.
10) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain a
    <Pascal BLOB variable>, <Pascal CLOB variable>, <Pascal CLOB locator variable>.




©ISO/IEC 2003 – All rights reserved                                                  Embedded SQL 1041
ISO/IEC 9075-2:2003 (E)
20.9 <embedded SQL PL/I program>



20.9 <embedded SQL PL/I program>

Function
Specify an <embedded SQL PL/I program>.


Format
<embedded SQL PL/I program> ::= !! See the Syntax Rules.

<PL/I variable definition> ::=
    { DCL | DECLARE } <PL/I type specification> [ <character representation>... ] <semicolon>
  | { <PL/I host identifier> | <left paren> <PL/I host identifier>
    [ { <comma> <PL/I host identifier> }... ] <right paren> }
    <PL/I type specification> [ <character representation>... ] <semicolon>

<PL/I host identifier> ::= !! See the Syntax Rules.

<PL/I type specification> ::=
    { CHAR | CHARACTER } [ VARYING ] <left paren> <length> <right paren>
    [ CHARACTER SET [ IS ] <character set specification> ]
  | <PL/I type fixed decimal> <left paren> <precision> [ <comma> <scale> ] <right paren>
  | <PL/I type fixed binary> [ <left paren> <precision> <right paren> ]
  | <PL/I type float binary> <left paren> <precision> <right paren>
  | <PL/I derived type specification>

<PL/I derived type specification> ::=
    <PL/I CLOB variable>
  | <PL/I BLOB variable>
  | <PL/I user-defined type variable>
  | <PL/I CLOB locator variable>
  | <PL/I BLOB locator variable>
  | <PL/I user-defined type locator variable>
  | <PL/I array locator variable>
  | <PL/I multiset locator variable>
  | <PL/I REF variable>

<PL/I CLOB variable> ::=
    SQL TYPE IS CLOB <left paren> <large object length> <right paren>
    [ CHARACTER SET [ IS ] <character set specification> ]

<PL/I BLOB variable> ::=
    SQL TYPE IS BLOB <left paren> <large object length> <right paren>

<PL/I user-defined type variable> ::=
    SQL TYPE IS <path-resolved user-defined type name> AS <predefined type>

<PL/I CLOB locator variable> ::=
    SQL TYPE IS CLOB AS LOCATOR

<PL/I BLOB locator variable> ::=
    SQL TYPE IS BLOB AS LOCATOR

<PL/I user-defined type locator variable> ::=



1042 Foundation (SQL/Foundation)                                    ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                         20.9 <embedded SQL PL/I program>



     SQL TYPE IS <path-resolved user-defined type name> AS LOCATOR

<PL/I array locator variable> ::=
    SQL TYPE IS <array type> AS LOCATOR

<PL/I multiset locator variable> ::=
    SQL TYPE IS <multiset type> AS LOCATOR

<PL/I REF variable> ::=
    SQL TYPE IS <reference type>

<PL/I type fixed decimal> ::=
    { DEC | DECIMAL } FIXED
  | FIXED { DEC | DECIMAL }

<PL/I type fixed binary> ::=
    { BIN | BINARY } FIXED
  | FIXED { BIN | BINARY }

<PL/I type float binary> ::=
    { BIN | BINARY } FLOAT
  | FLOAT { BIN | BINARY }


Syntax Rules
1) An <embedded SQL PL/I program> is a compilation unit that consists of PL/I text and SQL text. The PL/I
   text shall conform to [ISO6160]. The SQL text shall consist of one or more <embedded SQL statement>s
   and, optionally, one or more <embedded SQL declare section>s.
2) An <embedded SQL statement> may be specified wherever a PL/I statement may be specified within a
   procedure block. If the PL/I statement could include a label prefix, the <embedded SQL statement> may
   be immediately preceded by a label prefix.
3) A <PL/I host identifier> is any valid PL/I variable identifier. A <PL/I host identifier> shall be contained
   in an <embedded SQL PL/I program>.
4) A <PL/I variable definition> defines one or more host variables.
5) A <PL/I variable definition> shall be modified as follows before it is placed into the program derived from
   the <embedded SQL PL/I program> (see the Syntax Rules of Subclause 20.1, “<embedded SQL host pro-
   gram>”).
    a) Any optional CHARACTER SET specification shall be removed from the CHARACTER or CHAR-
       ACTER VARYING alternatives of a <PL/I type specification>.
    b) The <length> specified in the CHARACTER or CHARACTER VARYING alternatives of any <PL/I
       type specification> or a <PL/I CLOB variable> that contains a CHARACTER SET specification shall
       be replaced by a length equal to the length in octets of PN, where PN is the <PL/I host identifier>
       specified in the containing <PL/I variable definition>.
    c) The syntax
             SQL TYPE IS CLOB ( L )
         and the syntax


©ISO/IEC 2003 – All rights reserved                                                      Embedded SQL 1043
ISO/IEC 9075-2:2003 (E)
20.9 <embedded SQL PL/I program>



         SQL TYPE IS BLOB ( L )
       for a given <PL/I host identifier> HVN shall be replaced by
         DCL 1 HVN
               2 HVN_RESERVED FIXED BINARY(31),
               2 HVN_LENGTH   FIXED BINARY(31),
               2 HVN_DATA     CHARACTER(<length>);

       in any <PL/I CLOB variable> or <PL/I BLOB variable>, where L is the numeric value of <large object
       length> as specified in Subclause 5.2, “<token> and <separator>”.
   d) The syntax
         SQL TYPE IS UDTN AS PDT
       shall be replaced by
         ADT
       in any <PL/I user-defined type variable>, where ADT is the data type listed in the “PL/I data type”
       column corresponding to the row for SQL data type PDT in Table 22, “Data type correspondences for
       PL/I”. ADT shall not be “none”. The data type identified by UDTN is called the associated user-defined
       type of the host variable and the data type identified by PDT is called the associated SQL data type of
       the host variable.
   e) The syntax
         SQL TYPE IS BLOB AS LOCATOR
       shall be replaced by
         FIXED BINARY(31)
       in any <PL/I BLOB locator variable>. The host variable defined by <PL/I BLOB locator variable> is
       called a binary large object locator variable.
   f) The syntax
         SQL TYPE IS CLOB AS LOCATOR
       shall be replaced by
         FIXED BINARY(31)
       in any <PL/I CLOB locator variable>. The host variable defined by <PL/I CLOB locator variable> is
       called a character large object locator variable.
   g) The syntax
         SQL TYPE IS <path-resolved user-defined type name> AS LOCATOR
       shall be replaced by
         FIXED BINARY(31)




1044 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                            20.9 <embedded SQL PL/I program>



         in any <PL/I user-defined type locator variable>. The host variable defined by <PL/I user-defined type
         locator variable> is called a user-defined type locator variable. The data type identified by <path-
         resolved user-defined type name> is called the associated user-defined type of the host variable.
    h) The syntax
             SQL TYPE IS <array type> AS LOCATOR
         shall be replaced by
             FIXED BINARY(31)
         in any <PL/I array locator variable>. The host variable defined by <PL/I array locator variable> is
         called an array locator variable. The data type identified by <array type> is called the associated array
         type of the host variable.
    i)   The syntax
             SQL TYPE IS <multiset type> AS LOCATOR
         shall be replaced by
             FIXED BINARY(31)
         in any <PL/I multiset locator variable>. The host variable defined by <PL/I multiset locator variable>
         is called a multiset locator variable. The data type identified by <multiset type> is called the associated
         multiset type of the host variable.
    j)   The syntax
             SQL TYPE IS <reference type>
         for a given <PL/I host identifier> HVN shall be replaced by
             DCL HVN CHARACTER(<length>) VARYING
         in any <PL/I REF variable>, where <length> is the length in octets of the reference type.
    The modified <PL/I variable definition> shall be a valid PL/I data declaration in the program derived from
    the <embedded SQL PL/I program>.
6) The reference type identified by <reference type> contained in an <PL/I REF variable> is called the refer-
   enced type of the reference.
7) A <PL/I variable definition> shall specify a scalar variable, not an array or structure.
8) The optional <character representation> sequence in a <PL/I variable definition> may specify an INITIAL
   clause. Whether other clauses may be specified is implementation-defined. The <character representation>
   sequence shall be such that the <PL/I variable definition> is a valid PL/I DECLARE statement.
9) CHARACTER describes a character string variable whose equivalent SQL data type has the character set
   specified by <character set specification>. If <character set specification> is not specified, then an imple-
   mentation-defined <character set specification> is implicit.
    Case:




©ISO/IEC 2003 – All rights reserved                                                         Embedded SQL 1045
ISO/IEC 9075-2:2003 (E)
20.9 <embedded SQL PL/I program>



   a) If VARYING is not specified, then the length of the variable is fixed. The equivalent SQL data type
      is CHARACTER with the same length.
   b) If VARYING is specified, then the variable is of variable length, with maximum size the value of
      <length>. The equivalent SQL data type is CHARACTER VARYING with the same maximum length.
10) FIXED DECIMAL describes an exact numeric variable. The <scale> shall not be greater than the <preci-
    sion>. The equivalent SQL data type is DECIMAL with the same <precision> and <scale>.
11) FIXED BINARY describes an exact numeric variable. The equivalent SQL data type is SMALLINT,
    INTEGER, or BIGINT.
12) FLOAT BINARY describes an approximate numeric variable. The equivalent SQL data type is FLOAT
    with the same <precision>.


Access Rules
   None.


General Rules
1) See Subclause 20.1, “<embedded SQL host program>”


Conformance Rules
1) Without Feature B017, “Embedded PL/I”, conforming SQL language shall not contain an <embedded SQL
   PL/I program>.
2) Without Feature S041, “Basic reference types”, conforming SQL language shall not contain a <PL/I REF
   variable>.
3) Without Feature S241, “Transform functions”, conforming SQL language shall not contain a <PL/I user-
   defined type variable>.
4) Without Feature S232, “Array locators”, conforming SQL language shall not contain a <PL/I array locator
   variable>.
5) Without Feature S233, “Multiset locators”, conforming SQL language shall not contain a <PL/I multiset
   locator variable>.
6) Without Feature S231, “Structured type locators”, conforming SQL language shall not contain a <path-
   resolved user-defined type name> simply contained in a <PL/I user-defined type locator variable> that
   identifies a structured type.
7) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain a <PL/I
   BLOB variable>.
8) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain a <PL/I
   CLOB variable>.
9) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain a <PL/I
   BLOB locator variable>.


1046 Foundation (SQL/Foundation)                                             ©ISO/IEC 2003 – All rights reserved
                                                                                ISO/IEC 9075-2:2003 (E)
                                                                     20.9 <embedded SQL PL/I program>



10) Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not contain a <PL/I
    CLOB locator variable>.




©ISO/IEC 2003 – All rights reserved                                                 Embedded SQL 1047
ISO/IEC 9075-2:2003 (E)




                                   This page intentionally left blank.




1048 Foundation (SQL/Foundation)                                         ©ISO/IEC 2003 – All rights reserved
                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                               21.1 <direct SQL statement>




21 Direct invocation of SQL


21.1 <direct SQL statement>

Function
Specify direct execution of SQL.


Format
<direct SQL statement> ::= <directly executable statement> <semicolon>

<directly executable statement> ::=
    <direct SQL data statement>
  | <SQL schema statement>
  | <SQL transaction statement>
  | <SQL connection statement>
  | <SQL session statement>
  | <direct implementation-defined statement>

<direct SQL data statement> ::=
    <delete statement: searched>
  | <direct select statement: multiple rows>
  | <insert statement>
  | <update statement: searched>
  | <merge statement>
  | <temporary table declaration>

<direct implementation-defined statement> ::= !! See the Syntax Rules


Syntax Rules
1) The <direct SQL data statement> shall not contain an SQL parameter reference, SQL variable reference,
   <dynamic parameter specification>, or <embedded variable specification>.
2) The <value specification> that represents the null value is implementation-defined.
3) The Format and Syntax Rules for <direct implementation-defined statement> are implementation-defined.


Access Rules
1) The Access Rules for <direct implementation-defined statement> are implementation-defined.




©ISO/IEC 2003 – All rights reserved                                          Direct invocation of SQL 1049
ISO/IEC 9075-2:2003 (E)
21.1 <direct SQL statement>



General Rules
1) The following <direct SQL statement>s are transaction-initiating <direct SQL statement>s:
    a) <direct SQL statement>s that are transaction-initiating <SQL procedure statement>s.
    b) <direct select statement: multiple rows>.
    c) <direct implementation-defined statement>s that are transaction-initiating.
2) After the last invocation of an SQL-statement by an SQL-agent in an SQL-session:
    a) A <rollback statement> or a <commit statement> is effectively executed. If an unrecoverable error has
       occurred, or if the direct invocation of SQL terminated unexpectedly, or if any constraint is not satisfied,
       then a <rollback statement> is performed. Otherwise, the choice of which of these SQL-statements to
       perform is implementation-dependent. The determination of whether a direct invocation of SQL has
       terminated unexpectedly is implementation-dependent.
    b) Let D be the <descriptor name> of any SQL descriptor area that is currently allocated within the current
       SQL-session. A <deallocate descriptor statement> that specifies
              DEALLOCATE DESCRIPTOR D
        is effectively executed.
    c) All SQL-sessions associated with the SQL-agent are terminated.
3) Let S be the <direct SQL statement>.
4) A copy of the top cell of the authorization stack is pushed onto the authorization stack.
5) If S does not conform to the Format, Syntax Rules, and Access Rules for a <direct SQL statement>, then
   an exception condition is raised: syntax error or access rule violation.
6) When S is invoked by the SQL-agent:
    Case:
    a) If S is an <SQL connection statement>, then:
        i)      The first diagnostics area is emptied.
        ii)     S is executed.
        iii)    If S successfully initiated or resumed an SQL-session, then subsequent invocations of a <direct
                SQL statement> by the SQL-agent are associated with that SQL-session until the SQL-agent
                terminates the SQL-session or makes it dormant.
    b) Otherwise:
        i)      If no SQL-session is current for the SQL-agent, then
                Case:
                1) If the SQL-agent has not executed an <SQL connection statement> and there is no default
                   SQL-session associated with the SQL-agent, then the following <connect statement> is
                   effectively executed:


1050 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                             ISO/IEC 9075-2:2003 (E)
                                                                                         21.1 <direct SQL statement>



                          CONNECT TO DEFAULT

                  2) If the SQL-agent has not executed an <SQL connection statement> and there is a default
                     SQL-session associated with the SQL-agent, then the following <set connection statement>
                     is effectively executed:
                          SET CONNECTION DEFAULT

                  3) Otherwise, an exception condition is raised: connection exception — connection does not
                     exist.
                  Subsequent calls to an <externally-invoked procedure> or invocations of a <direct SQL statement>
                  by the SQL-agent are associated with the SQL-session until the SQL-agent terminates the SQL-
                  session or makes it dormant.
         ii)      If an SQL-transaction is active for the SQL-agent, then S is associated with that SQL-transaction.
                  If S is a <direct implementation-defined statement>, then it is implementation-defined whether
                  or not S may be associated with an active SQL-transaction; if not, then an exception condition
                  is raised: invalid transaction state — active SQL-transaction.
         iii)     If no SQL-transaction is active for the SQL-agent, then
                  1) Case:
                      A) If S is a transaction-initiating <direct SQL statement>, then an SQL-transaction is initi-
                         ated.
                      B) If S is a <direct implementation-defined statement>, then it is implementation-defined
                         whether or not S initiates an SQL-transaction. If an implementation defines S to be
                         transaction-initiating, then an SQL-transaction is initiated.
                  2) If S initiated an SQL-transaction, then:
                      A) Let T be the SQL-transaction initiated by S.
                      B) T is associated with this invocation and any subsequent invocations of <direct SQL
                         statement>s or calls to an <externally-invoked procedure> by the SQL-agent until the
                         SQL-agent terminates T.
                      C) If S is not a <start transaction statement>, then
                           Case:
                           I)         If a <set transaction statement> has been executed since the termination of the
                                      last SQL-transaction in the SQL-session (or if there has been no previous SQL-
                                      transaction in the SQL-session and a <set transaction statement> has been exe-
                                      cuted), then the access mode, constraint mode, and isolation level of T are set as
                                      specified by the <set transaction statement>.
                           II)        Otherwise, the access mode, constraint mode for all constraints, and isolation
                                      level for T are read-write, immediate, and SERIALIZABLE, respectively.
                      D) T is associated with the SQL-session.




©ISO/IEC 2003 – All rights reserved                                                     Direct invocation of SQL 1051
ISO/IEC 9075-2:2003 (E)
21.1 <direct SQL statement>



        iv)     If S contains an <SQL schema statement> and the access mode of the current SQL-transaction
                is read-only, then an exception condition is raised: invalid transaction state — read-only SQL-
                transaction.
        v)      The first diagnostics area is emptied.
        vi)     S is executed.
7) Upon completion of execution, the top cell in the authorization stack is removed.
8) If the execution of a <direct SQL data statement> occurs within the same SQL-transaction as the execution
   of an SQL-schema statement and this is not allowed by the SQL-implementation, then an exception condition
   is raised: invalid transaction state — schema and data statement mixing not supported.
9) Case:
    a) If S executed successfully, then either a completion condition is raised: successful completion, or a
       completion condition is raised: warning, or a completion condition is raised: no data.
    b) If S did not execute successfully, then all changes made to SQL-data or schemas by the execution of
       S are canceled and an exception condition is raised.
        NOTE 450 — The method of raising a condition is implementation-defined.

10) Diagnostics information resulting from the execution of S is placed into the first diagnostics area, causing
    the first condition area in the first diagnostics area to become occupied.
    NOTE 451 — The method of accessing the diagnostics information is implementation-defined, but does not alter the contents of
    the diagnostics area.


Conformance Rules
1) Without Feature B021, “Direct SQL”, conforming SQL language shall not contain a <direct SQL statement>.




1052 Foundation (SQL/Foundation)                                                             ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)
                                                                  21.2 <direct select statement: multiple rows>



21.2 <direct select statement: multiple rows>

Function
Specify a statement to retrieve multiple rows from a specified table.


Format
<direct select statement: multiple rows> ::= <cursor specification>


Syntax Rules
1) The <query expression> or <order by clause> of a <direct select statement: multiple rows> shall not contain
   a <value specification> other than a <literal>, CURRENT_USER, CURRENT_ROLE, SESSION_USER,
   SYSTEM_USER, CURRENT_PATH, CURRENT_DEFAULT_TRANSFORM_GROUP, or CUR-
   RENT_TRANSFORM_GROUP_FOR_TYPE.
2) The <cursor specification> shall not contain an <updatability clause>.


Access Rules
    None.


General Rules
1) Let Q be the result of the <cursor specification>.
2) Case:
    a) If Q is empty, then a completion condition is raised: no data.
    b) Otherwise, Q is not empty and Q is returned. The method of returning Q is implementation-defined.


Conformance Rules
    None.




©ISO/IEC 2003 – All rights reserved                                             Direct invocation of SQL 1053
ISO/IEC 9075-2:2003 (E)




                                   This page intentionally left blank.




1054 Foundation (SQL/Foundation)                                         ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                             22.1 <get diagnostics statement>




22 Diagnostics management


22.1 <get diagnostics statement>

Function
Get exception or completion condition information from a diagnostics area.


Format
<get diagnostics statement> ::=
    GET DIAGNOSTICS <SQL diagnostics information>

<SQL diagnostics information> ::=
    <statement information>
  | <condition information>

<statement information> ::=
    <statement information item> [ { <comma> <statement information item> }... ]

<statement information item> ::=
    <simple target specification> <equals operator> <statement information item name>

<statement information item name> ::=
    NUMBER
  | MORE
  | COMMAND_FUNCTION
  | COMMAND_FUNCTION_CODE
  | DYNAMIC_FUNCTION
  | DYNAMIC_FUNCTION_CODE
  | ROW_COUNT
  | TRANSACTIONS_COMMITTED
  | TRANSACTIONS_ROLLED_BACK
  | TRANSACTION_ACTIVE

<condition information> ::=
    { EXCEPTION | CONDITION } <condition number> <condition information item>
    [ { <comma> <condition information item> }... ]

<condition information item> ::=
    <simple target specification> <equals operator> <condition information item name>

<condition information item name> ::=
    CATALOG_NAME
  | CLASS_ORIGIN
  | COLUMN_NAME
  | CONDITION_NUMBER
  | CONNECTION_NAME
  | CONSTRAINT_CATALOG



©ISO/IEC 2003 – All rights reserved                                            Diagnostics management 1055
ISO/IEC 9075-2:2003 (E)
22.1 <get diagnostics statement>



  |   CONSTRAINT_NAME
  |   CONSTRAINT_SCHEMA
  |   CURSOR_NAME
  |   MESSAGE_LENGTH
  |   MESSAGE_OCTET_LENGTH
  |   MESSAGE_TEXT
  |   PARAMETER_MODE
  |   PARAMETER_NAME
  |   PARAMETER_ORDINAL_POSITION
  |   RETURNED_SQLSTATE
  |   ROUTINE_CATALOG
  |   ROUTINE_NAME
  |   ROUTINE_SCHEMA
  |   SCHEMA_NAME
  |   SERVER_NAME
  |   SPECIFIC_NAME
  |   SUBCLASS_ORIGIN
  |   TABLE_NAME
  |   TRIGGER_CATALOG
  |   TRIGGER_NAME
  |   TRIGGER_SCHEMA

<condition number> ::= <simple value specification>


Syntax Rules
1) The declared type of a <simple target specification> contained in a <statement information item> or
   <condition information item> shall be the data type specified in Table 30, “<identifier>s for use with <get
   diagnostics statement>”, for the corresponding <statement information item name> or <condition information
   item name>.
2) The declared type of <condition number> shall be exact numeric with scale 0 (zero).

                         Table 30 — <identifier>s for use with <get diagnostics statement>


      <identifier>                       Declared Type

      COMMAND_FUNCTION                   variable-length character string with maximum length L†

      COMMAND_FUNC-                      exact numeric with scale 0 (zero)
      TION_CODE

      DYNAMIC_FUNCTION                   variable-length character string with maximum length L†

      DYNAMIC_FUNCTION_CODE exact numeric with scale 0 (zero)

      MORE                               fixed-length character string with length 1

      NUMBER                             exact numeric with scale 0 (zero)




1056 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                 ISO/IEC 9075-2:2003 (E)
                                                                          22.1 <get diagnostics statement>



      <identifier>                    Declared Type

      ROW_COUNT                       exact numeric with scale 0 (zero)

      TRANSACTION_ACTIVE              exact numeric with scale 0 (zero)

      TRANSACTIONS_COMMIT-            exact numeric with scale 0 (zero)
      TED

      TRANSAC-                        exact numeric with scale 0 (zero)
      TIONS_ROLLED_BACK

      CATALOG_NAME                    variable-length character string with maximum length L

      CLASS_ORIGIN                    variable-length character string with maximum length L

      COLUMN_NAME                     variable-length character string with maximum length L

      CONDITION_NUMBER                exact numeric with scale 0 (zero)

      CONNECTION_NAME                 variable-length character string with maximum length L

      CONSTRAINT_CATALOG              variable-length character string with maximum length L

      CONSTRAINT_NAME                 variable-length character string with maximum length L

      CONSTRAINT_SCHEMA               variable-length character string with maximum length L

      CURSOR_NAME                     variable-length character string with maximum length L

      MESSAGE_LENGTH                  exact numeric with scale 0 (zero)

      MESSAGE_OCTET_LENGTH            exact numeric with scale 0 (zero)

      MESSAGE_TEXT                    variable-length character string with maximum length L

      PARAMETER_MODE                  variable-length character string with maximum length 5

      PARAMETER_NAME                  variable-length character string with maximum length L

      PARAMETER_ORDINAL_POSI- exact numeric with scale 0 (zero)
      TION

      RETURNED_SQLSTATE               fixed-length character string with length 5

      ROUTINE_CATALOG                 variable-length character string with maximum length L

      ROUTINE_NAME                    variable-length character string with maximum length L

      ROUTINE_SCHEMA                  variable-length character string with maximum length L




©ISO/IEC 2003 – All rights reserved                                         Diagnostics management 1057
ISO/IEC 9075-2:2003 (E)
22.1 <get diagnostics statement>



     <identifier>                                Declared Type

     SCHEMA_NAME                                 variable-length character string with maximum length L

     SERVER_NAME                                 variable-length character string with maximum length L

     SPECIFIC_NAME                               variable-length character string with maximum length L

     SUBCLASS_ORIGIN                             variable-length character string with maximum length L

     TABLE_NAME                                  variable-length character string with maximum length L

     TRIGGER_CATALOG                             variable-length character string with maximum length L

     TRIGGER_NAME                                variable-length character string with maximum length L

     TRIGGER_SCHEMA                              variable-length character string with maximum length L
     †
         Where L is an implementation-defined integer not less than 128.



Access Rules
    None.


General Rules
1) Let DA be the first diagnostics area.
2) Specification of <statement information item> assigns the value of the specified statement information
   item in DA to <simple target specification>.
    a) The value of NUMBER is the number of exception or completion conditions that have been stored in
       DA as a result of executing the previous SQL-statement other than a <get diagnostics statement>.
          NOTE 452 — The <get diagnostics statement> itself may return information via the SQLSTATE parameter, but does not
          modify the previous contents of DA.

    b) The value of MORE is:

           Y     More conditions were raised during execution of the SQL-statement than there are condition areas
                 in DA.

           N     All of the conditions that were raised during execution of the SQL-statement have been stored in
                 DA.

    c) The value of COMMAND_FUNCTION is the identification of the SQL-statement executed. Table 31,
       “SQL-statement codes” specifies the identifier of the SQL-statements.




1058 Foundation (SQL/Foundation)                                                            ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                             22.1 <get diagnostics statement>



    d) The value of COMMAND_FUNCTION_CODE is a number identifying the SQL-statement executed.
       Table 31, “SQL-statement codes” specifies the code for the SQL-statements. Positive values are reserved
       for SQL-statements defined by ISO/IEC 9075; negative values are reserved for implementation-defined
       SQL-statements.
    e) The value of DYNAMIC_FUNCTION is a character string that identifies the type of the SQL-statement
       being prepared or executed dynamically. Table 31, “SQL-statement codes”, specifies the identifier of
       the SQL-statements.
    f) The value of DYNAMIC_FUNCTION_CODE is a number that identifies the type of the SQL-statement
       being prepared or executed dynamically. Table 31, “SQL-statement codes”, specifies the code for the
       SQL-statements. Positive values are reserved for SQL-statements defined by ISO/IEC 9075; negative
       values are reserved for implementation-defined SQL-statements.

                                                  Table 31 — SQL-statement codes


           SQL-statement                                       Identifier                               Code

           <allocate cursor statement>                         ALLOCATE CURSOR                          1 (one)

           <allocate descriptor statement>                     ALLOCATE DESCRIPTOR                      2

           <alter domain statement>                            ALTER DOMAIN                             3

           <alter routine statement>                           ALTER ROUTINE                            17

           <alter sequence generator statement>                ALTER SEQUENCE                           134

           <alter type statement>                              ALTER TYPE                               60

           <alter table statement>                             ALTER TABLE                              4

           <alter transform statement>                         ALTER TRANSFORM                          127

           <assertion definition>                              CREATE ASSERTION                         6

           <call statement>                                    CALL                                     7

           <character set definition>                          CREATE CHARACTER SET                     8

           <close statement>                                   CLOSE CURSOR                             9

           <collation definition>                              CREATE COLLATION                         10

           <commit statement>                                  COMMIT WORK                              11

           <connect statement>                                 CONNECT                                  13

           <deallocate descriptor statement>                   DEALLOCATE DESCRIPTOR                    15




©ISO/IEC 2003 – All rights reserved                                            Diagnostics management 1059
ISO/IEC 9075-2:2003 (E)
22.1 <get diagnostics statement>



         SQL-statement                              Identifier                               Code

         <deallocate prepared statement>            DEALLOCATE PREPARE                       16

         <delete statement: positioned>             DELETE CURSOR                            18

         <delete statement: searched>               DELETE WHERE                             19

         <describe statement>                       DESCRIBE                                 20

         <direct select statement: multiple rows>   SELECT                                   21

         <disconnect statement>                     DISCONNECT                               22

         <domain definition>                        CREATE DOMAIN                            23

         <drop assertion statement>                 DROP ASSERTION                           24

         <drop character set statement>             DROP CHARACTER SET                       25

         <drop collation statement>                 DROP COLLATION                           26

         <drop data type statement>                 DROP TYPE                                35

         <drop domain statement>                    DROP DOMAIN                              27

         <drop role statement>                      DROP ROLE                                29

         <drop routine statement>                   DROP ROUTINE                             30

         <drop schema statement>                    DROP SCHEMA                              31

         <drop sequence generator statement>        DROP SEQUENCE                            135

         <drop table statement>                     DROP TABLE                               32

         <drop transform statement>                 DROP TRANSFORM                           116

         <drop transliteration statement>           DROP TRANSLATION                         33

         <drop trigger statement>                   DROP TRIGGER                             34

         <drop user-defined cast statement>         DROP CAST                                78

         <drop user-defined ordering statement>     DROP ORDERING                            115

         <drop view statement>                      DROP VIEW                                36

         <dynamic close statement>                  DYNAMIC CLOSE                            37

         <dynamic delete statement: positioned>     DYNAMIC DELETE CURSOR                    38



1060 Foundation (SQL/Foundation)                                 ©ISO/IEC 2003 – All rights reserved
                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                            22.1 <get diagnostics statement>



           SQL-statement                                       Identifier                             Code

           <dynamic fetch statement>                           DYNAMIC FETCH                          39

           <dynamic open statement>                            DYNAMIC OPEN                           40

           <dynamic select statement>                          SELECT CURSOR                          85

           <dynamic single row select statement>               SELECT                                 41

           <dynamic update statement: positioned>              DYNAMIC UPDATE CURSOR                  42

           <execute immediate statement>                       EXECUTE IMMEDIATE                      43

           <execute statement>                                 EXECUTE                                44

           <fetch statement>                                   FETCH                                  45

           <free locator statement>                            FREE LOCATOR                           98

           <get descriptor statement>                          GET DESCRIPTOR                         47

           <hold locator statement>                            HOLD LOCATOR                           99

           <grant privilege statement>                         GRANT                                  48

           <grant role statement>                              GRANT ROLE                             49

           <insert statement>                                  INSERT                                 50

           <merge statement>                                   MERGE                                  128

           <open statement>                                    OPEN                                   53

           <preparable dynamic delete statement: positioned>   PREPARABLE DYNAMIC DELETE              54
                                                               CURSOR

           <preparable dynamic update statement: positioned>   PREPARABLE DYNAMIC UPDATE 55
                                                               CURSOR

           <prepare statement>                                 PREPARE                                56

           <release savepoint statement>                       RELEASE SAVEPOINT                      57

           <return statement>                                  RETURN                                 58

           <revoke privilege statement>                        REVOKE                                 59

           <revoke role statement>                             REVOKE ROLE                            129

           <role definition>                                   CREATE ROLE                            61



©ISO/IEC 2003 – All rights reserved                                           Diagnostics management 1061
ISO/IEC 9075-2:2003 (E)
22.1 <get diagnostics statement>



         SQL-statement                             Identifier                               Code

         <rollback statement>                      ROLLBACK WORK                            62

         <savepoint statement>                     SAVEPOINT                                63

         <schema definition>                       CREATE SCHEMA                            64

         <schema routine>                          CREATE ROUTINE                           14

         <select statement: single row>            SELECT                                   65

         <sequence generator definition>           CREATE SEQUENCE                          133

         <set catalog statement>                   SET CATALOG                              66

         <set connection statement>                SET CONNECTION                           67

         <set constraints mode statement>          SET CONSTRAINT                           68

         <set descriptor statement>                SET DESCRIPTOR                           70

         <set local time zone statement>           SET TIME ZONE                            71

         <set names statement>                     SET NAMES                                72

         <set path statement>                      SET PATH                                 69

         <set role statement>                      SET ROLE                                 73

         <set schema statement>                    SET SCHEMA                               74

         <set session user identifier statement>   SET SESSION AUTHORIZATION                76

         <set session characteristics statement>   SET SESSION CHARACTERISTICS              109

         <set session collation statement>         SET COLLATION                            136

         <set transform group statement>           SET TRANSFORM GROUP                      118

         <set transaction statement>               SET TRANSACTION                          75

         <start transaction statement>             START TRANSACTION                        111

         <table definition>                        CREATE TABLE                             77

         <transform definition>                    CREATE TRANSFORM                         117

         <transliteration definition>              CREATE TRANSLATION                       79

         <trigger definition>                      CREATE TRIGGER                           80



1062 Foundation (SQL/Foundation)                                ©ISO/IEC 2003 – All rights reserved
                                                                                                   ISO/IEC 9075-2:2003 (E)
                                                                                            22.1 <get diagnostics statement>



           SQL-statement                                                    Identifier                                       Code

           <update statement: positioned>                                   UPDATE CURSOR                                    81

           <update statement: searched>                                     UPDATE WHERE                                     82

           <user-defined cast definition>                                   CREATE CAST                                      52

           <user-defined type definition>                                   CREATE TYPE                                      83

           <user-defined ordering definition>                               CREATE ORDERING                                  114

           <view definition>                                                CREATE VIEW                                      84

           Implementation-defined statements                                An implementation-defined character              x1
                                                                            string value different from the value
                                                                            associated with any other SQL-state-
                                                                            ment

           Unrecognized statements                                          A zero-length string                             0 (zero)
           1
               An implementation-defined negative number different from the value associated with any other SQL-statement.


         NOTE 453 — Other, additional, values are used in other parts of ISO/IEC 9075; please see the corresponding table in the
         other parts of ISO/IEC 9075; for more information.

    g) The value of ROW_COUNT is the number of rows affected as the result of executing a <delete statement:
       searched>, <insert statement>, <merge statement>, or <update statement: searched> or as a direct result
       of executing the previous SQL-statement. Let S be the <delete statement: searched>, <insert statement>,
       <merge statement>, or <update statement: searched>. Let T be the table identified by the <table name>
       directly contained in S.
         Case:
         i)         If S is an <insert statement>, then the value of ROW_COUNT is the number of rows inserted
                    into T.
         ii)        If S is a <merge statement>, then let TR1 be the <target table> immediately contained in S, let
                    TR2 be the <table reference> immediately contained in S, and let SC be the <search condition>
                    immediately contained in S. If <merge correlation name> is specified, let MCN be “AS <merge
                    correlation name>”; otherwise, let MCN be a zero-length string.
                    Case:
                    1) If S contains a <merge when matched clause> and does not contain a <merge when not
                       matched clause>, then the value of ROW_COUNT is effectively derived by executing the
                       statement:
                            SELECT COUNT (*)
                            FROM TR1 MCN, TR2
                            WHERE SC

                        before the execution of S.


©ISO/IEC 2003 – All rights reserved                                                           Diagnostics management 1063
ISO/IEC 9075-2:2003 (E)
22.1 <get diagnostics statement>



               2) If S contains a <merge when not matched clause> and does not contain a <merge when
                  matched clause>, then the value of ROW_COUNT is effectively derived by executing the
                  statement:
                         ( SELECT COUNT(*)
                          FROM TR1 MCN
                            RIGHT OUTER JOIN
                               TR2
                              ON SC )
                       -
                       ( SELECT COUNT (*)
                         FROM TR1 MCN, TR2
                         WHERE SC )

                    before the execution of S.
               3) If S contains both a <merge when matched clause> and a <merge when not matched clause>,
                  then the value of ROW_COUNT is effectively derived by executing the statement:
                       SELECT COUNT(*)
                       FROM TR1 MCN
                         RIGHT OUTER JOIN
                            TR2
                           ON SC

                    before the execution of S.
        iii)   If <correlation name> is specified, then let MCN be “AS <correlation name>”; otherwise, let
               MCN be a zero-length string. If S is a <delete statement: searched> or an <update statement:
               searched>, then
               Case:
               1) If S does not contain a <search condition>, then the value of ROW_COUNT is the cardinality
                  of T before the execution of S.
               2) Otherwise, let SC be the <search condition> directly contained in S. The value of
                  ROW_COUNT is effectively derived by executing the statement:
                       SELECT COUNT(*)
                       FROM T MCN
                       WHERE SC

                    before the execution of S.
               The value of ROW_COUNT following the execution of an SQL-statement that does not directly
               result in the execution of a <delete statement: searched>, an <insert statement>, a <merge
               statement>, or an <update statement: searched> is implementation-dependent.
    h) The value of TRANSACTIONS_COMMITTED is the number of SQL-transactions that have been
       committed since the most recent time at which DA was emptied.
        NOTE 454 — See the General Rules of Subclause 13.3, “<externally-invoked procedure>”, and Subclause 13.4, “Calls to an
        <externally-invoked procedure>”. TRANSACTIONS_COMMITTED indicates the number of SQL-transactions that were
        committed during the invocation of an external routine.




1064 Foundation (SQL/Foundation)                                                            ©ISO/IEC 2003 – All rights reserved
                                                                                                ISO/IEC 9075-2:2003 (E)
                                                                                         22.1 <get diagnostics statement>



    i)   The value of TRANSACTIONS_ROLLED_BACK is the number of SQL-transactions that have been
         rolled back since the most recent time at which DA was emptied.
         NOTE 455 — See the General Rules of Subclause 13.3, “<externally-invoked procedure>”, and Subclause 13.4, “Calls to an
         <externally-invoked procedure>”. TRANSACTIONS_ROLLED_BACK indicates the number of SQL-transactions that were
         rolled back during the invocation of an external routine.

    j)   The value of TRANSACTION_ACTIVE is 1 (one) if an SQL-transaction is currently active, and 0
         (zero) if an SQL-transaction is not currently active.
         NOTE 456 — TRANSACTION_ACTIVE indicates whether an SQL-transaction is active upon return from an external routine.

    k) It is implementation-defined whether the identifier and code from Table 31, “SQL-statement codes”,
       for <dynamic select statement> or <dynamic single row select statement> is used to describe a <dynamic
       select statement> or <dynamic single row select statement> that has been prepared but has not yet been
       executed dynamically.
3) If <condition information> is specified, then let N be the value of <condition number>. If N is less than 1
   (one) or greater than the number of occupied condition areas in DA, then an exception condition is raised:
   invalid condition number. If <condition number> has the value 1 (one), then the diagnostics information
   retrieved corresponds to the condition indicated by the SQLSTATE value actually returned by execution
   of the previous SQL-statement other than a <get diagnostics statement>. Otherwise, the association between
   <condition number> values and specific conditions raised during evaluation of the General Rules for that
   SQL-statement is implementation-dependent.
4) Specification of <condition information item> assigns the value of the specified condition information item
   in the N-th condition area in DA to <simple target specification>.
    a) The value of CONDITION_NUMBER is the value of <condition number>.
    b) The value of CLASS_ORIGIN is the identification of the naming authority that defined the class value
       of RETURNED_SQLSTATE. That value shall be 'ISO 9075' for any RETURNED_SQLSTATE whose
       class value is fully defined in Subclause 23.1, “SQLSTATE”, and shall be an implementation-defined
       character string other than 'ISO 9075' for any RETURNED_SQLSTATE whose class value is an
       implementation-defined class value.
    c) The value of SUBCLASS_ORIGIN is the identification of the naming authority that defined the subclass
       value of RETURNED_SQLSTATE. That value shall be 'ISO 9075' for any RETURNED_SQLSTATE
       whose subclass value is fully defined in Subclause 23.1, “SQLSTATE”, and shall be an implementation-
       defined character string other than 'ISO 9075' for any RETURNED_SQLSTATE whose subclass value
       is an implementation-defined subclass value.
    d) The value of RETURNED_SQLSTATE is the SQLSTATE parameter that would have been returned
       if this were the only completion or exception condition possible.
    e) If the value of RETURNED_SQLSTATE corresponds to warning with a subclass of cursor operation
       conflict, then the value of CURSOR_NAME is the name of the cursor that caused the completion
       condition to be raised.
    f) If the value of RETURNED_SQLSTATE corresponds to integrity constraint violation, transaction
       rollback — integrity constraint violation, or a triggered data change violation that was caused by a
       violation of a referential constraint, then:
         i)       The values of CONSTRAINT_CATALOG and CONSTRAINT_SCHEMA are the <catalog
                  name> and the <unqualified schema name> of the <schema name> of the schema containing


©ISO/IEC 2003 – All rights reserved                                                        Diagnostics management 1065
ISO/IEC 9075-2:2003 (E)
22.1 <get diagnostics statement>



              the constraint or assertion. The value of CONSTRAINT_NAME is the <qualified identifier> of
              the constraint or assertion.
        ii)   Case:
              1) If the violated integrity constraint is a table constraint, then the values of CATALOG_NAME,
                 SCHEMA_NAME, and TABLE_NAME are the <catalog name>, the <unqualified schema
                 name> of the <schema name>, and the <qualified identifier>, respectively, of the table in
                 which the table constraint is contained.
              2) If the violated integrity constraint is an assertion and if only one table referenced by the
                 assertion has been modified as a result of executing the SQL-statement, then the values of
                 CATALOG_NAME, SCHEMA_NAME, and TABLE_NAME are the <catalog name>, the
                 <unqualified schema name> of the <schema name>, and the <qualified identifier>, respec-
                 tively, of the modified table.
              3) Otherwise, the values of CATALOG_NAME, SCHEMA_NAME, and TABLE_NAME are
                 a zero-length string.
              If TABLE_NAME identifies a declared local temporary table, then CATALOG_NAME is a
              zero-length string and SCHEMA_NAME is “MODULE”.
    g) If the value of RETURNED_SQLSTATE corresponds to triggered action exception, transaction rollback
       — triggered action exception, or a triggered data change violation that was caused by a trigger, then:
        i)    The values of TRIGGER_CATALOG and TRIGGER_SCHEMA are the <catalog name> and
              the <unqualified schema name> of the <schema name> of the schema containing the trigger.
              The value of TRIGGER_NAME is the <qualified identifier> of the <trigger name> of the trigger.
        ii)   The values of CATALOG_NAME, SCHEMA_NAME, and TABLE_NAME are the <catalog
              name>, the <unqualified schema name> of the <schema name>, and the <qualified identifier>
              of the <table name>, respectively, of the table on which the trigger is defined.
    h) If the value of RETURNED_SQLSTATE corresponds to syntax error or access rule violation, then:
        i)    Case:
              1) If the syntax error or access rule violation was caused by reference to a specific table, then
                 the values of CATALOG_NAME, SCHEMA_NAME, and TABLE_NAME are
                  Case:
                  A) If the specific table referenced was not a declared local temporary table, then the <catalog
                     name>, the <unqualified schema name> of the <schema name> of the schema that
                     contains the table that caused the syntax error or access rule violation, and the <qualified
                     identifier>, respectively.
                  B) Otherwise, the zero-length string, “MODULE”, and the <qualified identifier>, respec-
                     tively.
              2) Otherwise, CATALOG_NAME, SCHEMA_NAME, and TABLE_NAME contain a zero-
                 length string.




1066 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)
                                                                                 22.1 <get diagnostics statement>



         ii)      If the syntax error or access rule violation was for an inaccessible column, then the value of
                  COLUMN_NAME is the <column name> of that column. Otherwise, the value of COL-
                  UMN_NAME is a zero-length string.
    i)   If the value of RETURNED_SQLSTATE corresponds to invalid cursor state, then the value of CUR-
         SOR_NAME is the name of the cursor that is in the invalid state.
    j)   If the value of RETURNED_SQLSTATE corresponds to with check option violation, then the values
         of CATALOG_NAME, SCHEMA_NAME, and TABLE_NAME are the <catalog name>, the
         <unqualified schema name> of the <schema name> of the schema that contains the view that caused
         the violation of the WITH CHECK OPTION, and the <qualified identifier> of that view, respectively.
    k) If the value of RETURNED_SQLSTATE does not correspond to syntax error or access rule violation,
       then:
         i)       If the values of CATALOG_NAME, SCHEMA_NAME, TABLE_NAME, and COL-
                  UMN_NAME identify a column for which no privileges are granted to the enabled authorization
                  identifiers, then the value of COLUMN_NAME is replaced by a zero-length string.
         ii)      If the values of CATALOG_NAME, SCHEMA_NAME, and TABLE_NAME identify a table
                  for which no privileges are granted to the enabled authorization identifiers, then the values of
                  CATALOG_NAME, SCHEMA_NAME, and TABLE_NAME are replaced by a zero-length
                  string.
         iii)     If the values of CONSTRAINT_CATALOG, CONSTRAINT_SCHEMA, and CON-
                  STRAINT_NAME identify a <table constraint> for some table T and if no privileges for T are
                  granted to the enabled authorization identifiers, then the values of CONSTRAINT_CATALOG,
                  CONSTRAINT_SCHEMA, and CONSTRAINT_NAME are replaced by a zero-length string.
         iv)      If the values of CONSTRAINT_CATALOG, CONSTRAINT_SCHEMA, and CON-
                  STRAINT_NAME identify an assertion contained in some schema S and if the owner of S is
                  not included in the set of enabled authorization identifiers, then the values of CON-
                  STRAINT_CATALOG, CONSTRAINT_SCHEMA, and CONSTRAINT_NAME are replaced
                  by a zero-length string.
    l)   If the value of RETURNED_SQLSTATE corresponds to external routine invocation exception,
         external routine exception, SQL routine exception, or warning, then
         i)       The values of ROUTINE_CATALOG and ROUTINE_SCHEMA are the <catalog name> and
                  the <unqualified schema name>, respectively, of the <schema name> of the schema containing
                  the SQL-invoked routine.
         ii)      The values of ROUTINE_NAME and SPECIFIC_NAME are the <identifier> of the <routine
                  name> and the <identifier> of the <specific name> of the SQL-invoked routine, respectively.
         iii)     Case:
                  1) If the condition is related to parameter Pi of the SQL-invoked routine, then:

                      A) The value of PARAMETER_MODE is the <parameter mode> of Pi.

                      B) The value of PARAMETER_ORDINAL_POSITION is the value of i.
                      C) The value of PARAMETER_NAME is a zero-length string.



©ISO/IEC 2003 – All rights reserved                                                Diagnostics management 1067
ISO/IEC 9075-2:2003 (E)
22.1 <get diagnostics statement>



                2) Otherwise:
                    A) The value of PARAMETER_MODE is a zero-length string.
                    B) The value of PARAMETER_ORDINAL_POSITION is 0 (zero).
                    C) The value of PARAMETER_NAME is a zero-length string.
    m) If the value of RETURNED_SQLSTATE corresponds to external routine invocation exception,
       external routine exception, SQL routine exception, or warning, then the value of MESSAGE_TEXT
       is the message text item of the SQL-invoked routine that raised the exception. Otherwise the value of
       MESSAGE_TEXT is an implementation-defined character string.
        NOTE 457 — An SQL-implementation may set this to <space>s, to a zero-length string, or to a character string describing
        the condition indicated by RETURNED_SQLSTATE.

    n) The value of MESSAGE_LENGTH is the length in characters of the character string value in MES-
       SAGE_TEXT.
    o) The value of MESSAGE_OCTET_LENGTH is the length in octets of the character string value in
       MESSAGE_TEXT.
    p) The values of CONNECTION_NAME and SERVER_NAME are respectively
        Case:
        i)      If COMMAND_FUNCTION or DYNAMIC_FUNCTION identifies an <SQL connection
                statement>, then the <connection name> and the <SQL-server name> specified by or implied
                by the <SQL connection statement>.
        ii)     Otherwise, the <connection name> and <SQL-server name> of the SQL-session in which the
                condition was raised.
    q) If the value of RETURNED_SQLSTATE corresponds to data exception — numeric value out of range,
       data exception — invalid character value for cast, data exception — string data, right truncation, data
       exception — interval field overflow, integrity constraint violation, or warning — string data, right
       truncation, and the condition was raised as the result of an assignment to an SQL parameter during an
       SQL-invoked routine invocation, then:
        i)      The values of ROUTINE_CATALOG and ROUTINE_SCHEMA are the <catalog name> and
                the <unqualified schema name>, respectively, of the <schema name> of the schema containing
                the routine.
        ii)     The values of the ROUTINE_NAME and SPECIFIC_NAME are the <identifier> of the <routine
                name> and the <identifier> of the <specific name>, respectively, of the routine.
        iii)    If the condition is related to parameter Pi of the SQL-invoked routine, then:

                1) The value of PARAMETER_MODE is the <parameter mode> of Pi.

                2) The value of PARAMETER_ORDINAL_POSITION is the value of i.
                3) If an <SQL parameter name> was specified for the SQL parameter when the SQL-invoked
                   routine was created, then the value of PARAMETER_NAME is the <SQL parameter name>
                   of Pi. Otherwise, the value of PARAMETER_NAME is a zero-length string.



1068 Foundation (SQL/Foundation)                                                             ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)
                                                                              22.1 <get diagnostics statement>



5) The values of character string items where not otherwise specified by the preceding rules are set to a zero-
   length string.
    NOTE 458 — There are no numeric items that are not set by these rules.

6) The General Rules of Subclause 9.2, “Store assignment”, apply to <simple target specification> and
   whichever of <statement information item name> or <condition information item name> is specified, as
   TARGET and VALUE, respectively.


Conformance Rules
1) Without Feature F121, “Basic diagnostics management”, conforming SQL language shall not contain a
   <get diagnostics statement>.
2) Without Feature T511, “Transaction counts”, conforming SQL language shall not contain a <statement
   information item name> that contains TRANSACTIONS_COMMITTED, TRANSAC-
   TIONS_ROLLED_BACK, or TRANSACTION_ACTIVE.




©ISO/IEC 2003 – All rights reserved                                             Diagnostics management 1069
ISO/IEC 9075-2:2003 (E)
22.2 Pushing and popping the diagnostics area stack



22.2 Pushing and popping the diagnostics area stack

Function
Define operations on the diagnostics area stack.


Syntax Rules
    None.


Access Rules
    None.


General Rules
1) Let OP be the OPERATION and let DAS be the STACK specified in an application of this Subclause.
2) Case:
    a) If OP is “PUSH”, then
        Case:
        i)      If the number of diagnostics areas in DAS is equal to the implementation-dependent maximum
                number of diagnostics areas per diagnostics area stack, then an exception condition is raised:
                diagnostics exception — maximum number of stacked diagnostics areas exceeded.
        ii)     Otherwise, DAS is pushed and the contents of the second diagnostics area in DAS are copied to
                the first.
    b) If OP is “POP”, then the first diagnostics area is removed from DAS such that all subsequent diagnostics
       areas in DAS move up one position, the second becoming the first, the third becoming the second, and
       so on.


Conformance Rules
    None.




1070 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                                         ISO/IEC 9075-2:2003 (E)
                                                                                                               23.1 SQLSTATE




23 Status codes


23.1 SQLSTATE

The character string value returned in an SQLSTATE parameter comprises a 2-character class value followed
by a 3-character subclass value, each with an implementation-defined character set that has a one-octet character
encoding form and is restricted to <digit>s and <simple Latin upper case letter>s. Table 32, “SQLSTATE class
and subclass values”, specifies the class value for each condition and the subclass value or values for each class
value.
Class values that begin with one of the <digit>s '0', '1', '2', '3', or '4' or one of the <simple Latin upper case letter>s
'A', 'B', 'C', 'D', 'E', 'F', 'G', or 'H' are returned only for conditions defined in ISO/IEC 9075 or in any other
International Standard. The range of such class values are called standard-defined classes. Some such class
codes are reserved for use by specific International Standards, as specified elsewhere in this Clause. Subclass
values associated with such classes that also begin with one of those 13 characters are returned only for conditions
defined in ISO/IEC 9075 or some other International Standard. The range of such class values are called standard-
defined classes. Subclass values associated with such classes that begin with one of the <digit>s '5', '6', '7', '8',
or '9' or one of the <simple Latin upper case letter>s 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
'X', 'Y', or 'Z' are reserved for implementation-specified conditions and are called implementation-defined
subclasses.
Class values that begin with one of the <digit>s '5', '6', '7', '8', or '9' or one of the <simple Latin upper case letter>s
'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', or 'Z' are reserved for implementation-specified
exception conditions and are called implementation-defined classes. All subclass values except '000', which
means no subclass, associated with such classes are reserved for implementation-specified conditions and are
called implementation-defined subclasses. An implementation-defined completion condition shall be indicated
by returning an implementation-defined subclass in conjunction with one of the classes successful completion,
warning, or no data.
If a subclass value is not specified for a condition, then either subclass '000' or an implementation-defined
subclass is returned.
NOTE 459 — One consequence of this is that an SQL-implementation may, but is not required by ISO/IEC 9075 to, provide subcodes
for exception condition syntax error or access rule violation that distinguish between the syntax error and access rule violation cases.

If multiple completion conditions: warning or multiple exception conditions, including implementation-defined
exception conditions, are raised, then it is implementation-dependent which of the corresponding SQLSTATE
values is returned in the SQLSTATE status parameter, provided that the precedence rules in Subclause 4.29.2,
“Status parameters”, are obeyed. Any number of applicable conditions values in addition to the one returned
in the SQLSTATE status parameter, may be returned in the diagnostics area.
An implementation-specified condition may duplicate, in whole or in part, a condition defined in ISO/IEC
9075; however, if such a condition occurs as a result of executing a statement, then the corresponding imple-
mentation-defined SQLSTATE value shall not be returned in the SQLSTATE parameter but may be returned
in the diagnostics area.




©ISO/IEC 2003 – All rights reserved                                                                              Status codes 1071
ISO/IEC 9075-2:2003 (E)
23.1 SQLSTATE



The “Category” column has the following meanings: “S” means that the class value given corresponds to suc-
cessful completion and is a completion condition; “W” means that the class value given corresponds to a suc-
cessful completion but with a warning and is a completion condition; “N” means that the class value given
corresponds to a no-data situation and is a completion condition; “X” means that the class value given corresponds
to an exception condition.

                             Table 32 — SQLSTATE class and subclass values


 Category     Condition                             Class     Subcondition                            Subclass

 X            ambiguous cursor name                 3C        (no subclass)                           000

 X            attempt to assign to non-updatable 0U           (no subclass)                           000
              column

 X            attempt to assign to ordering col- 0V           (no subclass)                           000
              umn

 X            cardinality violation                 21        (no subclass)                           000

 X            connection exception                  08        (no subclass)                           000

                                                              connection does not exist               003

                                                              connection failure                      006

                                                              connection name in use                  002

                                                              SQL-client unable to establish          001
                                                              SQL-connection

                                                              SQL-server rejected establishment 004
                                                              of SQL-connection

                                                              transaction resolution unknown          007

 X            cursor sensitivity exception          36        (no subclass)                           000

                                                              request failed                          002

                                                              request rejected                        001

 X            data exception                        22        (no subclass)                           000

                                                              array data, right truncation            02F

                                                              array element error                     02E

                                                              character not in repertoire             021




1072 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                         ISO/IEC 9075-2:2003 (E)
                                                                               23.1 SQLSTATE



 Category        Condition            Class   Subcondition                         Subclass

                                              datetime field overflow              008

                                              division by zero                     012

                                              error in assignment                  005

                                              escape character conflict            00B

                                              indicator overflow                   022

                                              interval field overflow              015

                                              interval value out of range          00P

                                              invalid argument for natural loga- 01E
                                              rithm

                                              invalid argument for power func-     01F
                                              tion

                                              invalid argument for width bucket 01G
                                              function

                                              invalid character value for cast     018

                                              invalid datetime format              007

                                              invalid escape character             019

                                              invalid escape octet                 00D

                                              invalid escape sequence              025

                                              invalid indicator parameter value 010

                                              invalid interval format              006

                                              invalid parameter value              023

                                              invalid preceding or following size 013
                                              in window function

                                              invalid regular expression           01B

                                              invalid repeat argument in a sam- 02G
                                              ple clause

                                              invalid sample size                  02H



©ISO/IEC 2003 – All rights reserved                                           Status codes 1073
ISO/IEC 9075-2:2003 (E)
23.1 SQLSTATE



 Category    Condition                         Class   Subcondition                          Subclass

                                                       invalid time zone displacement        009
                                                       value

                                                       invalid use of escape character       00C

                                                       most specific type mismatch           00G

                                                       multiset value overflow               00Q

                                                       noncharacter in UCS string            029

                                                       null value substituted for mutator    02D
                                                       subject parameter

                                                       null row not permitted in table       01C

                                                       null value in array target            00E

                                                       null value, no indicator parameter 002

                                                       null value not allowed                004

                                                       numeric value out of range            003

                                                       sequence generator limit exceeded 00H

                                                       string data, length mismatch          026

                                                       string data, right truncation         001

                                                       substring error                       011

                                                       trim error                            027

                                                       unterminated C string                 024

                                                       zero-length character string          00F

 X           dependent privilege descriptors   2B      (no subclass)                         000
             still exist

 X           diagnostics exception             0Z      (no subclass)                         000

                                                       maximum number of stacked             001
                                                       diagnostics areas exceeded

 X           dynamic SQL error                 07      (no subclass)                         000




1074 Foundation (SQL/Foundation)                                           ©ISO/IEC 2003 – All rights reserved
                                                                                 ISO/IEC 9075-2:2003 (E)
                                                                                       23.1 SQLSTATE



 Category        Condition                    Class   Subcondition                         Subclass

                                                      cursor specification cannot be       003
                                                      executed

                                                      data type transform function viola- 00B
                                                      tion

                                                      invalid DATA target                  00D

                                                      invalid DATETIME_INTER-              00F
                                                      VAL_CODE

                                                      invalid descriptor count             008

                                                      invalid descriptor index             009

                                                      invalid LEVEL value                  00E

                                                      prepared statement not a cursor      005
                                                      specification

                                                      restricted data type attribute viola- 006
                                                      tion

                                                      undefined DATA value                 00C

                                                      using clause does not match      001
                                                      dynamic parameter specifications

                                                      using clause does not match target 002
                                                      specifications

                                                      using clause required for dynamic 004
                                                      parameters

                                                      using clause required for result     007
                                                      fields

 X               external routine exception   38      (no subclass)                        000

                                                      containing SQL not permitted         001

                                                      modifying SQL-data not permitted 002

                                                      prohibited SQL-statement             003
                                                      attempted

                                                      reading SQL-data not permitted       004




©ISO/IEC 2003 – All rights reserved                                                    Status codes 1075
ISO/IEC 9075-2:2003 (E)
23.1 SQLSTATE



 Category    Condition                           Class   Subcondition                           Subclass

 X           external routine invocation         39      (no subclass)                          000
             exception

                                                         null value not allowed                 004

 X           feature not supported               0A      (no subclass)                          000

                                                         multiple server transactions           001

 X           integrity constraint violation      23      (no subclass)                          000

                                                         restrict violation                     001

 X           invalid authorization specification 28      (no subclass)                          000

 X           invalid catalog name                3D      (no subclass)                          000

 X           invalid character set name          2C      (no subclass)                          000

 X           invalid condition number            35      (no subclass)                          000

 X           invalid connection name             2E      (no subclass)                          000

 X           invalid cursor name                 34      (no subclass)                          000

 X           invalid cursor state                24      (no subclass)                          000

 X           invalid grantor                     0L      (no subclass)                          000

 X           invalid role specification          0P      (no subclass)                          000

 X           invalid schema name                 3F      (no subclass)                          000

 X           invalid schema name list specifica- 0E      (no subclass)                          000
             tion

 X           invalid collation name              2H      (no subclass)                          000

 X           invalid SQL descriptor name         33      (no subclass)                          000

 X           invalid SQL-invoked procedure       0M      (no subclass)                          000
             reference

 X           invalid SQL statement name          26      (no subclass)                          000

 X           invalid SQL statement identifier    30      (no subclass)                          000

 X           invalid target type specification   0D      (no subclass)                          000




1076 Foundation (SQL/Foundation)                                              ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                                                          23.1 SQLSTATE



 Category        Condition                         Class   Subcondition                         Subclass

 X               invalid transaction initiation    0B      (no subclass)                        000

 X               invalid transaction state         25      (no subclass)                        000

                                                           active SQL-transaction               001

                                                           branch transaction already active 002

                                                           held cursor requires same isola-     008
                                                           tion level

                                                           inappropriate access mode for        003
                                                           branch transaction

                                                           inappropriate isolation level for    004
                                                           branch transaction

                                                           no active SQL-transaction for        005
                                                           branch transaction

                                                           read-only SQL-transaction            006

                                                           schema and data statement mixing 007
                                                           not supported

 X               invalid transaction termination   2D      (no subclass)                        000

 X               invalid transform group name      0S      (no subclass)                        000
                 specification

 X               locator exception                 0F      (no subclass)                        000

                                                           invalid specification                001

 N               no data                           02      (no subclass)                        000

                                                           no additional dynamic result sets    001
                                                           returned

 X               prohibited statement encountered 0W       (no subclass)                        000
                 during trigger execution

 X               Remote Database Access            HZ      (See Table 33, “SQLSTATE class
                                                           codes for RDA”, for the definition
                                                           of protocol subconditions and
                                                           subclass code values)

 X               savepoint exception               3B      (no subclass)                        000



©ISO/IEC 2003 – All rights reserved                                                        Status codes 1077
ISO/IEC 9075-2:2003 (E)
23.1 SQLSTATE



 Category    Condition                            Class   Subcondition                              Subclass

                                                          invalid specification                     001

                                                          too many                                  002

 X           SQL routine exception                2F      (no subclass)                             000

                                                          function executed no return state- 005
                                                          ment

                                                          modifying SQL-data not permitted 002

                                                          prohibited SQL-statement                  003
                                                          attempted

                                                          reading SQL-data not permitted            004

 S           successful completion                00      (no subclass)                             000

 X           syntax error or access rule viola-   42      (no subclass)                             000
             tion

 X           target table disagrees with cursor   0T      (no subclass)                             000
             specification

 X           transaction rollback                 40      (no subclass)                             000

                                                          integrity constraint violation            002

                                                          serialization failure                     001

                                                          statement completion unknown              003

                                                          triggered action exception                004

 X           triggered action exception           09      (no subclass)                             000

 X           triggered data change violation      27      (no subclass)                             000

 W           warning                              01      (no subclass)                             000

                                                          additional result sets returned           00D

                                                          array data, right truncation              02F

                                                          attempt to return too many result         00E
                                                          sets

                                                          cursor operation conflict                 001



1078 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                ISO/IEC 9075-2:2003 (E)
                                                                                      23.1 SQLSTATE



 Category        Condition                     Class   Subcondition                         Subclass

                                                       default value too long for informa- 00B
                                                       tion schema

                                                       disconnect error                     002

                                                       dynamic result sets returned         00C

                                                       insufficient item descriptor areas   005

                                                       null value eliminated in set func-   003
                                                       tion

                                                       privilege not granted                007

                                                       privilege not revoked                006

                                                       query expression too long for        00A
                                                       information schema

                                                       search condition too long for        009
                                                       information schema

                                                       statement too long for information 00F
                                                       schema

                                                       string data, right truncation        004

 X               with check option violation   44      (no subclass)                        000




©ISO/IEC 2003 – All rights reserved                                                    Status codes 1079
ISO/IEC 9075-2:2003 (E)
23.2 Remote Database Access SQLSTATE Subclasses



23.2 Remote Database Access SQLSTATE Subclasses

ISO/IEC 9075 reserves SQLSTATE class 'HZ' for Remote Database Access errors, which may occur when an
SQL-client interacts with an SQL-server across a communications network using an RDA Application Context.
[ISO9579], [ISO8649], and [ISO10026] define a number of exception conditions that shall be detected in a
conforming ISO RDA implementation. This Subclause defines SQLSTATE subclass codes for each such con-
dition out of the set of codes reserved for International Standards.
If an implementation using RDA reports a condition shown in Table 33, “SQLSTATE class codes for RDA”,
for a given exception condition, then it shall use the SQLSTATE class code 'HZ' and the subclass codes shown,
and shall set the values of CLASS_ORIGIN to 'ISO 9075' and SUBCLASS_ORIGIN as indicated in Table 33,
“SQLSTATE class codes for RDA”, when those exceptions are retrieved by a <get diagnostics statement>.
An implementation using client-server communications other than RDA may report conditions corresponding
to the conditions shown in Table 33, “SQLSTATE class codes for RDA”, using the SQLSTATE class code
'HZ' and the corresponding subclass codes shown. It may set the values of CLASS_ORIGIN to 'ISO 9075' and
SUBCLASS_ORIGIN as indicated in Table 33, “SQLSTATE class codes for RDA”. Any other communications
error shall be returned with a subclass code from the implementation-defined range, with CLASS_ORIGIN set
to 'ISO 9075' and SUBCLASS_ORIGIN set to an implementation-defined character string.
A Remote Database Access exception may also result in an SQL completion condition defined in Table 32,
“SQLSTATE class and subclass values” (such as '40000', transaction rollback); if such a condition occurs,
then the 'HZ' class SQLSTATE shall not be returned in the SQLSTATE parameter, but may be returned in the
Diagnostics Area.

                              Table 33 — SQLSTATE class codes for RDA


 SQLSTATE        Subclass Origin
 Class

 HZ              ISO/IEC 9579




1080 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                 ISO/IEC 9075-2:2003 (E)
                                                           24.1 Claims of conformance to SQL/Foundation




24 Conformance


24.1 Claims of conformance to SQL/Foundation

In addition to the requirements of ISO/IEC 9075-1, in Clause 8, “Conformance”, a claim of conformance to
this part of ISO/IEC 9075 shall:
1) Claim conformance to at least one of:
    — Feature B011, “Embedded Ada”
    — Feature B012, “Embedded C”
    — Feature B013, “Embedded COBOL”
    — Feature B014, “Embedded Fortran”
    — Feature B015, “Embedded MUMPS”
    — Feature B016, “Embedded Pascal”
    — Feature B017, “Embedded PL/I”
    — Feature B111, “Module language Ada”
    — Feature B112, “Module language C”
    — Feature B113, “Module language COBOL”
    — Feature B114, “Module language Fortran”
    — Feature B115, “Module language MUMPS”
    — Feature B116, “Module language Pascal”
    — Feature B117, “Module language PL/I”
2) A claim conformance to at least one of:
    — Feature B121, “Routine language Ada”
    — Feature B122, “Routine language C”
    — Feature B123, “Routine language COBOL”
    — Feature B124, “Routine language Fortran”
    — Feature B125, “Routine language MUMPS”
    — Feature B126, “Routine language Pascal”
    — Feature B127, “Routine language PL/I”


©ISO/IEC 2003 – All rights reserved                                                   Conformance 1081
ISO/IEC 9075-2:2003 (E)
24.1 Claims of conformance to SQL/Foundation



    — Feature B128, “Routine language SQL”



24.2 Additional conformance requirements for SQL/Foundation

An SQL-implementation that claims conformance to a feature in this part of ISO/IEC 9075 shall also claim
conformance to the same feature, if present, in ISO/IEC 9075-11.
An SQL-implementation that claims conformance to Feature T061, “UCS support”, shall:
— Conform to ISO/IEC 10646-1:2000 at some specified level.
— Provide at least one of the named character sets UTF8, UTF16, and UTF32.
— Provide, as the default collation for each such character set, a collation that conforms to ISO/IEC 14651:2001
  at some level.



24.3 Implied feature relationships of SQL/Foundation

                      Table 34 — Implied feature relationships of SQL/Foundation


 Feature      Feature Name                            Implied       Implied Feature Name
 ID                                                   Feature
                                                      ID

 B032         Extended dynamic SQL                    B031          Basic dynamic SQL

 B034         Dynamic specification of cursor         B031          Basic dynamic SQL
              attributes

 B111         Module language Ada                     E182          Module language

 B112         Module language C                       E182          Module language

 B113         Module language COBOL                   E182          Module language

 B114         Module language Fortran                 E182          Module language

 B115         Module language MUMPS                   E182          Module language

 B116         Module language Pascal                  E182          Module language

 B117         Module language PL/I                    E182          Module language

 F381         Extended schema manipulation            F491          Constraint management




1082 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)
                                                       24.3 Implied feature relationships of SQL/Foundation



 Feature         Feature Name                        Implied     Implied Feature Name
 ID                                                  Feature
                                                     ID

 F451            Character set definition            F461        Named character sets

 F521            Assertions                          F491        Constraint management

 F691            Collation and translation           F695        Translation support

 F691            Collation and translation           F690        Collation support

 F693            SQL-session and client module colla- F690       Collation support
                 tions

 F711            ALTER domain                        F251        Domain support

 F721            Deferrable constraints              F491        Constraint management

 F801            Full set function                   F441        Extended set function support

 S024            Enhanced structured types           S023        Basic structured types

 S041            Basic reference types               S051        Create table of type

 S043            Enhanced reference types            S041        Basic reference types

 S051            Create table of type                S023        Basic structured types

 S081            Subtables                           S051        Create table of type

 S092            Arrays of user-defined types        S091        Basic array support

 S094            Arrays of reference types           S041        Basic reference types

 S094            Arrays of reference types           S091        Basic array support

 S095            Array constructors by query         S091        Basic array support

 S096            Optional array bounds               S091        Basic array support

 S111            ONLY in query expressions           S051        Create table of type

 S201            SQL-invoked routines on arrays      S091        Basic array support

 S202            SQL-invoked routines on multisets   S271        Basic multiset support

 S231            Structured type locators            S023        Basic structured types

 S232            Array locators                      S091        Basic array support




©ISO/IEC 2003 – All rights reserved                                                       Conformance 1083
ISO/IEC 9075-2:2003 (E)
24.3 Implied feature relationships of SQL/Foundation



 Feature     Feature Name                              Implied   Implied Feature Name
 ID                                                    Feature
                                                       ID

 S233        Multiset locators                         S271      Basic multiset support

 S242        Alter transform statement                 S241      Transform functions

 S272        Multisets of user-defined types           S271      Basic multiset support

 S274        Multisets of reference types              S041      Basic reference types

 S274        Multisets of reference types              S271      Basic multiset support

 S275        Advanced multiset support                 S271      Basic multiset support

 T042        Extended LOB data type support            T041      Basic LOB data type support

 T061        UCS Support                               F461      Named character sets

 T061        UCS support                               F690      Collation support

 T122        WITH (excluding RECURSIVE) in             T121      WITH (excluding RECURSIVE) in
             subquery                                            query expression

 T131        Recursive query                           T121      WITH (excluding RECURSIVE) in
                                                                 query expression

 T132        Recursive query in subquery               T122      WITH (excluding RECURSIVE) in
                                                                 subquery

 T132        Recursive query in subquery               T131      Recursive query

 T173        Extended LIKE clause in table defini- T171          LIKE clause in table definition
             tion

 T212        Enhanced trigger capability               T211      Basic trigger capability

 T332        Extended roles                            T331      Basic roles

 T511        Transaction counts                        F121      Basic diagnostics management

 T571        Array-returning external SQL-             S201      SQL-invoked routines on arrays
             invoked functions

 T572        Multiset-returning external SQL-          S202      SQL-invoked routines on multisets
             invoked functions

 T612        Advanced OLAP operations                  T611      Elementary OLAP operations




1084 Foundation (SQL/Foundation)                                               ©ISO/IEC 2003 – All rights reserved
                                                                                   ISO/IEC 9075-2:2003 (E)




                                                 Annex A
                                               (informative)

                                      SQL Conformance Summary

The contents of this Annex summarizes all Conformance Rules, ordered by Feature ID and by Subclause.
1) Specifications for Feature B011, “Embedded Ada”:
    a) Subclause 20.3, “<embedded SQL Ada program>”:
         i)       Without Feature B011, “Embedded Ada”, conforming SQL language shall not contain an
                  <embedded SQL Ada program>.
2) Specifications for Feature B012, “Embedded C”:
    a) Subclause 20.4, “<embedded SQL C program>”:
         i)       Without Feature B012, “Embedded C”, conforming SQL language shall not contain an
                  <embedded SQL C program>.
3) Specifications for Feature B013, “Embedded COBOL”:
    a) Subclause 20.5, “<embedded SQL COBOL program>”:
         i)       Without Feature B013, “Embedded COBOL”, conforming SQL language shall not contain an
                  <embedded SQL COBOL program>.
4) Specifications for Feature B014, “Embedded Fortran”:
    a) Subclause 20.6, “<embedded SQL Fortran program>”:
         i)       Without Feature B014, “Embedded Fortran”, conforming SQL language shall not contain an
                  <embedded SQL Fortran program>.
5) Specifications for Feature B015, “Embedded MUMPS”:
    a) Subclause 20.7, “<embedded SQL MUMPS program>”:
         i)       Without Feature B015, “Embedded MUMPS”, conforming SQL language shall not contain an
                  <embedded SQL MUMPS program>.
6) Specifications for Feature B016, “Embedded Pascal”:
    a) Subclause 20.8, “<embedded SQL Pascal program>”:
         i)       Without Feature B016, “Embedded Pascal”, conforming SQL language shall not contain an
                  <embedded SQL Pascal program>.
7) Specifications for Feature B017, “Embedded PL/I”:



©ISO/IEC 2003 – All rights reserved                                      SQL Conformance Summary 1085
ISO/IEC 9075-2:2003 (E)




   a) Subclause 20.9, “<embedded SQL PL/I program>”:
       i)     Without Feature B017, “Embedded PL/I”, conforming SQL language shall not contain an
              <embedded SQL PL/I program>.
8) Specifications for Feature B021, “Direct SQL”:
   a) Subclause 21.1, “<direct SQL statement>”:
       i)     Without Feature B021, “Direct SQL”, conforming SQL language shall not contain a <direct
              SQL statement>.
9) Specifications for Feature B031, “Basic dynamic SQL”:
   a) Subclause 5.4, “Names and identifiers”:
       i)     Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain an
              <SQL statement name>.
       ii)    Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain
              <dynamic cursor name>.
       iii)   Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain a
              <descriptor name>.
   b) Subclause 6.4, “<value specification> and <target specification>”:
       i)     Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain a
              <general value specification> that contains a <dynamic parameter specification>.
   c) Subclause 19.2, “<allocate descriptor statement>”:
       i)     Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain an
              <allocate descriptor statement>.
   d) Subclause 19.3, “<deallocate descriptor statement>”:
       i)     Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain a
              <deallocate descriptor statement>.
   e) Subclause 19.4, “<get descriptor statement>”:
       i)     Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain a
              <get descriptor statement>.
   f) Subclause 19.5, “<set descriptor statement>”:
       i)     Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain a
              <set descriptor statement>.
   g) Subclause 19.6, “<prepare statement>”:
       i)     Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain a
              <prepare statement>.
   h) Subclause 19.9, “<describe statement>”:



1086 Foundation (SQL/Foundation)                                           ©ISO/IEC 2003 – All rights reserved
                                                                                  ISO/IEC 9075-2:2003 (E)




         i)       Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain a
                  <describe output statement>.
    i)   Subclause 19.10, “<input using clause>”:
         i)       Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain an
                  <input using clause>.
    j)   Subclause 19.11, “<output using clause>”:
         i)       Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain an
                  <output using clause>.
    k) Subclause 19.12, “<execute statement>”:
         i)       Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain an
                  <execute statement>.
    l)   Subclause 19.13, “<execute immediate statement>”:
         i)       Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain an
                  <execute immediate statement>.
    m) Subclause 19.14, “<dynamic declare cursor>”:
         i)       Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain a
                  <dynamic declare cursor>.
    n) Subclause 19.16, “<dynamic open statement>”:
         i)       Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain a
                  <dynamic open statement>.
    o) Subclause 19.17, “<dynamic fetch statement>”:
         i)       Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain a
                  <dynamic fetch statement>.
    p) Subclause 19.18, “<dynamic single row select statement>”:
         i)       Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain a
                  <dynamic single row select statement>.
    q) Subclause 19.19, “<dynamic close statement>”:
         i)       Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain a
                  <dynamic close statement>.
    r) Subclause 19.20, “<dynamic delete statement: positioned>”:
         i)       Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain a
                  <dynamic delete statement: positioned>.
    s) Subclause 19.21, “<dynamic update statement: positioned>”:
         i)       Without Feature B031, “Basic dynamic SQL”, conforming SQL language shall not contain a
                  <dynamic update statement: positioned>.


©ISO/IEC 2003 – All rights reserved                                      SQL Conformance Summary 1087
ISO/IEC 9075-2:2003 (E)




10) Specifications for Feature B032, “Extended dynamic SQL”:
    a) Subclause 5.4, “Names and identifiers”:
        i)    Without Feature B032, “Extended dynamic SQL”, conforming SQL language shall not contain
              a <extended statement name> or <extended cursor name>.
        ii)   Without Feature B032, “Extended dynamic SQL”, conforming SQL language shall not contain
              a <descriptor name> that is not a <literal>.
    b) Subclause 19.2, “<allocate descriptor statement>”:
        i)    Without Feature B032, “Extended dynamic SQL”, conforming SQL language shall not contain
              an <occurrences> that is not a <literal>.
    c) Subclause 19.8, “<deallocate prepared statement>”:
        i)    Without Feature B032, “Extended dynamic SQL”, conforming SQL language shall not contain
              a <deallocate prepared statement>.
    d) Subclause 19.9, “<describe statement>”:
        i)    Without Feature B032, “Extended dynamic SQL”, conforming SQL language shall not contain
              a <describe input statement>.
    e) Subclause 19.12, “<execute statement>”:
        i)    Without Feature B032, “Extended dynamic SQL”, conforming SQL language shall not contain
              a <result using clause>.
    f) Subclause 19.15, “<allocate cursor statement>”:
        i)    Without Feature B032, “Extended dynamic SQL”, conforming SQL language shall not contain
              an <allocate cursor statement>.
    g) Subclause 19.22, “<preparable dynamic delete statement: positioned>”:
        i)    Without Feature B032, “Extended dynamic SQL”, conforming SQL language shall not contain
              a <preparable dynamic delete statement: positioned>.
    h) Subclause 19.23, “<preparable dynamic update statement: positioned>”:
        i)    Without Feature B032, “Extended dynamic SQL”, conforming SQL language shall not contain
              a <preparable dynamic update statement: positioned>.
11) Specifications for Feature B033, “Untyped SQL-invoked function arguments”:
    a) Subclause 10.4, “<routine invocation>”:
        i)    Without Feature B033, “Untyped SQL-invoked function arguments”, conforming SQL language
              shall not contain a <routine invocation> that is not simply contained in a <call statement> that
              simply contains an <SQL argument> that is a <dynamic parameter specification>.
12) Specifications for Feature B034, “Dynamic specification of cursor attributes”:
    a) Subclause 19.6, “<prepare statement>”:



1088 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)




         i)       Without Feature B034, “Dynamic specification of cursor attributes”, conforming SQL language
                  shall not contain an <attributes specification>.
13) Specifications for Feature B041, “Extensions to embedded SQL exception declarations”:
    a) Subclause 20.2, “<embedded exception declaration>”:
         i)       Without Feature B041, “Extensions to embedded SQL exception declarations”, conforming
                  SQL language shall not contain an <SQL condition> that contains either SQLSTATE or CON-
                  STRAINT.
14) Specifications for Feature B051, “Enhanced execution rights”:
    a) Subclause 13.1, “<SQL-client module definition>”:
         i)       Without Feature B051, “Enhanced execution rights”, conforming SQL language shall not contain
                  a <module authorization clause> that immediately contains FOR STATIC ONLY or FOR
                  STATIC AND DYNAMIC.
    b) Subclause 20.1, “<embedded SQL host program>”:
         i)       Without Feature B051, “Enhanced execution rights”, conforming SQL language shall not contain
                  an <embedded authorization declaration>.
15) Specifications for Feature B111, “Module language Ada”:
    a) Subclause 13.1, “<SQL-client module definition>”:
         i)       Without Feature B111, “Module language Ada”, conforming SQL language shall not contain
                  an <SQL-client module definition> that contains a <language clause> that contains ADA.
16) Specifications for Feature B112, “Module language C”:
    a) Subclause 13.1, “<SQL-client module definition>”:
         i)       Without Feature B112, “Module language C”, conforming SQL language shall not contain an
                  <SQL-client module definition> that contains a <language clause> that contains C.
17) Specifications for Feature B113, “Module language COBOL”:
    a) Subclause 13.1, “<SQL-client module definition>”:
         i)       Without Feature B113, “Module language COBOL”, conforming SQL language shall not contain
                  an <SQL-client module definition> that contains a <language clause> that contains COBOL.
18) Specifications for Feature B114, “Module language Fortran”:
    a) Subclause 13.1, “<SQL-client module definition>”:
         i)       Without Feature B114, “Module language Fortran”, conforming SQL language shall not contain
                  an <SQL-client module definition> that contains a <language clause> that contains FORTRAN.
19) Specifications for Feature B115, “Module language MUMPS”:
    a) Subclause 13.1, “<SQL-client module definition>”:




©ISO/IEC 2003 – All rights reserved                                         SQL Conformance Summary 1089
ISO/IEC 9075-2:2003 (E)




       i)     Without Feature B115, “Module language MUMPS”, conforming SQL language shall not contain
              an <SQL-client module definition> that contains a <language clause> that contains M.
20) Specifications for Feature B116, “Module language Pascal”:
   a) Subclause 13.1, “<SQL-client module definition>”:
       i)     Without Feature B116, “Module language Pascal”, conforming SQL language shall not contain
              an <SQL-client module definition> that contains a <language clause> that contains PASCAL.
21) Specifications for Feature B117, “Module language PL/I”:
   a) Subclause 13.1, “<SQL-client module definition>”:
       i)     Without Feature B117, “Module language PL/I”, conforming SQL language shall not contain
              an <SQL-client module definition> that contains a <language clause> that contains PLI.
22) Specifications for Feature B121, “Routine language Ada”:
   a) Subclause 11.50, “<SQL-invoked routine>”:
       i)     Without Feature B121, “Routine language Ada”, conforming SQL language shall not contain a
              <routine characteristic> that contains a <language clause> that contains ADA.
23) Specifications for Feature B122, “Routine language C”:
   a) Subclause 11.50, “<SQL-invoked routine>”:
       i)     Without Feature B122, “Routine language C”, conforming SQL language shall not contain a
              <routine characteristic>that contains a <language clause> that contains C.
24) Specifications for Feature B123, “Routine language COBOL”:
   a) Subclause 11.50, “<SQL-invoked routine>”:
       i)     Without Feature B123, “Routine language COBOL”, conforming SQL language shall not contain
              a <routine characteristic> that contains a <language clause> that contains COBOL.
25) Specifications for Feature B124, “Routine language Fortran”:
   a) Subclause 11.50, “<SQL-invoked routine>”:
       i)     Without Feature B124, “Routine language Fortran”, conforming SQL language shall not contain
              a <routine characteristic> that contains a <language clause> that contains FORTRAN.
26) Specifications for Feature B125, “Routine language MUMPS”:
   a) Subclause 11.50, “<SQL-invoked routine>”:
       i)     Without Feature B125, “Routine language MUMPS”, conforming SQL language shall not contain
              a <routine characteristic> that contains a <language clause> that contains M.
27) Specifications for Feature B126, “Routine language Pascal”:
   a) Subclause 11.50, “<SQL-invoked routine>”:
       i)     Without Feature B126, “Routine language Pascal”, conforming SQL language shall not contain
              a <routine characteristic> that contains a <language clause> that contains PASCAL.


1090 Foundation (SQL/Foundation)                                            ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)




28) Specifications for Feature B127, “Routine language PL/I”:
    a) Subclause 11.50, “<SQL-invoked routine>”:
         i)       Without Feature B127, “Routine language PL/I”, conforming SQL language shall not contain
                  a <routine characteristic> that contains a <language clause> that contains PLI.
29) Specifications for Feature B128, “Routine language SQL”:
    a) Subclause 11.50, “<SQL-invoked routine>”:
         i)       Without Feature B128, “Routine language SQL”, conforming SQL language shall not contain
                  a <routine characteristic> that contains a <language clause> that contains SQL.
30) Specifications for Feature F032, “CASCADE drop behavior”:
    a) Subclause 11.21, “<drop table statement>”:
         i)       Without Feature F032, “CASCADE drop behavior”, conforming SQL language shall not contain
                  a <drop table statement> that contains <drop behavior> that contains CASCADE.
    b) Subclause 11.23, “<drop view statement>”:
         i)       Without Feature F032, “CASCADE drop behavior”, conforming SQL language shall not contain
                  a <drop view statement> that contains a <drop behavior> that contains CASCADE.
    c) Subclause 11.49, “<drop data type statement>”:
         i)       Without Feature F032, “CASCADE drop behavior”, conforming SQL language shall not contain
                  a <drop data type statement> that contains a <drop behavior> that contains CASCADE.
    d) Subclause 11.52, “<drop routine statement>”:
         i)       Without Feature F032, “CASCADE drop behavior”, conforming SQL language shall not contain
                  a <drop routine statement> that contains a <drop behavior> that contains CASCADE.
31) Specifications for Feature F033, “ALTER TABLE statement: DROP COLUMN clause”:
    a) Subclause 11.18, “<drop column definition>”:
         i)       Without Feature F033, “ALTER TABLE statement: DROP COLUMN clause”, conforming
                  SQL language shall not contain a <drop column definition>.
32) Specifications for Feature F034, “Extended REVOKE statement”:
    a) Subclause 12.7, “<revoke statement>”:
         i)       Without Feature F034, “Extended REVOKE statement”, conforming SQL language shall not
                  contain a <revoke statement> that contains a <drop behavior> that contains CASCADE.
         ii)      Without Feature F034, “Extended REVOKE statement”, conforming SQL language shall not
                  contain a <revoke option extension> that contains GRANT OPTION FOR.
         iii)     Without Feature F034, “Extended REVOKE statement”, conforming SQL language shall not
                  contain a <revoke statement> that contains a <privileges> that contains an <object name> where
                  the owner of the SQL-schema that is specified explicitly or implicitly in the <object name> is
                  not the current authorization identifier.


©ISO/IEC 2003 – All rights reserved                                          SQL Conformance Summary 1091
ISO/IEC 9075-2:2003 (E)




        iv)    Without Feature F034, “Extended REVOKE statement”, conforming SQL language shall not
               contain a <revoke statement> such that there exists a privilege descriptor PD that satisfies all
               the following conditions:
               1) PD identifies the object identified by <object name> simply contained in <privileges>
                  contained in the <revoke statement>.
               2) PD identifies the <grantee> identified by any <grantee> simply contained in <revoke
                  statement> and that <grantee> does not identify the owner of the SQL-schema that is spec-
                  ified explicitly or implicitly in the <object name> simply contained in <privileges> contained
                  in the <revoke statement>.
               3) PD identifies the action identified by the <action> simply contained in <privileges> contained
                  in the <revoke statement>.
               4) PD indicates that the privilege is grantable.
33) Specifications for Feature F052, “Intervals and datetime arithmetic”:
    a) Subclause 5.3, “<literal>”:
        i)     Without Feature F052, “Intervals and datetime arithmetic”, conforming SQL language shall not
               contain an <interval literal>.
    b) Subclause 6.1, “<data type>”:
        i)     Without Feature F052, “Intervals and datetime arithmetic”, conforming SQL language shall not
               contain an <interval type>.
    c) Subclause 6.27, “<numeric value function>”:
        i)     Without Feature F052, “Intervals and datetime arithmetic”, conforming SQL language shall not
               contain an <extract expression>.
        ii)    Without Feature F052, “Intervals and datetime arithmetic”, conforming SQL language shall not
               contain an <extract expression> that specifies a <time zone field>.
    d) Subclause 6.30, “<datetime value expression>”:
        i)     Without Feature F052, “Intervals and datetime arithmetic”, conforming SQL language shall not
               contain <datetime value expression> that immediately contains a <plus sign> or a <minus sign>.
    e) Subclause 6.32, “<interval value expression>”:
        i)     Without Feature F052, “Intervals and datetime arithmetic”, conforming SQL language shall not
               contain an <interval value expression>.
    f) Subclause 6.33, “<interval value function>”:
        i)     Without Feature F052, “Intervals and datetime arithmetic”, conforming SQL shall not contain
               an <interval value function>.
    g) Subclause 10.1, “<interval qualifier>”:
        i)     Without Feature F052, “Intervals and datetime arithmetic”, conforming SQL language shall not
               contain an <interval qualifier>.



1092 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)




34) Specifications for Feature F053, “OVERLAPS predicate”:
    a) Subclause 8.13, “<overlaps predicate>”:
         i)       Without Feature F053, “OVERLAPS predicate”, conforming SQL language shall not contain
                  an <overlaps predicate>.
35) Specifications for Feature F111, “Isolation levels other than SERIALIZABLE”:
    a) Subclause 16.1, “<start transaction statement>”:
         i)       Without Feature F111, “Isolation levels other than SERIALIZABLE”, conforming SQL language
                  shall not contain an <isolation level> that contains a <level of isolation> other than SERIALIZ-
                  ABLE.
    b) Subclause 18.1, “<set session characteristics statement>”:
         i)       Without Feature F111, “Isolation levels other than SERIALIZABLE”, conforming SQL language
                  shall not contain a <set session characteristics statement> that contains a <level of isolation>
                  other than SERIALIZABLE.
36) Specifications for Feature F121, “Basic diagnostics management”:
    a) Subclause 16.1, “<start transaction statement>”:
         i)       Without Feature F121, “Basic diagnostics management”, conforming SQL language shall not
                  contain a <diagnostics size>.
    b) Subclause 22.1, “<get diagnostics statement>”:
         i)       Without Feature F121, “Basic diagnostics management”, conforming SQL language shall not
                  contain a <get diagnostics statement>.
37) Specifications for Feature F171, “Multiple schemas per user”:
    a) Subclause 11.1, “<schema definition>”:
         i)       Without Feature F171, “Multiple schemas per user”, conforming SQL language shall not contain
                  a <schema name clause> that contains a <schema name>.
38) Specifications for Feature F191, “Referential delete actions”:
    a) Subclause 11.8, “<referential constraint definition>”:
         i)       Without Feature F191, “Referential delete actions”, conforming SQL language shall not contain
                  a <delete rule>.
39) Specifications for Feature F222, “INSERT statement: DEFAULT VALUES clause”:
    a) Subclause 14.8, “<insert statement>”:
         i)       Without Feature F222, “INSERT statement: DEFAULT VALUES clause”, conforming SQL
                  language shall not contain a <from default>.
40) Specifications for Feature F251, “Domain support”:
    a) Subclause 5.4, “Names and identifiers”:



©ISO/IEC 2003 – All rights reserved                                           SQL Conformance Summary 1093
ISO/IEC 9075-2:2003 (E)




        i)    Without Feature F251, “Domain support”, conforming SQL language shall not contain a <domain
              name>.
    b) Subclause 6.4, “<value specification> and <target specification>”:
        i)    Without Feature F251, “Domain support”, conforming SQL language shall not contain a <general
              value specification> that contains VALUE.
    c) Subclause 11.24, “<domain definition>”:
        i)    Without Feature F251, “Domain support”, conforming SQL language shall not contain a <domain
              definition>.
    d) Subclause 11.30, “<drop domain statement>”:
        i)    Without Feature F251, “Domain support”, conforming SQL language shall not contain a <drop
              domain statement>.
41) Specifications for Feature F262, “Extended CASE expression”:
    a) Subclause 6.11, “<case expression>”:
        i)    Without Feature F262, “Extended CASE expression”, in conforming SQL language, a <case
              operand> immediately contained in a <simple case> shall be a <row value predicand> that is a
              <row value constructor predicand> that is a single <common value expression> or <boolean
              predicand>.
        ii)   Without Feature F262, “Extended CASE expression”, in conforming SQL language, a <when
              operand> contained in a <simple when clause> shall be a <row value predicand> that is a <row
              value constructor predicand> that is a single <common value expression> or <boolean predicand>.
42) Specifications for Feature F263, “Comma-separated predicates in simple CASE expression”:
    a) Subclause 6.11, “<case expression>”:
        i)    Without Feature F263, “Comma-separated predicates in simple CASE expression”, in conforming
              SQL language, a <when operand list> contained in a <simple when clause> shall simply contain
              exactly one <when operand>.
43) Specifications for Feature F271, “Compound character literals”:
    a) Subclause 5.3, “<literal>”:
        i)    Without Feature F271, “Compound character literals”, in conforming SQL language, a <character
              string literal> shall contain exactly one repetition of <character representation> (that is, it shall
              contain exactly one sequence of “<quote> <character representation>... <quote>”).
44) Specifications for Feature F281, “LIKE enhancements”:
    a) Subclause 8.5, “<like predicate>”:
        i)    Without Feature F281, “LIKE enhancements”, conforming SQL language shall not contain a
              <common value expression> simply contained in the <row value predicand> immediately con-
              tained in <character like predicate> that is not a column reference.




1094 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                                ISO/IEC 9075-2:2003 (E)




         ii)      Without Feature F281, “LIKE enhancements”, conforming SQL language shall not contain a
                  <character pattern> that is not a <value specification>.
         iii)     Without Feature F281, “LIKE enhancements”, conforming SQL language shall not contain an
                  <escape character> that is not a <value specification>.
45) Specifications for Feature F291, “UNIQUE predicate”:
    a) Subclause 8.10, “<unique predicate>”:
         i)       Without Feature F291, “UNIQUE predicate”, conforming SQL language shall not contain a
                  <unique predicate>.
                  NOTE 460 — The Conformance Rules of Subclause 9.10, “Grouping operations”, also apply.

46) Specifications for Feature F301, “CORRESPONDING in query expressions”:
    a) Subclause 7.13, “<query expression>”:
         i)       Without Feature F301, “CORRESPONDING in query expressions”, conforming SQL language
                  shall not contain a <query expression> that contains CORRESPONDING.
47) Specifications for Feature F302, “INTERSECT table operator”:
    a) Subclause 7.13, “<query expression>”:
         i)       Without Feature F302, “INTERSECT table operator”, conforming SQL language shall not
                  contain a <query term> that contains INTERSECT.
48) Specifications for Feature F304, “EXCEPT ALL table operator”:
    a) Subclause 7.13, “<query expression>”:
         i)       Without Feature F304, “EXCEPT ALL table operator”, conforming SQL language shall not
                  contain a <query expression> that contains EXCEPT ALL.
                  NOTE 461 — If DISTINCT, INTERSECT or EXCEPT is specified, then the Conformance Rules of Subclause 9.10,
                  “Grouping operations”, apply.

49) Specifications for Feature F312, “MERGE statement”:
    a) Subclause 14.9, “<merge statement>”:
         i)       Without Feature F312, “MERGE statement”, conforming SQL language shall not contain a
                  <merge statement>.
50) Specifications for Feature F321, “User authorization”:
    a) Subclause 6.4, “<value specification> and <target specification>”:
         i)       Without Feature F321, “User authorization”, conforming SQL language shall not contain a
                  <general value specification> that contains CURRENT_USER, SYSTEM_USER, or SES-
                  SION_USER.
                  NOTE 462 — Although CURRENT_USER and USER are semantically the same, without Feature F321, “User
                  authorization”, CURRENT_USER shall be specified as USER.

    b) Subclause 11.5, “<default clause>”:



©ISO/IEC 2003 – All rights reserved                                                 SQL Conformance Summary 1095
ISO/IEC 9075-2:2003 (E)




       i)     Without Feature F321, “User authorization”, conforming SQL language shall not contain a
              <default option> that contains CURRENT_USER, SESSION_USER, or SYSTEM_USER.
              NOTE 463 — Although CURRENT_USER and USER are semantically the same, without Feature F321, “User
              authorization”, CURRENT_USER shall be specified as USER.

   c) Subclause 18.2, “<set session user identifier statement>”:
       i)     Without Feature F321, “User authorization”, conforming SQL language shall not contain a <set
              session user identifier statement>.
51) Specifications for Feature F361, “Subprogram support”:
   a) Subclause 20.1, “<embedded SQL host program>”:
       i)     Without Feature F361, “Subprogram support”, conforming SQL language shall not contain two
              <host variable definition>s that specify the same variable name.
52) Specifications for Feature F381, “Extended schema manipulation”:
   a) Subclause 11.2, “<drop schema statement>”:
       i)     Without Feature F381, “Extended schema manipulation”, conforming SQL language shall not
              contain a <drop schema statement>.
   b) Subclause 11.12, “<alter column definition>”:
       i)     Without Feature F381, “Extended schema manipulation”, conforming SQL language shall not
              contain an <alter column definition>.
   c) Subclause 11.13, “<set column default clause>”:
       i)     Without Feature F381, “Extended schema manipulation”, conforming SQL language shall not
              contain a <set column default clause>.
   d) Subclause 11.14, “<drop column default clause>”:
       i)     Without Feature F381, “Extended schema manipulation”, conforming SQL language shall not
              contain a <drop column default clause>.
   e) Subclause 11.15, “<add column scope clause>”:
       i)     Without Feature F381, “Extended schema manipulation”, conforming SQL language shall not
              contain an <add column scope clause>.
   f) Subclause 11.16, “<drop column scope clause>”:
       i)     Without Feature F381, “Extended schema manipulation”, conforming SQL language shall not
              contain a <drop column scope clause>.
   g) Subclause 11.19, “<add table constraint definition>”:
       i)     Without Feature F381, “Extended schema manipulation”, conforming SQL language shall not
              contain an <add table constraint definition>.
   h) Subclause 11.20, “<drop table constraint definition>”:




1096 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                                             ISO/IEC 9075-2:2003 (E)




         i)       Without Feature F381, “Extended schema manipulation”, conforming SQL language shall not
                  contain a <drop table constraint definition>.
    i)   Subclause 11.51, “<alter routine statement>”:
         i)       Without Feature F381, “Extended schema manipulation”, conforming SQL language shall not
                  contain an <alter routine statement>.
53) Specifications for Feature F391, “Long identifiers”:
    a) Subclause 5.2, “<token> and <separator>”:
         i)       Without Feature F391, “Long identifiers”, in a <regular identifier>, the number of <identifier
                  part>s shall be less than 18.
         ii)      Without Feature F391, “Long identifiers”, the <delimited identifier body> of a <delimited
                  identifier> shall not comprise more than 18 <delimited identifier part>s.
                  NOTE 464 — Not every character set supported by a conforming SQL-implementation necessarily contains every
                  character associated with <identifier start> and <identifier part> that is identified in the Syntax Rules of this Subclause.
                  No conforming SQL-implementation shall be required to support in <identifier start> or <identifier part> any character
                  identified in the Syntax Rules of this Subclause unless that character belongs to the character set in use for an SQL-
                  client module or in SQL-data.

54) Specifications for Feature F392, “Unicode escapes in identifiers”:
    a) Subclause 5.2, “<token> and <separator>”:
         i)       Without Feature F392, “Unicode escapes in identifiers”, conforming SQL language shall not
                  contain a <Unicode delimited identifier>.
55) Specifications for Feature F393, “Unicode escapes in literals”:
    a) Subclause 5.3, “<literal>”:
         i)       Without Feature F393, “Unicode escapes in literals”, conforming SQL language shall not contain
                  a <Unicode character string literal>.
56) Specifications for Feature F401, “Extended joined table”:
    a) Subclause 7.7, “<joined table>”:
         i)       Without Feature F401, “Extended joined table”, conforming SQL language shall not contain a
                  <cross join>.
         ii)      Without Feature F401, “Extended joined table”, conforming SQL language shall not contain a
                  <natural join>.
         iii)     Without Feature F401, “Extended joined table”, conforming SQL language shall not contain
                  FULL.
57) Specifications for Feature F402, “Named column joins for LOBs, arrays, and multisets”:
    a) Subclause 7.7, “<joined table>”:
         i)       Without Feature F402, “Named column joins for LOBs, arrays, and multisets”, conforming SQL
                  language shall not contain a <joined table> that simply contains either <natural join> or <named



©ISO/IEC 2003 – All rights reserved                                                             SQL Conformance Summary 1097
ISO/IEC 9075-2:2003 (E)




              columns join> in which, if C is a corresponding join column, the declared type of C is LOB-
              ordered, array-ordered, or multiset-ordered.
              NOTE 465 — If C is a corresponding join column, then the Conformance Rules of Subclause 9.9, “Equality operations”,
              also apply.

58) Specifications for Feature F411, “Time zone specification”:
    a) Subclause 5.3, “<literal>”:
        i)    Without Feature F411, “Time zone specification”, conforming SQL language shall not contain
              a <time zone interval>.
    b) Subclause 6.1, “<data type>”:
        i)    Without Feature F411, “Time zone specification”, conforming SQL language shall not contain
              <with or without time zone>.
    c) Subclause 6.27, “<numeric value function>”:
        i)    Feature F411, “Time zone specification”, conforming SQL language shall not contain an <extract
              expression> that specifies a <time zone field>.
    d) Subclause 6.30, “<datetime value expression>”:
        i)    Without Feature F411, “Time zone specification”, conforming SQL language shall not contain
              a <time zone>.
    e) Subclause 6.31, “<datetime value function>”:
        i)    Without Feature F411, “Time zone specification”, conforming SQL language shall not contain
              a <current time value function>.
        ii)   Without Feature F411, “Time zone specification”, conforming SQL language shall not contain
              a <current timestamp value function>.
    f) Subclause 18.4, “<set local time zone statement>”:
        i)    Without Feature F411, “Time zone specification”, conforming SQL language shall not contain
              a <set local time zone statement>.
59) Specifications for Feature F421, “National character”:
    a) Subclause 5.3, “<literal>”:
        i)    Without Feature F421, “National character”, conforming SQL language shall not contain a
              <national character string literal>.
    b) Subclause 6.1, “<data type>”:
        i)    Without Feature F421, “National character”, conforming SQL language shall not contain a
              <national character string type>
    c) Subclause 6.12, “<cast specification>”:
        i)    Without Feature F421, “National character”, conforming SQL language shall not contain a <cast
              operand> whose declared type is NATIONAL CHARACTER LARGE OBJECT.



1098 Foundation (SQL/Foundation)                                                             ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)




    d) Subclause 6.27, “<numeric value function>”:
         i)       Without Feature F421, “National character”, conforming SQL language shall not contain a
                  <length expression> that simply contains a <string value expression> that has a declared type
                  of NATIONAL CHARACTER LARGE OBJECT.
    e) Subclause 8.5, “<like predicate>”:
         i)       Without Feature F421, “National character”, and Feature T042, “Extended LOB data type sup-
                  port”, in conforming SQL language, a <character value expression> simply contained in a <like
                  predicate> shall not be of declared type NATIONAL CHARACTER LARGE OBJECT.
60) Specifications for Feature F431, “Read-only scrollable cursors”:
    a) Subclause 14.1, “<declare cursor>”:
         i)       Without Feature F431, “Read-only scrollable cursors”, conforming SQL language shall not
                  contain a <cursor scrollability>.
    b) Subclause 14.3, “<fetch statement>”:
         i)       Without Feature F431, “Read-only scrollable cursors”, a <fetch statement> shall not contain a
                  <fetch orientation>.
61) Specifications for Feature F441, “Extended set function support”:
    a) Subclause 7.8, “<where clause>”:
         i)       Without Feature F441, “Extended set function support”, conforming SQL language shall not
                  contain a <value expression> directly contained in a <where clause> that contains a <column
                  reference> that references a <derived column> that generally contains a <set function specifica-
                  tion> without an intervening <routine invocation>.
    b) Subclause 10.9, “<aggregate function>”:
         i)       Without Feature F441, “Extended set function support”, conforming SQL language shall not
                  contain a <general set function> that contains a <computational operation> that immediately
                  contains COUNT and does not contain a <set quantifier> that immediately contains DISTINCT.
         ii)      Without Feature F441, “Extended set function support”, conforming SQL language shall not
                  contain a <general set function> that does not contain a <set quantifier> that immediately contains
                  DISTINCT and that contains a <value expression> that contains a column reference that does
                  not reference a column of T.
         iii)     Without Feature F441, “Extended set function support”, conforming SQL language shall not
                  contain a <binary set function> that does not contain either a <dependent variable expression>
                  or an <independent variable expression> that contains a column reference that references a column
                  of T.
         iv)      Without Feature F441, “Extended set function support”, conforming SQL language shall not
                  contain a <value expression> simply contained in a <general set function> that contains a column
                  reference that is an outer reference where the <value expression> is not a column reference.
         v)       Without Feature F441, “Extended set function support”, conforming SQL language shall not
                  contain a <numeric value expression> simply contained in a <dependent variable expression>



©ISO/IEC 2003 – All rights reserved                                             SQL Conformance Summary 1099
ISO/IEC 9075-2:2003 (E)




               or an <independent variable expression> that contains a column reference that is an outer reference
               and in which the <numeric value expression> is not a column reference.
        vi)    Without Feature F441, “Extended set function support”, conforming SQL language shall not
               contain a column reference contained in an <aggregate function> that contains a reference to a
               column derived from a <value expression> that generally contains an <aggregate function>
               SFS2 without an intervening <routine invocation>.
62) Specifications for Feature F442, “Mixed column references in set functions”:
    a) Subclause 10.9, “<aggregate function>”:
        i)     Without Feature F442, “Mixed column references in set functions”, conforming SQL language
               shall not contain a <hypothetical set function value expression list> or a <sort specification list>
               that simply contains a <value expression> that contains more than one column reference, one
               of which is an outer reference.
        ii)    Without Feature F442, “Mixed column references in set functions”, conforming SQL language
               shall not contain an <inverse distribution function> that contains an <inverse distribution function
               argument> or a <sort specification> that contains more than one column reference, one of which
               is an outer reference.
        iii)   Without Feature F442, “Mixed column references in set functions”, conforming SQL language
               shall not contain an <aggregate function> that contains a <general set function> whose simply
               contained <value expression> contains more than one column reference, one of which is an
               outer reference.
        iv)    Without Feature F442, “Mixed column references in set functions”, conforming SQL language
               shall not contain an <aggregate function> that contains a <binary set function> whose simply
               contained <dependent variable expression> or <independent variable expression> contains more
               than one column reference, one of which is an outer reference.
63) Specifications for Feature F451, “Character set definition”:
    a) Subclause 11.31, “<character set definition>”:
        i)     Without Feature F451, “Character set definition”, conforming SQL language shall not contain
               a <character set definition>.
    b) Subclause 11.32, “<drop character set statement>”:
        i)     Without Feature F451, “Character set definition”, conforming SQL language shall not contain
               a <drop character set statement>.
64) Specifications for Feature F461, “Named character sets”:
    a) Subclause 5.4, “Names and identifiers”:
        i)     Without Feature F461, “Named character sets”, conforming SQL language shall not contain a
               <character set name>.
    b) Subclause 10.5, “<character set specification>”:
        i)     Without Feature F461, “Named character sets”, conforming SQL language shall not contain a
               <character set specification>.



1100 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)




    c) Subclause 11.1, “<schema definition>”:
         i)       Without Feature F461, “Named character sets”, conforming SQL language shall not contain a
                  <schema character set specification>.
    d) Subclause 13.2, “<module name clause>”:
         i)       Without Feature F461, “Named character sets”, conforming SQL language shall not contain a
                  <module character set specification>.
    e) Subclause 18.7, “<set names statement>”:
         i)       Without and Feature F461, “Named character sets”, conforming SQL language shall not contain
                  a <set names statement>.
    f) Subclause 20.1, “<embedded SQL host program>”:
         i)       Without Feature F461, “Named character sets”, conforming SQL language shall not contain an
                  <embedded character set declaration>.
65) Specifications for Feature F491, “Constraint management”:
    a) Subclause 5.4, “Names and identifiers”:
         i)       Without Feature F491, “Constraint management”, conforming SQL language shall not contain
                  a <constraint name>.
    b) Subclause 10.8, “<constraint name definition> and <constraint characteristics>”:
         i)       Without Feature F491, “Constraint management”, conforming SQL language shall not contain
                  a <constraint name definition>.
    c) Subclause 11.29, “<drop domain constraint definition>”:
         i)       Without Feature F491, “Constraint management”, conforming SQL language shall not contain
                  a <drop domain constraint definition>.
    d) Subclause 20.2, “<embedded exception declaration>”:
         i)       Without Feature F491, “Constraint management”, conforming SQL language shall not contain
                  an <SQL condition> that contains a <constraint name>.
66) Specifications for Feature F521, “Assertions”:
    a) Subclause 11.37, “<assertion definition>”:
         i)       Without Feature F521, “Assertions”, conforming SQL language shall not contain an <assertion
                  definition>.
    b) Subclause 11.38, “<drop assertion statement>”:
         i)       Without Feature F521, “Assertions”, conforming SQL language shall not contain a <drop
                  assertion statement>.
67) Specifications for Feature F531, “Temporary tables”:
    a) Subclause 11.3, “<table definition>”:



©ISO/IEC 2003 – All rights reserved                                        SQL Conformance Summary 1101
ISO/IEC 9075-2:2003 (E)




        i)     Without Feature F531, “Temporary tables”, conforming SQL language shall not contain a <table
               scope> and shall not reference any global or local temporary table.
    b) Subclause 14.13, “<temporary table declaration>”:
        i)     Without Feature F531, “Temporary tables”, conforming SQL language shall not contain a
               <temporary table declaration>.
68) Specifications for Feature F555, “Enhanced seconds precision”:
    a) Subclause 5.3, “<literal>”:
        i)     Without Feature F555, “Enhanced seconds precision”, in conforming SQL language, an <unsigned
               integer> that is a <seconds fraction> that is contained in a <timestamp literal> shall not contain
               more than 6 <digit>s.
        ii)    Without Feature F555, “Enhanced seconds precision”, in conforming SQL language, a <time
               literal> shall not contain a <seconds fraction>.
    b) Subclause 6.1, “<data type>”:
        i)     Without Feature F555, “Enhanced seconds precision”, conforming SQL language shall not
               contain a <time precision> that does not specify 0 (zero).
        ii)    Without Feature F555, “Enhanced seconds precision”, conforming SQL language shall not
               contain a <timestamp precision> that does not specify either 0 (zero) or 6.
    c) Subclause 6.31, “<datetime value function>”:
        i)     Without Feature F555, “Enhanced seconds precision”, conforming SQL language shall not
               contain a <current local time value function> that contains a <time precision> that is not 0 (zero).
        ii)    Without Feature F555, “Enhanced seconds precision”, conforming SQL language shall not
               contain a <current local timestamp value function> that contains a <timestamp precision> that
               is neither 0 (zero) nor 6.
69) Specifications for Feature F561, “Full value expressions”:
    a) Subclause 8.4, “<in predicate>”:
        i)     Without Feature F561, “Full value expressions”, conforming SQL language shall not contain a
               <row value expression> immediately contained in an <in value list> that is not a <value specifi-
               cation>.
               NOTE 466 — Since <in predicate> is an equality operation, the Conformance Rules of Subclause 9.9, “Equality
               operations”, also apply.

    b) Subclause 10.9, “<aggregate function>”:
        i)     Without Feature F561, “Full value expressions”, or Feature F801, “Full set function”, conforming
               SQL language shall not contain a <general set function> that immediately contains DISTINCT
               and contains a <value expression> that is not a column reference.
70) Specifications for Feature F571, “Truth value tests”:
    a) Subclause 6.34, “<boolean value expression>”:



1102 Foundation (SQL/Foundation)                                                           ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)




         i)       Without Feature F571, “Truth value tests”, conforming SQL language shall not contain a <boolean
                  test> that simply contains a <truth value>.
71) Specifications for Feature F591, “Derived tables”:
    a) Subclause 7.6, “<table reference>”:
         i)       Without Feature F591, “Derived tables”, conforming SQL language shall not contain a <derived
                  table>.
72) Specifications for Feature F611, “Indicator data types”:
    a) Subclause 6.4, “<value specification> and <target specification>”:
         i)       Without Feature F611, “Indicator data types”, in conforming SQL language, the specific declared
                  types of <indicator parameter>s and <indicator variable>s shall be the same implementation-
                  defined data type.
73) Specifications for Feature F641, “Row and table constructors”:
    a) Subclause 7.1, “<row value constructor>”:
         i)       Without Feature F641, “Row and table constructors”, conforming SQL language shall not contain
                  an <explicit row value constructor> that is not simply contained in a <table value constructor>
                  and that contains more than one <row value constructor element>.
         ii)      Without Feature F641, “Row and table constructors”, conforming SQL language shall not contain
                  an <explicit row value constructor> that is a <row subquery>.
         iii)     Without Feature F641, “Row and table constructors”, conforming SQL language shall not contain
                  a <contextually typed row value constructor> that is not simply contained in a <contextually
                  typed table value constructor> and that contains more than one <row value constructor element>.
         iv)      Without Feature F641, “Row and table constructors”, conforming SQL language shall not contain
                  a <contextually typed row value constructor> that is a <row subquery>.
    b) Subclause 7.3, “<table value constructor>”:
         i)       Without Feature F641, “Row and table constructors”, in conforming SQL language, the <con-
                  textually typed row value expression list> of a <contextually typed table value constructor>
                  shall contain exactly one <contextually typed row value constructor> RVE. RVE shall be of the
                  form “(<contextually typed row value constructor element list>)”.
         ii)      Without Feature F641, “Row and table constructors”, conforming SQL language shall not contain
                  a <table value constructor>.
74) Specifications for Feature F651, “Catalog name qualifiers”:
    a) Subclause 5.4, “Names and identifiers”:
         i)       Without Feature F651, “Catalog name qualifiers”, conforming SQL language shall not contain
                  a <catalog name>.
    b) Subclause 18.5, “<set catalog statement>”:




©ISO/IEC 2003 – All rights reserved                                           SQL Conformance Summary 1103
ISO/IEC 9075-2:2003 (E)




        i)    Without Feature F651, “Catalog name qualifiers”, conforming SQL language shall not contain
              a <set catalog statement>.
75) Specifications for Feature F661, “Simple tables”:
    a) Subclause 7.13, “<query expression>”:
        i)    Without Feature F661, “Simple tables”, conforming SQL language shall not contain a <simple
              table> that immediately contains a <table value constructor> except in an <insert statement>.
        ii)   Without Feature F661, “Simple tables”, conforming SQL language shall not contain an <explicit
              table>.
76) Specifications for Feature F671, “Subqueries in CHECK constraints”:
    a) Subclause 11.9, “<check constraint definition>”:
        i)    Without Feature F671, “Subqueries in CHECK constraints”, conforming SQL language shall
              not contain a <search condition> contained in a <check constraint definition> that contains a
              <subquery>.
77) Specifications for Feature F672, “Retrospective check constraints”:
    a) Subclause 11.9, “<check constraint definition>”:
        i)    Without Feature F672, “Retrospective check constraints”, conforming SQL language shall not
              contain a <check constraint definition> that generally contains CURRENT_DATE, CUR-
              RENT_TIMESTAMP, or LOCALTIMESTAMP.
    b) Subclause 11.37, “<assertion definition>”:
        i)    Without Feature F672, “Retrospective check constraints”, conforming SQL language shall not
              contain an <assertion definition> that generally contains CURRENT_DATE, CURRENT_TIMES-
              TAMP, or LOCALTIMESTAMP.
78) Specifications for Feature F690, “Collation support”:
    a) Subclause 5.4, “Names and identifiers”:
        i)    Without Feature F690, “Collation support”, conforming SQL language shall not contain a
              <collation name>.
    b) Subclause 10.7, “<collate clause>”:
        i)    Without Feature F690, “Collation support”, conforming SQL language shall not contain a
              <collate clause>.
    c) Subclause 11.33, “<collation definition>”:
        i)    Without Feature F690, “Collation support”, conforming SQL language shall not contain a
              <collation definition>.
    d) Subclause 11.34, “<drop collation statement>”:
        i)    Without Feature F690, “Collation support”, conforming SQL language shall not contain a <drop
              collation statement>.



1104 Foundation (SQL/Foundation)                                               ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)




79) Specifications for Feature F692, “Extended collation support”:
    a) Subclause 11.4, “<column definition>”:
         i)       Without Feature F692, “Extended collation support”, conforming SQL language shall not contain
                  a <column definition> that immediately contains a <collate clause>.
    b) Subclause 11.24, “<domain definition>”:
         i)       Without Feature F692, “Extended collation support”, conforming SQL language shall not contain
                  a <domain definition> that immediately contains a <collate clause>.
    c) Subclause 11.42, “<attribute definition>”:
         i)       Without Feature F692, “Extended collation support”, conforming SQL language shall not contain
                  an <attribute definition> that immediately contains a <collate clause>.
80) Specifications for Feature F693, “SQL-session and client module collations”:
    a) Subclause 6.4, “<value specification> and <target specification>”:
         i)       Without Feature F693, “SQL-session and client module collations”, conforming SQL language
                  shall not contain <current collation specification>.
    b) Subclause 13.1, “<SQL-client module definition>”:
         i)       Without Feature F693, “SQL-session and client module collations”, conforming SQL language
                  shall not contain a <module collation specification>.
    c) Subclause 18.10, “<set session collation statement>”:
         i)       Without Feature F693, “SQL-session and client module collations”, conforming SQL language
                  shall not contain a <set session collation statement>.
81) Specifications for Feature F695, “Translation support”:
    a) Subclause 5.4, “Names and identifiers”:
         i)       Without Feature F695, “Translation support”, conforming SQL language shall not contain a
                  <transliteration name>.
         ii)      Without Feature F695, “Translation support”, conforming SQL language shall not contain a
                  <transcoding name>.
    b) Subclause 6.29, “<string value function>”:
         i)       Without Feature F695, “Translation support”, conforming SQL language shall not contain a
                  <character transliteration>.
         ii)      Without Feature F695, “Translation support”, conforming SQL language shall not contain a
                  <transcoding>.
    c) Subclause 11.35, “<transliteration definition>”:
         i)       Without Feature F695, “Translation support”, conforming SQL language shall not contain a
                  <transliteration definition>.



©ISO/IEC 2003 – All rights reserved                                         SQL Conformance Summary 1105
ISO/IEC 9075-2:2003 (E)




    d) Subclause 11.36, “<drop transliteration statement>”:
        i)     Without Feature F695, “Translation support”, conforming SQL language shall not contain a
               <drop transliteration statement>.
82) Specifications for Feature F701, “Referential update actions”:
    a) Subclause 11.8, “<referential constraint definition>”:
        i)     Without Feature F701, “Referential update actions”, conforming SQL language shall not contain
               an <update rule>.
83) Specifications for Feature F711, “ALTER domain”:
    a) Subclause 11.25, “<alter domain statement>”:
        i)     Without Feature F711, “ALTER domain”, conforming SQL language shall not contain an <alter
               domain statement>.
    b) Subclause 11.26, “<set domain default clause>”:
        i)     Without Feature F711, “ALTER domain”, conforming SQL language shall not contain a <set
               domain default clause>.
    c) Subclause 11.27, “<drop domain default clause>”:
        i)     Without Feature F711, “ALTER domain”, conforming SQL language shall not contain a <drop
               domain default clause>.
    d) Subclause 11.28, “<add domain constraint definition>”:
        i)     Without Feature F711, “ALTER domain”, conforming SQL language shall not contain an <add
               domain constraint definition>.
    e) Subclause 11.29, “<drop domain constraint definition>”:
        i)     Without Feature F711, “ALTER domain”, conforming SQL language shall not contain a <drop
               domain constraint definition>.
84) Specifications for Feature F721, “Deferrable constraints”:
    a) Subclause 10.8, “<constraint name definition> and <constraint characteristics>”:
        i)     Without Feature F721, “Deferrable constraints”, conforming SQL language shall not contain a
               <constraint characteristics>.
               NOTE 467 — This means that INITIALLY IMMEDIATE NOT DEFERRABLE is implicit.

    b) Subclause 16.3, “<set constraints mode statement>”:
        i)     Without Feature F721, “Deferrable constraints”, conforming SQL language shall not contain a
               <set constraints mode statement>.
85) Specifications for Feature F731, “INSERT column privileges”:
    a) Subclause 12.3, “<privileges>”:




1106 Foundation (SQL/Foundation)                                               ©ISO/IEC 2003 – All rights reserved
                                                                                                 ISO/IEC 9075-2:2003 (E)




         i)       Without Feature F731, “INSERT column privileges”, in conforming SQL language, an <action>
                  that contains INSERT shall not contain a <privilege column list>.
86) Specifications for Feature F741, “Referential MATCH types”:
    a) Subclause 8.12, “<match predicate>”:
         i)       Without Feature F741, “Referential MATCH types”, conforming SQL language shall not contain
                  a <match predicate>.
                  NOTE 468 — The Conformance Rules of Subclause 9.9, “Equality operations”, also apply.

    b) Subclause 11.8, “<referential constraint definition>”:
         i)       Without Feature F741, “Referential MATCH types”, conforming SQL language shall not contain
                  a <references specification> that contains MATCH.
87) Specifications for Feature F751, “View CHECK enhancements”:
    a) Subclause 11.22, “<view definition>”:
         i)       Without Feature F751, “View CHECK enhancements”, conforming SQL language shall not
                  contain a <levels clause>.
         ii)      Without Feature F751, “View CHECK enhancements”, conforming SQL language shall not
                  contain <view definition> that contains a <subquery> and contains CHECK OPTION.
88) Specifications for Feature F761, “Session management”:
    a) Subclause 18.1, “<set session characteristics statement>”:
         i)       Without Feature F761, “Session management”, conforming SQL language shall not contain a
                  <set session characteristics statement>.
    b) Subclause 18.5, “<set catalog statement>”:
         i)       Without Feature F761, “Session management”, conforming SQL language shall not contain a
                  <set catalog statement>.
    c) Subclause 18.6, “<set schema statement>”:
         i)       Without Feature F761, “Session management”, conforming SQL language shall not contain a
                  <set schema statement>.
    d) Subclause 18.7, “<set names statement>”:
         i)       Without Feature F761, “Session management”, conforming SQL language shall not contain a
                  <set names statement>.
89) Specifications for Feature F771, “Connection management”:
    a) Subclause 5.4, “Names and identifiers”:
         i)       Without Feature F771, “Connection management”, conforming SQL language shall not contain
                  an explicit <connection name>.
    b) Subclause 17.1, “<connect statement>”:



©ISO/IEC 2003 – All rights reserved                                                  SQL Conformance Summary 1107
ISO/IEC 9075-2:2003 (E)




        i)     Without Feature F771, “Connection management”, conforming SQL language shall not contain
               a <connect statement>.
    c) Subclause 17.2, “<set connection statement>”:
        i)     Without Feature F771, “Connection management”, conforming SQL language shall not contain
               a <set connection statement>.
    d) Subclause 17.3, “<disconnect statement>”:
        i)     Without Feature F771, “Connection management”, conforming SQL language shall not contain
               a <disconnect statement>.
90) Specifications for Feature F781, “Self-referencing operations”:
    a) Subclause 14.7, “<delete statement: searched>”:
        i)     Without Feature F781, “Self-referencing operations”, conforming SQL language shall not contain
               a <delete statement: searched> in which a leaf generally underlying table of T is an underlying
               table of any <query expression> generally contained in the <search condition>.
    b) Subclause 14.8, “<insert statement>”:
        i)     Without Feature F781, “Self-referencing operations”, conforming SQL language shall not contain
               an <insert statement> in which the <table name> of a leaf generally underlying table of T is
               generally contained in the <from subquery> except as the table name of a qualifying table of a
               column reference.
    c) Subclause 14.9, “<merge statement>”:
        i)     Without Feature F781, “Self-referencing operations”, conforming SQL language shall not contain
               a <merge statement> in which a leaf generally underlying table of T is generally contained in a
               <query expression> immediately contained in the <table reference> except as the <table or query
               name> or <correlation name> of a column reference.
        ii)    Without Feature F781, “Self-referencing operations”, conforming SQL language shall not contain
               a <merge statement> in which a leaf generally underlying table of T is an underlying table of
               any <query expression> generally contained in the <search condition>.
    d) Subclause 14.11, “<update statement: searched>”:
        i)     Without Feature F781, “Self-referencing operations”, conforming SQL language shall not contain
               an <update statement: positioned> in which a leaf generally underlying table of T is an underlying
               table of any <query expression> generally contained in the <search condition>.
    e) Subclause 14.12, “<set clause list>”:
        i)     Without Feature F781, “Self-referencing operations”, conforming SQL language shall not contain
               a <set clause> in which a leaf generally underlying table of T is an underlying table of any
               <query expression> generally contained in any <value expression> simply contained in an
               <update source> or <assigned row> immediately contained in the <set clause>.
91) Specifications for Feature F791, “Insensitive cursors”:
    a) Subclause 14.1, “<declare cursor>”:



1108 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)




         i)       Without Feature F791, “Insensitive cursors”, conforming SQL language shall not contain a
                  <cursor sensitivity> that immediately contains INSENSITIVE.
         ii)      Without Feature F791, “Insensitive cursors”, or Feature T231, “Sensitive cursors”, conforming
                  SQL language shall not contain a <cursor sensitivity> that immediately contains ASENSITIVE.
92) Specifications for Feature F801, “Full set function”:
    a) Subclause 7.12, “<query specification>”:
         i)       Without Feature F801, “Full set function”, conforming SQL language shall not contain a <query
                  specification> that contains more than 1 (one) <set quantifier> that contains DISTINCT,
                  excluding any <subquery> of that <query specification>.
93) Specifications for Feature F821, “Local table references”:
    a) Subclause 5.4, “Names and identifiers”:
         i)       Without Feature F821, “Local table references”, conforming SQL language shall not contain a
                  <local or schema qualifier> that contains a <local qualifier>.
    b) Subclause 6.7, “<column reference>”:
         i)       Without Feature F821, “Local table references”, conforming SQL language shall not contain a
                  <column reference> that simply contains MODULE.
94) Specifications for Feature F831, “Full cursor update”:
    a) Subclause 14.1, “<declare cursor>”:
         i)       Without Feature F831, “Full cursor update”, conforming SQL language shall not contain an
                  <updatability clause> that contains FOR UPDATE and that contains a <cursor scrollability>.
         ii)      Without Feature F831, “Full cursor update”, conforming SQL language shall not contain an
                  <updatability clause> that specifies FOR UPDATE and that contains an <order by clause>.
    b) Subclause 14.10, “<update statement: positioned>”:
         i)       Without Feature F831, “Full cursor update”, conforming SQL language shall not contain an
                  <update statement: positioned> in which CR identifies an ordered cursor.
95) Specifications for Feature S023, “Basic structured types”:
    a) Subclause 5.4, “Names and identifiers”:
         i)       Without Feature S023, “Basic structured types”, conforming SQL language shall not contain a
                  <attribute name>.
    b) Subclause 6.1, “<data type>”:
         i)       Without Feature S023, “Basic structured types”, conforming SQL language shall not contain a
                  <path-resolved user-defined type name> that identifies a structured type.
    c) Subclause 6.16, “<method invocation>”:
         i)       Without Feature S023, “Basic structured types”, conforming SQL language shall not contain a
                  <method invocation>.


©ISO/IEC 2003 – All rights reserved                                         SQL Conformance Summary 1109
ISO/IEC 9075-2:2003 (E)




    d) Subclause 6.18, “<new specification>”:
         i)    Without Feature S023, “Basic structured types”, conforming SQL language shall not contain a
               <new specification>.
    e) Subclause 10.4, “<routine invocation>”:
         i)    Without Feature S023, “Basic structured types”, conforming SQL language shall not contain a
               <generalized expression>.
    f) Subclause 11.41, “<user-defined type definition>”:
         i)    Without Feature S023, “Basic structured types”, conforming SQL language shall not contain a
               <member list>.
         ii)   Without Feature S023, “Basic structured types”, conforming SQL language shall not contain a
               <method specification list>.
    g) Subclause 11.42, “<attribute definition>”:
         i)    Without Feature S023, “Basic structured types”, conforming SQL language shall not contain an
               <attribute definition>.
    h) Subclause 11.50, “<SQL-invoked routine>”:
         i)    Without Feature S023, “Basic structured types”, conforming SQL language shall not contain a
               <method specification designator>.
    i)   Subclause 12.3, “<privileges>”:
         i)    Without Feature S023, “Basic structured types”, conforming SQL language shall not contain a
               <privileges> that contains an <action> that contains UNDER and that contains an <object name>
               that contains a <schema-resolved user-defined type name> that identifies a structured type.
96) Specifications for Feature S024, “Enhanced structured types”:
    a) Subclause 6.17, “<static method invocation>”:
         i)    Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain
               a <static method invocation>.
    b) Subclause 9.9, “Equality operations”:
         i)    Without Feature S024, “Enhanced structured types”, in conforming SQL language, the declared
               type of an operand of an equality operation shall not be ST-ordered.
    c) Subclause 9.10, “Grouping operations”:
         i)    Without Feature S024, “Enhanced structured types”, in conforming SQL language, the declared
               type of an operand of a grouping operation shall not be ST-ordered.
    d) Subclause 9.11, “Multiset element grouping operations”:
         i)    Without Feature S024, “Enhanced structured types”, in conforming SQL language, the declared
               element type of a multiset operand of a multiset element grouping operation shall not be ST-
               ordered.



1110 Foundation (SQL/Foundation)                                               ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)




    e) Subclause 9.12, “Ordering operations”:
         i)       Without Feature S024, “Enhanced structured types”, in conforming SQL language, the declared
                  type of an operand of an ordering operation shall not be ST-ordered.
    f) Subclause 10.6, “<specific routine designator>”:
         i)       Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain
                  a <specific routine designator> that contains a <routine type> that immediately contains
                  METHOD.
    g) Subclause 11.41, “<user-defined type definition>”:
         i)       Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain
                  an <instantiable clause> that contains NOT INSTANTIABLE.
         ii)      Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain
                  an <original method specification> that immediately contains SELF AS RESULT.
         iii)     Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain
                  a <method characteristics> that contains a <parameter style> that contains GENERAL.
         iv)      Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain
                  an <original method specification> that contains an <SQL-data access indication> that immedi-
                  ately contains NO SQL.
         v)       Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain
                  a <partial method specification> that contains INSTANCE or STATIC.
    h) Subclause 11.42, “<attribute definition>”:
         i)       Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain
                  an <attribute default>.
    i)   Subclause 11.43, “<alter type statement>”:
         i)       Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain
                  an <alter type statement>.
    j)   Subclause 11.50, “<SQL-invoked routine>”:
         i)       Without Feature S024, “Enhanced structured types”, an <SQL parameter declaration> shall not
                  contain RESULT.
    k) Subclause 11.52, “<drop routine statement>”:
         i)       Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain
                  a <drop routine statement> that contains a <specific routine designator> that identifies a method.
    l)   Subclause 12.2, “<grant privilege statement>”:
         i)       Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain
                  a <specific routine designator> contained in a <grant privilege statement> that identifies a
                  method.
    m) Subclause 12.3, “<privileges>”:



©ISO/IEC 2003 – All rights reserved                                            SQL Conformance Summary 1111
ISO/IEC 9075-2:2003 (E)




        i)     Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain
               a <privileges> that contains an <action> that contains USAGE and that contains an <object
               name> that contains a <schema-resolved user-defined type name> that identifies a structured
               type.
        ii)    Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain
               a <privilege method list>.
    n) Subclause 14.8, “<insert statement>”:
        i)     Without Feature S024, “Enhanced structured types”, in conforming SQL language, for each
               column C identified in the explicit or implicit <insert column list>, if the declared type of C is
               a structured type TY, then the declared type of the corresponding column of the <query expres-
               sion> or <contextually typed table value constructor> shall be TY.
    o) Subclause 14.9, “<merge statement>”:
        i)     Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain
               a <merge statement> that does not satisfy the condition: for each column C identified in the
               explicit or implicit <insert column list>, if the declared type of C is a structured type TY, then
               the declared type of the corresponding column of the <query expression> or <contextually typed
               table value constructor> is TY.
    p) Subclause 14.12, “<set clause list>”:
        i)     Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain
               a <set clause> in which the declared type of the <update target> in the <set clause> is a structured
               type TY and the declared type of the <update source> or corresponding field of the <assigned
               row> contained in the <set clause> is not TY.
        ii)    Without Feature S024, “Enhanced structured types”, conforming SQL language shall not contain
               a <set clause> that contains a <mutated set clause> and in which the declared type of the last
               <method name> identifies a structured type TY, and the declared type of the <update source>
               contained in the <set clause> is not TY.
97) Specifications for Feature S025, “Final structured types”:
    a) Subclause 11.41, “<user-defined type definition>”:
        i)     Without Feature S025, “Final structured types”, in conforming SQL language, a <user-defined
               type definition> that defines a structured type shall contain a <finality> that is NOT FINAL.
98) Specifications for Feature S026, “Self-referencing structured types”:
    a) Subclause 11.42, “<attribute definition>”:
        i)     Without Feature S026, “Self-referencing structured types”, conforming SQL language shall not
               contain a <data type> simply contained in an <attribute definition> that is not be a <reference
               type> whose <referenced type> is equivalent to the <schema-resolved user-defined type name>
               simply contained in the <user-defined type definition> that contains <attribute definition>.
99) Specifications for Feature S027, “Create method by specific method name”:
    a) Subclause 11.50, “<SQL-invoked routine>”:



1112 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                               ISO/IEC 9075-2:2003 (E)




         i)       Without Feature S027, “Create method by specific method name”, conforming SQL language
                  shall not contain a <method specification designator> that contains SPECIFIC METHOD.
100) Specifications for Feature S028, “Permutable UDT options list”:
    a) Subclause 11.41, “<user-defined type definition>”:
         i)       Without Feature S028, “Permutable UDT options list”, conforming SQL language shall not
                  contain a <user-defined type option list> in which <instantiable clause>, if specified, <finality>,
                  <reference type specification>, if specified, <cast to ref>, if specified, <cast to type>, if specified,
                  <cast to distinct>, if specified, and <cast to source>, if specified, do not appear in that sequence.
101) Specifications for Feature S041, “Basic reference types”:
    a) Subclause 6.1, “<data type>”:
         i)       Without Feature S041, “Basic reference types”, conforming SQL language shall not contain a
                  <reference type>.
    b) Subclause 6.19, “<attribute or method reference>”:
         i)       Without Feature S041, “Basic reference types”, conforming SQL language shall not contain an
                  <attribute or method reference>.
    c) Subclause 6.20, “<dereference operation>”:
         i)       Without Feature S041, “Basic reference types”, conforming SQL language shall not contain a
                  <dereference operation>.
    d) Subclause 6.25, “<value expression>”:
         i)       Without Feature S041, “Basic reference types”, conforming SQL language shall not contain a
                  <reference value expression>.
    e) Subclause 20.3, “<embedded SQL Ada program>”:
         i)       Without Feature S041, “Basic reference types”, conforming SQL language shall not contain an
                  <Ada REF variable>.
    f) Subclause 20.4, “<embedded SQL C program>”:
         i)       Without Feature S041, “Basic reference types”, conforming SQL language shall not contain a
                  <C REF variable>.
    g) Subclause 20.5, “<embedded SQL COBOL program>”:
         i)       Without Feature S041, “Basic reference types”, conforming SQL language shall not contain a
                  <COBOL REF variable>.
    h) Subclause 20.6, “<embedded SQL Fortran program>”:
         i)       Without Feature S041, “Basic reference types”, conforming SQL language shall not contain a
                  <Fortran REF variable>.
    i)   Subclause 20.7, “<embedded SQL MUMPS program>”:




©ISO/IEC 2003 – All rights reserved                                                SQL Conformance Summary 1113
ISO/IEC 9075-2:2003 (E)




         i)    Without Feature S041, “Basic reference types”, conforming SQL language shall not contain a
               <MUMPS REF variable>.
    j)   Subclause 20.8, “<embedded SQL Pascal program>”:
         i)    Without Feature S041, “Basic reference types”, conforming SQL language shall not contain a
               <Pascal REF variable>.
    k) Subclause 20.9, “<embedded SQL PL/I program>”:
         i)    Without Feature S041, “Basic reference types”, conforming SQL language shall not contain a
               <PL/I REF variable>.
102) Specifications for Feature S043, “Enhanced reference types”:
    a) Subclause 6.1, “<data type>”:
         i)    Without Feature S043, “Enhanced reference types”, conforming SQL language shall not contain
               a <scope clause> that is not simply contained in a <data type> that is simply contained in a
               <column definition>.
    b) Subclause 6.12, “<cast specification>”:
         i)    Without Feature S043, “Enhanced reference types”, in conforming SQL language, if the declared
               data type of <cast operand> is a reference type, then <cast target> shall contain a <data type>
               that is a reference type.
    c) Subclause 6.21, “<method reference>”:
         i)    Without Feature S043, “Enhanced reference types”, conforming SQL language shall not contain
               a <method reference>.
    d) Subclause 6.22, “<reference resolution>”:
         i)    Without Feature S043, “Enhanced reference types”, conforming SQL language shall not contain
               a <reference resolution>.
    e) Subclause 11.3, “<table definition>”:
         i)    Without Feature S043, “Enhanced reference types”, conforming SQL language shall not contain
               a <column option list> that contains a <scope clause>.
         ii)   Without Feature S043, “Enhanced reference types”, conforming SQL language shall not contain
               <reference generation> that does not contain SYSTEM GENERATED.
    f) Subclause 11.15, “<add column scope clause>”:
         i)    Without Feature S043, “Enhanced reference types”, conforming SQL language shall not contain
               an <add column scope clause>.
    g) Subclause 11.16, “<drop column scope clause>”:
         i)    Without Feature S043, “Enhanced reference types”, conforming SQL language shall not contain
               a <drop column scope clause>.
    h) Subclause 11.22, “<view definition>”:



1114 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)




         i)       Without Feature S043, “Enhanced reference types”, conforming SQL language shall not contain
                  a <referenceable view specification>.
    i)   Subclause 11.41, “<user-defined type definition>”:
         i)       Without Feature S043, “Enhanced reference types”, conforming SQL language shall not contain
                  a <reference type specification>.
    j)   Subclause 14.8, “<insert statement>”:
         i)       Without Feature S043, “Enhanced reference types”, conforming SQL language shall not contain
                  an <override clause>.
103) Specifications for Feature S051, “Create table of type”:
    a) Subclause 11.3, “<table definition>”:
         i)       Without Feature S051, “Create table of type”, conforming SQL language shall not contain “OF
                  <path-resolved user-defined type name>”.
104) Specifications for Feature S071, “SQL paths in function and type name resolution”:
    a) Subclause 6.4, “<value specification> and <target specification>”:
         i)       Without Feature S071, “SQL paths in function and type name resolution”, conforming SQL
                  language shall not contain a <general value specification> that contains CURRENT_PATH.
    b) Subclause 10.3, “<path specification>”:
         i)       Without Feature S071, “SQL paths in function and type name resolution”, conforming SQL
                  language shall not contain a <path specification>.
    c) Subclause 11.1, “<schema definition>”:
         i)       Without Feature S071, “SQL paths in function and type name resolution”, conforming SQL
                  language shall not contain a <schema path specification>.
    d) Subclause 11.5, “<default clause>”:
         i)       Without Feature S071, “SQL paths in function and type name resolution”, conforming SQL
                  language shall not contain a <default option> that contains CURRENT_PATH.
    e) Subclause 13.1, “<SQL-client module definition>”:
         i)       Without Feature S071, “SQL paths in function and type name resolution”, conforming SQL
                  language shall not contain a <module path specification>.
    f) Subclause 18.8, “<set path statement>”:
         i)       Without Feature S071, “SQL paths in function and type name resolution”, Conforming SQL
                  language shall not contain a <set path statement>.
    g) Subclause 20.1, “<embedded SQL host program>”:
         i)       Without Feature S071, “SQL paths in function and type name resolution”, conforming SQL
                  language shall not contain an <embedded path specification>.



©ISO/IEC 2003 – All rights reserved                                         SQL Conformance Summary 1115
ISO/IEC 9075-2:2003 (E)




105) Specifications for Feature S081, “Subtables”:
    a) Subclause 11.3, “<table definition>”:
        i)     Without Feature S081, “Subtables”, conforming SQL language shall not contain a <subtable
               clause>.
    b) Subclause 12.2, “<grant privilege statement>”:
        i)     Without Feature S081, “Subtables”, conforming SQL language shall not contain a <grant privilege
               statement> that contains WITH HIERARCHY OPTION.
    c) Subclause 12.3, “<privileges>”:
        i)     Without Feature S081, “Subtables”, conforming SQL language shall not contain a <privileges>
               that contains an <action> that contains UNDER and that contains an <object name> that contains
               a <table name>.
    d) Subclause 12.7, “<revoke statement>”:
        i)     Without Feature S081, “Subtables”, conforming SQL language shall not contain a <revoke
               option extension> that contains HIERARCHY OPTION FOR.
106) Specifications for Feature S091, “Basic array support”:
    a) Subclause 6.1, “<data type>”:
        i)     Without Feature S091, “Basic array support”, conforming SQL language shall not contain an
               <array type>.
    b) Subclause 6.5, “<contextually typed value specification>”:
        i)     Without Feature S091, “Basic array support”, conforming SQL language shall not contain an
               <empty specification> that simply contains ARRAY.
    c) Subclause 6.23, “<array element reference>”:
        i)     Without Feature S091, “Basic array support”, conforming SQL language shall not contain an
               <array element reference>.
    d) Subclause 6.27, “<numeric value function>”:
        i)     Without Feature S091, “Basic array support”, or Feature S271, “Basic multiset support”, con-
               forming SQL language shall not contain a <cardinality expression>.
    e) Subclause 6.35, “<array value expression>”:
        i)     Without Feature S091, “Basic array support”, conforming SQL language shall not contain an
               <array value expression>.
    f) Subclause 6.36, “<array value constructor>”:
        i)     Without Feature S091, “Basic array support”, conforming SQL language shall not contain an
               <array value constructor by enumeration>.
    g) Subclause 7.6, “<table reference>”:



1116 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)




         i)       Without Feature S091, “Basic array support”, or Feature S271, “Basic multiset support”, con-
                  forming SQL language shall not contain a <collection derived table>.
    h) Subclause 14.12, “<set clause list>”:
         i)       Without Feature S091, “Basic array support”, conforming SQL language shall not contain an
                  <update target> that immediately contains a <simple value specification>.
107) Specifications for Feature S092, “Arrays of user-defined types”:
    a) Subclause 6.1, “<data type>”:
         i)       Without Feature S092, “Arrays of user-defined types”, conforming SQL language shall not
                  contain an <array type> that is based on a <data type> that contains a <path-resolved user-defined
                  type name>.
108) Specifications for Feature S094, “Arrays of reference types”:
    a) Subclause 6.1, “<data type>”:
         i)       Without Feature S094, “Arrays of reference types”, conforming SQL language shall not contain
                  an <array type> that is based on a <data type> that contains a <reference type>.
109) Specifications for Feature S095, “Array constructors by query”:
    a) Subclause 6.36, “<array value constructor>”:
         i)       Without Feature S095, “Array constructors by query”, conforming SQL language shall not
                  contain an <array value constructor by query>.
110) Specifications for Feature S096, “Optional array bounds”:
    a) Subclause 6.1, “<data type>”:
         i)       Without Feature S096, “Optional array bounds”, conforming SQL language shall not contain
                  an <array type> that does not immediately contain <maximum cardinality>.
111) Specifications for Feature S097, “Array element assignment”:
    a) Subclause 6.4, “<value specification> and <target specification>”:
         i)       Without Feature S097, “Array element assignment”, conforming SQL language shall not contain
                  a <target array element specification>.
112) Specifications for Feature S111, “ONLY in query expressions”:
    a) Subclause 7.6, “<table reference>”:
         i)       Without Feature S111, “ONLY in query expressions”, conforming SQL language shall not
                  contain a <table reference> that contains an <only spec>.
    b) Subclause 14.6, “<delete statement: positioned>”:
         i)       Without Feature S111, “ONLY in query expressions”, conforming SQL language shall not
                  contain a <target table> that contains ONLY.
113) Specifications for Feature S151, “Type predicate”:



©ISO/IEC 2003 – All rights reserved                                            SQL Conformance Summary 1117
ISO/IEC 9075-2:2003 (E)




    a) Subclause 8.18, “<type predicate>”:
        i)     Without Feature S151, “Type predicate”, conforming SQL language shall not contain a <type
               predicate>.
114) Specifications for Feature S161, “Subtype treatment”:
    a) Subclause 6.15, “<subtype treatment>”:
        i)     Without Feature S161, “Subtype treatment”, conforming SQL Language shall not contain a
               <subtype treatment>.
115) Specifications for Feature S162, “Subtype treatment for references”:
    a) Subclause 6.15, “<subtype treatment>”:
        i)     Without Feature S162, “Subtype treatment for references”, conforming SQL language shall not
               contain a <target subtype> that contains a <reference type>.
116) Specifications for Feature S201, “SQL-invoked routines on arrays”:
    a) Subclause 10.4, “<routine invocation>”:
        i)     Without Feature S201, “SQL-invoked routines on arrays”, conforming SQL language shall not
               contain an <SQL argument> whose declared type is an array type.
    b) Subclause 11.50, “<SQL-invoked routine>”:
        i)     Without Feature S201, “SQL-invoked routines on arrays”, conforming SQL language shall not
               contain a <parameter type> that is based on an array type.
        ii)    Without Feature S201, “SQL-invoked routines on arrays”, conforming SQL language shall not
               contain a <returns data type> that is based on an array type.
117) Specifications for Feature S202, “SQL-invoked routines on multisets”:
    a) Subclause 10.4, “<routine invocation>”:
        i)     Without Feature S202, “SQL-invoked routines on multisets”, conforming SQL language shall
               not contain an <SQL argument> whose declared type is a multiset type.
    b) Subclause 11.50, “<SQL-invoked routine>”:
        i)     Without Feature S202, “SQL-invoked routines on multisets”, conforming SQL language shall
               not contain a <parameter type> that is based on a multiset type.
        ii)    Without Feature S202, “SQL-invoked routines on multisets”, conforming SQL language shall
               not contain a <returns data type> that is based on a multiset type.
118) Specifications for Feature S211, “User-defined cast functions”:
    a) Subclause 11.53, “<user-defined cast definition>”:
        i)     Without Feature S211, “User-defined cast functions”, conforming SQL language shall not contain
               a <user-defined cast definition>.
    b) Subclause 11.54, “<drop user-defined cast statement>”:



1118 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)




         i)       Without Feature S211, “User-defined cast functions”, conforming SQL language shall not contain
                  a <drop user-defined cast statement>.
119) Specifications for Feature S231, “Structured type locators”:
    a) Subclause 11.50, “<SQL-invoked routine>”:
         i)       Without Feature S231, “Structured type locators”, conforming SQL language shall not contain
                  a <parameter type> that contains a <locator indication> and that simply contains a <data type>
                  that identifies a structured type.
         ii)      Without Feature S231, “Structured type locators”, conforming SQL language shall not contain
                  a <returns data type> that contains a <locator indication> and that simply contains a <data type>
                  that identifies a structured type.
    b) Subclause 13.3, “<externally-invoked procedure>”:
         i)       Without Feature S231, “Structured type locators”, conforming SQL language shall not contain
                  a <host parameter data type> that simply contains a <data type> that specifies a structured type
                  and that contains a <locator indication>.
    c) Subclause 20.3, “<embedded SQL Ada program>”:
         i)       Without Feature S231, “Structured type locators”, conforming SQL language shall not contain
                  a <path-resolved user-defined type name> simply contained in an <Ada user-defined type
                  locator variable> that identifies a structured type.
    d) Subclause 20.4, “<embedded SQL C program>”:
         i)       Without Feature S231, “Structured type locators”, conforming SQL language shall not contain
                  a <path-resolved user-defined type name> simply contained in a <C user-defined type locator
                  variable> that identifies a structured type.
    e) Subclause 20.5, “<embedded SQL COBOL program>”:
         i)       Without Feature S231, “Structured type locators”, conforming SQL language shall not contain
                  a <path-resolved user-defined type name> simply contained in a <COBOL user-defined type
                  locator variable> that identifies a structured type.
    f) Subclause 20.6, “<embedded SQL Fortran program>”:
         i)       Without Feature S231, “Structured type locators”, conforming SQL language shall not contain
                  a <path-resolved user-defined type name> simply contained in a <Fortran user-defined type
                  locator variable> that identifies a structured type.
    g) Subclause 20.7, “<embedded SQL MUMPS program>”:
         i)       Without Feature S231, “Structured type locators”, conforming SQL language shall not contain
                  a <path-resolved user-defined type name> simply contained in a <MUMPS user-defined type
                  locator variable> that identifies a structured type.
    h) Subclause 20.8, “<embedded SQL Pascal program>”:
         i)       Without Feature S231, “Structured type locators”, conforming SQL language shall not contain
                  a <path-resolved user-defined type name> simply contained in a <Pascal user-defined type
                  locator variable> that identifies a structured type.


©ISO/IEC 2003 – All rights reserved                                            SQL Conformance Summary 1119
ISO/IEC 9075-2:2003 (E)




    i)   Subclause 20.9, “<embedded SQL PL/I program>”:
         i)    Without Feature S231, “Structured type locators”, conforming SQL language shall not contain
               a <path-resolved user-defined type name> simply contained in a <PL/I user-defined type locator
               variable> that identifies a structured type.
120) Specifications for Feature S232, “Array locators”:
    a) Subclause 11.50, “<SQL-invoked routine>”:
         i)    Without Feature S232, “Array locators”, conforming SQL language shall not contain a
               <parameter type> that contains a <locator indication> and that simply contains a <data type>
               that identifies an array type.
         ii)   Without Feature S232, “Array locators”, conforming SQL language shall not contain a <returns
               data type> that contains a <locator indication> and that simply contains a <data type> that
               identifies an array type.
    b) Subclause 13.3, “<externally-invoked procedure>”:
         i)    Without Feature S232, “Array locators”, conforming SQL language shall not contain a <host
               parameter data type> that simply contains an <array type> and that contains a <locator indica-
               tion>.
    c) Subclause 20.3, “<embedded SQL Ada program>”:
         i)    Without Feature S232, “Array locators”, conforming SQL language shall not contain an <Ada
               array locator variable>.
    d) Subclause 20.4, “<embedded SQL C program>”:
         i)    Without Feature S232, “Array locators”, conforming SQL language shall not contain an <C
               array locator variable>.
    e) Subclause 20.5, “<embedded SQL COBOL program>”:
         i)    Without Feature S232, “Array locators”, conforming SQL language shall not contain a <COBOL
               array locator variable>.
    f) Subclause 20.6, “<embedded SQL Fortran program>”:
         i)    Without Feature S232, “Array locators”, conforming SQL language shall not contain a <Fortran
               array locator variable>.
    g) Subclause 20.7, “<embedded SQL MUMPS program>”:
         i)    Without Feature S232, “Array locators”, conforming SQL language shall not contain a <MUMPS
               array locator variable>.
    h) Subclause 20.8, “<embedded SQL Pascal program>”:
         i)    Without Feature S232, “Array locators”, conforming SQL language shall not contain a <Pascal
               array locator variable>.
    i)   Subclause 20.9, “<embedded SQL PL/I program>”:




1120 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)




         i)       Without Feature S232, “Array locators”, conforming SQL language shall not contain a <PL/I
                  array locator variable>.
121) Specifications for Feature S233, “Multiset locators”:
    a) Subclause 11.50, “<SQL-invoked routine>”:
         i)       Without Feature S233, “Multiset locators”, conforming SQL language shall not contain a
                  <parameter type> that contains a <locator indication> and that simply contains a <data type>
                  that identifies a multiset type.
         ii)      Without Feature S233, “Multiset locators”, conforming SQL language shall not contain a <returns
                  data type> that contains a <locator indication> and that simply contains a <data type> that
                  identifies a multiset type.
    b) Subclause 13.3, “<externally-invoked procedure>”:
         i)       Without Feature S233, “Multiset locators”, conforming SQL language shall not contain a <host
                  parameter data type> that simply contains a <multiset type> and that contains a <locator indica-
                  tion>.
    c) Subclause 20.3, “<embedded SQL Ada program>”:
         i)       Without Feature S233, “Multiset locators”, conforming SQL language shall not contain an <Ada
                  multiset locator variable>.
    d) Subclause 20.4, “<embedded SQL C program>”:
         i)       Without Feature S233, “Multiset locators”, conforming SQL language shall not contain a <C
                  multiset locator variable>.
    e) Subclause 20.5, “<embedded SQL COBOL program>”:
         i)       Without Feature S233, “Multiset locators”, conforming SQL language shall not contain a
                  <COBOL multiset locator variable>.
    f) Subclause 20.6, “<embedded SQL Fortran program>”:
         i)       Without Feature S233, “Multiset locators”, conforming SQL language shall not contain a
                  <Fortran multiset locator variable>.
    g) Subclause 20.7, “<embedded SQL MUMPS program>”:
         i)       Without Feature S233, “Multiset locators”, conforming SQL language shall not contain a
                  <MUMPS multiset locator variable>.
    h) Subclause 20.8, “<embedded SQL Pascal program>”:
         i)       Without Feature S233, “Multiset locators”, conforming SQL language shall not contain a
                  <Pascal multiset locator variable>.
    i)   Subclause 20.9, “<embedded SQL PL/I program>”:
         i)       Without Feature S233, “Multiset locators”, conforming SQL language shall not contain a <PL/I
                  multiset locator variable>.
122) Specifications for Feature S241, “Transform functions”:


©ISO/IEC 2003 – All rights reserved                                           SQL Conformance Summary 1121
ISO/IEC 9075-2:2003 (E)




   a) Subclause 6.4, “<value specification> and <target specification>”:
        i)    Without Feature S241, “Transform functions”, conforming SQL language shall not contain
              CURRENT_DEFAULT_TRANSFORM_GROUP.
        ii)   Without Feature S241, “Transform functions”, conforming SQL language shall not contain
              CURRENT_TRANSFORM_GROUP_FOR_TYPE.
   b) Subclause 11.50, “<SQL-invoked routine>”:
        i)    Without Feature S241, “Transform functions”, conforming SQL language shall not contain a
              <transform group specification>.
   c) Subclause 11.57, “<transform definition>”:
        i)    Without Feature S241, “Transform functions”, conforming SQL language shall not contain a
              <transform definition>.
   d) Subclause 11.61, “<drop transform statement>”:
        i)    Without Feature S241, “Transform functions”, conforming SQL language shall not contain a
              <drop transform statement>.
   e) Subclause 13.1, “<SQL-client module definition>”:
        i)    Without Feature S241, “Transform functions”, conforming SQL language shall not contain a
              <module transform group specification>.
   f) Subclause 18.9, “<set transform group statement>”:
        i)    Without Feature S241, “Transform functions”, conforming SQL language shall not contain a
              <set transform group statement>.
   g) Subclause 20.1, “<embedded SQL host program>”:
        i)    Without Feature S241, “Transform functions”, conforming SQL language shall not contain a
              <embedded transform group specification>.
   h) Subclause 20.3, “<embedded SQL Ada program>”:
        i)    Without Feature S241, “Transform functions”, conforming SQL language shall not contain an
              <Ada user-defined type variable>.
   i)   Subclause 20.4, “<embedded SQL C program>”:
        i)    Without Feature S241, “Transform functions”, conforming SQL language shall not contain a
              <C user-defined type variable>.
   j)   Subclause 20.5, “<embedded SQL COBOL program>”:
        i)    Without Feature S241, “Transform functions”, conforming SQL language shall not contain a
              <COBOL user-defined type variable>.
   k) Subclause 20.6, “<embedded SQL Fortran program>”:
        i)    Without Feature S241, “Transform functions”, conforming SQL language shall not contain a
              <Fortran user-defined type variable>.


1122 Foundation (SQL/Foundation)                                           ©ISO/IEC 2003 – All rights reserved
                                                                                                   ISO/IEC 9075-2:2003 (E)




    l)   Subclause 20.7, “<embedded SQL MUMPS program>”:
         i)       Without Feature S241, “Transform functions”, conforming SQL language shall not contain a
                  <MUMPS user-defined type variable>.
    m) Subclause 20.8, “<embedded SQL Pascal program>”:
         i)       Without Feature S241, “Transform functions”, conforming SQL language shall not contain a
                  <Pascal user-defined type variable>.
    n) Subclause 20.9, “<embedded SQL PL/I program>”:
         i)       Without Feature S241, “Transform functions”, conforming SQL language shall not contain a
                  <PL/I user-defined type variable>.
123) Specifications for Feature S242, “Alter transform statement”:
    a) Subclause 11.58, “<alter transform statement>”:
         i)       Without Feature S242, “Alter transform statement”, conforming SQL language shall not contain
                  an <alter transform statement>.
124) Specifications for Feature S251, “User-defined orderings”:
    a) Subclause 11.55, “<user-defined ordering definition>”:
         i)       Without Feature S251, “User-defined orderings”, conforming SQL shall not contain a <user-
                  defined ordering definition>.
                  NOTE 469 — If MAP is specified, then the Conformance Rules of Subclause 9.9, “Equality operations”, apply. If
                  ORDER FULL BY MAP is specified, then the Conformance Rules of Subclause 9.12, “Ordering operations”, also
                  apply.

    b) Subclause 11.56, “<drop user-defined ordering statement>”:
         i)       Without Feature S251, “User-defined orderings”, conforming SQL language shall not contain
                  a <drop user-defined ordering statement>.
125) Specifications for Feature S261, “Specific type method”:
    a) Subclause 6.29, “<string value function>”:
         i)       Without Feature S261, “Specific type method”, conforming SQL language shall not contain a
                  <specific type method>.
126) Specifications for Feature S271, “Basic multiset support”:
    a) Subclause 6.1, “<data type>”:
         i)       Without Feature S271, “Basic multiset support”, conforming SQL language shall not contain a
                  <multiset type>.
    b) Subclause 6.5, “<contextually typed value specification>”:
         i)       Without Feature S271, “Basic multiset support”, conforming SQL language shall not contain
                  an <empty specification> that simply contains MULTISET.
    c) Subclause 6.24, “<multiset element reference>”:


©ISO/IEC 2003 – All rights reserved                                                    SQL Conformance Summary 1123
ISO/IEC 9075-2:2003 (E)




         i)    Without Feature S271, “Basic multiset support”, conforming SQL language shall not contain a
               <multiset element reference>.
    d) Subclause 6.27, “<numeric value function>”:
         i)    Without Feature S091, “Basic array support”, or Feature S271, “Basic multiset support”, con-
               forming SQL language shall not contain a <cardinality expression>.
    e) Subclause 6.38, “<multiset value function>”:
         i)    Without Feature S271, “Basic multiset support”, conforming SQL language shall not contain a
               <multiset value function>.
               NOTE 470 — The Conformance Rules of Subclause 9.11, “Multiset element grouping operations”, also apply.

    f) Subclause 6.39, “<multiset value constructor>”:
         i)    Without Feature S271, “Basic multiset support”, conforming SQL language shall not contain a
               <multiset value constructor>.
    g) Subclause 7.6, “<table reference>”:
         i)    Without Feature S091, “Basic array support”, or Feature S271, “Basic multiset support”, con-
               forming SQL language shall not contain a <collection derived table>.
    h) Subclause 8.15, “<member predicate>”:
         i)    Without Feature S271, “Basic multiset support”, conforming SQL language shall not contain a
               <member predicate>.
               NOTE 471 — The Conformance Rules of Subclause 9.9, “Equality operations”, also apply.

    i)   Subclause 8.17, “<set predicate>”:
         i)    Without Feature S271, “Basic multiset support”, conforming SQL language shall not contain a
               <set predicate>.
               NOTE 472 — The Conformance Rules of Subclause 9.11, “Multiset element grouping operations”, also apply.

    j)   Subclause 10.9, “<aggregate function>”:
         i)    Without Feature S271, “Basic multiset support”, conforming SQL language shall not contain a
               <computational operation> that immediately contains COLLECT.
127) Specifications for Feature S272, “Multisets of user-defined types”:
    a) Subclause 6.1, “<data type>”:
         i)    Without Feature S272, “Multisets of user-defined types”, conforming SQL language shall not
               contain a <multiset type> that is based on a <data type> that contains a <path-resolved user-
               defined type name>.
128) Specifications for Feature S274, “Multisets of reference types”:
    a) Subclause 6.1, “<data type>”:
         i)    Without Feature S274, “Multisets of reference types”, conforming SQL language shall not
               contain a <multiset type> that is based on a <data type> that contains a <reference type>.



1124 Foundation (SQL/Foundation)                                                         ©ISO/IEC 2003 – All rights reserved
                                                                                                       ISO/IEC 9075-2:2003 (E)




129) Specifications for Feature S275, “Advanced multiset support”:
    a) Subclause 6.37, “<multiset value expression>”:
         i)       Without Feature S275, “Advanced multiset support”, conforming SQL language shall not contain
                  MULTISET UNION, MULTISET INTERSECTION, or MULTISET EXCEPT.
                  NOTE 473 — If MULTISET UNION DISTINCT, MULTISET INTERSECTION, or MULTISET EXCEPT is
                  specified, then the Conformance Rules of Subclause 9.11, “Multiset element grouping operations”, also apply.

    b) Subclause 8.16, “<submultiset predicate>”:
         i)       Without Feature S275, “Advanced multiset support”, conforming SQL language shall not contain
                  a <submultiset predicate>.
                  NOTE 474 — The Conformance Rules of Subclause 9.11, “Multiset element grouping operations”, also apply.

    c) Subclause 9.9, “Equality operations”:
         i)       Without Feature S275, “Advanced multiset support”, in conforming SQL language, the declared
                  type of an operand of an equality operation shall not be multiset-ordered.
                  NOTE 475 — If the declared type of an operand OP of an equality operation is a multiset type, then OP is a multiset
                  operand of a multiset element grouping operation. The Conformance Rules of Subclause 9.11, “Multiset element
                  grouping operations”, apply.

    d) Subclause 10.9, “<aggregate function>”:
         i)       Without Feature S275, “Advanced multiset support”, conforming SQL language shall not contain
                  a <computational operation> that immediately contains FUSION or INTERSECTION.
                  NOTE 476 — If INTERSECTION is specified, then the Conformance Rules of Subclause 9.11, “Multiset element
                  grouping operations”, also apply.

130) Specifications for Feature S281, “Nested collection types”:
    a) Subclause 6.1, “<data type>”:
         i)       Without Feature S281, “Nested collection types”, conforming SQL language shall not contain
                  a collection type that is based on a <data type> that contains a <collection type>.
131) Specifications for Feature S291, “Unique constraint on entire row”:
    a) Subclause 11.7, “<unique constraint definition>”:
         i)       Without Feature S291, “Unique constraint on entire row”, conforming SQL language shall not
                  contain UNIQUE(VALUE).
132) Specifications for Feature T031, “BOOLEAN data type”:
    a) Subclause 5.3, “<literal>”:
         i)       Without Feature T031, “BOOLEAN data type”, conforming SQL language shall not contain a
                  <boolean literal>.
    b) Subclause 6.1, “<data type>”:
         i)       Without Feature T031, “BOOLEAN data type”, conforming SQL language shall not contain a
                  <boolean type>.



©ISO/IEC 2003 – All rights reserved                                                       SQL Conformance Summary 1125
ISO/IEC 9075-2:2003 (E)




    c) Subclause 6.25, “<value expression>”:
        i)     Without Feature T031, “BOOLEAN data type”, conforming SQL language shall not contain a
               <value expression> that is a <boolean value expression>.
    d) Subclause 6.34, “<boolean value expression>”:
        i)     Without Feature T031, “BOOLEAN data type”, conforming SQL language shall not contain a
               <boolean primary> that simply contains a <nonparenthesized value expression primary>.
    e) Subclause 7.1, “<row value constructor>”:
        i)     Without Feature T031, “BOOLEAN data type”, conforming SQL language shall not contain a
               <row value constructor predicand> that immediately contains a <boolean predicand>.
    f) Subclause 10.9, “<aggregate function>”:
        i)     Without Feature T031, “BOOLEAN data type”, conforming SQL language shall not contain a
               <computational operation> that immediately contains EVERY, ANY, or SOME.
133) Specifications for Feature T041, “Basic LOB data type support”:
    a) Subclause 5.3, “<literal>”:
        i)     Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
               contain a <binary string literal>.
    b) Subclause 6.1, “<data type>”:
        i)     Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
               contain a <binary large object string type>, a <character large object type>, or a <national
               character large object type>.
    c) Subclause 11.50, “<SQL-invoked routine>”:
        i)     Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
               contain a <parameter type> that contains a <locator indication> and that simply contains a <data
               type> that identifies a large object type.
        ii)    Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
               contain a <returns data type> that contains a <locator indication> and that simply contains a
               <data type> that identifies a large object type.
    d) Subclause 20.3, “<embedded SQL Ada program>”:
        i)     Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
               contain an <Ada BLOB variable>.
        ii)    Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
               contain an <Ada CLOB variable>.
        iii)   Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
               contain an <Ada BLOB locator variable>.
        iv)    Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
               contain an <Ada CLOB locator variable>.



1126 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                   ISO/IEC 9075-2:2003 (E)




    e) Subclause 20.4, “<embedded SQL C program>”:
         i)       Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
                  contain a <C BLOB variable>.
         ii)      Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
                  contain a <C CLOB variable>.
         iii)     Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
                  contain a <C BLOB locator variable>.
         iv)      Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
                  contain a <C CLOB locator variable>.
    f) Subclause 20.5, “<embedded SQL COBOL program>”:
         i)       Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
                  contain a <COBOL BLOB variable>.
         ii)      Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
                  contain a <COBOL CLOB variable>.
         iii)     Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
                  contain a <COBOL BLOB locator variable>.
         iv)      Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
                  contain a <COBOL CLOB locator variable>.
    g) Subclause 20.6, “<embedded SQL Fortran program>”:
         i)       Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
                  contain a <Fortran BLOB variable>.
         ii)      Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
                  contain a <Fortran CLOB variable>.
         iii)     Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
                  contain a <Fortran BLOB locator variable>.
         iv)      Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
                  contain a <Fortran CLOB locator variable>.
    h) Subclause 20.7, “<embedded SQL MUMPS program>”:
         i)       Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
                  contain a <MUMPS BLOB variable>.
         ii)      Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
                  contain a <MUMPS CLOB variable>.
         iii)     Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
                  contain a <MUMPS BLOB locator variable>.
         iv)      Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
                  contain a and <MUMPS CLOB locator variable>.



©ISO/IEC 2003 – All rights reserved                                      SQL Conformance Summary 1127
ISO/IEC 9075-2:2003 (E)




   i)   Subclause 20.8, “<embedded SQL Pascal program>”:
        i)     Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
               contain a <Pascal BLOB variable>.
        ii)    Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
               contain a <Pascal CLOB variable>.
        iii)   Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
               contain a <Pascal BLOB locator variable>.
        iv)    Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
               contain a <Pascal BLOB variable>, <Pascal CLOB variable>, <Pascal CLOB locator variable>.
   j)   Subclause 20.9, “<embedded SQL PL/I program>”:
        i)     Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
               contain a <PL/I BLOB variable>.
        ii)    Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
               contain a <PL/I CLOB variable>.
        iii)   Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
               contain a <PL/I BLOB locator variable>.
        iv)    Without Feature T041, “Basic LOB data type support”, conforming SQL language shall not
               contain a <PL/I CLOB locator variable>.
134) Specifications for Feature T042, “Extended LOB data type support”:
   a) Subclause 6.12, “<cast specification>”:
        i)     Without Feature T042, “Extended LOB data type support”, conforming SQL language shall not
               contain a <cast operand> whose declared type is BINARY LARGE OBJECT or CHARACTER
               LARGE OBJECT.
        ii)    Without Feature T042, “Extended LOB data type support”, conforming SQL language shall not
               contain a <cast operand> whose declared type is NATIONAL CHARACTER LARGE OBJECT.
   b) Subclause 6.29, “<string value function>”:
        i)     Without Feature T042, “Extended LOB data type support”, conforming SQL language shall not
               contain a <blob value function>.
   c) Subclause 8.5, “<like predicate>”:
        i)     Without Feature T042, “Extended LOB data type support”, conforming SQL language shall not
               contain an <octet like predicate>.
        ii)    Without Feature T042, “Extended LOB data type support”, in conforming SQL language, a
               <character value expression> simply contained in a <like predicate> shall not be of declared
               type CHARACTER LARGE OBJECT
        iii)   Without Feature F421, “National character”, and Feature T042, “Extended LOB data type sup-
               port”, in conforming SQL language, a <character value expression> simply contained in a <like
               predicate> shall not be of declared type NATIONAL CHARACTER LARGE OBJECT.


1128 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)




    d) Subclause 8.6, “<similar predicate>”:
         i)       Without Feature T042, “Extended LOB data type support”, in conforming SQL language, a
                  <character value expression> simply contained in a <similar predicate> shall not be of declared
                  type CHARACTER LARGE OBJECT.
    e) Subclause 9.9, “Equality operations”:
         i)       Without Feature T042, “Extended LOB data type support”, in conforming SQL language, the
                  declared type of an operand of an equality operation shall not be LOB-ordered.
135) Specifications for Feature T051, “Row types”:
    a) Subclause 5.4, “Names and identifiers”:
         i)       Without Feature T051, “Row types”, conforming SQL language shall not contain a <field name>.
    b) Subclause 6.1, “<data type>”:
         i)       Without Feature T051, “Row types”, conforming SQL language shall not contain a <row type>.
    c) Subclause 6.2, “<field definition>”:
         i)       Without Feature T051, “Row types”, conforming SQL language shall not contain a <field defi-
                  nition>.
    d) Subclause 6.14, “<field reference>”:
         i)       Without Feature T051, “Row types”, conforming SQL language shall not contain a <field refer-
                  ence>.
    e) Subclause 7.1, “<row value constructor>”:
         i)       Without Feature T051, “Row types”, conforming SQL language shall not contain an <explicit
                  row value constructor> that immediately contains ROW.
         ii)      Without Feature T051, “Row types”, conforming SQL language shall not contain a <contextually
                  typed row value constructor> that immediately contains ROW.
    f) Subclause 7.2, “<row value expression>”:
         i)       Without Feature T051, “Row types”, conforming SQL language shall not contain a <row value
                  special case>.
    g) Subclause 7.12, “<query specification>”:
         i)       Without Feature T051, “Row types”, conforming SQL language shall not contain an <all fields
                  reference>.
136) Specifications for Feature T052, “MAX and MIN for row types”:
    a) Subclause 10.9, “<aggregate function>”:
         i)       Without Feature T052, “MAX and MIN for row types”, conforming SQL language shall not
                  contain a <computational operation> that immediately contains MAX or MIN in which the
                  declared type of the <value expression> is a row type.



©ISO/IEC 2003 – All rights reserved                                           SQL Conformance Summary 1129
ISO/IEC 9075-2:2003 (E)




               NOTE 477 — If DISTINCT is specified, then the Conformance Rules of Subclause 9.10, “Grouping operations”,
               also apply. If MAX or MIN is specified, then the Conformance Rules of Subclause 9.12, “Ordering operations”, also
               apply.

137) Specifications for Feature T053, “Explicit aliases for all-fields reference”:
    a) Subclause 7.12, “<query specification>”:
        i)     Without Feature T053, “Explicit aliases for all-fields reference”, conforming SQL language
               shall not contain an <all fields column name list>.
               NOTE 478 — If a <set quantifier> DISTINCT is specified, then the Conformance Rules of Subclause 9.10,
               “Grouping operations”, also apply.

138) Specifications for Feature T061, “UCS support”:
    a) Subclause 6.1, “<data type>”:
        i)     Without Feature T061, “UCS support”, conforming SQL language shall not contain a <char
               length units>.
    b) Subclause 6.29, “<string value function>”:
        i)     Without Feature T061, “UCS support”, conforming SQL language shall not contain a <normalize
               function>.
    c) Subclause 8.11, “<normalized predicate>”:
        i)     Without Feature T061, “UCS support”, conforming SQL language shall not contain a <normalized
               predicate>.
139) Specifications for Feature T071, “BIGINT data type”:
    a) Subclause 6.1, “<data type>”:
        i)     Without Feature T071, “BIGINT data type”, conforming SQL language shall not contain BIGINT.
    b) Subclause 20.3, “<embedded SQL Ada program>”:
        i)     Without Feature T071, “BIGINT data type”, conforming SQL language shall not contain an
               <Ada qualified type specification> that contains Interfaces.SQL.BIGINT.
        ii)    Without Feature T071, “BIGINT data type”, conforming SQL language shall not contain an
               <Ada unqualified type specification> that contains BIGINT.
    c) Subclause 20.4, “<embedded SQL C program>”:
        i)     Without Feature T071, “BIGINT data type”, conforming SQL language shall not contain a <C
               numeric variable> that contains long long.
140) Specifications for Feature T111, “Updatable joins, unions and columns”:
    a) Subclause 11.22, “<view definition>”:
        i)     Without Feature T111, “Updatable joins, unions and columns”, in conforming SQL language,
               if WITH CHECK OPTION is specified, then the viewed table shall be simply updatable.
    b) Subclause 14.1, “<declare cursor>”:



1130 Foundation (SQL/Foundation)                                                             ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)




         i)       Without Feature T111, “Updatable joins, unions, and columns”, in conforming SQL language,
                  if FOR UPDATE is specified, then QE shall be simply updatable.
    c) Subclause 14.7, “<delete statement: searched>”:
         i)       Without Feature T111, “Updatable joins, unions, and columns”, conforming SQL language shall
                  not contain a <delete statement: searched> that contains a <target table> that identifies a table
                  that is not simply updatable.
    d) Subclause 14.8, “<insert statement>”:
         i)       Without Feature T111, “Updatable joins, unions, and columns”, conforming SQL language shall
                  not contain an <insert statement> that contains an <insertion target> that identifies a table that
                  is not simply updatable.
    e) Subclause 14.9, “<merge statement>”:
         i)       Without Feature T111, “Updatable joins, unions, and columns”, conforming SQL language shall
                  not contain a <merge statement> that contains an <target table> that identifies a table that is not
                  simply updatable.
    f) Subclause 14.11, “<update statement: searched>”:
         i)       Without Feature T111, “Updatable joins, unions, and columns”, conforming SQL language shall
                  not contain an <update statement: searched> that contains a <target table> that identifies a table
                  that is not simply updatable.
141) Specifications for Feature T121, “WITH (excluding RECURSIVE) in query expression”:
    a) Subclause 5.4, “Names and identifiers”:
         i)       Without Feature T121, “WITH (excluding RECURSIVE) in query expression”, conforming
                  SQL language shall not contain a <query name>.
    b) Subclause 7.6, “<table reference>”:
         i)       Without Feature T121, “WITH (excluding RECURSIVE) in query expression”, conforming
                  SQL language shall not contain a <query name>.
    c) Subclause 7.13, “<query expression>”:
         i)       Without Feature T121, “WITH (excluding RECURSIVE) in query expression”, in conforming
                  SQL language, a <query expression> shall not contain a <with clause>.
142) Specifications for Feature T122, “WITH (excluding RECURSIVE) in subquery”:
    a) Subclause 7.13, “<query expression>”:
         i)       Without Feature T122, “WITH (excluding RECURSIVE) in subquery”, in conforming SQL
                  language, a <query expression> contained in a <subquery>, a <multiset value constructor by
                  query>, or an <array value constructor by query> shall not contain a <with clause>.
143) Specifications for Feature T131, “Recursive query”:
    a) Subclause 7.13, “<query expression>”:




©ISO/IEC 2003 – All rights reserved                                             SQL Conformance Summary 1131
ISO/IEC 9075-2:2003 (E)




        i)     Without Feature T131, “Recursive query”, conforming SQL language shall not contain a <query
               expression> that contains RECURSIVE.
    b) Subclause 11.22, “<view definition>”:
        i)     Without Feature T131, “Recursive query”, conforming SQL language shall not contain a <view
               definition> that immediately contains RECURSIVE.
144) Specifications for Feature T132, “Recursive query in subquery”:
    a) Subclause 7.13, “<query expression>”:
        i)     Without Feature T132, “Recursive query in subquery”, in conforming SQL language, a <query
               expression> contained in a <subquery>, a <multiset value constructor by query>, or an <array
               value constructor by query> shall not contain RECURSIVE.
145) Specifications for Feature T141, “SIMILAR predicate”:
    a) Subclause 8.6, “<similar predicate>”:
        i)     Without Feature T141, “SIMILAR predicate”, conforming SQL language shall not contain a
               <similar predicate>.
146) Specifications for Feature T151, “DISTINCT predicate”:
    a) Subclause 8.14, “<distinct predicate>”:
        i)     Without Feature T151, “DISTINCT predicate”, conforming SQL language shall not contain a
               <distinct predicate>.
               NOTE 479 — The Conformance Rules of Subclause 9.9, “Equality operations”, also apply.

147) Specifications for Feature T152, “DISTINCT predicate with negation”:
    a) Subclause 8.14, “<distinct predicate>”:
        i)     Without Feature T152, “DISTINCT predicate with negation”, conforming SQL language shall
               not contain a <distinct predicate part 2> that immediately contains NOT.
148) Specifications for Feature T171, “LIKE clause in table definition”:
    a) Subclause 11.3, “<table definition>”:
        i)     Without Feature T171, “LIKE clause in table definition”, conforming SQL language shall not
               contain a <like clause>.
149) Specifications for Feature T172, “AS subquery clause in table definition”:
    a) Subclause 11.3, “<table definition>”:
        i)     Without Feature T172, “AS subquery clause in table definition”, conforming SQL language
               shall not contain an <as subquery clause>.
150) Specifications for Feature T173, “Extended LIKE clause in table definition”:
    a) Subclause 11.3, “<table definition>”:




1132 Foundation (SQL/Foundation)                                                         ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)




         i)       Without Feature T173, “Extended LIKE clause in table definition”, a <like clause> shall not
                  contain <like options>.
151) Specifications for Feature T174, “Identity columns”:
    a) Subclause 11.4, “<column definition>”:
         i)       Without Feature T174, “Identity columns”, conforming SQL language shall not contain an
                  <identity column specification>.
    b) Subclause 11.17, “<alter identity column specification>”:
         i)       Without Feature T174, “Identity columns”, an <alter column definition> shall not contain an
                  <alter identity column specification>.
152) Specifications for Feature T175, “Generated columns”:
    a) Subclause 11.4, “<column definition>”:
         i)       Without Feature T175, “Generated columns”, conforming SQL language shall not contain a
                  <generation clause>.
153) Specifications for Feature T176, “Sequence generator support”:
    a) Subclause 5.4, “Names and identifiers”:
         i)       Without Feature T176, “Sequence generator support”, conforming SQL language shall not
                  contain a <sequence generator name>.
    b) Subclause 6.13, “<next value expression>”:
         i)       Without Feature T176, “Sequence generator support”, conforming SQL language shall not
                  contain a <next value expression>.
    c) Subclause 11.62, “<sequence generator definition>”:
         i)       Without Feature T176, “Sequence generator support”, conforming SQL language shall not
                  contain a <sequence generator definition>.
    d) Subclause 11.63, “<alter sequence generator statement>”:
         i)       Without Feature T176, “Sequence generator support”, conforming SQL language shall not
                  contain an <alter sequence generator statement>.
    e) Subclause 11.64, “<drop sequence generator statement>”:
         i)       Without Feature T176, “Sequence generator support”, conforming SQL language shall not
                  contain a <drop sequence generator statement>.
154) Specifications for Feature T191, “Referential action RESTRICT”:
    a) Subclause 11.8, “<referential constraint definition>”:
         i)       Without Feature T191, “Referential action RESTRICT”, conforming SQL language shall not
                  contain a <referential action> that contains RESTRICT.
155) Specifications for Feature T201, “Comparable data types for referential constraints”:



©ISO/IEC 2003 – All rights reserved                                         SQL Conformance Summary 1133
ISO/IEC 9075-2:2003 (E)




    a) Subclause 11.8, “<referential constraint definition>”:
        i)     Without Feature T201, “Comparable data types for referential constraints”, conforming SQL
               language shall not contain a <referencing columns> in which the data type of each referencing
               column is not the same as the data type of the corresponding referenced column.
               NOTE 480 — The Conformance Rules of Subclause 9.10, “Grouping operations”, also apply.

156) Specifications for Feature T211, “Basic trigger capability”:
    a) Subclause 7.6, “<table reference>”:
        i)     Without Feature T211, “Basic trigger capability”, conforming SQL language shall not contain
               a <transition table name>.
    b) Subclause 11.39, “<trigger definition>”:
        i)     Without Feature T211, “Basic trigger capability”, conforming SQL language shall not contain
               a <trigger definition>.
    c) Subclause 11.40, “<drop trigger statement>”:
        i)     Without Feature T211, “Basic trigger capability”, conforming SQL language shall not contain
               a <drop trigger statement>.
    d) Subclause 12.3, “<privileges>”:
        i)     Without Feature T211, “Basic trigger capability”, conforming SQL language shall not contain
               an <action> that contains TRIGGER.
157) Specifications for Feature T212, “Enhanced trigger capability”:
    a) Subclause 11.39, “<trigger definition>”:
        i)     Without Feature T212, “Enhanced trigger capability”, in conforming SQL language, a <triggered
               action> shall contain FOR EACH ROW.
158) Specifications for Feature T231, “Sensitive cursors”:
    a) Subclause 14.1, “<declare cursor>”:
        i)     Without Feature T231, “Sensitive cursors”, conforming SQL language shall not contain a
               <cursor sensitivity> that immediately contains SENSITIVE.
        ii)    Without Feature F791, “Insensitive cursors”, or Feature T231, “Sensitive cursors”, conforming
               SQL language shall not contain a <cursor sensitivity> that immediately contains ASENSITIVE.
159) Specifications for Feature T241, “START TRANSACTION statement”:
    a) Subclause 16.1, “<start transaction statement>”:
        i)     Without Feature T241, “START TRANSACTION statement”, conforming SQL language shall
               not contain a <start transaction statement>.
160) Specifications for Feature T251, “SET TRANSACTION statement: LOCAL option”:
    a) Subclause 16.2, “<set transaction statement>”:



1134 Foundation (SQL/Foundation)                                                        ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)




         i)       Without Feature T251, “SET TRANSACTION statement: LOCAL option”, conforming SQL
                  language shall not contain a <set transaction statement> that immediately contains LOCAL.
161) Specifications for Feature T261, “Chained transactions”:
    a) Subclause 16.6, “<commit statement>”:
         i)       Without Feature T261, “Chained transactions”, conforming SQL language shall not contain a
                  <commit statement> that immediately contains CHAIN.
    b) Subclause 16.7, “<rollback statement>”:
         i)       Without Feature T261, “Chained transactions”, conforming SQL language shall not contain a
                  <rollback statement> that immediately contains CHAIN.
162) Specifications for Feature T271, “Savepoints”:
    a) Subclause 5.4, “Names and identifiers”:
         i)       Without Feature T271, “Savepoints”, conforming SQL language shall not contain a <savepoint
                  name>.
    b) Subclause 16.4, “<savepoint statement>”:
         i)       Without Feature T271, “Savepoints”, conforming SQL language shall not contain a <savepoint
                  statement>.
    c) Subclause 16.5, “<release savepoint statement>”:
         i)       Without Feature T271, “Savepoints”, conforming SQL language shall not contain a <release
                  savepoint statement>.
    d) Subclause 16.7, “<rollback statement>”:
         i)       Without Feature T271, “Savepoints”, conforming SQL language shall not contain a <savepoint
                  clause>.
163) Specifications for Feature T272, “Enhanced savepoint management”:
    a) Subclause 11.50, “<SQL-invoked routine>”:
         i)       Without Feature T272, “Enhanced savepoint management”, conforming SQL language shall
                  not contain a <routine characteristics> that contains a <savepoint level indication>.
164) Specifications for Feature T281, “SELECT privilege with column granularity”:
    a) Subclause 12.3, “<privileges>”:
         i)       Without Feature T281, “SELECT privilege with column granularity”, in conforming SQL lan-
                  guage, an <action> that contains SELECT shall not contain a <privilege column list>.
165) Specifications for Feature T301, “Functional dependencies”:
    a) Subclause 7.10, “<having clause>”:
         i)       Without Feature T301, “Functional dependencies”, in conforming SQL language, each column
                  reference directly contained in the <search condition> shall be one of the following:



©ISO/IEC 2003 – All rights reserved                                       SQL Conformance Summary 1135
ISO/IEC 9075-2:2003 (E)




               1) An unambiguous reference to a grouping column of T.
               2) An outer reference.
        ii)    Without Feature T301, “Functional dependencies”, in conforming SQL language, each column
               reference contained in a <subquery> in the <search condition> that references a column of T
               shall be one of the following:
               1) An unambiguous reference to a grouping column of T.
               2) Contained in an aggregated argument of a <set function specification>.
    b) Subclause 7.11, “<window clause>”:
        i)     Without Feature T301, “Functional dependencies”, in conforming SQL language, if T is a grouped
               table, then each column reference contained in <window clause> that references a column of T
               shall be a reference to a grouping column of T or be contained in an aggregated argument of a
               <set function specification>.
    c) Subclause 7.12, “<query specification>”:
        i)     Without Feature T301, “Functional dependencies”, in conforming SQL language, if T is a grouped
               table, then in each <value expression> contained in the <select list>, each <column reference>
               that references a column of T shall reference a grouping column or be specified in an aggregated
               argument of a <set function specification>.
    d) Subclause 19.4, “<get descriptor statement>”:
        i)     Without Feature T301, “Functional dependencies”, conforming SQL language shall not contain
               a <descriptor item name> that contains KEY_MEMBER.
166) Specifications for Feature T312, “OVERLAY function”:
    a) Subclause 6.29, “<string value function>”:
        i)     Without Feature T312, “OVERLAY function”, conforming SQL language shall not contain a
               <character overlay function>.
        ii)    Without Feature T312, “OVERLAY function”, conforming SQL language shall not contain a
               <blob overlay function>.
167) Specifications for Feature T322, “Overloading of SQL-invoked functions and procedures”:
    a) Subclause 11.50, “<SQL-invoked routine>”:
        i)     Without Feature T322, “Overloading of SQL-invoked functions and procedures”, conforming
               SQL language shall not contain a <schema routine> in which the schema identified by the explicit
               or implicit schema name of the <schema qualified routine name> includes a routine descriptor
               whose routine name is <schema qualified routine name>.
168) Specifications for Feature T323, “Explicit security for external routines”:
    a) Subclause 11.50, “<SQL-invoked routine>”:
        i)     Without Feature T323, “Explicit security for external routines”, conforming SQL language shall
               not contain an <external security clause>.



1136 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)




169) Specifications for Feature T324, “Explicit security for SQL routines”:
    a) Subclause 11.50, “<SQL-invoked routine>”:
         i)       Without Feature T324, “Explicit security for SQL routines”, conforming SQL language shall
                  not contain a <rights clause>.
170) Specifications for Feature T325, “Qualified SQL parameter references”:
    a) Subclause 6.6, “<identifier chain>”:
         i)       Without Feature T325, “Qualified SQL parameter references”, conforming SQL language shall
                  not contain an SQL parameter reference whose first <identifier> is the <qualified identifier> of
                  a <routine name>.
    b) Subclause 7.12, “<query specification>”:
         i)       Without Feature T325, “Qualified SQL parameter references”, conforming SQL language shall
                  not contain an <asterisked identifier chain> whose referent is an SQL parameter and whose first
                  <identifier> is the <qualified identifier> of a <routine name>.
171) Specifications for Feature T326, “Table functions”:
    a) Subclause 6.39, “<multiset value constructor>”:
         i)       Without Feature T326, “Table functions”, a <multiset value constructor> shall not contain a
                  <table value constructor by query>.
    b) Subclause 7.6, “<table reference>”:
         i)       Without Feature T326, “Table functions”, conforming SQL language shall not contain a <table
                  function derived table>.
    c) Subclause 11.50, “<SQL-invoked routine>”:
         i)       Without Feature T326, “Table functions”, conforming SQL language shall not contain a <returns
                  table type>.
172) Specifications for Feature T331, “Basic roles”:
    a) Subclause 5.4, “Names and identifiers”:
         i)       Without Feature T331, “Basic roles”, conforming SQL language shall not contain a <role name>.
    b) Subclause 12.4, “<role definition>”:
         i)       Without Feature T331, “Basic roles”, conforming SQL language shall not contain a <role defi-
                  nition>.
    c) Subclause 12.5, “<grant role statement>”:
         i)       Without Feature T331, “Basic roles”, conforming SQL language shall not contain a <grant role
                  statement>.
    d) Subclause 12.6, “<drop role statement>”:




©ISO/IEC 2003 – All rights reserved                                           SQL Conformance Summary 1137
ISO/IEC 9075-2:2003 (E)




        i)     Without Feature T331, “Basic roles”, conforming SQL language shall not contain a <drop role
               statement>.
    e) Subclause 12.7, “<revoke statement>”:
        i)     Without Feature T331, “Basic roles”, conforming SQL language shall not contain a <revoke
               role statement>.
    f) Subclause 18.3, “<set role statement>”:
        i)     Without Feature T331, “Basic roles”, conforming SQL language shall not contain a <set role
               statement>.
173) Specifications for Feature T332, “Extended roles”:
    a) Subclause 6.4, “<value specification> and <target specification>”:
        i)     Without Feature T332, “Extended roles”, conforming SQL language shall not contain CUR-
               RENT_ROLE.
    b) Subclause 11.5, “<default clause>”:
        i)     Without Feature T332, “Extended roles”, conforming SQL language shall not contain a <default
               option> that contains CURRENT_ROLE.
    c) Subclause 12.3, “<privileges>”:
        i)     Without Feature T332, “Extended roles”, conforming SQL language shall not contain a <grantor>.
    d) Subclause 12.4, “<role definition>”:
        i)     Without Feature T332, “Extended roles”, conforming SQL language shall not contain a <role
               definition> that immediately contains WITH ADMIN.
174) Specifications for Feature T351, “Bracketed comments”:
    a) Subclause 5.2, “<token> and <separator>”:
        i)     Without Feature T351, “Bracketed comments”, conforming SQL language shall not contain a
               <bracketed comment>.
175) Specifications for Feature T431, “Extended grouping capabilities”:
    a) Subclause 6.9, “<set function specification>”:
        i)     Without Feature T431, “Extended grouping capabilities”, conforming SQL language shall not
               contain a <grouping operation>.
    b) Subclause 7.9, “<group by clause>”:
        i)     Without Feature T431, “Extended grouping capabilities”, conforming SQL language shall not
               contain a <rollup list>.
        ii)    Without Feature T431, “Extended grouping capabilities”, conforming SQL language shall not
               contain a <cube list>.




1138 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                                 ISO/IEC 9075-2:2003 (E)




         iii)     Without Feature T431, “Extended grouping capabilities”, conforming SQL language shall not
                  contain a <grouping sets specification>.
         iv)      Without Feature T431, “Extended grouping capabilities”, conforming SQL language shall not
                  contain an <empty grouping set>.
         v)       Without Feature T431, “Extended grouping capabilities”, conforming SQL language shall not
                  contain an <ordinary grouping set> that contains a <grouping column reference list>.
176) Specifications for Feature T432, “Nested and concatenated GROUPING SETS”:
    a) Subclause 7.9, “<group by clause>”:
         i)       Without Feature T432, “Nested and concatenated GROUPING SETS”, conforming SQL language
                  shall not contain a <grouping set list> that contains a <grouping sets specification>.
         ii)      Without Feature T432, “Nested and concatenated GROUPING SETS”, conforming SQL language
                  shall not contain a <group by clause> that simply contains a <grouping sets specification> GSS
                  where GSS is not the only <grouping element> simply contained in the <group by clause>.
                  NOTE 481 — The Conformance Rules of Subclause 9.10, “Grouping operations”, also apply.

177) Specifications for Feature T433, “Multiargument GROUPING function”:
    a) Subclause 6.9, “<set function specification>”:
         i)       Without Feature T433, “Multiargument GROUPING function”, conforming SQL language shall
                  not contain a <grouping operation> that contains more than one <column reference>.

178) Specifications for Feature T434, “GROUP BY DISTINCT”:
    a) Subclause 7.9, “<group by clause>”:
         i)       Without Feature T434, “GROUP BY DISTINCT”, conforming SQL language shall not contain
                  a <group by clause> that simply contains a <set quantifier>.
179) Specifications for Feature T441, “ABS and MOD functions”:
    a) Subclause 6.27, “<numeric value function>”:
         i)       Without Feature T441, “ABS and MOD functions”, conforming language shall not contain an
                  <absolute value expression>.
         ii)      Without Feature T441, “ABS and MOD functions”, conforming language shall not contain a
                  <modulus expression>.
180) Specifications for Feature T461, “Symmetric BETWEEN predicate”:
    a) Subclause 8.3, “<between predicate>”:
         i)       Without Feature T461, “Symmetric BETWEEN predicate”, conforming SQL language shall not
                  contain SYMMETRIC or ASYMMETRIC.
                  NOTE 482 — Since <between predicate> is an ordering operation, the Conformance Rules of Subclause 9.12,
                  “Ordering operations”, also apply.

181) Specifications for Feature T471, “Result sets return value”:



©ISO/IEC 2003 – All rights reserved                                                   SQL Conformance Summary 1139
ISO/IEC 9075-2:2003 (E)




    a) Subclause 11.50, “<SQL-invoked routine>”:
        i)     Without Feature T471, “Result sets return value”, conforming SQL language shall not contain
               a <dynamic result sets characteristic>.
    b) Subclause 14.1, “<declare cursor>”:
        i)     Without Feature T471, “Result sets return value”, conforming SQL language shall not contain
               a <cursor returnability>.
182) Specifications for Feature T491, “LATERAL derived table”:
    a) Subclause 7.6, “<table reference>”:
        i)     Without Feature T491, “LATERAL derived table”, conforming SQL language shall not contain
               a <lateral derived table>.
183) Specifications for Feature T501, “Enhanced EXISTS predicate”:
    a) Subclause 8.9, “<exists predicate>”:
        i)     Without Feature T501, “Enhanced EXISTS predicate”, conforming SQL language shall not
               contain an <exists predicate> that simply contains a <table subquery> in which the <select list>
               of a <query specification> directly contained in the <table subquery> does not comprise either
               an <asterisk> or a single <derived column>.
184) Specifications for Feature T511, “Transaction counts”:
    a) Subclause 22.1, “<get diagnostics statement>”:
        i)     Without Feature T511, “Transaction counts”, conforming SQL language shall not contain a
               <statement information item name> that contains TRANSACTIONS_COMMITTED,
               TRANSACTIONS_ROLLED_BACK, or TRANSACTION_ACTIVE.
185) Specifications for Feature T551, “Optional key words for default syntax”:
    a) Subclause 7.13, “<query expression>”:
        i)     Without Feature T551, “Optional key words for default syntax”, conforming SQL language
               shall not contain UNION DISTINCT, EXCEPT DISTINCT, or INTERSECT DISTINCT.
    b) Subclause 14.1, “<declare cursor>”:
        i)     Without Feature T551, “Optional key words for default syntax”, conforming SQL language
               shall not contain a <cursor holdability> that immediately contains WITHOUT HOLD.
186) Specifications for Feature T561, “Holdable locators”:
    a) Subclause 14.14, “<free locator statement>”:
        i)     Without Feature T561, “Holdable locators”, conforming SQL language shall not contain a <free
               locator statement>.
    b) Subclause 14.15, “<hold locator statement>”:
        i)     Without Feature T561, “Holdable locators”, conforming SQL language shall not contain a <hold
               locator statement>.


1140 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                                ISO/IEC 9075-2:2003 (E)




187) Specifications for Feature T571, “Array-returning external SQL-invoked functions”:
    a) Subclause 11.41, “<user-defined type definition>”:
         i)       Without Feature T571, “Array-returning external SQL-invoked functions”, conforming SQL
                  language shall not contain a <method specification> that contains a <returns clause> that satisfies
                  either of the following conditions:
                  1) A <result cast from type> is specified that simply contains an <array type> and does not
                     contain a <locator indication>.
                  2) A <result cast from type> is not specified and <returns data type> simply contains an <array
                     type> and does not contain a <locator indication>.
    b) Subclause 11.50, “<SQL-invoked routine>”:
         i)       Without Feature T571, “Array-returning external SQL-invoked functions”, conforming SQL
                  language shall not contain an <SQL-invoked routine> that defines an array-returning external
                  function.
188) Specifications for Feature T572, “Multiset-returning external SQL-invoked functions”:
    a) Subclause 11.41, “<user-defined type definition>”:
         i)       Without Feature T572, “Multiset-returning external SQL-invoked functions”, conforming SQL
                  language shall not contain a <method specification> that contains a <returns clause> that satisfies
                  either of the following conditions:
                  1) A <result cast from type> is specified that simply contains a <multiset type> and does not
                     contain a <locator indication>.
                  2) A <result cast from type> is not specified and <returns data type> simply contains a <mul-
                     tiset type> and does not contain a <locator indication>.
    b) Subclause 11.50, “<SQL-invoked routine>”:
         i)       Without Feature T572, “Multiset-returning external SQL-invoked functions”, conforming SQL
                  language shall not contain an <SQL-invoked routine> that defines a multiset-returning external
                  function.
189) Specifications for Feature T581, “Regular expression substring function”:
    a) Subclause 6.29, “<string value function>”:
         i)       Without Feature T581, “Regular expression substring function”, conforming SQL language
                  shall not contain a <regular expression substring function>.
190) Specifications for Feature T591, “UNIQUE constraints of possibly null columns”:
    a) Subclause 11.7, “<unique constraint definition>”:
         i)       Without Feature T591, “UNIQUE constraints of possibly null columns”, in conforming SQL
                  language, if UNIQUE is specified, then the <column definition> for each column whose <column
                  name> is contained in the <unique column list> shall contain NOT NULL.
                  NOTE 483 — The Conformance Rules of Subclause 9.10, “Grouping operations”, also apply.




©ISO/IEC 2003 – All rights reserved                                                 SQL Conformance Summary 1141
ISO/IEC 9075-2:2003 (E)




191) Specifications for Feature T601, “Local cursor references”:
    a) Subclause 5.4, “Names and identifiers”:
        i)     Without Feature T601, “Local cursor references”, a <cursor name> shall not contain a <local
               qualifier>.
192) Specifications for Feature T611, “Elementary OLAP operations”:
    a) Subclause 6.10, “<window function>”:
        i)     Without Feature T611, “Elementary OLAP operations”, conforming SQL language shall not
               contain a <window function>.
    b) Subclause 7.11, “<window clause>”:
        i)     Without Feature T611, “Elementary OLAP operations”, conforming SQL language shall not
               contain a <window specification>.
    c) Subclause 10.10, “<sort specification list>”:
        i)     Without Feature T611, “Elementary OLAP operations”, conforming SQL language shall not
               contain a <null ordering>.
               NOTE 484 — The Conformance Rules of Subclause 9.12, “Ordering operations”, also apply.

193) Specifications for Feature T612, “Advanced OLAP operations”:
    a) Subclause 5.4, “Names and identifiers”:
        i)     Without Feature T612, “Advanced OLAP operations”, conforming SQL language shall not
               contain a <window name>.
    b) Subclause 6.10, “<window function>”:
        i)     Without Feature T612, “Advanced OLAP operations”, conforming SQL language shall not
               contain a <window name>.
        ii)    Without Feature T612, “Advanced OLAP operations”, conforming SQL language shall not
               contain PERCENT_RANK or CUME_DIST.
        iii)   Without Feature T612, “Advanced OLAP operations”, conforming SQL language shall not
               contain a <window function> that simply contains ROW_NUMBER and immediately contains
               a <window name or specification> whose window structure descriptor does not contain a window
               ordering clause.
    c) Subclause 6.27, “<numeric value function>”:
        i)     Without Feature T612, “Advanced OLAP operations”, conforming SQL language shall not
               contain a <width bucket function>.
    d) Subclause 7.11, “<window clause>”:
        i)     Without Feature T612, “Advanced OLAP operations”, conforming SQL language shall not
               contain a <window clause>.




1142 Foundation (SQL/Foundation)                                                        ©ISO/IEC 2003 – All rights reserved
                                                                                                ISO/IEC 9075-2:2003 (E)




         ii)      Without Feature T612, “Advanced OLAP operations”, conforming SQL language shall not
                  contain an <existing window name>.
         iii)     Without Feature T612, “Advanced OLAP operations”, conforming SQL language shall not
                  contain a <window frame exclusion>.
                  NOTE 485 — The Conformance Rules of Subclause 9.10, “Grouping operations”, also apply.

    e) Subclause 10.9, “<aggregate function>”:
         i)       Without Feature T612, “Advanced OLAP operations”, conforming SQL language shall not
                  contain a <hypothetical set function> or an <inverse distribution function>.
         ii)      Without Feature T612, “Advanced OLAP operations”, conforming SQL language shall not
                  contain a <filter clause>.
194) Specifications for Feature T613, “Sampling”:
    a) Subclause 7.6, “<table reference>”:
         i)       Without Feature T613, “Sampling”, conforming SQL language shall not contain a <sample
                  clause>.
195) Specifications for Feature T621, “Enhanced numeric functions”:
    a) Subclause 6.27, “<numeric value function>”:
         i)       Without Feature T621, “Enhanced numeric functions”, conforming SQL language shall not
                  contain a <natural logarithm>.
         ii)      Without Feature T621, “Enhanced numeric functions”, conforming SQL language shall not
                  contain an <exponential function>.
         iii)     Without Feature T621, “Enhanced numeric functions”, conforming SQL language shall not
                  contain a <power function>.
         iv)      Without Feature T621, “Enhanced numeric functions”, conforming SQL language shall not
                  contain a <square root>.
         v)       Without Feature T621, “Enhanced numeric functions”, conforming SQL language shall not
                  contain a <floor function>.
         vi)      Without Feature T621, “Enhanced numeric functions”, conforming SQL language shall not
                  contain a <ceiling function>.
    b) Subclause 10.9, “<aggregate function>”:
         i)       Without Feature T621, “Enhanced numeric functions”, conforming SQL language shall not
                  contain a <computational operation> that immediately contains STDDEV_POP, STD-
                  DEV_SAMP, VAR_POP, or VAR_SAMP.
         ii)      Without Feature T621, “Enhanced numeric functions”, conforming SQL language shall not
                  contain a <binary set function type>.
196) Specifications for Feature T641, “Multiple column assignment”:
    a) Subclause 14.12, “<set clause list>”:


©ISO/IEC 2003 – All rights reserved                                                 SQL Conformance Summary 1143
ISO/IEC 9075-2:2003 (E)




        i)     Without Feature T641, “Multiple column assignment”, conforming SQL language shall not
               contain a <multiple column assignment>.
197) Specifications for Feature T651, “SQL-schema statements in SQL routines”:
    a) Subclause 11.50, “<SQL-invoked routine>”:
        i)     Without Feature T651, “SQL-schema statements in SQL routines”, conforming SQL language
               shall not contain an <SQL routine body> that contains an SQL-schema statement.
198) Specifications for Feature T652, “SQL-dynamic statements in SQL routines”:
    a) Subclause 11.50, “<SQL-invoked routine>”:
        i)     Without Feature T652, “SQL-dynamic statements in SQL routines”, conforming SQL language
               shall not contain an <SQL routine body> that contains an SQL-dynamic statement.
199) Specifications for Feature T653, “SQL-schema statements in external routines”:
    a) Subclause 11.50, “<SQL-invoked routine>”:
        i)     Without Feature T653, “SQL-schema statements in external routines”, conforming SQL language
               shall not contain an <external routine name> that identifies a program in which an SQL-schema
               statement appears.
200) Specifications for Feature T654, “SQL-dynamic statements in external routines”:
    a) Subclause 11.50, “<SQL-invoked routine>”:
        i)     Without Feature T654, “SQL-dynamic statements in external routines”, conforming SQL language
               shall not contain an <external routine name> that identifies a program in which an SQL-dynamic
               statement appears.
201) Specifications for Feature T655, “Cyclically dependent routines”:
    a) Subclause 11.50, “<SQL-invoked routine>”:
        i)     Without Feature T655, “Cyclically dependent routines”, conforming SQL language shall not
               contain an <SQL routine body> that contains a <routine invocation> whose subject routine is
               generally dependent on the routine descriptor of the SQL-invoked routine specified by <SQL-
               invoked routine>.




1144 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)




                                                  Annex B
                                                (informative)

                                      Implementation-defined elements

This Annex references those features that are identified in the body of this part of ISO/IEC 9075 as implemen-
tation-defined.
1) Subclause 4.2.2, “Comparison of character strings”:
    a) The specific character set associated with the subtype of character string represented by the <key word>s
       NATIONAL CHARACTER is implementation-defined.
    b) The circumstances in which conversion of non-UCS character string expressions from one character
       set to another is automatic is implementation-defined.
2) Subclause 4.2.4, “Character repertoires”:
    a) The character repertoires, including standard defined repertoires, supported by the SQL-implementation
       are implementation-defined.
    b) The character set named SQL_TEXT is an implementation-defined character set that contains every
       character that is in <SQL language character> and all characters that are in other character sets supported
       by the SQL-implementation.
    c) The character set named SQL_IDENTIFIER is an implementation-defined character set that contains
       every character that is in <SQL language character> and all characters that the SQL-implementation
       supports for use in <regular identifier>s, which is the same as the repertoire that the SQL-implementation
       supports for use in <delimited identifier>s.
3) Subclause 4.2.5, “Character encoding forms”:
    a) The character encodings in the SQL_CHARACTER character encoding form are implementation-
       defined.
    b) The character encodings in the SQL_TEXT character encoding form are implementation-defined.
    c) The character encodings in the SQL_IDENTIFIER character encoding form are implementation-defined.
    d) Which character encoding forms, including standard defined encoding forms, is implemented are
       implementation-defined.
4) Subclause 4.2.6, “Collations”:
    a) The collations, including standard defined collations, supported by the SQL-implementation are
       implementation-defined.
    b) The ordering specified by the SQL_CHARACTER collation is implementation-defined.
    c) The ordering specified by the SQL_TEXT collation is implementation-defined.


©ISO/IEC 2003 – All rights reserved                                      Implementation-defined elements 1145
ISO/IEC 9075-2:2003 (E)




    d) The ordering specified by the SQL_IDENTIFIER collation is implementation-defined.
5) Subclause 4.2.7, “Character sets”:
    a) It is implementation-defined which collation, UCS_BASIC or UNICODE, is the default for the UTF8,
       UTF16, and UTF32 character sets.
6) Subclause 4.2.8, “Universal character sets”:
    a) With the exception of <normalize function> and <normalized predicate>, the result of any operation
       on an unnormalized UCS string is implementation-defined.
7) Subclause 4.4, “Numbers”:
    a) Whether truncation or rounding is performed when trailing digits are removed from a numeric value
       is implementation-defined.
    b) When an approximation is obtained by truncation or rounding and there are more than one approximation,
       then it is implementation-defined which approximation is chosen.
    c) It is implementation-defined which numeric values have approximations obtained by rounding or
       truncation for a given approximate numeric type.
    d) The boundaries within which the normal rules of arithmetic apply are implementation-defined.
8) Subclause 4.4.2, “Characteristics of numbers”:
    a) When converting between numeric data types, if least significant digits are lost, then it is implementation-
       defined whether rounding or truncation occurs.
9) Subclause 4.6.2, “Datetimes”:
    a) Whether an SQL-implementation supports leap seconds, and the consequences of such support for date
       and interval arithmetic, are implementation-defined.
10) Subclause 4.9, “Reference types”:
    a) In a host variable, a reference type is materialized as an N-octet value, where N is implementation-
       defined.
11) Subclause 4.14.6, “Operations involving tables”:
    a) If a <table reference> contains a <sample clause>, and the <sample clause> contains <repeatable
       clause>, then repeated executions of that <table reference> return a result table with identical rows for
       a given <repeat argument>, provided certain implementation-defined conditions are satisfied.
12) Subclause 4.15.3, “Window functions”:
    a) If PERCENT_RANK is specified, then the declared type of the result is approximate numeric with
       implementation-defined precision.
    b) If CUME_DIST is specified, then the declared type of the result is approximate numeric with imple-
       mentation-defined precision.
13) Subclause 4.17.3, “Table constraints”:




1146 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)




    a) The ordering of the lists of referencing column names and referenced column names in a referential
       constrict descriptor is implementation-defined, but shall be such that corresponding column names
       occupy corresponding positions in each list.
14) Subclause 4.18, “Functional dependencies”:
    a) An SQL-implementation may define additional known functional dependencies.
15) Subclause 4.22, “SQL-client modules”:
    a) The mechanisms by which SQL-client modules are created or destroyed are implementation-defined.
    b) The manner in which an association between an SQL-client module and an SQL-agent is defined is
       implementation-defined.
    c) Whether a compilation unit may invoke or transfer control to other compilation units, written in the
       same or a different programming language is implementation-defined.
16) Subclause 4.23, “Embedded syntax”:
    a) Whether a portion of the name space is reserved by an implementation for the names of procedures,
       subroutines, program variables, branch labels, <SQL-client module definition>s, or <externally-invoked
       procedure>s is implementation-defined; if a portion of the name space is so reserved, the portion
       reserved is also implementation-defined.
17) Subclause 4.24, “Dynamic SQL concepts”:
    a) Within an SQL-session, all prepared statements belong to the same implementation-defined <SQL-
       client module definition> that is different from any other <SQL-client module definition> that exists
       simultaneously in the environment.
18) Subclause 4.25, “Direct invocation of SQL”:
    a) The method of invoking <direct SQL statement>s, the method of raising conditions as a result of <direct
       SQL statement>s, the method of accessing diagnostic information, and the method of returning the
       results are all implementation-defined.
19) Subclause 4.32, “Cursors”:
    a) If a sensitive or asensitive holdable cursor is held open for a subsequent SQL-transaction, then whether
       any significant changes made to SQL-data (by this or any subsequent SQL-transaction in which the
       cursor is held open) will be visible through that cursor in the subsequent SQL-transaction before that
       cursor is closed is implementation-defined.
20) Subclause 4.35, “SQL-transactions”:
    a) It is implementation-defined whether or not the execution of an SQL-data statement is permitted to
       occur within the same SQL-transaction as the execution of an SQL-schema statement. If it does occur,
       then the effect on any open cursor or deferred constraint is also implementation-defined.
    b) If an SQL-implementation detects unrecoverable errors and implicitly initiates the execution of a
       <rollback statement>, an exception condition is raised with an implementation-defined exception code.
    c) It is implementation-defined whether or not the dynamic execution of an <SQL dynamic data statement>
       is permitted to occur within the same SQL-transaction as the dynamic execution of an SQL-schema



©ISO/IEC 2003 – All rights reserved                                    Implementation-defined elements 1147
ISO/IEC 9075-2:2003 (E)




        statement. If it does occur, then the effect on any prepared dynamic statement is also implementation-
        defined.
21) Subclause 4.36, “SQL-connections”:
    a) It is implementation-defined how an SQL-implementation uses <SQL-server name> to determine the
       location, identity, and communication protocol required to access the SQL-server and initiate an SQL-
       session.
22) Subclause 4.37, “SQL-sessions”:
    a) When an SQL-session is initiated other than through the use of an explicit <connect statement>, then
       an SQL-session associated with an implementation-defined SQL-server is initiated. The default SQL-
       server is implementation-defined.
    b) The mechanism and rules by which an SQL-implementation determines whether a call to an <externally-
       invoked procedure> is the last call within the last active SQL-client module is implementation-defined.
    c) An SQL-session uses one or more implementation-defined schemas that contain the instances of any
       global temporary tables, created local temporary tables, or declared local temporary tables within the
       SQL-session.
    d) When an SQL-session is initiated, there is an implementation-defined default time zone used as the
       current default time zone displacement of the SQL-session.
    e) When an SQL-session is initiated other than through the use of an explicit <connect statement>, there
       is an implementation-defined initial value of the SQL-session user identifier.
    f) When an SQL-session is initiated, there is an implementation-defined default catalog whose name is
       used to effectively qualify all unqualified <schema name>s contained in <preparable statement>s that
       are dynamically prepared in the current SQL-session through the execution of <prepare statement>s
       and <execute immediate statement>s.
    g) When an SQL-session is initiated, there is an implementation-defined default schema whose name is
       used to effectively qualify all unqualified <schema qualified name>s contained in <preparable state-
       ment>s that are dynamically prepared in the current SQL-session through the execution of <prepare
       statement>s and <execute immediate statement>s.
    h) The value of the current SQL-path before a successful execution of <set path statement> is implemen-
       tation-defined.
23) Subclause 5.1, “<SQL terminal character>”:
    a) The end-of-line indicator (<newline>) is implementation-defined.
24) Subclause 5.2, “<token> and <separator>”:
    a) Equivalence of two <regular identifier>s, or of a <regular identifier> and a <delimited identifier> is
       determined using an implementation-defined collation that is sensitive to case.
    b) When the source character set does not contain <reverse solidus>, the character used as the default
       <Unicode escape character> is implementation-defined.
25) Subclause 5.3, “<literal>”:




1148 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)




    a) The <character set name> character set of the used to represent national characters is implementation-
       defined.
    b) The declared type of an <exact numeric literal> is implementation-defined.
    c) The declared type of an <approximate numeric literal> is implementation-defined.
26) Subclause 5.4, “Names and identifiers”:
    a) If a <schema name> contained in a <schema name clause> but not contained in an SQL-client module
       does not contain a <catalog name>, then an implementation-defined <catalog name> is implicit.
    b) If a <schema name> contained in a <module authorization clause> does not contain a <catalog name>,
       then an implementation-defined <catalog name> is implicit.
    c) Those <identifier>s that are valid <authorization identifier>s are implementation-defined.
    d) Those <identifier>s that are valid <catalog name>s are implementation-defined.
    e) All <transcoding name>s are implementation-defined.
    f) If a <schema name> contained in a <preparable statement> that is dynamically prepared in the current
       SQL-session through the execution of a <prepare statement> or an <execute immediate statement>
       does not contain a <catalog name>, then the implementation-defined <catalog name> for the SQL-
       session is implicit.
    g) If a <schema qualified name> contained in a <preparable statement> that is dynamically prepared in
       the current SQL-session through the execution of a <prepare statement> or an <execute immediate
       statement> does not contain a <schema name>, then the implementation-defined <schema name> for
       the SQL-session is implicit.
27) Subclause 6.1, “<data type>”:
    a) The <character set name> associated with NATIONAL CHARACTER is implementation-defined.
    b) If a <precision> is omitted, then an implementation-defined <precision> is implicit.
    c) The decimal precision of a data type defined as DECIMAL for each value specified by <precision> is
       implementation-defined.
    d) The precisions of data types defined as SMALLINT, INTEGER, and BIGINT are implementation-
       defined, but all three data types have the same radix.
    e) The binary precision of a data type defined as FLOAT for each value specified by <precision> is
       implementation-defined.
    f) The precision of a data type defined as REAL is implementation-defined.
    g) The precision of a data type defined as DOUBLE PRECISION is implementation-defined, but greater
       than that for REAL.
    h) For every <data type>, the limits of the <data type> are implementation-defined.
    i)   The maximum lengths for character string types and binary string types are implementation-defined.
    j)   If CHARACTER SET is not specified for <character string type>, then the character set is implemen-
         tation-defined.


©ISO/IEC 2003 – All rights reserved                                   Implementation-defined elements 1149
ISO/IEC 9075-2:2003 (E)




    k) For the <exact numeric type>s DECIMAL and NUMERIC, the maximum values of <precision> and
       of <scale> are implementation-defined.
    l)   The transformation ENNF() of an <exact numeric type> to its normal form, to obtain the data type
         name saved in a numeric data type descriptor, is implementation-defined, though it shall adhere to the
         following constraints:
         i)     For every <exact numeric type> ENT, ENNF(ENT) shall not specify DEC or INT.
                NOTE 486 — The preceding requirement prohibits the function ENNF from returning a value that uses the abbreviated
                spelling of the two data types; the function shall instead return the long versions of DECIMAL or INTEGER.

         ii)    For every <exact numeric type> ENT, the precision, scale, and radix of ENNF(ENT) shall be
                the precision, scale, and radix of ENT.
         iii)   For every <exact numeric type> ENT, ENNF(ENT) shall be the same as ENNF(ENNF(ENT)).
         iv)    For every <exact numeric type> ENT, if ENNF(ENT) specifies DECIMAL, then ENNF(ENT)
                shall specify <precision>, and the precision of ENNF(ENT) shall be the value of the <precision>
                specified in ENNF(ENT).
    m) For the <approximate numeric type> FLOAT, the maximum value of <precision> is implementation-
       defined.
    n) The transformation ANNF() of an <approximate numeric type> to its normal form, to obtain the data
       type name saved in a numeric data type descriptor, is implementation-defined, though it shall adhere
       to the following constraints:
         i)     For every <approximate numeric type> ANT, the precision of ANNF(ANT) shall be the precision
                of ANT.
         ii)    For every <approximate numeric type> ANT, ANNF(ANT) shall be the same as
                ANNF(ANNF(ANT)).
         iii)   For every <exact numeric type> ANT, if ANNF(ANT) specifies FLOAT, then ANNF(ANT) shall
                specify <precision>, and the precision of ANNF(ANT) shall be the value of the <precision>
                specified in ANNF(ANT).
    o) For the <approximate numeric type>s FLOAT, REAL, and DOUBLE PRECISION, the maximum and
       minimum values of the exponent are implementation-defined.
    p) The maximum value of <time fractional seconds precision> is implementation-defined, but shall not
       be less than 6.
    q) The maximum values of <time precision> and <timestamp precision> for a <datetime type> are the
       same implementation-defined value.
    r) If the maximum cardinality of an <array type> is omitted, then an implementation-defined maximum
       cardinality is implicit.
28) Subclause 6.4, “<value specification> and <target specification>”:
    a) Whether the character string of the <value specification>s CURRENT_USER, SESSION_USER, and
       SYSTEM_USER is variable-length or fixed-length, and its maximum length if it is variable-length or
       its length if it is fixed-length, are implementation-defined.



1150 Foundation (SQL/Foundation)                                                              ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)




    b) The value specified by SYSTEM_USER is an implementation-defined string that represents the oper-
       ating system user who executed the SQL-client module that contains the SQL-statement whose execution
       caused the SYSTEM_USER <general value specification> to be evaluated.
    c) Whether the data type of CURRENT_PATH is fixed-length or variable-length, and its length if it is
       fixed-length or its maximum length if it is variable-length, are implementation-defined.
    d) If a <target specification> or <simple target specification> is assigned a value that is a zero-length
       character string, then it is implementation-defined whether an exception condition is raised: data
       exception — zero-length character string.
    e) In Intermediate SQL, the specific data type of <indicator parameter>s and <indicator variable>s shall
       be the same implementation-defined data type.
29) Subclause 6.9, “<set function specification>”:
    a) The precision of the value derived from application of the COUNT function is implementation-defined.
    b) The precision of the value derived from application of the SUM function to a declared type of exact
       numeric is implementation-defined.
    c) The precision and scale of the value derived from application of the AVG function to a declared type
       of exact numeric is implementation-defined.
    d) The precision of the value derived from application of the SUM function or AVG function to a data
       type of approximate numeric is implementation-defined.
30) Subclause 6.12, “<cast specification>”:
    a) Whether to round or truncate when casting to exact numeric, approximate numeric, datetime, or interval
       data types is implementation-defined.
31) Subclause 6.26, “<numeric value expression>”:
    a) When the declared type of both operands of the addition, subtraction, multiplication, or division oper-
       ator is exact numeric, the declared type of the result is an implementation-defined exact numeric type.
    b) When the declared type of both operands of the division operator is exact numeric, the scale of the
       result is implementation-defined.
    c) When the declared type of either operand of an arithmetic operator is approximate numeric, the declared
       type of the result is an implementation-defined approximate numeric type.
    d) Whether to round or truncate when performing division is implementation-defined.
32) Subclause 6.27, “<numeric value function>”:
    a) The declared type of <position expression> is an implementation-defined exact numeric type with scale
       0 (zero).
    b) The declared type of <extract expression> is an implementation-defined exact numeric type. If <primary
       datetime field> specifies SECOND, then the scale is implementation-defined; otherwise, the scale is
       0 (zero).
    c) The declared type of <length expression> is an implementation-defined exact numeric type with scale
       0 (zero).


©ISO/IEC 2003 – All rights reserved                                     Implementation-defined elements 1151
ISO/IEC 9075-2:2003 (E)




    d) The declared type of the result of <natural logarithm> is an implementation-defined approximate
       numeric.
    e) The declared type of the result of <exponential function> is an implementation-defined approximate
       numeric.
    f) The declared type of the result of <power function> is an implementation-defined approximate numeric.
    g) The declared types of the results of <floor function> and of <ceiling function> are implementation-
       defined exact numeric type with scale 0 (zero) if the declared type of the simply contained <numeric
       value expression> is exact numeric; otherwise, the declared types of the results are implementation-
       defined approximate numeric types.
33) Subclause 6.28, “<string value expression>”:
    a) If the result of the <character value expression> is a zero-length character string, then it is implemen-
       tation-defined whether an exception condition is raised: data exception — zero-length character string.
    b) If the character encoding form of <character factor> is UTF8, UTF16, or UTF32, and either of the
       operands is not normalized, then the result is implementation-defined.
34) Subclause 6.29, “<string value function>”:
    a) The maximum length of <character transliteration> or <transcoding> is implementation-defined.
    b) The character set of the result of a <transcoding> is implementation-defined.
35) Subclause 6.32, “<interval value expression>”:
    a) The difference of two values of type TIME (with or without time zone) is constrained to be between
       –24:00:00 and +24:00:00 (excluding each end point); it is implementation-defined which of two non-
       zero values in this range is the result, although the computation shall be deterministic.
    b) When an interval is produced from the difference of two datetimes, the choice of whether to round or
       truncate is implementation-defined.
    c) The result's <interval leading field precision> is implementation-defined, but shall not be less than the
       <interval leading field precision> of the <interval primary>.
    d) The <interval leading field precision> is implementation-defined, but shall be sufficient to represent
       all interval values with the interval fields and <interval leading field precision> of <interval value
       expression 1> as well as all interval values with the interval fields and <interval leading field precision>
       of <interval term 1>.
36) Subclause 7.12, “<query specification>”:
    a) An SQL-implementation may define additional implementation-defined rules for recognizing known-
       not-null columns.
37) Subclause 8.5, “<like predicate>”:
    a) It is implementation-defined which collations can be used as collations for the <like predicate>.
38) Subclause 8.6, “<similar predicate>”:
    a) It is implementation-defined which collations can be used as collations for the <similar predicate>.



1152 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)




39) Subclause 9.1, “Retrieval assignment”:
    a) If a value V is approximate numeric and a target T is exact numeric, then whether the approximation
       of V retrieved into T is obtained by rounding or by truncation is implementation-defined.
    b) If a value V is datetime with a greater precision than a target T, then it is implementation-defined
       whether the approximation of V retrieved into T is obtained by rounding or truncation.
    c) If a value V is interval with a greater precision than a target T, then it is implementation-defined whether
       the approximation of V retrieved into T is obtained by rounding or by truncation.
40) Subclause 9.2, “Store assignment”:
    a) If a value V is approximate numeric and a target T is exact numeric, then whether the approximation
       of V stored into T is obtained by rounding or by truncation is implementation-defined.
    b) If a value V is datetime with a greater precision than a target T, then it is implementation-defined
       whether the approximation of V stored into T is obtained by rounding or truncation.
    c) If a value V is interval with a greater precision than a target T, then it is implementation-defined whether
       the approximation of V stored into T is obtained by rounding or by truncation.
41) Subclause 9.3, “Data types of results of aggregations”:
    a) If all of the data types in DTS are exact numeric, then the result data type is exact numeric with
       implementation-defined precision.
    b) If any data type in DTS is approximate numeric, then each data type in DTS shall be numeric and the
       result data type is approximate numeric with implementation-defined precision.
42) Subclause 9.22, “Creation of a sequence generator”:
    a) If <sequence generator maxvalue option> specifies NO MAXVALUE or if <sequence generator max-
       value option> is not specified, then a <sequence generator max value> that is an implementation-defined
       <signed numeric literal> of declared type DT is implicit.
    b) If <sequence generator minvalue option> specifies NO MINVALUE or if <sequence generator minvalue
       option> is not specified, then a <sequence generator min value> that is an implementation-defined
       <signed numeric literal> of declared type DT is implicit.
43) Subclause 9.23, “Altering a sequence generator”:
    a) If <sequence generator maxvalue option> specifies NO MAXVALUE, then a <sequence generator
       max value> that is an implementation-defined <signed numeric literal> of declared type DT is implicit.
    b) If <sequence generator minvalue option> specifies NO MINVALUE, then a <sequence generator min
       value> that is an implementation-defined <signed numeric literal> of declared type DT is implicit.
44) Subclause 10.1, “<interval qualifier>”:
    a) The maximum value of <interval leading field precision> is implementation-defined, but shall not be
       less than 2.
    b) The maximum value of <interval fractional seconds precision> is implementation-defined, but shall
       not be less than 2.



©ISO/IEC 2003 – All rights reserved                                       Implementation-defined elements 1153
ISO/IEC 9075-2:2003 (E)




45) Subclause 10.4, “<routine invocation>”:
   a) If an SQL-invoked routine does not contain SQL, does not possibly read SQL-data, and does not pos-
      sibly modify SQL-data, then the SQL-session module of the new SQL-session context RSC is set to
      be an implementation-defined module.
   b) If Pi is an output SQL parameter, then CPVi is an implementation-defined value of type Ti.

   c) Whether a syntax error occurs if an <SQL routine body> contains an <SQL connection statement> or
      an <SQL transaction statement> is implementation-defined.
   d) When a new SQL-session context RSC is created, the current default catalog name, current default
      unqualified schema name, the current default character set name, the SQL-path of the current SQL-
      session, the current default time zone displacement of the current SQL-session, and the contents of all
      SQL dynamic descriptor areas are set to implementation-defined values.
   e) If R is an external routine, then it is implementation-defined whether the identities of all instances of
      created local temporary tables that are referenced in the <SQL-client module definition> of P, declared
      local temporary tables that are defined by <temporary table declaration>s that are contained in the
      <SQL-client module definition> of P, and the cursor position of all open cursors that are defined by
      <declare cursor>s that are contained in the <SQL-client module definition> of P are removed from
      RSC.
   f) After the completion of P, it is implementation-defined whether open cursors declared in the <SQL-
      client module definition> of P are closed and destroyed, whether local temporary tables associated
      with RCS are destroyed, and whether prepared statements prepared by P are deallocated.
   g) If R is an SQL-invoked procedure, then for each SQL parameter that is an output SQL parameter or
      both an input and output SQL parameter whose corresponding argument was not assigned a value, that
      corresponding argument is set to an implementation-defined value of the appropriate type.
   h) If the external security characteristic of an external SQL-invoked routine is IMPLEMENTATION
      DEFINED, then the user identifier and role name in the first cell of the authorization stack of the new
      SQL-session context are implementation-defined.
46) Subclause 10.9, “<aggregate function>”:
   a) If COUNT is specified, then the declared type of the result is an implementation-defined exact numeric
      type with scale of 0 (zero).
   b) If SUM or AVG is specified, then:
       i)     If SUM is specified and the declared type of the argument is exact numeric with scale S, then
              the declared type of the result is an implementation-defined exact numeric type with scale S.
       ii)    If AVG is specified and the declared type DT of the argument is exact numeric, then the declared
              type of the result is an implementation-defined exact numeric type with precision not less than
              the precision of DT and scale not less than the scale of DT.
       iii)   If the declared type DT of the argument is approximate numeric, then the declared type of the
              result is an implementation-defined approximate numeric type with precision not less than the
              precision of DT.




1154 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)




    c) If VAR_POP or VAR_SAMP is specified, then the declared type of the result is an implementation-
       defined approximate numeric type. If the declared type of the argument is approximate numeric, then
       the precision of the result is not less than the precision of the argument.
    d) If <binary set function type> is specified, then
         Case:
         i)       If REGR_COUNT is specified, then the declared type of the result is an implementation-defined
                  exact numeric type with scale of 0 (zero).
         ii)      Otherwise, the declared type of the result is an implementation-defined approximate numeric
                  type. If either argument is approximate numeric, then the precision of the result shall be at least
                  as great as the precision of the approximate numeric argument(s).
    e) If <hypothetical set function> is specified, then
         Case:
         i)       If RANK or DENSE_RANK is specified, then the declared type of the result is exact numeric
                  with implementation-defined precision and with scale 0 (zero).
         ii)      Otherwise, the declared type of the result is approximate numeric with implemenation-defined
                  precision.
    f) If the declared type of the <value expression> simply contained in the <sort specification> of an <inverse
       distribution function> that specifies PERCENTILE_CONT is numeric, then the result type is approximate
       numeric with implementation-defined precision.
47) Subclause 10.10, “<sort specification list>”:
    a) If <null ordering> is not specified, then an implementation-defined <null ordering> is implicit. The
       implementation-defined default for <null ordering> shall not depend on the context outside of <sort
       specification list>.
48) Subclause 11.1, “<schema definition>”:
    a) If <schema character set specification> is not specified, then a <schema character set specification>
       containing an implementation-defined <character set specification> is implicit.
    b) If <schema path specification> is not specified, then a <schema path specification> containing an
       implementation-defined <schema name list> is implicit.
    c) If AUTHORIZATION <authorization identifier> is not specified, then an <authorization identifier>
       equivalent to the implementation-defined <authorization identifier> for the SQL-session is implicit.
    d) The privileges necessary to execute the <schema definition> are implementation-defined.
49) Subclause 11.6, “<table constraint definition>”:
    a) The ordering of the lists of referencing column names and referenced column names in a referential
       constraint descriptor is implementation-defined, but shall be such that corresponding column names
       occupy corresponding positions in each list.
50) Subclause 11.33, “<collation definition>”:



©ISO/IEC 2003 – All rights reserved                                         Implementation-defined elements 1155
ISO/IEC 9075-2:2003 (E)




    a) The <existing collation name>s that are supported are implementation-defined.
    b) The collation resulting from the specification of EXTERNAL in a <collation definition> may be
       implementation-defined.
51) Subclause 11.35, “<transliteration definition>”:
    a) The <existing transliteration name>s that are supported are implementation-defined.
52) Subclause 11.39, “<trigger definition>”:
    a) It is implementation-defined whether the <triggered SQL statement> shall not generally contain an
       <SQL transaction statement>, an <SQL connection statement>, an <SQL schema statement>, an <SQL
       dynamic statement>, or an <SQL session statement>.
    b) It is implementation-defined whether the <triggered action> shall not generally contain an <SQL data
       change statement> or a <routine invocation> whose subject routine is an SQL-invoked routine that
       possibly modifies SQL-data.
53) Subclause 11.50, “<SQL-invoked routine>”:
    a) If READS SQL DATA is specified, then it is implementation-defined whether the SQL routine body
       shall not contain an <SQL procedure statement> S that satisfies at least one of the following:
        i)     S is an <SQL data change statement>.
        ii)    S contains a <routine invocation> whose subject routine is an SQL-invoked routine that possibly
               modifies SQL-data.
        iii)   S contains an <SQL procedure statement> that is an <SQL data change statement>.
    b) If CONTAINS SQL is specified, then it is implementation-defined whether the SQL routine body shall
       not contain an <SQL procedure statement> S that satisfies at least one of the following:
        i)     S is an <SQL data statement> other than <free locator statement> and <hold locator statement>.
        ii)    S contains a <routine invocation> whose subject routine is an SQL-invoked routine that possibly
               modifies SQL-data or possibly reads SQL-data.
        iii)   S contains an <SQL procedure statement> that is an <SQL data statement> other than <free
               locator statement> and <hold locator statement>.
    c) If DETERMINISTIC is specified, then it is implementation-defined whether the <SQL routine body>
       shall not contain an <SQL procedure statement> that is possibly non-deterministic.
    d) It is implementation-defined whether the <SQL routine body> shall not contain an <SQL connection
       statement>, an <SQL schema statement>, an <SQL dynamic statement>, or an <SQL transaction
       statement> other than a <savepoint statement>, <release savepoint statement>, or a <rollback statement>
       that specifies a <savepoint clause>.
54) Subclause 11.62, “<sequence generator definition>”:
    a) If <sequence generator data type option> is not specified, then an implementation-defined exact numeric
       type DT with scale 0 (zero) is implicit.
55) Subclause 12.4, “<role definition>”:



1156 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)




    a) The Access Rules are implementation-defined.
56) Subclause 12.7, “<revoke statement>”:
    a) When loss of the USAGE privilege on a character set causes an SQL-client module to be determined
       to be a lost module, the impact on that SQL-client module is implementation-defined.
57) Subclause 13.1, “<SQL-client module definition>”:
    a) If the explicit or implicit <schema name> does not specify a <catalog name>, then an implementation-
       defined <catalog name> is implicit.
    b) If <module path specification> is not specified, then a <module path specification> containing an
       implementation-defined <schema name list> is implicit.
    c) If a <module character set specification> is not specified, then a <module character set specification>
       that specifies the implementation-defined character set that contains every character that is in <SQL
       language character> is implicit.
58) Subclause 14.1, “<declare cursor>”:
    a) Whether null values shall be considered greater than or less than all non-null values in determining the
       order of rows in a table associated with a <declare cursor> is implementation-defined.
    b) Whether an SQL-implementation is able to disallow significant changes that would not be visible
       through a currently open cursor is implementation-defined.
59) Subclause 14.2, “<open statement>”:
    a) The extent to which an SQL-implementation may disallow independent changes that are not significant
       is implementation-defined.
60) Subclause 14.6, “<delete statement: positioned>”:
    a) The extent to which an SQL-implementation may disallow independent changes that are not significant
       is implementation-defined.
    b) If there is any sensitive cursor CR that is open in the SQL-transaction in which this statement is being
       executed and CR has been held into a subsequent SQL-transaction, then whether the change resulting
       from the successful execution of this statement is made visible to CR is implementation-defined.
61) Subclause 14.7, “<delete statement: searched>”:
    a) The extent to which an SQL-implementation may disallow independent changes that are not significant
       is implementation-defined.
    b) If there is any sensitive cursor CR that is open in the SQL-transaction in which this statement is being
       executed and CR has been held into a subsequent SQL-transaction, then whether the change resulting
       from the successful execution of this statement is made visible to CR is implementation-defined.
62) Subclause 14.8, “<insert statement>”:
    a) The extent to which an SQL-implementation may disallow independent changes that are not significant
       is implementation-defined.




©ISO/IEC 2003 – All rights reserved                                    Implementation-defined elements 1157
ISO/IEC 9075-2:2003 (E)




    b) If there is any sensitive cursor CR that is open in the SQL-transaction in which this statement is being
       executed and CR has been held into a subsequent SQL-transaction, then whether the change resulting
       from the successful execution of this statement is made visible to CR is implementation-defined.
63) Subclause 14.9, “<merge statement>”:
    a) The extent to which an SQL-implementation may disallow independent changes that are not significant
       is implementation-defined.
    b) If there is any sensitive cursor CR that is open in the SQL-transaction in which this statement is being
       executed and CR has been held into a subsequent SQL-transaction, then whether the change resulting
       from the successful execution of this statement is made visible to CR is implementation-defined.
64) Subclause 14.10, “<update statement: positioned>”:
    a) The extent to which an SQL-implementation may disallow independent changes that are not significant
       is implementation-defined.
    b) If there is any sensitive cursor CR that is open in the SQL-transaction in which this statement is being
       executed and CR has been held into a subsequent SQL-transaction, then whether the change resulting
       from the successful execution of this statement is made visible to CR is implementation-defined.
65) Subclause 14.11, “<update statement: searched>”:
    a) The extent to which an SQL-implementation may disallow independent changes that are not significant
       is implementation-defined.
    b) If there is any sensitive cursor CR that is open in the SQL-transaction in which this statement is being
       executed and CR has been held into a subsequent SQL-transaction, then whether the change resulting
       from the successful execution of this statement is made visible to CR is implementation-defined.
66) Subclause 16.2, “<set transaction statement>”:
    a) The isolation level that is set for a transaction is an implementation-defined isolation level that will not
       exhibit any of the phenomena that the explicit or implicit <level of isolation> would not exhibit, as
       specified in Table 8, “SQL-transaction isolation levels and the three phenomena”.
67) Subclause 16.4, “<savepoint statement>”:
    a) The maximum number of savepoints per SQL-transaction is implementation-defined.
68) Subclause 16.7, “<rollback statement>”:
    a) The status of any open cursors in any SQL-client module associated with the current SQL-transaction
       that were opened by that SQL-transaction before the establishment of a savepoint to which a rollback
       is executed is implementation-defined.
69) Subclause 17.1, “<connect statement>”:
    a) If <connection user name> is not specified, then an implementation-defined <connection user name>
       for the SQL-connection is implicit.
    b) The initial value of the current role name is the null value.




1158 Foundation (SQL/Foundation)                                                    ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)




    c) The restrictions on whether or not the <connection user name> shall be identical to the <module
       authorization identifier> for the SQL-client module that contains the <externally-invoked procedure>
       that contains the <connect statement> are implementation-defined.
    d) If DEFAULT is specified, then the method by which the default SQL-server is determined is implemen-
       tation-defined.
    e) The method by which <SQL-server name> is used to determine the appropriate SQL-server is imple-
       mentation-defined.
70) Subclause 18.2, “<set session user identifier statement>”:
    a) Whether or not the <authorization identifier> for the SQL-session can be set to an <authorization
       identifier> other than the <authorization identifier> of the SQL-session when the SQL-session is started
       is implementation-defined, as are any restrictions pertaining to such changes.
71) Subclause 18.10, “<set session collation statement>”:
    a) If no <character set specification> is specified in a <set session collation statement>, then the character
       sets for which the SQL-session collations are set are implementation-defined.
72) Subclause 19.2, “<allocate descriptor statement>”:
    a) If WITH MAX <occurrences> is not specified, then an implementation-defined default value for
       <occurrences> that is greater than 0 (zero) is implicit.
    b) The maximum number of SQL descriptor areas and the maximum number of item descriptor areas for
       a single SQL descriptor area are implementation-defined.
73) Subclause 19.5, “<set descriptor statement>”:
    a) Restrictions on changing TYPE, LENGTH, OCTET_LENGTH, SCALE, COLLATION_CATALOG,
       COLLATION_SCHEMA, COLLATION_NAME, CHARACTER_SET_CATALOG, CHARAC-
       TER_SET_SCHEMA, and CHARACTER_SET_NAME values resulting from the execution of a
       <describe statement> before execution of an <execute statement>, <dynamic open statement>, or
       <dynamic fetch statement> are implementation-defined.
74) Subclause 19.6, “<prepare statement>”:
    a) The Format and Syntax Rules for a <preparable implementation-defined statement> are implementation-
       defined.
75) Subclause 19.9, “<describe statement>”:
    a) The character set of the data type of <descriptor name> is implementation-defined.
    b) If SR does not contain a single routine SQL-invoked R, then the values of PARAMETER_MODE,
       PARAMETER_ORDINAL_POSITION, PARAMETER_SPECIFIC_CATALOG, PARAMETER_SPE-
       CIFIC_SCHEMA, and PARAMETER_SPECIFIC_NAME in the descriptor for each <dynamic
       parameter specification> simply contained in the <call statement> are set to implementation-defined
       values.
76) Subclause 20.1, “<embedded SQL host program>”:
    a) If H does not contain an <embedded authorization declaration> that specifies SCHEMA, then the
       <schema name> of the <module authorization clause> of M is implementation-defined.


©ISO/IEC 2003 – All rights reserved                                      Implementation-defined elements 1159
ISO/IEC 9075-2:2003 (E)




   b) If H does not contain an <embedded authorization declaration>, then M contains a <module authorization
      clause> that specifies “SCHEMA SN”, where SN is an implementation-defined <schema name>.
   c) If an <embedded character set declaration> is not specified, then an <embedded character set declaration>
      containing an implementation-defined <character set specification> is implicit.
   d) Each <allocate cursor statement> is replaced with a host language procedure or subroutine call of an
      implementation-defined procedure that associates the <dynamic cursor name> with the prepared
      statement.
   e) If an <embedded SQL host program> does not contain an <embedded path specification>, then the
      implied module contains an implementation-defined <module path specification>.
77) Subclause 20.4, “<embedded SQL C program>”:
   a) The implicit character set in a <C character variable>, a <C VARCHAR variable>, or a <C CLOB
      variable>is implementation-defined.
78) Subclause 20.5, “<embedded SQL COBOL program>”:
   a) The COBOL data description clauses, in addition to the PICTURE, SIGN, USAGE and VALUE clauses,
      that may appear in a <COBOL variable definition> are implementation-defined.
79) Subclause 20.9, “<embedded SQL PL/I program>”:
   a) The PL/I data description clauses, in addition to the <PL/I type specification> and the INITIAL clause,
      that may appear in a <PL/I variable definition> are implementation-defined.
80) Subclause 21.1, “<direct SQL statement>”:
   a) The <value specification> that represents the null value is implementation-defined.
   b) The Format, Syntax Rules, and Access Rules for <direct implementation-defined statement> are
      implementation-defined.
   c) Whether a <direct implementation-defined statement> may be associated with an active transaction is
      implementation-defined.
   d) Whether a <direct implementation-defined statement> initiates a transaction is implementation-defined.
81) Subclause 22.1, “<get diagnostics statement>”:
   a) The actual length of variable-length character items in the diagnostics area is implementation-defined
      but not less than 128.
   b) The character string value set for CLASS_ORIGIN and SUBCLASS_ORIGIN for an implementation-
      defined class code or subclass code is implementation-defined, but shall not be 'ISO 9075'.
   c) The value of MESSAGE_TEXT is an implementation-defined character string.
   d) Negative values of COMMAND_FUNCTION_CODE are implementation-defined and indicate
      implementation-defined SQL-statements.
82) Subclause 23.1, “SQLSTATE”:
   a) The character set associated with the class value and subclass value of the SQLSTATE parameter is
      implementation-defined.


1160 Foundation (SQL/Foundation)                                                 ©ISO/IEC 2003 – All rights reserved
                                                                                                 ISO/IEC 9075-2:2003 (E)




    b) The values and meanings for classes and subclasses that begin with one of the <digit>s '5', '6', '7', '8',
       or '9' or one of the <simple Latin upper case letter>s 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',
       'V', 'W', 'X', 'Y', or 'Z' are implementation-defined. The values and meanings for all subclasses that are
       associated with implementation-defined class values are implementation-defined.
83) Clause 24, “Conformance”:
    a) The method of flagging nonconforming SQL language or processing of conforming SQL language is
       implementation-defined, as is the list of additional <key word>s that may be required by the SQL-
       implementation.




©ISO/IEC 2003 – All rights reserved                                              Implementation-defined elements 1161
ISO/IEC 9075-2:2003 (E)




                                   This page intentionally left blank.




1162 Foundation (SQL/Foundation)                                         ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)




                                                  Annex C
                                                (informative)

                                      Implementation-dependent elements

This Annex references those places where this part of ISO/IEC 9075 states explicitly that the actions of a con-
forming SQL-implementation are implementation-dependent.
1) Subclause 3.1.6, “Definitions provided in Part 2”:
    a) Whether two non-null values of user-defined type whose comprison form is RELATIVE or MAP that
       result in Unknown when tested for equality according to the rules of Subclause 8.2, “<comparison
       predicate>”, are distinct or not is implementation-dependent.
2) Subclause 4.1, “Data types”:
    a) The physical representation of a value of a data type is implementation-dependent.
    b) The null value or values for each data type is implementation-dependent.
3) Subclause 4.14, “Tables”:
    a) Because global temporary table contents are distinct within SQL-sessions, and created local temporary
       tables are distinct within SQL-client modules within SQL-sessions, the effective <schema name> of
       the schema in which the global temporary table or the created local temporary table is instantiated is
       an implementation-dependent <schema name> that may be thought of as having been effectively derived
       from the <schema name> of the schema in which the global temporary table or created local temporary
       table is defined and the implementation-dependent SQL-session identifier associated with the SQL-
       session.
    b) The effective <schema name> of the schema in which the created local temporary table is instantiated
       may be thought of as being further qualified by a unique implementation-dependent name associated
       with the SQL-client module in which the created local temporary table is referenced.
4) Subclause 4.14.9, “Windowed tables”:
    a) The window name of a window defined implicitly by an <in-line window specification> is implemen-
       tation-dependent.
5) Subclause 4.30, “Diagnostics area”:
    a) The condition area limit is implementation-dependent when not explicitly specified.
    b) The ordering of the information about conditions placed into the diagnostics area is implementation-
       dependent, except that the first condition in the diagnostics area always corresponds to the condition
       corresponding to the SQLSTATE value.
    c) The maximum number of diagnostics area in a diagnostics area stack is implementation-defined.



©ISO/IEC 2003 – All rights reserved                                 Implementation-dependent elements 1163
ISO/IEC 9075-2:2003 (E)




6) Subclause 4.32, “Cursors”:
    a) If the <declare cursor> does not contain an <order by clause>, or contains an <order by clause> that
       does not specify the order of the rows completely, then the rows of the table have an order that is defined
       only to the extent that the <order by clause> specifies an order and is otherwise implementation-
       dependent.
    b) The effect on the position and state of an open cursor when an error occurs during the execution of an
       SQL-statement that identifies the cursor is implementation-dependent.
    c) If an asensitive cursor is open and a change is made to SQL-data from within the same SQL-transaction
       other than through that cursor, then whether that change will be visible through that cursor before it is
       closed is implementation-dependent.
7) Subclause 4.34, “Basic security model”:
    a) The mapping of <authorization identifier>s to operating system users is implementation-dependent.
8) Subclause 4.35, “SQL-transactions”:
    a) The schema definitions that are implicitly read on behalf of executing an SQL-statement are implemen-
       tation-dependent.
9) Subclause 4.37, “SQL-sessions”:
    a) A unique implementation-dependent SQL-session identifier is associated with each SQL-session.
10) Subclause 4.39, “Client-server operation”:
    a) The <SQL-client module name> of the SQL-client module that is effectively materialized on an SQL-
       server is implementation-dependent.
    b) Following the execution of an <SQL procedure statement> by an SQL-server, diagnostic information
       is passed in an implementation-dependent manner into the SQL-agent's diagnostics area stack in the
       SQL-client.
    c) The effect on diagnostic information of incompatibilities between the character repertoires supported
       by the SQL-client and SQL-server environments is implementation-dependent.
11) Subclause 6.7, “<column reference>”:
    a) If QCR is a group-invariant column reference and the most specific type of QCR is character string,
       datetime with time zone, or a user-defined type, then QCR denotes an implementation-dependent value
       that is not distinct from the value of C in every row of a given group of the qualifying query of QCR.
12) Subclause 6.9, “<set function specification>”:
    a) The maximum or minimum of a set of values of a user-defined type is implementation-dependent if
       the comparison of at least two values of the set results in Unknown.
13) Subclause 6.12, “<cast specification>”:
    a) When a multiset is cast to an array type, the order of elements in the result is implementation-dependent.
14) Subclause 6.31, “<datetime value function>”:




1164 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)




    a) The time of evaluation of the CURRENT_DATE, CURRENT_TIME, and CURRENT_TIMESTAMP
       functions during the execution of an SQL-statement is implementation-dependent.
15) Subclause 6.32, “<interval value expression>”:
    a) The start datetime used for converting intervals to scalars for subtraction purposes is implementation-
       dependent.
16) Subclause 6.36, “<array value constructor>”:
    a) The order of array elements in the result of an <array value constructor by query> which is not decided
       by the <order by clause> is implementation-dependent.
17) Subclause 7.1, “<row value constructor>”:
    a) The names of the fields of a <row value constructor> that specifies a <row value constructor element
       list> are implementation-dependent.
    b) The names of the fields of a <contextually typed row value constructor> are implementation-dependent.
18) Subclause 7.3, “<table value constructor>”:
    a) The column names of a <table value constructor> or a <contextually typed table value constructor>
       are implementation-dependent.
19) Subclause 7.9, “<group by clause>”:
    a) If the declared type of a grouping column is a user-defined type and the comparison of that column for
       two rows results in Unknown, then the assignment of those rows to groups in the result of the <group
       by clause> is implementation-dependent.
    b) When a <search condition> or <value expression> is applied to a group, the value of a group-invariant
       column reference whose most specific type is character string, datetime with time zone or a user-defined
       type, and that references a column that is functionally dependent on the grouping columns is implemen-
       tation-dependent.
20) Subclause 7.11, “<window clause>”:
    a) If the window ordering clause of a window structure descriptor is absent, then the window ordering is
       implementation-dependent.
    b) The window ordering of peer rows within a window partition is implementation-dependent, but the
       window ordering shall be the same for all window structure descriptors that are order-equivalent. It
       shall also be the same for windows W1 and W2 if W1 is the ordering window for W2.
21) Subclause 7.12, “<query specification>”:
    a) When a column is not named by an <as clause> and is not derived from a single column reference,
       then the name of the column is implementation-dependent.
    b) If the <set quantifier> DISTINCT is specified, and the most specific type of a result column is character
       string, datetime with time zone or a user-defined type, then the precise values retained in that column
       after eliminating redundant duplicates is implementation-dependent.
22) Subclause 7.13, “<query expression>”:



©ISO/IEC 2003 – All rights reserved                                  Implementation-dependent elements 1165
ISO/IEC 9075-2:2003 (E)




    a) If a <simple table> is neither a <query specification> nor an <explicit table>, then the name of each
       column of the <simple table> is implementation-dependent.
    b) If a <query term> immediately contains INTERSECT and the <column name>s of a pair of corresponding
       columns of the operand tables are not equivalent, then the result column has an implementation-
       dependent <column name>.
    c) If a <query expression body> immediately contains UNION or INTERSECT, and the <column name>s
       of a pair of corresponding columns of the operand tables are not equivalent, then the result column has
       an implementation-dependent <column name>.
23) Subclause 8.2, “<comparison predicate>”:
    a) When the operations MAX, MIN, DISTINCT, and references to a grouping column refer to a variable-
       length character string, the specific value selected from the set of equal values is implementation-
       dependent.
24) Subclause 10.4, “<routine invocation>”:
    a) Each SQL argument Ai in SAL is evaluated, in an implementation-dependent order, to obtain a value
       Vi.

25) Subclause 10.9, “<aggregate function>”:
    a) If the declared type of the argument of MAX or MIN is a user-defined type and the comparison of two
       values results in Unknown, then the maximum or minimum is implementation-dependent.
26) Subclause 10.10, “<sort specification list>”:
    a) If PVi and QVi are not null and the result of “PVi <comp op> QVi” is Unknown, then the relative
       ordering of PViand QVi is implementation-dependent.

    b) The relative ordering of two rows that are not distinct with respect to the <sort specification> is
       implementation-dependent.
27) Subclause 11.6, “<table constraint definition>”:
    a) The <constraint name> of a constraint that does not specify a <constraint name definition> is imple-
       mentation-dependent.
28) Subclause 11.8, “<referential constraint definition>”:
    a) The specific value to use for cascading among various values that are not distinct is implementation-
       dependent.
29) Subclause 11.24, “<domain definition>”:
    a) The <constraint name> of a constraint that does not specify a <constraint name definition> is imple-
       mentation-dependent.
30) Subclause 11.33, “<collation definition>”:
    a) The collation of characters for which a collation is not otherwise specified is implementation-dependent.
31) Subclause 14.1, “<declare cursor>”:



1166 Foundation (SQL/Foundation)                                                  ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)




    a) If a <declare cursor> does not contain an <order by clause>, then the ordering of rows in the table
       associated with that <declare cursor> is implementation-dependent.
    b) If a <declare cursor> contains an <order by clause> and a group of two or more rows in the table
       associated with that <declare cursor> contain values that
         Case:
         i)       are the same null value, or
         ii)      compare equal according to Subclause 8.2, “<comparison predicate>”
         in all columns specified in the <order by clause>, then the order in which rows in that group are returned
         is implementation-dependent.
    c) The relative ordering of two non-null values of a user-defined type UDT whose comparison as determined
       by the user-defined ordering of UDT is Unknown is implementation-dependent.
32) Subclause 14.3, “<fetch statement>”:
    a) The order of assignment to targets in the <fetch target list> of values returned by a <fetch statement>,
       other than status parameters, is implementation-dependent.
    b) If an error occurs during assignment of a value to a target during the execution of a <select statement:
       single row>, then the values of targets other than status parameters are implementation-dependent.
    c) If an exception condition occurs during the assignment of a value to a target, then the values of all
       targets are implementation-dependent and CR remains positioned on the current row.
    d) It is implementation-dependent whether CR remains positioned on the current row when an exception
       condition is raised during the derivation of any <derived column>.
33) Subclause 14.5, “<select statement: single row>”:
    a) The order of assignment to targets in the <select target list> of values returned by a <select statement:
       single row>, other than status parameters, is implementation-dependent.
    b) If the cardinality of the <query expression> is greater than 1 (one), then it is implementation-dependent
       whether or not values are assigned to the targets identified by the <select target list>.
    c) If an error occurs during assignment of a value to a target during the execution of a <select statement:
       single row>, then the values of targets other than status parameters are implementation-dependent.
34) Subclause 14.8, “<insert statement>”:
    a) The generation of the value of a derived self-referencing column is implementation-dependent.
35) Subclause 14.9, “<merge statement>”:
    a) The generation of the value of a derived self-referencing column is implementation-dependent.
36) Subclause 16.2, “<set transaction statement>”:
    a) If <number of conditions> is not specified, then an implementation-dependent value not less than 1
       (one) is implicit.
37) Subclause 17.3, “<disconnect statement>”:


©ISO/IEC 2003 – All rights reserved                                    Implementation-dependent elements 1167
ISO/IEC 9075-2:2003 (E)




    a) If ALL is specified, then L is a list representing every active SQL-connection that has been established
       by a <connect statement> by the current SQL-agent and that has not yet been disconnected by a <dis-
       connect statement>, in an implementation-dependent order.
38) Subclause 19.4, “<get descriptor statement>”:
    a) If an exception condition is raised in a <get descriptor statement>, then the values of all targets specified
       by <simple target specification 1> and <simple target specification 2> are implementation-dependent.
    b) For a <dynamic parameter specification>, the value of UNNAMED is 1 (one) and the value of NAME
       is implementation-dependent.
    c) The value retrieved by a <get descriptor statement> for any field whose value is undefined is imple-
       mentation-dependent.
39) Subclause 19.5, “<set descriptor statement>”:
    a) If an exception condition is raised in a <set descriptor statement>, then the values of all elements of
       the descriptor specified in the <set descriptor statement> are implementation-dependent.
40) Subclause 19.6, “<prepare statement>”:
    a) The validity of an <extended statement name> value or a <statement name> in an SQL-transaction
       different from the one in which the statement was prepared is implementation-dependent.
41) Subclause 19.10, “<input using clause>”:
    a) When a <describe input statement> is used, the values for NAME, DATA, and INDICATOR in the
       SQL dynamic descriptor area structure is implementation-dependent. If TYPE indicates a character
       string type or a binary large object type, then the values of SCALE and PRECISION are implementation-
       dependent. If TYPE indicates an exact or approximate numeric type, then the values of LENGTH and
       OCTET_LENGTH are implementation-dependent. If TYPE indicates a boolean type, then the values
       of PRECISION, SCALE, LENGTH, and OCTET_LENGTH are implementation-dependent.
42) Subclause 19.11, “<output using clause>”:
    a) When a <describe output statement> is executed, the values of DATA and INDICATOR are implemen-
       tation-dependent. If TYPE indicates a character string type or a binary large object type, then the values
       of SCALE and PRECISION are implementation-dependent. If TYPE indicates an exact or approximate
       numeric type, then the values of LENGTH and OCTET_LENGTH are implementation-dependent. If
       TYPE indicates a boolean type, then the values of PRECISION, SCALE, LENGTH, and
       OCTET_LENGTH are implementation-dependent.
43) Subclause 20.1, “<embedded SQL host program>”:
    a) The <SQL-client module name> of the implied <SQL-client module definition> derived from an
       <embedded SQL host program> is implementation-dependent.
    b) If an <embedded SQL host program> does not contain an <embedded authorization declaration>, then
       the <module authorization identifier> of the implied <SQL-client module definition> derived from the
       <embedded SQL host program> is implementation-dependent.
    c) In each <declare cursor> in the implied <SQL-client module definition> derived from an <embedded
       SQL host program>, each <embedded variable name> has been replaced consistently with a distinct
       <host parameter name> that is implementation-dependent.


1168 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)




    d) The <procedure name> of each <externally-invoked procedure> in the implied <SQL-client module
       definition> derived from an <embedded SQL host program> is implementation-dependent.
    e) In each <externally-invoked procedure> in the implied <SQL-client module definition> derived from
       an <embedded SQL host program>, each <embedded variable name> has been replaced consistently
       with a distinct <host parameter name> that is implementation-dependent.
    f) For <SQL procedure statement>s other than <open statement>s, whether one <externally-invoked
       procedure> in the implied <SQL-client module definition> derived from an <embedded SQL host
       program> can correspond to more than one <SQL procedure statement> in the <embedded SQL host
       program> is implementation-dependent.
    g) In each <externally-invoked procedure> in the implied <SQL-client module definition> derived from
       an <embedded SQL host program>, the order of the instances of <host parameter declaration> is
       implementation-dependent.
44) Subclause 21.1, “<direct SQL statement>”:
    a) A <commit statement> or a <rollback statement> is executed. If an unrecoverable error has occurred,
       or if the direct invocation of SQL terminated unexpectedly, or if any constraint is not satisfied, then a
       <rollback statement> is performed. Otherwise, the choice of which of these SQL-statements to perform
       is implementation-dependent. The determination of whether a direct invocation of SQL has terminated
       unexpectedly is implementation-dependent.
45) Subclause 22.1, “<get diagnostics statement>”:
    a) The value of ROW_COUNT following the execution of an SQL-statement that does not directly result
       in the execution of a <delete statement: searched>, an <insert statement>, a <merge statement>, or an
       <update statement: searched> is implementation-dependent.
    b) If <condition number> has a value other than 1 (one), then the association between <condition number>
       values and specific conditions raised during evaluation of the General Rules for that SQL-statement is
       implementation-dependent.




©ISO/IEC 2003 – All rights reserved                                  Implementation-dependent elements 1169
ISO/IEC 9075-2:2003 (E)




                                   This page intentionally left blank.




1170 Foundation (SQL/Foundation)                                         ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)




                                                   Annex D
                                                (informative)

                                          Deprecated features

It is intended that the following features will be removed at a later date from a revised version of this part of
ISO/IEC 9075:
1) The use of the keyword EXCEPTION to mean the same as the keyword CONDITION has been deprecated.




©ISO/IEC 2003 – All rights reserved                                                    Deprecated features 1171
ISO/IEC 9075-2:2003 (E)




                                   This page intentionally left blank.




1172 Foundation (SQL/Foundation)                                         ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)




                                                  Annex E
                                               (informative)

                               Incompatibilities with ISO/IEC 9075:1999

This edition of this part of ISO/IEC 9075 introduces some incompatibilities with the earlier version of Database
Language SQL as specified in ISO/IEC 9075-2:1999.
Except as specified in this Annex, features and capabilities of Database Language SQL are compatible with
ISO/IEC 9075-2:1999.
1) In ISO/IEC 9075-2:1999, the regular expression used in the <similar predicate> required a particular set
   of distinguished characters. In this edition of ISO/IEC 9075, the following additional characters are distin-
   guished characters:
    — <question mark>
    — <left brace>
    — <right brace>
2) ISO/IEC 9075-2:1999 defined data types called BIT and BIT VARYING. These data types have been
   deleted from this edition of ISO/IEC 9075.
3) In ISO/IEC 9075-2:1999, it was not permitted to use a <routine name> to qualify an <SQL parameter ref-
   erence>. This gives rise to an incompatibility with ISO/IEC 9075 in the case where a routine has the same
   name as one of its parameters, the declared type of that parameter is such that it has components that can
   be referenced using “dot notation”, and one of those components has the same name as one of the other
   parameters.
    For example, if function F has a parameter named P and another parameter named F of type ROW(P
    INTEGER), then "F.P" can be a reference to either the parameter P or the field P of the parameter F and is
    thus a syntax error. In ISO/IEC 9075-2:1999, it unambiguously references the field.
4) In ISO/IEC 9075-2:1999, <predicate>s such as “A = B = C” were permitted, although the BNF did not
   indicate whether to interpret this as left associative (“(A = B) = C”) or right associative (“A = (B = C)”).
   In this edition of ISO/IEC 9075, all <predicate>s are non-associative; for example, “A = B = C” is prohibited,
   although the explicit syntax “(A = B) = C” or “A = (B = C)” is permitted.
5) In ISO/IEC 9075-2:1999, the <column name> of a <derived column> that is not a column reference and
   does not specify an <as clause> is implementation-dependent, though subject to the requirement that the
   <column name> shall not be equivalent to the <column name> of any column, other than itself, of a table
   referenced by any <table reference> contained in the SQL-statement. This edition of ISO/IEC 9075 has
   eliminated the latter requirement.
6) In ISO/IEC 9075-2:1999, a <query expression body>, <query term>, or <query primary> could consist of
   a <joined table>. None of those three elements can consist of a <joined table> in this edition of ISO/IEC
   9075.


©ISO/IEC 2003 – All rights reserved                             Incompatibilities with ISO/IEC 9075:1999 1173
ISO/IEC 9075-2:2003 (E)




7) In ISO/IEC 9075-2:1999, the columns of a table created by a <table definition> that contains a <like clause>
   inherit only the column names and the data types of the columns of the original table. In this edition of
   ISO/IEC 9075, the columns also inherit the nullability charactistics of the columns of the original table.
8) In ISO/IEC 9075-2:1999 and ISO/IEC 9075-4:1999, a <savepoint statement> that specifies the name of
   an existing savepoint SP, executed by either of the following, causes SP to be destroyed:
    — An atomic <compound statement> (see ISO/IEC 9075-4).
    — A <triggered SQL statement>.
    In this edition of ISO/IEC 9075, SP is destroyed only if it exists in the current savepoint level.
9) In ISO/IEC 9075-2:1999 and ISO/IEC 9075-4:1999, a <release savepoint statement> specifying savepoint
   name SP, executed by either of the following, causes SP to be destroyed:
    — An atomic <compound statement>.
    — A <triggered SQL statement>.
    In this edition of ISO/IEC 9075, SP is destroyed only if SP was established in the current savepoint level.
10) In ISO/IEC 9075-2:1999, <column options> could contain a <collate clause>. This functionality has been
    removed.
11) In ISO/IEC 9075-2:1999, the Syntax Rules of Subclause 11.4, “<column definition>”, permitted a <column
    definition> to contains both a <domain name> and a <collate clause>. That functionality was not satisfac-
    torily specified and has been removed from this edition of ISO/IEC 9075.
12) In ISO/IEC 9075-2:1999, the Identifiers associated with SQL-statement codes 54 and 55 in Table 31, “SQL-
    statement codes”, were “DYNAMIC DELETE CURSOR” and “DYNAMIC UPDATE CURSOR”,
    respectively. In this edition of ISO/IEC 9075, to better distinguish those two SQL-statement codes, the
    Identifiers have been changed to “PREPARABLE DYNAMIC DELETE CURSOR” and “PREPARABLE
    DYNAMIC UPDATE CURSOR”, respectively.
13) In ISO/IEC 9075-2:1999, a <case abbreviation> could contain a <value expression> that contains a <routine
    invocation> whose subject routine is an SQL-invoked routine that is possibly non-deterministic or that
    possibly modifies SQL-data. In this edition of ISO/IEC 9075, that capability has been removed.
14) In ISO/IEC 9075-2:1999, <joined table> contained a UNION JOIN alternative. This edition of ISO/IEC
    9075 removes that alternative.
15) ISO/IEC 9075-2:1999 defined the character represented by the Unicode code point U+FEFF (Zero Width
    No-Break Space) as being one of those used to separate tokens. U+FEFF is not so defined in this edition
    of ISO/IEC 9075.
16) In ISO/IEC 9075:1999, <field definition>, <column definition>, and <attribute definition> could contain
    <reference scope check>. That functionality was not satisfactorily specified and has been removed from
    this edition of ISO/IEC 9075.
17) A number of additional <reserved word>s have been added to the language. These <reserved word>s are:
    — ATOMIC
    — BIGINT



1174 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                           ISO/IEC 9075-2:2003 (E)




    — COLLECT
    — CONDITION
    — ELEMENT
    — FUSION
    — INTERSECTION
    — MEMBER
    — MERGE
    — MULTISET
    — NORMALIZE
    — SUBMULTISET
    — TABLESAMPLE
    — UESCAPE




©ISO/IEC 2003 – All rights reserved   Incompatibilities with ISO/IEC 9075:1999 1175
ISO/IEC 9075-2:2003 (E)




                                   This page intentionally left blank.




1176 Foundation (SQL/Foundation)                                         ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)




                                                    Annex F
                                                  (informative)

                                          SQL feature taxonomy

This Annex describes a taxonomy of features and packages defined in this part of ISO/IEC 9075.
Table 35, “Feature taxonomy and definition for mandatory features”, contains a taxonomy of the mandatory
features of SQL language that are specified in this part of ISO/IEC 9075. Table 36, “Feature taxonomy for
optional features”, contains a taxonomy of the optional features of the SQL language that are specified in this
part of ISO/IEC 9075.
In these tables, the first column contains a counter that may be used to quickly locate rows of the table; these
values otherwise have no use and are not stable — that is, they are subject to change in future editions of or
even Technical Corrigenda to ISO/IEC 9075 without notice.
The “Feature ID” column of Table 35, “Feature taxonomy and definition for mandatory features”, and of
Table 36, “Feature taxonomy for optional features”, specifies the formal identification of each feature and each
subfeature contained in the table.
The “Feature Name” column of Table 35, “Feature taxonomy and definition for mandatory features”, contains
a brief description of the feature or subfeature associated with the Feature ID value.
The “Feature Description” column of Table 35, “Feature taxonomy and definition for mandatory features”,
provides the only definition of the mandatory features of this part of ISO/IEC 9075. This definition consists of
indications of specific language elements supported in each feature, subject to the constraints of all Syntax
Rules, Access Rules, and Conformance Rules.

                     Table 35 — Feature taxonomy and definition for mandatory features


         Feature ID          Feature Name                 Feature Description

 1       E011                Numeric data types           Subclause 6.1, “<data type>”, <numeric type>,
                                                          including numeric expressions, numeric literals,
                                                          numeric comparisons, and numeric assignments

 2       E011-01             INTEGER and SMALLINT         — Subclause 5.2, “<token> and <separator>”:
                             data types (including all    The <reserved word>s INT, INTEGER, and
                             spellings)                   SMALLINT — Subclause 5.3, “<literal>”:
                                                          [<sign>] <unsigned integer> —
                                                          Subclause 6.1, “<data type>”: The INTEGER
                                                          and SMALLINT <exact numeric type>s —
                                                          Subclause 13.6, “Data type correspondences”:
                                                          Type correspondences for INTEGER and
                                                          SMALLINT for all supported languages


©ISO/IEC 2003 – All rights reserved                                                SQL feature taxonomy 1177
ISO/IEC 9075-2:2003 (E)




       Feature ID     Feature Name                 Feature Description

 3     E011-02        REAL, DOUBLE PRECISON, — Subclause 5.2, “<token> and <separator>”:
                      and FLOAT data types   The <reserved word>s REAL, DOUBLE,
                                             FLOAT, and PRECISION — Subclause 5.3,
                                             “<literal>”: [<sign>] <approximate
                                             numeric literal> — Subclause 6.1, “<data
                                             type>”: <approximate numeric type> —
                                             Subclause 13.6, “Data type correspondences”:
                                             Type correspondences for REAL, DOUBLE
                                             PRECISION, and FLOAT for all supported lan-
                                             guages

 4     E011-03        DECIMAL and NUMERIC          — Subclause 5.2, “<token> and <separator>”:
                      data types                   The <reserved word>s DEC, DECIMAL, and
                                                   NUMERIC — Subclause 5.3, “<literal>”:
                                                   [<sign>] <exact numeric literal>
                                                   — Subclause 6.1, “<data type>”: The DECIMAL
                                                   and NUMERIC <exact numeric type>s —
                                                   Subclause 13.6, “Data type correspondences”:
                                                   Type correspondences for DECIMAL and
                                                   NUMERIC for all supported languages

 5     E011-04        Arithmetic operators         — Subclause 6.26, “<numeric value expres-
                                                   sion>”: When the <numeric primary> is a <value
                                                   expression primary>

 6     E011-05        Numeric comparison           — Subclause 8.2, “<comparison predicate>”: For
                                                   the numeric data types, without support for <table
                                                   subquery> and without support for Feature F131,
                                                   “Grouped operations”

 7     E011-06        Implicit casting among the   — Subclause 8.2, “<comparison predicate>”:
                      numeric data types           Values of any of the numeric data types can be
                                                   compared to each other; such values are compared
                                                   with respect to their algebraic values —
                                                   Subclause 9.1, “Retrieval assignment”, and
                                                   Subclause 9.2, “Store assignment”: Values of one
                                                   numeric type can be assigned to another numeric
                                                   type, subject to rounding, truncation, and out of
                                                   range conditions

 8     E021           Character string types       — Subclause 6.1, “<data type>”: <character string
                                                   type>, including character expressions, character
                                                   literals, character comparisons, character assign-
                                                   ments, and other operations on character data




1178 Foundation (SQL/Foundation)                                           ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)




         Feature ID          Feature Name                    Feature Description

 9       E021-01             CHARACTER data type             — Subclause 5.2, “<token> and <separator>”:
                             (including all its spellings)   The <reserved word>s CHAR and CHARACTER
                                                             — Subclause 6.1, “<data type>”: The CHARAC-
                                                             TER <character string type> — Subclause 6.28,
                                                             “<string value expression>”: For values of type
                                                             CHARACTER — Subclause 13.6, “Data type
                                                             correspondences”: Type correspondences for
                                                             CHARACTER for all supported languages

 10      E021-02             CHARACTER VARYING               — Subclause 5.2, “<token> and <separator>”:
                             data type (including all its    The <reserved word>s VARCHAR and VARY-
                             spellings)                      ING — Subclause 6.1, “<data type>”: The
                                                             CHARACTER VARYING <character string
                                                             type> — Subclause 6.28, “<string value expres-
                                                             sion>”: For values of type CHARACTER
                                                             VARYING — Subclause 13.6, “Data type corre-
                                                             spondences”: Type correspondences for CHAR-
                                                             ACTER VARYING for all supported languages

 11      E021-03             Character literals              — Subclause 5.3, “<literal>”: <quote> [
                                                             <character representation>... ]
                                                             <quote>

 12      E021-04             CHARACTER_LENGTH                — Subclause 6.27, “<numeric value function>”:
                             function                        The <char length expression>

 13      E021-05             OCTET_LENGTH function           — Subclause 6.27, “<numeric value function>”:
                                                             The <octet length expression>

 14      E021-06             SUBSTRING function              — Subclause 6.29, “<string value function>”:
                                                             The <character substring function>

 15      E021-07             Character concatenation         — Subclause 6.28, “<string value expression>”:
                                                             The <concatenation> expression

 16      E021-08             UPPER and LOWER functions — Subclause 6.29, “<string value function>”:
                                                       The <fold> function

 17      E021-09             TRIM function                   — Subclause 6.29, “<string value function>”:
                                                             The <trim function>




©ISO/IEC 2003 – All rights reserved                                                 SQL feature taxonomy 1179
ISO/IEC 9075-2:2003 (E)




       Feature ID     Feature Name                    Feature Description

 18    E021-10        Implicit casting among the      — Subclause 8.2, “<comparison predicate>”:
                      fixed-length and variable-      Values of either the CHARACTER or CHARAC-
                      length character string types   TER VARYING data types can be compared to
                                                      each other — Subclause 9.1, “Retrieval assign-
                                                      ment”, and Subclause 9.2, “Store assignment”:
                                                      Values of either the CHARACTER or CHARAC-
                                                      TER VARYING data type can be assigned to the
                                                      other type, subject to truncation conditions

 19    E021-11        POSITION function               — Subclause 6.27, “<numeric value function>”:
                                                      The <position expression>

 20    E021-12        Character comparison            — Subclause 8.2, “<comparison predicate>”: For
                                                      the CHARACTER and CHARACTER VARY-
                                                      ING data types, without support for <table sub-
                                                      query> and without support for Feature F131,
                                                      “Grouped operations”

 21    E031           Identifiers                     — Subclause 5.2, “<token> and <separator>”:
                                                      <regular identifier> and <delimited identifier>

 22    E031-01        Delimited identifiers           — Subclause 5.2, “<token> and <separator>”:
                                                      <delimited identifier>

 23    E031-02        Lower case identifiers          — Subclause 5.2, “<token> and <separator>”:
                                                      An alphabetic character in a <regular identifier>
                                                      can be either lower case or upper case (meaning
                                                      that non-delimited identifiers need not comprise
                                                      only upper case letters)

 24    E031-03        Trailing underscore             — Subclause 5.2, “<token> and <separator>”:
                                                      The list <identifier part> in a <regular identifier>
                                                      can be an <underscore>

 25    E051           Basic query specification       — Subclause 7.12, “<query specification>”:
                                                      When <table reference> is a <table or query
                                                      name> that is a <table name>, without the support
                                                      of Feature F131, “Grouped operations”

 26    E051-01        SELECT DISTINCT                 — Subclause 7.12, “<query specification>”: With
                                                      a <set quantifier> of DISTINCT, but without
                                                      subfeatures E051-02 through E051-09




1180 Foundation (SQL/Foundation)                                               ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)




         Feature ID          Feature Name                   Feature Description

 27      E051-02             GROUP BY clause                — Subclause 7.4, “<table expression>”: <group
                                                            by clause>, but without subfeatures E051-04
                                                            through E051-09 — Subclause 7.9, “<group by
                                                            clause>”: With the restrictions that the <group
                                                            by clause> shall contain all non-aggregated
                                                            columns in the <select list> and that any column
                                                            in the <group by clause> shall also appear in the
                                                            <select list>

 28      E051-04             GROUP BY can contain           — Subclause 7.9, “<group by clause>”: Without
                             columns not in <select list>   the restriction that any column in the <group by
                                                            clause> shall also appear in the <select list>

 29      E051-05             Select list items can be       — Subclause 7.12, “<query specification>”: <as
                             renamed                        clause>

 30      E051-06             HAVING clause                  — Subclause 7.4, “<table expression>”: <having
                                                            clause> — Subclause 7.10, “<having clause>”

 31      E051-07             Qualified * in select list     — Subclause 7.12, “<query specification>”:
                                                            <qualified asterisk>

 32      E051-08             Correlation names in the       — Subclause 7.6, “<table reference>”: [ AS ]
                             FROM clause                    <correlation name>

 33      E051-09             Rename columns in the FROM — Subclause 7.6, “<table reference>”: [ AS ]
                             clause                     <correlation name> [ <left paren>
                                                        <derived column list> <right
                                                        paren> ]

 34      E061                Basic predicates and search    — Subclause 8.19, “<search condition>”, and
                             conditions                     Subclause 8.1, “<predicate>”

 35      E061-01             Comparison predicate           — Subclause 8.2, “<comparison predicate>”: For
                                                            supported data types, without support for <table
                                                            subquery>

 36      E061-02             BETWEEN predicate              — Subclause 8.3, “<between predicate>”

 37      E061-03             IN predicate with list of values — Subclause 8.4, “<in predicate>”: Without
                                                              support for <table subquery>

 38      E061-04             LIKE predicate                 — Subclause 8.5, “<like predicate>”: Without [
                                                            ESCAPE <escape character> ]

 39      E061-05             LIKE predicate: ESCAPE         — Subclause 8.5, “<like predicate>”: With [
                             clause                         ESCAPE <escape character> ]




©ISO/IEC 2003 – All rights reserved                                                 SQL feature taxonomy 1181
ISO/IEC 9075-2:2003 (E)




       Feature ID     Feature Name                    Feature Description

 40    E061-06        NULL predicate                  — Subclause 8.7, “<null predicate>”: Without
                                                      Feature F481, “Expanded NULL predicate”

 41    E061-07        Quantified comparison predi-    — Subclause 8.8, “<quantified comparison
                      cate                            predicate>”: Without support for <table sub-
                                                      query>

 42    E061-08        EXISTS predicate                — Subclause 8.9, “<exists predicate>”

 43    E061-09        Subqueries in comparison        — Subclause 8.2, “<comparison predicate>”: For
                      predicate                       supported data types, with support for <table
                                                      subquery>

 44    E061-11        Subqueries in IN predicate      — Subclause 8.4, “<in predicate>”: With support
                                                      for <table subquery>

 45    E061-12        Subqueries in quantified com-   — Subclause 8.8, “<quantified comparison
                      parison predicate               predicate>”: With support for <table subquery>

 46    E061-13        Correlated subqueries           — Subclause 8.1, “<predicate>”: When a <corre-
                                                      lation name> can be used in a <table subquery>
                                                      as a correlated reference to a column in the outer
                                                      query

 47    E061-14        Search condition                — Subclause 8.19, “<search condition>”

 48    E071           Basic query expressions         — Subclause 7.13, “<query expression>”

 49    E071-01        UNION DISTINCT table            — Subclause 7.13, “<query expression>”: With
                      operator                        support for UNION [ DISTINCT ]

 50    E071-02        UNION ALL table operator        — Subclause 7.13, “<query expression>”: With
                                                      support for UNION ALL

 51    E071-03        EXCEPT DISTINCT table           — Subclause 7.13, “<query expression>”: With
                      operator                        support for EXCEPT [ DISTINCT ]

 52    E071-05        Columns combined via table      — Subclause 7.13, “<query expression>”:
                      operators need not have exactly Columns combined via UNION and EXCEPT
                      the same data type.             need not have exactly the same data type

 53    E071-06        Table operators in subqueries   — Subclause 7.13, “<query expression>”: <table
                                                      subquery>s can specify UNION and EXCEPT

 54    E081           Basic Privileges                — Subclause 12.3, “<privileges>”

 55    E081-01        SELECT privilege at the table — Subclause 12.3, “<privileges>”: With <action>
                      level                         of SELECT without <privilege column list>



1182 Foundation (SQL/Foundation)                                              ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)




         Feature ID          Feature Name                    Feature Description

 56      E081-02             DELETE privilege                — Subclause 12.3, “<privileges>”: With <action>
                                                             of DELETE

 57      E081-03             INSERT privilege at the table   — Subclause 12.3, “<privileges>”: With <action>
                             level                           of INSERT without <privilege column list>

 58      E081-04             UPDATE privilege at the table — Subclause 12.3, “<privileges>”: With <action>
                             level                         of UPDATE without <privilege column list>

 59      E081-05             UPDATE privilege at the col-    — Subclause 12.3, “<privileges>”: With <action>
                             umn level                       of UPDATE <left paren> <privilege
                                                             column list> <right paren>

 60      E081-06             REFERENCES privilege at the — Subclause 12.3, “<privileges>”: with <action>
                             table level                 of REFERENCES without <privilege column
                                                         list>

 61      E081-07             REFERENCES privilege at the — Subclause 12.3, “<privileges>”: With <action>
                             column level                of REFERENCES <left paren> <privi-
                                                         lege column list> <right paren>

 62      E081-08             WITH GRANT OPTION               — Subclause 12.2, “<grant privilege statement>”:
                                                             WITH GRANT OPTION

 63      E081-09             USAGE privilege                 — Subclause 12.3, “<privileges>”: With <action>
                                                             of USAGE

 64      E081-10             EXECUTE privilege               — Subclause 12.3, “<privileges>”: With <action>
                                                             of EXECUTE

 65      E091                Set functions                   — Subclause 6.9, “<set function specification>”

 66      E091-01             AVG                             — Subclause 6.9, “<set function specification>”:
                                                             With <computational operation> of AVG

 67      E091-02             COUNT                           — Subclause 6.9, “<set function specification>”:
                                                             With <computational operation> of COUNT

 68      E091-03             MAX                             — Subclause 6.9, “<set function specification>”:
                                                             With <computational operation> of MAX

 69      E091-04             MIN                             — Subclause 6.9, “<set function specification>”:
                                                             With <computational operation> of MIN

 70      E091-05             SUM                             — Subclause 6.9, “<set function specification>”:
                                                             With <computational operation> of SUM




©ISO/IEC 2003 – All rights reserved                                                  SQL feature taxonomy 1183
ISO/IEC 9075-2:2003 (E)




       Feature ID     Feature Name                 Feature Description

 71    E091-06        ALL quantifier               — Subclause 6.9, “<set function specification>”:
                                                   With <set quantifier> of ALL

 72    E091-07        DISTINCT quantifier          — Subclause 6.9, “<set function specification>”:
                                                   With <set quantifier> of DISTINCT

 73    E101           Basic data manipulation      — Clause 14, “Data manipulation”: <insert
                                                   statement>, <delete statement: searched>, and
                                                   <update statement: searched>

 74    E101-01        INSERT statement             — Subclause 14.8, “<insert statement>”: When
                                                   a <contextually typed table value constructor>
                                                   can consist of no more than a single <contextually
                                                   typed row value expression>

 75    E101-03        Searched UPDATE statement    — Subclause 14.11, “<update statement:
                                                   searched>”: But without support either of Feature
                                                   E153, “Updatable tables with subqueries”, or
                                                   Feature F221, “Explicit defaults”

 76    E101-04        Searched DELETE statement    — Subclause 14.7, “<delete statement:
                                                   searched>”

 77    E111           Single row SELECT state-     — Subclause 14.5, “<select statement: single
                      ment                         row>”: Without support of Feature F131,
                                                   “Grouped operations”

 78    E121           Basic cursor support         — Clause 14, “Data manipulation”: <declare
                                                   cursor>, <open statement>, <fetch statement>,
                                                   <close statement>, <delete statement: posi-
                                                   tioned>, and <update statement: positioned>

 79    E121-01        DECLARE CURSOR               — Subclause 14.1, “<declare cursor>”: When
                                                   each <value expression> in the <sort key> shall
                                                   be a <column reference> and that <column refer-
                                                   ence> shall also be in the <select list>, and <cur-
                                                   sor holdability> is not specified

 80    E121-02        ORDER BY columns need not — Subclause 14.1, “<declare cursor>”: Extend
                      be in select list         subfeature E121-01 so that <column reference>
                                                need not also be in the <select list>

 81    E121-03        Value expressions in ORDER   — Subclause 14.1, “<declare cursor>”: Extend
                      BY clause                    subfeature E121-01 so that the <value expres-
                                                   sion> in the <sort key> need not be a <column
                                                   reference>

 82    E121-04        OPEN statement               — Subclause 14.2, “<open statement>”


1184 Foundation (SQL/Foundation)                                           ©ISO/IEC 2003 – All rights reserved
                                                                                        ISO/IEC 9075-2:2003 (E)




         Feature ID          Feature Name                   Feature Description

 83      E121-06             Positioned UPDATE statement — Subclause 14.10, “<update statement: posi-
                                                         tioned>”: Without support of either Feature E153,
                                                         “Updateable tables with subqueries” or Feature
                                                         F221, “Explicit defaults”

 84      E121-07             Positioned DELETE statement — Subclause 14.6, “<delete statement: posi-
                                                         tioned>”

 85      E121-08             CLOSE statement                — Subclause 14.4, “<close statement>”

 86      E121-10             FETCH statement: implicit      — Subclause 14.3, “<fetch statement>”
                             NEXT

 87      E121-17             WITH HOLD cursors              — Subclause 14.1, “<declare cursor>”: Where
                                                            the <value expression> in the <sort key> need
                                                            not be a <column reference> and need not be in
                                                            the <select list>, and <cursor holdability> may
                                                            be specified

 88      E131                Null value support (nulls in   — Subclause 4.13, “Columns, fields, and
                             lieu of values)                attributes”: Nullability characteristic —
                                                            Subclause 6.5, “<contextually typed value speci-
                                                            fication>”: <null specification>

 89      E141                Basic integrity constraints    — Subclause 11.6, “<table constraint defini-
                                                            tion>”: As specified by the subfeatures of this
                                                            feature in this table

 90      E141-01             NOT NULL constraints           — Subclause 11.4, “<column definition>”: With
                                                            <column constraint> of NOT NULL

 91      E141-02             UNIQUE constraints of NOT      — Subclause 11.4, “<column definition>”: With
                             NULL columns                   <unique specification> of UNIQUE for columns
                                                            specified as NOT NULL — Subclause 11.7,
                                                            “<unique constraint definition>”: With <unique
                                                            specification> of UNIQUE

 92      E141-03             PRIMARY KEY constraints        — Subclause 11.4, “<column definition>”: With
                                                            <unique specification> of PRIMARY KEY for
                                                            columns specified as NOT NULL —
                                                            Subclause 11.7, “<unique constraint definition>”:
                                                            With <unique specification> of PRIMARY KEY




©ISO/IEC 2003 – All rights reserved                                                 SQL feature taxonomy 1185
ISO/IEC 9075-2:2003 (E)




       Feature ID     Feature Name                    Feature Description

 93    E141-04        Basic FOREIGN KEY con-          — Subclause 11.4, “<column definition>”: With
                      straint with the NO ACTION      <column constraint> of <references specification>
                      default for both referential    — Subclause 11.8, “<referential constraint defi-
                      delete action and referential   nition>”: Where the columns in the <column
                      update action.                  name list>, if specified, shall be in the same order
                                                      as the names in the <unique column list> of the
                                                      applicable <unique constraint definition> and the
                                                      <data type>s of the matching columns shall be
                                                      the same

 94    E141-06        CHECK constraints               — Subclause 11.4, “<column definition>”: With
                                                      <column constraint> of <check constraint defini-
                                                      tion> — Subclause 11.9, “<check constraint def-
                                                      inition>”

 95    E141-07        Column defaults                 — Subclause 11.4, “<column definition>”: With
                                                      <default clause>

 96    E141-08        NOT NULL inferred on PRI-       — Subclause 11.4, “<column definition>”, and
                      MARY KEY                        Subclause 11.7, “<unique constraint definition>”:
                                                      Remove the restriction in subfeatures E141-02
                                                      and E141-03 that NOT NULL be specified along
                                                      with every PRIMARY KEY and UNIQUE con-
                                                      straint — Subclause 11.4, “<column definition>”:
                                                      NOT NULL is implicit on PRIMARY KEY
                                                      constraints

 97    E141-10        Names in a foreign key can be — Subclause 11.4, “<column definition>”, and
                      specified in any order        Subclause 11.8, “<referential constraint defini-
                                                    tion>”: Extend subfeature E141-04 so that the
                                                    columns in the <column name list>, if specified,
                                                    need not be in the same order as the names in the
                                                    <unique column list> of the applicable <unique
                                                    constraint definition>

 98    E151           Transaction support             — Clause 16, “Transaction management”:
                                                      <commit statement> and <rollback statement>

 99    E151-01        COMMIT statement                — Subclause 16.6, “<commit statement>”

 100   E151-02        ROLLBACK statement              — Subclause 16.7, “<rollback statement>”

 101   E152           Basic SET TRANSACTION           — Subclause 16.2, “<set transaction statement>”
                      statement

 102   E152-01        SET TRANSACTION state-          — Subclause 16.2, “<set transaction statement>”:
                      ment: ISOLATION LEVEL           With <transaction mode> of ISOLATION
                      SERIALIZABLE clause             LEVEL SERIALIZABLE clause


1186 Foundation (SQL/Foundation)                                               ©ISO/IEC 2003 – All rights reserved
                                                                                              ISO/IEC 9075-2:2003 (E)




         Feature ID          Feature Name                  Feature Description

 103     E152-02             SET TRANSACTION state-        — Subclause 16.2, “<set transaction statement>”:
                             ment: READ ONLY and           with <transaction access mode> of READ ONLY
                             READ WRITE clauses            or READ WRITE

 104     E153                Updatable queries with sub-   — Subclause 7.13, “<query expression>”: A
                             queries                       <query expression> is updatable even though its
                                                           <where clause> contains a <subquery>

 105     E161                SQL comments using leading — Subclause 5.2, “<token> and <separator>”:
                             double minus               <simple comment>

 106     E171                SQLSTATE support              — Subclause 23.1, “SQLSTATE”

 107     E182                Module language               — Clause 13, “SQL-client modules”
                                                           NOTE 487 — An SQL-implementation is required to supply
                                                           at least one binding to a standard host language using either
                                                           module language, embedded SQL, or both.

 108     F031                Basic schema manipulation     — Clause 11, “Schema definition and manipula-
                                                           tion”: Selected facilities as indicated by the sub-
                                                           features of this Feature

 109     F031-01             CREATE TABLE statement to — Subclause 11.3, “<table definition>”: Not in
                             create persistent base tables the context of a <schema definition>

 110     F031-02             CREATE VIEW statement         — Subclause 11.22, “<view definition>”: Not in
                                                           the context of a <schema definition>, and without
                                                           support of Feature F081, “UNION and EXCEPT
                                                           in views”

 111     F031-03             GRANT statement               — Subclause 12.1, “<grant statement>”: Not in
                                                           the context of a <schema definition>

 112     F031-04             ALTER TABLE statement:        — Subclause 11.10, “<alter table statement>”:
                             ADD COLUMN clause             The <add column definition> clause —
                                                           Subclause 11.11, “<add column definition>”

 113     F031-13             DROP TABLE statement:         — Subclause 11.21, “<drop table statement>”:
                             RESTRICT clause               With a <drop behavior> of RESTRICT

 114     F031-16             DROP VIEW statement:          — Subclause 11.23, “<drop view statement>”:
                             RESTRICT clause               With a <drop behavior> of RESTRICT

 115     F031-19             REVOKE statement:             — Subclause 12.7, “<revoke statement>”: With
                             RESTRICT clause               a <drop behavior> of RESTRICT, only where
                                                           the use of this statement can be restricted to the
                                                           owner of the table being dropped




©ISO/IEC 2003 – All rights reserved                                                      SQL feature taxonomy 1187
ISO/IEC 9075-2:2003 (E)




       Feature ID     Feature Name                      Feature Description

 116   F041           Basic joined table                — Subclause 7.7, “<joined table>”

 117   F041-01        Inner join (but not necessarily   — Subclause 7.6, “<table reference>”: The
                      the INNER keyword)                <joined table> clause, but without support for
                                                        subfeatures F041-02 through F041-08

 118   F041-02        INNER keyword                     — Subclause 7.7, “<joined table>”: <join type>
                                                        of INNER

 119   F041-03        LEFT OUTER JOIN                   — Subclause 7.7, “<joined table>”: <outer join
                                                        type> of LEFT

 120   F041-04        RIGHT OUTER JOIN                  — Subclause 7.7, “<joined table>”: <outer join
                                                        type> of RIGHT

 121   F041-05        Outer joins can be nested         — Subclause 7.7, “<joined table>”: Subfeature
                                                        F041-1 extended so that a <table reference>
                                                        within the <joined table> can itself be a <joined
                                                        table>

 122   F041-07        The inner table in a left or right — Subclause 7.7, “<joined table>”: Subfeature
                      outer join can also be used in F041-1 extended so that a <table name> within
                      an inner join                      a nested <joined table> can be the same as a
                                                         <table name> in an outer <joined table>

 123   F041-08        All comparison operators are      — Subclause 7.7, “<joined table>”: Subfeature
                      supported (rather than just =)    F041-1 extended so that the <join condition> is
                                                        not limited to a <comparison predicate> with a
                                                        <comp op> of <equals operator>

 124   F051           Basic date and time               — Subclause 6.1, “<data type>”: <datetime type>
                                                        including datetime literals, datetime comparisons,
                                                        and datetime conversions

 125   F051-01        DATE data type (including         — Subclause 5.3, “<literal>”: The <date literal>
                      support of DATE literal)          form of <datetime literal> — Subclause 6.1,
                                                        “<data type>”: The DATE <datetime type> —
                                                        Subclause 6.30, “<datetime value expression>”:
                                                        For values of type DATE




1188 Foundation (SQL/Foundation)                                                ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)




         Feature ID          Feature Name                      Feature Description

 126     F051-02             TIME data type (including         — Subclause 5.3, “<literal>”: The <time literal>
                             support of TIME literal) with     form of <datetime literal>, where the value of
                             fractional seconds precision of   <unquoted time string> is simply <time value>
                             at least 0.                       that does not include the optional <time zone
                                                               interval> — Subclause 6.1, “<data type>”: The
                                                               TIME <datetime type> without the <with or
                                                               without time zone> clause — Subclause 6.30,
                                                               “<datetime value expression>”: For values of
                                                               type TIME

 127     F051-03             TIMESTAMP data type               — Subclause 5.3, “<literal>”: The <timestamp
                             (including support of TIMES-      literal> form of <datetime literal>, where the
                             TAMP literal) with fractional     value of <unquoted timestamp string> is simply
                             seconds precision of at least 0   <time value> that does not include the optional
                             and 6.                            <time zone interval> — Subclause 6.1, “<data
                                                               type>”: The TIMESTAMP <datetime type>
                                                               without the <with or without time zone> clause
                                                               — Subclause 6.30, “<datetime value expres-
                                                               sion>”: For values of type TIMESTAMP

 128     F051-04             Comparison predicate on           — Subclause 8.2, “<comparison predicate>”: For
                             DATE, TIME, and TIMES-            comparison between values of the following
                             TAMP data types                   types: DATE and DATE, TIME and TIME,
                                                               TIMESTAMP and TIMESTAMP, DATE and
                                                               TIMESTAMP, and TIME and TIMESTAMP

 129     F051-05             Explicit CAST between date- — Subclause 6.12, “<cast specification>”: If
                             time types and character string support for Feature F201, “CAST function” is
                             types                           available, then CASTing between the following
                                                             types: from character string to DATE, TIME, and
                                                             TIMESTAMP; from DATE to DATE, TIMES-
                                                             TAMP, and character string; from TIME to
                                                             TIME, TIMESTAMP, and character string; from
                                                             TIMESTAMP to DATE, TIME, TIMESTAMP,
                                                             and character string

 130     F051-06             CURRENT_DATE                      — Subclause 6.31, “<datetime value function>”:
                                                               The <current date value function> —
                                                               Subclause 6.30, “<datetime value expression>”:
                                                               When the value is a <current date value function>




©ISO/IEC 2003 – All rights reserved                                                    SQL feature taxonomy 1189
ISO/IEC 9075-2:2003 (E)




       Feature ID     Feature Name                   Feature Description

 131   F051-07        LOCALTIME                      — Subclause 6.31, “<datetime value function>”:
                                                     The <current local time value function> —
                                                     Subclause 6.30, “<datetime value expression>”:
                                                     When the value is a <current local time value
                                                     function> — Subclause 11.5, “<default clause>”:
                                                     LOCALTIME option of <datetime value func-
                                                     tion>

 132   F051-08        LOCALTIMESTAMP                 — Subclause 6.31, “<datetime value function>”:
                                                     The <current local timestamp value function> —
                                                     Subclause 6.30, “<datetime value expression>”:
                                                     When the value is a <current local timestamp
                                                     value function> — Subclause 11.5, “<default
                                                     clause>”: LOCALTIMESTAMP option of
                                                     <datetime value function>

 133   F081           UNION and EXCEPT in            — Subclause 11.22, “<view definition>”: A
                      views                          <query expression> in a <view definition> may
                                                     specify UNION, UNION ALL, and/or EXCEPT

 134   F131           Grouped operations             — A grouped view is a view whose <query
                                                     expression> contains a <group by clause>

 135   F131-01        WHERE, GROUP BY, and        — Subclause 7.4, “<table expression>”: Even
                      HAVING clauses supported in though a table in the <from clause> is a grouped
                      queries with grouped views  view, the <where clause>, <group by clause>,
                                                  and <having clause> may be specified

 136   F131-02        Multiple tables supported in   — Subclause 7.5, “<from clause>”: Even though
                      queries with grouped views     a table in the <from clause> is a grouped view,
                                                     the <from clause> may specify more than one
                                                     <table reference>

 137   F131-03        Set functions supported in     — Subclause 7.12, “<query specification>”: Even
                      queries with grouped views     though a table in the <from clause> is a grouped
                                                     view, the <select list> may specify a <set function
                                                     specification>

 138   F131-04        Subqueries with GROUP BY       — Subclause 7.15, “<subquery>”: A <subquery>
                      and HAVING clauses and         in a <comparison predicate> is allowed to contain
                      grouped views                  a <group by clause> and/or a <having clause>
                                                     and/or it may identify a grouped view




1190 Foundation (SQL/Foundation)                                             ©ISO/IEC 2003 – All rights reserved
                                                                                               ISO/IEC 9075-2:2003 (E)




         Feature ID          Feature Name                       Feature Description

 139     F131-05             Single row SELECT with             — Subclause 14.5, “<select statement: single
                             GROUP BY and HAVING                row>”: The table in a <from clause> can be a
                             clauses and grouped views          grouped view — Subclause 14.5, “<select state-
                                                                ment: single row>”: The <table expression> may
                                                                specify a <group by clause> and/or a <having
                                                                clause>

 140     F181                Multiple module support              — Subclause 13.1, “<SQL-client module defini-
                             NOTE 488 — The ability to associate tion>”:An SQL-agent can be associated with more
                             multiple host compilation units with than one <SQL-client module definition> With
                             a single SQL-session at one time.    this feature, it is possible to compile <SQL-client
                                                                  module definition>s or <embedded SQL host
                                                                  program>s separately and rely on the SQL-
                                                                  implementation to “link” the together properly at
                                                                  execution time. To ensure portability, applications
                                                                  should adhere to the following limitations:
                                                                  —Avoid linking modules having cursors with the
                                                                  same <cursor name>.
                                                                  —Avoid linking modules that prepare statements
                                                                  using the same <SQL statement name>.
                                                                  —Avoid linking modules that allocate descriptors
                                                                  with the same <descriptor name>.
                                                                  —Assume that the scope of an <embedded
                                                                  exception declaration> is a single compilation
                                                                  unit.
                                                                  —Assume that an <embedded variable name>
                                                                  can be referenced only in the same compilation
                                                                  unit in which it is declared.

 141     F201                CAST function                      — Subclause 6.12, “<cast specification>”: For
                             NOTE 489 — This means the support all supported data types — Subclause 6.25,
                             of CAST, where relevant, among all “<value expression>”: <cast specification>
                             supported data types.

 142     F221                Explicit defaults                  — Subclause 6.5, “<contextually typed value
                                                                specification>”: <default specification>
                                                                NOTE 490 — Including its use in UPDATE and INSERT
                                                                statements.

 143     F261                CASE expression                    — Subclause 6.25, “<value expression>”: <case
                                                                expression>

 144     F261-01             Simple CASE                        — Subclause 6.11, “<case expression>”: The
                                                                <simple case> variation

 145     F261-02             Searched CASE                      — Subclause 6.11, “<case expression>”: The
                                                                <searched case> variation



©ISO/IEC 2003 – All rights reserved                                                       SQL feature taxonomy 1191
ISO/IEC 9075-2:2003 (E)




       Feature ID     Feature Name                 Feature Description

 146   F261-03        NULLIF                       — Subclause 6.11, “<case expression>”: The
                                                   NULLIF <case abbreviation>

 147   F261-04        COALESCE                     — Subclause 6.11, “<case expression>”: The
                                                   COALESCE <case abbreviation>

 148   F311           Schema definition statement — Subclause 11.1, “<schema definition>”

 149   F311-01        CREATE SCHEMA                — Subclause 11.1, “<schema definition>”: Sup-
                                                   port for circular references in that <referential
                                                   constraint definition>s in two different <table
                                                   definition>s may reference columns in the other
                                                   table

 150   F311-02        CREATE TABLE for persis-     — Subclause 11.1, “<schema definition>”: A
                      tent base tables             <schema element> that is a <table definition> —
                                                   Subclause 11.3, “<table definition>”: In the con-
                                                   text of a <schema definition>

 151   F311-03        CREATE VIEW                  — Subclause 11.1, “<schema definition>”: A
                                                   <schema element> that is a <view definition> —
                                                   Subclause 11.22, “<view definition>”: In the
                                                   context of a <schema definition> without the
                                                   WITH CHECK OPTION clause and without
                                                   support of Feature F081, “UNION and EXCEPT
                                                   in views”

 152   F311-04        CREATE VIEW: WITH            — Subclause 11.22, “<view definition>”: The
                      CHECK OPTION                 WITH CHECK OPTION clause, in the context
                                                   of a <schema definition>, but without support of
                                                   Feature F081, “UNION and EXCEPT in views”

 153   F311-05        GRANT statement              — Subclause 11.1, “<schema definition>”: A
                                                   <schema element> that is a <grant statement> —
                                                   Subclause 12.1, “<grant statement>”: In the con-
                                                   text of a <schema definition>

 154   F471           Scalar subquery values       — Subclause 6.25, “<value expression>”: A
                                                   <value expression primary> can be a <scalar
                                                   subquery>

 155   F481           Expanded NULL predicate      — Subclause 8.7, “<null predicate>”: The <row
                                                   value expression> can be something other than a
                                                   <column reference>




1192 Foundation (SQL/Foundation)                                          ©ISO/IEC 2003 – All rights reserved
                                                                                               ISO/IEC 9075-2:2003 (E)




         Feature ID          Feature Name                  Feature Description

 156     F812                Basic flagging                — Part 1, Subclause 8.5, “SQL flagger”: With
                                                           “level of flagging” specified to be Core SQL
                                                           Flagging and “extent of checking” specified to
                                                           be Syntax Only
                                                           NOTE 491 — This form of flagging identifies vendor
                                                           extensions and other non-standard SQL by checking syntax
                                                           only without requiring access to the catalog information.

 157     S011                Distinct data types           — Subclause 11.41, “<user-defined type defini-
                                                           tion>”: When <representation> is <predefined
                                                           type> — Subclause 11.49, “<drop data type
                                                           statement>”

 158     T321                Basic SQL-invoked routines    — Subclause 11.50, “<SQL-invoked routine>”
                                                           — Subclause 11.52, “<drop routine statement>”
                                                           — If Feature T041, “Basic LOB data type sup-
                                                           port”, is supported, then the <locator indication>
                                                           clause shall also be supported
                                                           NOTE 492 — “Routine” is the collective term for functions,
                                                           methods, and procedures. This feature requires a conforming
                                                           SQL-implementation to support both user-defined functions
                                                           and user-defined procedures. An SQL-implementation that
                                                           conforms to Core SQL shall support at least one language
                                                           for writing routines; that language may be SQL. If the lan-
                                                           guage is SQL, then the basic specification capability in Core
                                                           SQL is the ability to specify a one-statement routine. Support
                                                           for overloaded functions and procedures is not part of Core
                                                           SQL.

 159     T321-01             User-defined functions with no — Subclause 11.50, “<SQL-invoked routine>”:
                             overloading                    With <function specification>

 160     T321-02             User-defined stored procedures — Subclause 11.50, “<SQL-invoked routine>”:
                             with no overloading            With <SQL-invoked procedure>

 161     T321-03             Function invocation           — Subclause 6.4, “<value specification> and
                                                           <target specification>”: With a <value expression
                                                           primary> that is a <routine invocation> —
                                                           Subclause 10.4, “<routine invocation>”: For user-
                                                           defined functions

 162     T321-04             CALL statement                — Subclause 10.4, “<routine invocation>”: Used
                                                           by <call statement>s — Subclause 15.1, “<call
                                                           statement>”

 163     T321-05             RETURN statement              — Subclause 15.2, “<return statement>”, if the
                                                           SQL-implementation supports SQL routines




©ISO/IEC 2003 – All rights reserved                                                       SQL feature taxonomy 1193
ISO/IEC 9075-2:2003 (E)




        Feature ID         Feature Name                          Feature Description

 164    T631               IN predicate with one list            — Subclause 8.4, “<in predicate>”: <in value
                           element                               list> containing exactly one <row value expres-
                                                                 sion>
 1
  A conforming SQL-implementation is required (by Clause 8, “Conformance”, in ISO/IEC 9075-1) to support at least one
 embedded language or to support the SQL-client module binding for at least one host language.


Table 36, “Feature taxonomy for optional features”, does not provide definitions of the features; the definition
of those features is found in the Conformance Rules that are further summarized in Annex A, “SQL Conformance
Summary”.

                               Table 36 — Feature taxonomy for optional features


        Feature ID         Feature Name

 1      B011               Embedded Ada

 2      B012               Embedded C

 3      B013               Embedded COBOL

 4      B014               Embedded Fortran

 5      B015               Embedded MUMPS

 6      B016               Embedded Pascal

 7      B017               Embedded PL/I

 8      B021               Direct SQL

 9      B031               Basic dynamic SQL

 10     B032               Extended dynamic SQL

 11     B032-01            <describe input statement>

 12     B033               Untyped SQL-invoked function arguments

 13     B034               Dynamic specification of cursor attributes

 14     B041               Extensions to embedded SQL exception declarations

 15     B051               Enhanced execution rights

 16     B111               Module language Ada



1194 Foundation (SQL/Foundation)                                                            ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)




         Feature ID          Feature Name

 17      B112                Module language C

 18      B113                Module language COBOL

 19      B114                Module language Fortran

 20      B115                Module language MUMPS

 21      B116                Module language Pascal

 22      B117                Module language PL/I

 23      B121                Routine language Ada

 24      B122                Routine language C

 25      B123                Routine language COBOL

 26      B124                Routine language Fortran

 27      B125                Routine language MUMPS

 28      B126                Routine language Pascal

 29      B127                Routine language PL/I

 30      B128                Routine language SQL

 31      F032                CASCADE drop behavior

 32      F033                ALTER TABLE statement: DROP COLUMN clause

 33      F034                Extended REVOKE statement

 34      F034-01             REVOKE statement performed by other than the owner of a schema object

 35      F034-02             REVOKE statement: GRANT OPTION FOR clause

 36      F034-03             REVOKE statement to revoke a privilege that the grantee has WITH GRANT
                             OPTION

 37      F052                Intervals and datetime arithmetic

 38      F053                OVERLAPS predicate

 39      F111                Isolation levels other than SERIALIZABLE

 40      F111-01             READ UNCOMMITTED isolation level




©ISO/IEC 2003 – All rights reserved                                              SQL feature taxonomy 1195
ISO/IEC 9075-2:2003 (E)




       Feature ID     Feature Name

 41    F111-02        READ COMMITTED isolation level

 42    F111-03        REPEATABLE READ isolation level

 43    F121           Basic diagnostics management

 44    F121-01        GET DIAGNOSTICS statement

 45    F121-02        SET TRANSACTION statement: DIAGNOSTICS SIZE clause

 46    F171           Multiple schemas per user

 47    F191           Referential delete actions

 48    F222           INSERT statement: DEFAULT VALUES clause

 49    F231           Privilege tables

 50    F231-01        TABLE_PRIVILEGES view

 51    F231-02        COLUMN_PRIVILEGES view

 52    F231-03        USAGE_PRIVILEGES view

 53    F251           Domain support

 54    F262           Extended CASE expression

 55    F263           Comma-separated predicates in simple CASE expression

 56    F271           Compound character literals

 57    F281           LIKE enhancements

 58    F291           UNIQUE predicate

 59    F301           CORRESPONDING in query expressions

 60    F302           INTERSECT table operator

 61    F302-01        INTERSECT DISTINCT table operator

 62    F302-02        INTERSECT ALL table operator

 63    F304           EXCEPT ALL table operator

 64    F312           MERGE statement

 65    F321           User authorization



1196 Foundation (SQL/Foundation)                                      ©ISO/IEC 2003 – All rights reserved
                                                                                     ISO/IEC 9075-2:2003 (E)




         Feature ID          Feature Name

 66      F341                Usage tables

 67      F361                Subprogram support

 68      F381                Extended schema manipulation

 69      F381-01             ALTER TABLE statement: ALTER COLUMN clause

 70      F381-02             ALTER TABLE statement: ADD CONSTRAINT clause

 71      F381-03             ALTER TABLE statement: DROP CONSTRAINT clause

 72      F391                Long identifiers

 73      F392                Unicode escapes in identifiers

 74      F393                Unicode escapes in literals

 75      F401                Extended joined table

 76      F401-01             NATURAL JOIN

 77      F401-02             FULL OUTER JOIN

 78      F401-04             CROSS JOIN

 79      F402                Named column joins for LOBs, arrays, and multisets

 80      F411                Time zone specification

 81      F421                National character

 82      F431                Read-only scrollable cursors

 83      F431-01             FETCH with explicit NEXT

 84      F431-02             FETCH FIRST

 85      F431-03             FETCH LAST

 86      F431-04             FETCH PRIOR

 87      F431-05             FETCH ABSOLUTE

 88      F431-06             FETCH RELATIVE

 89      F441                Extended set function support

 90      F442                Mixed column references in set functions



©ISO/IEC 2003 – All rights reserved                                               SQL feature taxonomy 1197
ISO/IEC 9075-2:2003 (E)




       Feature ID     Feature Name

 91    F451           Character set definition

 92    F461           Named character sets

 93    F491           Constraint management

 94    F502           Enhanced documentation tables

 95    F502-01        SQL_SIZING_PROFILES view

 96    F502-02        SQL_IMPLEMENTATION_INFO view

 97    F502-03        SQL_PACKAGES view

 98    F521           Assertions

 99    F531           Temporary tables

 100   F555           Enhanced seconds precision

 101   F561           Full value expressions

 102   F571           Truth value tests

 103   F591           Derived tables

 104   F611           Indicator data types

 105   F641           Row and table constructors

 106   F651           Catalog name qualifiers

 107   F661           Simple tables

 108   F671           Subqueries in CHECK

 109   F672           Retrospective check constraints

 110   F691           Collation and translation

 111   F692           Enhanced collation support

 112   F693           SQL-session and client module collations

 113   F695           Translation support

 114   F696           Additional translation documentation

 115   F701           Referential update actions



1198 Foundation (SQL/Foundation)                                 ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)




         Feature ID          Feature Name

 116     F711                ALTER domain

 117     F721                Deferrable constraints

 118     F731                INSERT column privileges

 119     F741                Referential MATCH types

 120     F751                View CHECK enhancements

 121     F761                Session management

 122     F771                Connection management

 123     F781                Self-referencing operations

 124     F791                Insensitive cursors

 125     F801                Full set function

 126     F813                Extended flagging — Part 1, Subclause 8.5, “SQL flagger”: With “level of flag-
                             ging” specified to be Core SQL Flagging and “extent of checking” specified to be
                             Catalog Lookup

 127     F821                Local table references

 128     F831                Full cursor update

 129     F831-01             Updateable scrollable cursors

 130     F831-02             Updateable ordered cursors

 131     S023                Basic structured types

 132     S024                Enhanced structured types

 133     S025                Final structured types

 134     S026                Self-referencing structured types

 135     S027                Create method by specific method name

 136     S028                Permutable UDT options list

 137     S041                Basic reference types

 138     S043                Enhanced reference types

 139     S051                Create table of type



©ISO/IEC 2003 – All rights reserved                                                  SQL feature taxonomy 1199
ISO/IEC 9075-2:2003 (E)




       Feature ID     Feature Name

 140   S071           SQL paths in function and type name resolution

 141   S081           Subtables

 142   S091           Basic array support

 143   S091-01        Arrays of built-in data types

 144   S091-02        Arrays of distinct types

 145   S091-03        Array expressions

 146   S092           Arrays of user-defined types

 147   S094           Arrays of reference types

 148   S095           Array constructors by query

 149   S096           Optional array bounds

 150   S097           Array element assignment

 151   S111           ONLY in query expressions

 152   S151           Type predicate

 153   S161           Subtype treatment

 154   S162           Subtype treatment for references

 155   S201           SQL-invoked routines on arrays

 156   S201-01        Array parameters

 157   S201-02        Array as result type of functions

 158   S202           SQL-invoked routines on multisets

 159   S211           User-defined cast functions

 160   S231           Structured type locators

 161   S232           Array locators

 162   S233           Multiset locators

 163   S241           Transform functions

 164   S242           Alter transform statement



1200 Foundation (SQL/Foundation)                                       ©ISO/IEC 2003 – All rights reserved
                                                                                       ISO/IEC 9075-2:2003 (E)




         Feature ID          Feature Name

 165     S251                User-defined orderings

 166     S261                Specific type method

 167     S271                Basic multiset support

 168     S272                Multisets of user-defined types

 169     S274                Multisets of reference types

 170     S275                Advanced multiset support

 171     S281                Nested collection types

 172     S291                Unique constraint on entire row

 173     T011                Timestamp in Information Schema

 174     T031                BOOLEAN data type

 175     T041                Basic LOB data type support

 176     T041-01             BLOB data type — Subclause 5.2, “<token> and <separator>”: The <reserved
                             word>s BINARY, BLOB, LARGE, and OBJECT — Subclause 5.3, “<literal>”:
                             <binary string literal> — Subclause 6.1, “<data type>”: The BINARY LARGE
                             OBJECT data type — Subclause 6.28, “<string value expression>”: For values of
                             type BINARY LARGE OBJECT — Subclause 13.6, “Data type correspondences”:
                             Type correspondences for BINARY LARGE OBJECT for all supported languages

 177     T041-02             CLOB data type — Subclause 5.2, “<token> and <separator>”: The <reserved
                             word>s CHARACTER, CLOB, LARGE, and OBJECT — Subclause 6.1, “<data
                             type>”: The CHARACTER LARGE OBJECT data type — Subclause 6.28, “<string
                             value expression>”: For values of type CHARACTER LARGE OBJECT —
                             Subclause 13.6, “Data type correspondences”: Type correspondences for CHAR-
                             ACTER LARGE OBJECT for all supported languages — The implicit casting
                             among the fixed-length and variable-length character string types supported by
                             subfeature E021-10 is extended to support the character large object type




©ISO/IEC 2003 – All rights reserved                                                SQL feature taxonomy 1201
ISO/IEC 9075-2:2003 (E)




       Feature ID     Feature Name

 178   T041-03        POSITION, LENGTH, LOWER, TRIM, UPPER, and SUBSTRING functions for
                      LOB data types — Subclause 6.27, “<numeric value function>”: The <position
                      expression> for expressions of type BINARY LARGE OBJECT and CHARACTER
                      LARGE OBJECT — Subclause 6.27, “<numeric value function>”: The <char
                      length expression> for expressions of type CHARACTER LARGE OBJECT —
                      Subclause 6.27, “<numeric value function>”: The <octet length expression> for
                      expressions of type BINARY LARGE OBJECT and CHARACTER LARGE
                      OBJECT — Subclause 6.29, “<string value function>”: The <fold> function for
                      expressions of type CHARACTER LARGE OBJECT — Subclause 6.29, “<string
                      value function>”: The <trim function> for expressions of type CHARACTER
                      LARGE OBJECT — Subclause 6.29, “<string value function>”: The <blob trim
                      function> — Subclause 6.29, “<string value function>”: The <character substring
                      function> for expressions of type CHARACTER LARGE OBJECT —
                      Subclause 6.29, “<string value function>”: The <blob substring function>

 179   T041-04        Concatenation of LOB data types — Subclause 6.28, “<string value expression>”:
                      The <concatenation> expression for expressions of type CHARACTER LARGE
                      OBJECT — Subclause 6.28, “<string value expression>”: The <blob concatena-
                      tion> expression

 180   T041-05        LOB locator: non-holdable — Subclause 13.3, “<externally-invoked procedure>”:
                      <locator indication> — Subclause 14.14, “<free locator statement>”

 181   T042           Extended LOB data type support

 182   T051           Row types

 183   T052           MAX and MIN for row types

 184   T053           Explicit aliases for all-fields reference

 185   T061           UCS support

 186   T071           BIGINT data type

 187   T111           Updatable joins, unions, and columns

 188   T121           WITH (excluding RECURSIVE) in query expression

 189   T122           WITH (excluding RECURSIVE) in subquery

 190   T131           Recursive query

 191   T132           Recursive query in subquery

 192   T141           SIMILAR predicate

 193   T151           DISTINCT predicate



1202 Foundation (SQL/Foundation)                                            ©ISO/IEC 2003 – All rights reserved
                                                                                              ISO/IEC 9075-2:2003 (E)




         Feature ID          Feature Name

 194     T152                DISTINCT predicate with negation

 195     T171                LIKE clause in table definition

 196     T172                AS subquery clause in table definition

 197     T173                Extended LIKE clause in table definition

 198     T174                Identity columns

 199     T175                Generated columns

 200     T176                Sequence generator support

 201     T191                Referential action RESTRICT

 202     T201                Comparable data types for referential constraints

 203     T211                Basic trigger capability

 204     T211-01             Triggers activated on UPDATE, INSERT, or DELETE of one base table.

 205     T211-02             BEFORE triggers

 206     T211-03             AFTER triggers

 207     T211-04             FOR EACH ROW triggers

 208     T211-05             Ability to specify a search condition that shall be True before the trigger is invoked.

 209     T211-06             Support for run-time rules for the interaction of triggers and constraints.

 210     T211-07             TRIGGER privilege

 211     T211-08             Multiple triggers for the same event are executed in the order in which they were
                             created in the catalog.

 212     T212                Enhanced trigger capability

 213     T231                Sensitive cursors

 214     T241                START TRANSACTION statement

 215     T251                SET TRANSACTION statement: LOCAL option

 216     T261                Chained transactions

 217     T271                Savepoints




©ISO/IEC 2003 – All rights reserved                                                       SQL feature taxonomy 1203
ISO/IEC 9075-2:2003 (E)




       Feature ID     Feature Name

 218   T272           Enhanced savepoint management

 219   T281           SELECT privilege with column granularity

 220   T301           Functional dependencies

 221   T312           OVERLAY function

 222   T322           Overloading of SQL-invoked functions and procedures

 223   T323           Explicit security for external routines

 224   T324           Explicit security for SQL routines

 225   T325           Qualified SQL parameter references

 226   T326           Table functions

 227   T331           Basic roles

 228   T332           Extended roles

 229   T351           Bracketed SQL comments (/*...*/ comments)

 230   T431           Extended grouping capabilities

 231   T432           Nested and concatenated GROUPING SETS

 232   T433           Multiargument GROUPING function

 233   T434           GROUP BY DISINCT

 234   T441           ABS and MOD functions

 235   T461           Symmetric BETWEEN predicate

 236   T471           Result sets return value

 237   T491           LATERAL derived table

 238   T501           Enhanced EXISTS predicate

 239   T511           Transaction counts

 240   T551           Optional key words for default syntax

 241   T561           Holdable locators

 242   T571           Array-returning external SQL-invoked functions



1204 Foundation (SQL/Foundation)                                       ©ISO/IEC 2003 – All rights reserved
                                                                                    ISO/IEC 9075-2:2003 (E)




         Feature ID          Feature Name

 243     T572                Multiset-returning external SQL-invoked functions

 244     T581                Regular expression substring function

 245     T591                UNIQUE constraints of possibly null columns

 246     T601                Local cursor references

 247     T611                Elementary OLAP operations

 248     T612                Advanced OLAP operations

 249     T613                Sampling

 250     T621                Enhanced numeric functions

 251     T641                Multiple column assignment

 252     T651                SQL-schema statements in SQL routines

 253     T652                SQL-dynamic statements in SQL routines

 254     T653                SQL-schema statements in external routines

 255     T654                SQL-dynamic statements in external routines

 256     T655                Cyclically dependent routines




©ISO/IEC 2003 – All rights reserved                                              SQL feature taxonomy 1205
ISO/IEC 9075-2:2003 (E)




                                   This page intentionally left blank.




1206 Foundation (SQL/Foundation)                                         ©ISO/IEC 2003 – All rights reserved
                                                                                      ISO/IEC 9075-2:2003 (E)




                                                 Annex G
                                               (informative)

                Defect Reports not addressed in this edition of ISO/IEC 9075

Each entry in this Annex describes a reported defect in the previous edition of this part of ISO/IEC 9075 that
remains in this edition.
1) Subclause 10.4, “<routine invocation>”:
    There is no definition of how to pass values of type BOOLEAN or of large object types as arguments to
    invocations of external routines. More generally, the question of how to convert a value of any SQL type
    to a value of an appropriate host language type at the interface to an SQL-invoked routine is not addressed.
    The rules in Subclause 13.4, “Calls to an <externally-invoked procedure>”, are appropriate, but they are
    not referenced by the rules of Subclause 10.4, “<routine invocation>”.
2) Subclause 20.1, “<embedded SQL host program>”:
    SR 21)h)i)6) and SR 21)l)i)3)B)VI) both refer to the SQL data type that corresponds to a given host language
    data type, as determined by application of the rules in Subclause 13.6, “Data type correspondences”. These
    two syntax rules are sometimes ambiguous, because Subclause 13.6, “Data type correspondences” does
    not always give exactly one SQL data type for a given host language type, as can be seen by inspection of
    the data type correspondence tables given in that Subclause. For example, Table 17, “Data type correspon-
    dences for C”, in which the C data type “pointer to long” maps to both INTEGER and BOOLEAN.
3) Subclause 16.3, “<set constraints mode statement>”:
    There are several problems with the deferred constraint checking specified by use of the keyword
    DEFERRED:
    a) Exactly when <referential action>s of deferred referential constraints are processed is not precisely
       specified.
    b) When referential constraint checking is immediate and execution of an SQL-statement causes rows to
       be deleted, those rows are merely “marked for deletion” and not actually deleted until all constraint
       checking has been done. This ensures the correct processing of <referential action>s, such as ON
       DELETE SET DEFAULT, that cause changes to SQL-data. When the checking of some referential
       constraint has been deferred and the mode of that constraint is set to IMMEDIATE, it can happen that
       a row whose presence is needed to ensure the correct processing of a <referential action> has been
       actually deleted, as a result of the successful prior execution of some SQL-data change statement.
         For example, consider:

         CREATE TABLE T1 ( A INTEGER, PRIMARY KEY ( A ) ) ;

         CREATE TABLE T2 ( A INTEGER,
           CONSTRAINT C1
             FOREIGN KEY ( A ) REFERENCES T2



©ISO/IEC 2003 – All rights reserved          Defect Reports not addressed in this edition of ISO/IEC 9075 1207
ISO/IEC 9075-2:2003 (E)




            ON UPDATE CASCADE
            DEFERRABLE) ;

       INSERT INTO T1 VALUES ( 1 ) ;

       INSERT INTO T2 VALUES ( 1 ) ;

       Now VALUES ( 1 ) is a matching row in T2 for the only row in T1.

       SET CONSTRAINTS C1 DEFERRED ;
       UPDATE T1 SET A = 9 ;

       The processing of the UPDATE statement causes the only row in T1 to change from VALUES ( 1 ) to
       VALUES ( 9 ). The update to that row in T1 is supposed to be propagated to the only row in T2 under
       the rule for constraint C1, but processing of constraint C1 is deferred and does not take place at this
       time.

       SET CONSTRAINTS C1 IMMEDIATE ;

       Constraint C1 is processed now, but, there now being no row in T1 for which the VALUES ( 1 ) in T2
       is a matching row, no change to T2 will take place under the General Rules of Subclause 11.8, “<refer-
       ential constraint definition>”. Thus, the constraint is violated in spite of the existence of the <referential
       action> that is expected to prevent this from happening. Moreover, the unmatched row in T2 remains
       even after the mode of C1 has been set to IMMEDIATE, for a <set constraints mode statement> does
       not make any changes to SQL-data that might be canceled under the General Rules of Subclause 13.5,
       “<SQL procedure statement>”.
   c) Various problems have been noted with the possible interaction of deferred processing of referential
      constraints and triggers. For example, consider:

       CREATE TABLE T1 ( A INTEGER, PRIMARY KEY ( A ) ) ;

       CREATE TABLE T2 (A INTEGER,
         PRIMARY KEY ( A ),
         CONSTRAINT C1
           FOREIGN KEY ( A ) REFERENCES T1
             ON DELETE CASCADE
             DEFERRABLE ) ;

       CREATE TABLE T3 ( A INTEGER, PRIMARY KEY ( A ) ) ;

       CREATE TRIGGER TR1 AFTER DELETE ON T2
         FOR EACH STATEMENT
           INSERT INTO T3 VALUES ( ( SELECT COUNT(*) FROM T3 ) + 1 ) ;

       INSERT INTO T1 VALUES ( 1 ), ( 2 ) ;

       INSERT INTO T2 VALUES ( 1 ), ( 2 ) ;

       DELETE FROM T1 WHERE A = 1 ;


       Because constraint checking is immediate, this deletion from T1 will cause the same row, VALUES (
       1 ), to be deleted from T2, thus activating trigger TR1 and causing VALUES ( 1 ) to be inserted into
       T3.


1208 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)




         DELETE FROM T1 WHERE A = 2 ;

         Likewise, this deletion will cause the row VALUES ( 2 ) to be deleted from T2, thus activating trigger
         TR1 and causing VALUES ( 1 ) to be inserted into T3..
         Likewise, this deletion will cause the row VALUES ( 2 ) to be deleted from T2, thus activating trigger
         TR1 for a second time and causing VALUES ( 2 ) to be inserted into T3.
         But if SET CONSTRAINTS C1 DEFERRED is executed immediately before those two deletions, then
         the deletions from T1 will not be propagated to T2 and so trigger TR1 will not be activated and T3 will
         not be updated. When SET CONSTRAINTS C1 IMMEDIATE is subsequently executed, even if the
         problem illustrated in point b) is addressed so that the deletions are somehow now propagated to T2
         after all, it is not clear how many activations of trigger TR1 will take place (nor, if there are more than
         one, in what order those activations will take place).




©ISO/IEC 2003 – All rights reserved            Defect Reports not addressed in this edition of ISO/IEC 9075 1209
ISO/IEC 9075-2:2003 (E)




                                   This page intentionally left blank.




1210 Foundation (SQL/Foundation)                                         ©ISO/IEC 2003 – All rights reserved
                                                                                              ISO/IEC 9075-2:2003 (E)




                                                        Index

Index entries appearing in boldface indicate the page where the word, phrase, or BNF nonterminal was defined; index
entries appearing in italics indicate a page where the BNF nonterminal was used in a Format; and index entries appearing
in roman type indicate a page where the word, phrase, or BNF nonterminal was used in a heading, Function, Syntax Rule,
Access Rule, General Rule, Leveling Rule, Table, or other descriptive text.

                        —A—                                    <add column definition> • 571, 572, 1187
                                                               <add column scope clause> • 574, 577, 1096, 1114
A • 136, 415
                                                               <add domain constraint definition> • 605, 608, 1106
ABS • 137, 244, 251, 277, 1139
                                                               <add original method specification> • 652, 657, 662
ABSOLUTE • 136, 817, 818, 819, 820
                                                               <add overriding method specification> • 652, 663, 667
<absolute value expression> • 29, 243, 244, 245, 247,
                                                               <add table constraint definition> • 548, 571, 583, 611, 1096
 251, 1139
                                                               <add transform element list> • 717, 719, 720
ACTION • 136, 549, 550, 551
                                                               additional result sets returned • 822, 1078
<action> • 112, 113, 732, 735, 736, 737, 739, 741, 742,
 747, 748, 763, 764, 1092, 1107, 1110, 1112, 1116, 1134,       ADMIN • 114, 136, 741, 743, 744, 745, 746, 747, 751,
 1135, 1182, 1183                                               761, 762, 1138
active SQL-transaction • 888, 890, 906, 910, 911, 1051,        AFTER • 69, 125, 126, 129, 136, 478, 629, 882, 1208
 1077                                                          <aggregate function> • 191, 192, 193, 195, 196, 217, 239,
<actual identifier> • 151                                       346, 445, 449, 505, 506, 515, 516, 1100, 1166
ADA • 136, 452, 471, 487, 489, 691, 699, 701, 768, 770,        aggregated column reference • 191
 772, 774, 785, 788, 995, 1089, 1090                           ALL • 47, 61, 62, 137, 287, 288, 316, 321, 351, 354, 355,
<Ada array locator variable> • 1008, 1010, 1012, 1120           356, 357, 359, 360, 362, 363, 364, 399, 505, 506, 513,
                                                                588, 599, 673, 723, 724, 737, 739, 740, 763, 864, 871,
<Ada assignment operator> • 1007
                                                                876, 879, 892, 896, 906, 1095, 1168
<Ada BLOB locator variable> • 1008, 1009, 1011, 1126
                                                               <all> • 399, 400
<Ada BLOB variable> • 1007, 1008, 1009, 1011, 1126
                                                               <all fields column name list> • 341, 343, 350, 1130
<Ada CLOB locator variable> • 1007, 1008, 1009, 1011,
                                                               <all fields reference> • 341, 342, 343, 349, 1129
 1126
                                                               ALLOCATE • 137, 933, 976
<Ada CLOB variable> • 1007, 1008, 1009, 1011, 1126
                                                               <allocate cursor statement> • 82, 94, 100, 103, 106, 108,
<Ada derived type specification> • 1007, 1008
                                                                110, 159, 792, 953, 956, 976, 977, 979, 986, 988, 1059,
<Ada host identifier> • 992, 1007, 1008, 1009, 1010             1088, 1160
<Ada initial value> • 1007, 1011                               <allocate descriptor statement> • 82, 102, 104, 159, 792,
<Ada multiset locator variable> • 1008, 1010, 1012, 1121        933, 934, 938, 1059, 1086, 1159
<Ada qualified type specification> • 1007, 1008, 1011,         ALTER • 137, 571, 574, 579, 582, 585, 589, 602, 605,
 1130                                                           606, 607, 608, 609, 611, 628, 652, 700, 713, 717, 728,
<Ada REF variable> • 1008, 1010, 1012, 1113                     762, 763, 764, 1091, 1106
<Ada type specification> • 1007                                <alter column action> • 574
<Ada unqualified type specification> • 1007, 1011, 1130        <alter column definition> • 541, 571, 574, 575, 576, 577,
<Ada user-defined type locator variable> • 1008, 1010,          578, 580, 1096, 1133
 1012, 1119                                                    <alter domain action> • 605
<Ada user-defined type variable> • 1008, 1009, 1012, 1122      <alter domain statement> • 98, 541, 569, 603, 605, 606,
<Ada variable definition> • 992, 1007, 1008, 1010               607, 608, 609, 762, 791, 1059, 1106
ADD • 136, 572, 577, 583, 608, 611, 653, 657, 663, 719         <alter group> • 717, 719, 721
<add attribute definition> • 83, 652, 653, 654                 <alter identity column option> • 580




©ISO/IEC 2003 – All rights reserved                                                                          Index 1211
ISO/IEC 9075-2:2003 (E)




<alter identity column specification> • 574, 580, 1133         <array type> • 163, 166, 171, 649, 680, 773, 1008, 1010,
<alter routine behavior> • 700                                   1015, 1017, 1022, 1024, 1028, 1030, 1033, 1035, 1038,
<alter routine characteristic> • 700                             1039, 1040, 1043, 1045, 1116, 1117, 1120, 1141, 1150
<alter routine characteristics> • 700, 701                     <array value constructor> • 174, 175, 285, 286, 1165
<alter routine statement> • 83, 99, 700, 702, 790, 1059,       <array value constructor by enumeration> • 285, 286, 1116
 1097                                                          <array value constructor by query> • 238, 285, 286, 363,
<alter sequence generator option> • 728                          364, 1117, 1131, 1132, 1165
<alter sequence generator options> • 465, 580, 728             <array value expression> • 235, 237, 239, 283, 284, 1116
<alter sequence generator restart option> • 465, 466, 580,     <array value expression 1> • 283
 728                                                           AS • 92, 137, 181, 194, 195, 201, 203, 205, 206, 207, 211,
<alter sequence generator statement> • 77, 99, 728, 791,         212, 213, 214, 220, 222, 223, 236, 270, 273, 274, 275,
 1059, 1133                                                      287, 288, 290, 291, 303, 304, 305, 306, 313, 326, 327,
                                                                 331, 341, 343, 344, 345, 346, 351, 362, 368, 381, 422,
<alter table action> • 571
                                                                 427, 474, 492, 513, 514, 526, 528, 535, 536, 590, 591,
<alter table statement> • 98, 536, 537, 539, 545, 547, 548,      596, 603, 612, 629, 634, 635, 637, 638, 639, 640, 641,
 549, 569, 571, 572, 573, 574, 577, 578, 579, 581, 582,          646, 647, 648, 651, 657, 658, 659, 660, 673, 674, 675,
 583, 584, 585, 589, 602, 628, 713, 762, 763, 790, 1059,         682, 704, 705, 706, 707, 726, 785, 788, 811, 828, 831,
 1187                                                            839, 843, 844, 846, 849, 854, 886, 901, 909, 965, 969,
<alter transform action> • 717                                   996, 997, 998, 1000, 1008, 1009, 1010, 1014, 1015,
<alter transform action list> • 717                              1016, 1017, 1018, 1022, 1023, 1024, 1027, 1028, 1029,
<alter transform statement> • 99, 717, 718, 719, 721, 791,       1030, 1032, 1033, 1034, 1035, 1037, 1038, 1039, 1040,
 1059, 1123                                                      1042, 1043, 1044, 1045, 1063, 1064, 1111, 1132
<alter type action> • 652                                      <as clause> • 341, 344, 345, 346, 811, 1165, 1173, 1181
<alter type statement> • 83, 99, 652, 653, 654, 655, 657,      <as subquery clause> • 217, 525, 526, 528, 529, 532, 534,
 663, 668, 791, 1059, 1111                                       535, 1132
ALWAYS • 57, 136, 528, 536, 539                                ASC • 58, 59, 136, 517
ambiguous cursor name • 952, 1072                              ASENSITIVE • 96, 137, 809, 810, 813, 1109, 1134
<ampersand> • 131, 132, 134, 140, 143, 146, 991, 993           ASSERTION • 136, 523, 579, 585, 589, 602, 625, 627,
                                                                 628, 708, 713, 762
AND • 17, 30, 68, 70, 103, 104, 120, 137, 194, 254, 262,
 278, 279, 281, 315, 332, 333, 380, 382, 408, 514, 547,        <assertion definition> • 98, 188, 309, 519, 625, 626, 790,
 711, 765, 767, 768, 896, 897, 898, 991, 992, 1089               1059, 1101, 1104
ANY • 61, 137, 383, 399, 505, 507, 510, 514, 1126              <assigned row> • 755, 756, 757, 759, 760, 853, 854, 857,
                                                                 1108, 1112
<approximate numeric literal> • 27, 144, 147, 149, 208,
 209, 514, 1149, 1178                                          ASSIGNMENT • 136, 646, 647, 705, 706
<approximate numeric type> • 27, 28, 162, 165, 169, 170,       <asterisk> • 19, 74, 131, 132, 139, 241, 242, 272, 321,
 961, 1150, 1178                                                 341, 343, 344, 391, 392, 393, 394, 401, 505, 946, 1027,
                                                                 1029, 1140
ARE • 137, 770, 992
                                                               <asterisked identifier> • 341, 342
ARRAY • 11, 45, 46, 94, 137, 163, 170, 181, 182, 285,
 304, 366, 367, 435, 455, 456, 541, 784, 835, 841, 855,        <asterisked identifier chain> • 321, 341, 342, 349, 1137
 924, 926, 938, 940, 947, 961, 964, 970, 971, 1037, 1038,      ASYMMETRIC • 137, 382, 1139
 1039, 1040, 1116                                              AT • 137, 267, 275
<array concatenation> • 47, 283, 284                           ATOMIC • 137, 629, 1000, 1174
array data, right truncation • 205, 206, 284, 286, 422, 428,   attempt to assign to non-updatable column • 985, 1072
 1072, 1078                                                    attempt to assign to ordering column • 984, 1072
<array element> • 285, 286, 946, 947                           attempt to return too many result sets • 495, 1078
array element error • 235, 453, 494, 821, 827, 856, 1072       ATTRIBUTE • 136, 653, 655
<array element list> • 285, 286, 946                           <attribute default> • 50, 650, 651, 1111
<array element reference> • 47, 174, 175, 235, 347, 944,       <attribute definition> • 541, 634, 637, 647, 650, 651, 653,
 1116                                                            654, 1105, 1110, 1112, 1174
<array primary> • 283                                          <attribute name> • 152, 158, 159, 230, 530, 594, 596, 635,
                                                                 637, 638, 650, 655, 1109



1212 Foundation (SQL/Foundation)                                                        ©ISO/IEC 2003 – All rights reserved
                                                                                            ISO/IEC 9075-2:2003 (E)




<attribute or method reference> • 174, 175, 228, 229, 1113   Feature B121, “Routine language Ada” • 699, 1081, 1090
ATTRIBUTES • 136, 943                                        Feature B122, “Routine language C” • 699, 1081, 1090
<attributes specification> • 943, 953, 954, 1089             Feature B123, “Routine language COBOL” • 699, 1081,
<attributes variable> • 943, 944, 953                         1090
AUTHORIZATION • 137, 519, 520, 765, 910, 991, 992,           Feature B124, “Routine language Fortran” • 699, 1081,
 1155                                                         1090
<authorization identifier> • 76, 111, 112, 113, 114, 151,    Feature B125, “Routine language MUMPS” • 699, 1081,
 157, 158, 188, 204, 217, 231, 233, 261, 309, 475, 497,       1090
 502, 519, 520, 521, 522, 527, 534, 537, 569, 571, 582,      Feature B126, “Routine language Pascal” • 699, 1081,
 588, 594, 595, 601, 604, 605, 610, 612, 613, 614, 616,       1090
 618, 621, 623, 625, 628, 631, 633, 644, 652, 673, 692,      Feature B127, “Routine language PL/I” • 699, 1081, 1091
 693, 695, 696, 701, 704, 705, 706, 708, 710, 712, 715,      Feature B128, “Routine language SQL” • 699, 1082, 1091
 717, 720, 724, 727, 728, 729, 739, 741, 743, 746, 752,
                                                             <basic identifier chain> • 183, 185, 187, 190
 765, 772, 831, 836, 841, 847, 849, 910, 1149, 1155,
 1159, 1164                                                  <basic sequence generator option> • 580, 726, 728
AVG • 60, 61, 137, 505, 507, 510, 1151, 1154                 BEFORE • 69, 125, 126, 129, 136, 185, 629, 631, 881,
                                                              884
                        —B—                                  BEGIN • 137, 629, 992, 1000
                                                             BERNOULLI • 136, 303, 310
Feature B011, “Embedded Ada” • 1011, 1081, 1085
                                                             BETWEEN • 137, 194, 332, 333, 382, 1139
Feature B012, “Embedded C” • 1019, 1081, 1085
                                                             <between predicate> • 238, 280, 347, 373, 382, 449, 949,
Feature B013, “Embedded COBOL” • 1025, 1081, 1085
                                                              1139, 1181
Feature B014, “Embedded Fortran” • 1031, 1081, 1085
                                                             <between predicate part 2> • 197, 382
Feature B015, “Embedded MUMPS” • 1035, 1081, 1085
                                                             BIGINT • 11, 12, 27, 137, 162, 165, 172, 433, 438, 775,
Feature B016, “Embedded Pascal” • 1041, 1081, 1085            782, 924, 925, 1007, 1011, 1019, 1020, 1025, 1046,
Feature B017, “Embedded PL/I” • 1046, 1081, 1085, 1086        1130, 1149, 1174
Feature B021, “Direct SQL” • 1052, 1086                      BINARY • 11, 12, 25, 137, 162, 163, 164, 169, 215, 433,
Feature B031, “Basic dynamic SQL” • 160, 180, 934, 935,       438, 786, 787, 788, 924, 925, 941, 971, 1022, 1023,
 938, 942, 954, 962, 966, 971, 973, 974, 975, 978, 979,       1024, 1043, 1044, 1045, 1046, 1128
 980, 981, 983, 985, 1086, 1087                              <binary large object string type> • 161, 162, 169, 172, 961,
Feature B032, “Extended dynamic SQL” • 160, 934, 956,         1126
 962, 973, 977, 987, 989, 1088                               <binary set function> • 191, 505, 508, 515, 516, 1099,
Feature B033, “Untyped SQL-invoked function arguments”        1100
 • 496, 1088                                                 <binary set function type> • 505, 511, 515, 1143, 1155
Feature B034, “Dynamic specification of cursor attributes”   <binary string literal> • 134, 143, 144, 146, 147, 150, 542,
 • 954, 1088, 1089                                            1126, 1201
Feature B041, “Extensions to embedded SQL exception          BLOB • 137, 162, 163, 438, 996, 998, 1008, 1009, 1014,
 declarations” • 1006, 1089                                   1015, 1016, 1017, 1018, 1021, 1022, 1023, 1027, 1028,
Feature B051, “Enhanced execution rights” • 768, 1002,        1029, 1032, 1033, 1034, 1037, 1038, 1039, 1042, 1044
 1089                                                        <blob concatenation> • 26, 252, 253, 255, 1202
Feature B111, “Module language Ada” • 768, 1081, 1089        <blob factor> • 252, 253, 255
Feature B112, “Module language C” • 768, 1081, 1089          <blob overlay function> • 26, 257, 260, 264, 265, 1136
Feature B113, “Module language COBOL” • 769, 1081,           <blob position expression> • 243, 246
 1089                                                        <blob primary> • 252, 253
Feature B114, “Module language Fortran” • 769, 1081,         <blob substring function> • 26, 257, 260, 264, 265, 1202
 1089
                                                             <blob trim function> • 257, 260, 264, 265, 1202
Feature B115, “Module language MUMPS” • 769, 1081,
                                                             <blob trim operands> • 257
 1089, 1090
                                                             <blob trim source> • 257, 260
Feature B116, “Module language Pascal” • 769, 1081,
 1090                                                        <blob value expression> • 243, 246, 252, 253, 255, 257,
                                                              260, 264, 385, 386, 443
Feature B117, “Module language PL/I” • 769, 1081, 1090
                                                             <blob value function> • 256, 257, 260, 261, 264, 266, 1128


©ISO/IEC 2003 – All rights reserved                                                                        Index 1213
ISO/IEC 9075-2:2003 (E)




BOOLEAN • ?, ?, 11, 30, 94, 137, 150, 162, 166, 170, 171,    <C NCHAR VARYING variable> • 1013, 1014, 1015, 1016,
 239, 282, 295, 435, 514, 711, 775, 785, 788, 924, 926,       1018
 946, 1007, 1011, 1019, 1031, 1037, 1040, 1125, 1126,        <C NCLOB variable> • 1013, 1014, 1015, 1016, 1018
 1207                                                        <C numeric variable> • 1013, 1020, 1130
<boolean factor> • 68, 278, 280                              <C REF variable> • 1014, 1015, 1018, 1019, 1113
<boolean literal> • 143, 145, 150, 542, 1125                 <C storage class> • 1013
<boolean predicand> • 68, 199, 200, 278, 279, 293, 294,      <C user-defined type locator variable> • 1014, 1015, 1018,
 295, 1094, 1126                                              1019, 1119
<boolean primary> • 278, 279, 280, 281, 282, 946, 1126       <C user-defined type variable> • 1014, 1016, 1019, 1122
<boolean term> • 68, 278                                     <C VARCHAR variable> • 1013, 1014, 1015, 1016, 1018,
<boolean test> • 68, 278, 279, 282, 1103                      1160
<boolean type> • 161, 162, 170, 171, 1125                    <C variable definition> • 992, 1013, 1015, 1016, 1018
<boolean value expression> • 30, 49, 63, 68, 237, 239,       <C variable specification> • 1013
 278, 279, 280, 281, 293, 294, 295, 411, 418, 569, 625,      CALL • 137, 885
 1126
                                                             <call statement> • 84, 85, 101, 105, 107, 108, 109, 436,
BOTH • 137, 211, 212, 213, 214, 215, 256, 259, 260, 264,      474, 475, 476, 477, 496, 791, 885, 932, 951, 961, 962,
 265, 901, 902, 910, 911, 914, 915, 917, 918, 919, 920,       1059, 1088, 1159, 1193
 933, 952, 976
                                                             CALLED • 137, 637, 640, 658, 677, 680
<bracketed comment> • 136, 139, 142, 1138
                                                             CARDINALITY • 137, 244, 304, 305, 411, 413, 415, 924,
<bracketed comment contents> • 136, 139                       926, 936, 940, 961
<bracketed comment introducer> • 136, 139                    <cardinality expression> • 29, 243, 244, 245, 247, 250,
<bracketed comment terminator> • 136                          1116, 1124
branch transaction already active • 891, 1077                cardinality violation • 370, 371, 825, 842, 980, 1072
BREADTH • 136, 365, 366                                      CASCADE • 125, 136, 522, 523, 549, 551, 552, 555, 558,
BY • 57, 95, 137, 320, 321, 322, 325, 326, 327, 328, 329,     563, 578, 579, 581, 582, 585, 586, 587, 588, 589, 600,
 331, 345, 351, 365, 449, 506, 513, 514, 528, 536, 539,       601, 602, 611, 615, 619, 623, 627, 628, 673, 674, 703,
 647, 709, 711, 726, 736, 737, 744, 747, 748, 809, 810,       704, 707, 708, 712, 713, 722, 724, 725, 729, 761, 762,
 1123, 1139                                                   763, 764, 859, 1091, 1208
                                                             CASCADED • 54, 56, 137, 590, 591, 592, 596, 871, 879
                       —C—                                   CASE • 137, 194, 197, 198, 199, 200, 287, 288, 290, 367,
C • 136, 452, 471, 487, 489, 691, 699, 783, 785, 787, 788,    1094
 961, 995, 1090                                              <case abbreviation> • 197, 198, 947, 1174, 1192
<C array locator variable> • 1014, 1015, 1017, 1019, 1120    <case expression> • 174, 175, 197, 199, 217, 346, 429,
<C array specification> • 1013, 1014, 1016, 1018              1191, 1192
<C BLOB locator variable> • 1014, 1015, 1017, 1019, 1127     <case operand> • 197, 198, 199, 948, 1094
<C BLOB variable> • 1014, 1016, 1019, 1127                   <case specification> • 197, 198, 199, 947
<C character type> • 1013, 1016                              CAST • 48, 137, 181, 194, 201, 203, 205, 206, 207, 211,
                                                              212, 213, 214, 270, 273, 274, 275, 304, 326, 327, 346,
<C character variable> • 1013, 1015, 1016, 1018, 1160
                                                              362, 381, 422, 427, 492, 514, 635, 640, 646, 648, 651,
<C class modifier> • 1013                                     658, 673, 674, 676, 682, 704, 705, 707, 785, 788, 854,
<C CLOB locator variable> • 1014, 1017, 1019, 1127            886, 965, 969, 997, 1000, 1189
<C CLOB variable> • 1013, 1014, 1015, 1016, 1018, 1019,      <cast function> • 705
 1127, 1160                                                  <cast operand> • 201, 202, 204, 215, 216, 238, 947, 1098,
<C derived variable> • 1013                                   1114, 1128
<C host identifier> • 992, 1013, 1014, 1015, 1016, 1018      <cast specification> • 15, 33, 66, 94, 174, 175, 201, 202,
<C initial value> • 1013, 1014, 1015, 1018                    203, 204, 205, 206, 207, 215, 238, 594, 707, 947, 965,
<C multiset locator variable> • 1014, 1015, 1017, 1019,       969, 1191
 1121                                                        <cast target> • 201, 216, 707, 947, 1114
<C NCHAR variable> • 1013, 1014, 1015, 1016, 1018            <cast to distinct> • 634, 635, 636, 637, 638, 649, 1113
                                                             <cast to distinct identifier> • 635, 636



1214 Foundation (SQL/Foundation)                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)




<cast to ref> • 634, 635, 636, 637, 638, 649, 1113           <character set name> • 146, 152, 155, 157, 158, 160, 163,
<cast to ref identifier> • 635, 637, 638                      497, 523, 604, 612, 613, 614, 620, 621, 732, 739, 740,
<cast to source> • 634, 635, 636, 638, 649, 1113              750, 781, 917, 1100, 1149
<cast to source identifier> • 635, 636                       <character set name characteristic> • 917, 950
<cast to type> • 634, 635, 636, 637, 638, 649, 1113          <character set source> • 612
<cast to type identifier> • 635, 637, 638                    <character set specification> • 23, 140, 141, 143, 146,
                                                              147, 153, 161, 164, 173, 497, 498, 519, 521, 537, 603,
CATALOG • 136, 914, 915
                                                              612, 613, 616, 620, 650, 732, 763, 765, 766, 767, 770,
<catalog name> • 77, 151, 156, 157, 158, 159, 179, 264,       920, 925, 992, 1007, 1008, 1011, 1013, 1014, 1018,
 520, 522, 766, 914, 915, 1065, 1066, 1067, 1068, 1103,       1021, 1025, 1027, 1030, 1032, 1037, 1040, 1042, 1045,
 1149, 1157                                                   1100, 1155, 1159, 1160
<catalog name characteristic> • 914, 950                     <character set specification list> • 765, 767, 920, 921
CATALOG_NAME • 136, 1055, 1066, 1067                         <character specifier> • 391, 392, 393, 394
CEIL • 137, 244                                              <character string literal> • 135, 139, 140, 141, 143, 145,
CEILING • 137, 244                                            146, 147, 148, 149, 150, 152, 153, 541, 917, 1094
<ceiling function> • 29, 243, 244, 245, 249, 251, 1143,      <character string type> • 161, 163, 164, 603, 650, 960,
 1152                                                         1149, 1178, 1179
CHAIN • 103, 104, 120, 136, 896, 897, 898, 899, 1135         <character substring function> • 16, 26, 256, 257, 258,
CHAR • 137, 161, 163, 438, 775, 780, 781, 782, 784, 1007,     261, 1179, 1202
 1008, 1009, 1010, 1011, 1037, 1038, 1039, 1040, 1042        <character transliteration> • 19, 256, 257, 259, 261, 263,
<char length expression> • 243, 247, 944, 1179, 1202          266, 1105, 1152
<char length units> • 162, 163, 167, 172, 243, 245, 246,     <character value expression> • 244, 247, 252, 253, 254,
 247, 256, 257, 258, 261, 1130                                255, 256, 257, 258, 259, 261, 262, 263, 264, 385, 390,
CHAR_LENGTH • 137, 243, 246, 259                              391, 392, 393, 394, 396, 1099, 1128, 1129, 1152
CHARACTER • 11, 12, 14, 15, 94, 137, 147, 161, 162,          <character value function> • 256, 257, 261
 163, 164, 169, 173, 215, 216, 251, 390, 396, 419, 433,      CHARACTER_LENGTH • 8, 137, 243, 440
 438, 497, 519, 523, 537, 612, 614, 615, 739, 781, 782,      CHARACTER_SET_CATALOG • 136, 924, 925, 936, 940,
 783, 784, 785, 786, 787, 788, 803, 924, 925, 941, 944,       941, 942, 960, 1159
 945, 946, 949, 950, 971, 1007, 1008, 1011, 1013, 1014,      CHARACTER_SET_NAME • 136, 924, 925, 936, 940,
 1015, 1016, 1018, 1021, 1023, 1025, 1027, 1028, 1029,        941, 942, 960, 1159
 1030, 1032, 1033, 1037, 1038, 1040, 1042, 1043, 1044,
                                                             CHARACTER_SET_SCHEMA • 136, 924, 925, 936, 940,
 1045, 1046, 1098, 1099, 1128, 1129, 1145, 1149
                                                              941, 942, 960, 1159
<character enumeration> • 392, 393, 394, 395
                                                             CHARACTERISTICS • 136, 909
<character enumeration exclude> • 392, 395
                                                             CHARACTERS • 136, 162, 163, 167, 245, 246, 258
<character enumeration include> • 392, 395
                                                             CHECK • 54, 56, 137, 538, 569, 570, 590, 591, 592, 596,
<character factor> • 252, 253, 254, 263, 1152                 599, 625, 837, 843, 844, 848, 851, 871, 879, 1067, 1104,
<character large object type> • 161, 172, 1126                1107, 1130
<character like predicate> • 385, 386, 389, 949, 1094        <check constraint definition> • 188, 215, 309, 536, 538,
<character like predicate part 2> • 197, 385                  545, 546, 569, 570, 603, 611, 1104, 1186
character not in repertoire • 167, 1072                      <circumflex> • 19, 132, 133, 392, 393, 395
<character overlay function> • 18, 26, 256, 257, 259, 260,   CLASS_ORIGIN • 136, 1055, 1065, 1080, 1160
 261, 265, 1136                                              CLOB • 137, 161, 163, 438, 996, 998, 1008, 1009, 1014,
<character pattern> • 385, 390, 442, 949, 1095                1016, 1017, 1018, 1021, 1022, 1023, 1024, 1027, 1028,
<character primary> • 252, 253                                1029, 1032, 1033, 1034, 1037, 1038, 1039, 1042, 1043,
                                                              1044
<character representation> • 143, 145, 146, 147, 148, 150,
 1007, 1011, 1015, 1018, 1021, 1025, 1042, 1045, 1094,       CLOSE • 137, 489, 822, 896, 899, 981
 1179                                                        <close statement> • 95, 100, 103, 106, 108, 110, 791, 822,
<character set definition> • 98, 155, 497, 519, 612, 613,     1059, 1184, 1185
 790, 1059, 1100                                             COALESCE • 8, 71, 137, 197, 198, 313, 317




©ISO/IEC 2003 – All rights reserved                                                                      Index 1215
ISO/IEC 9075-2:2003 (E)




COBOL • ?, 94, 136, 452, 471, 487, 489, 691, 699, 701,       <collection value constructor> • 174, 175
 769, 783, 785, 786, 787, 788, 995, 1022, 1023, 1025,        <collection value expression> • 237, 239, 244, 246, 247,
 1081, 1085, 1089, 1090, 1160                                 303, 304, 429
<COBOL array locator variable> • 1021, 1022, 1024, 1025,     <colon> • 131, 132, 144, 145, 152, 392, 393, 395, 469,
 1120                                                         470, 992, 1007, 1037
<COBOL binary integer> • 1022, 1025                          COLUMN • 137, 572, 574, 581, 582, 763, 764, 1091
<COBOL BLOB locator variable> • 1021, 1022, 1024,            <column constraint> • 528, 536, 538, 1185, 1186
 1026, 1127                                                  <column constraint definition> • 526, 528, 530, 531, 536,
<COBOL BLOB variable> • 1021, 1023, 1026, 1127                538, 539
<COBOL character type> • 1021, 1023, 1025                    <column default option> • 526, 527
<COBOL CLOB locator variable> • 1021, 1022, 1024,            <column definition> • 164, 171, 521, 525, 527, 529, 530,
 1026, 1127                                                   531, 532, 534, 536, 537, 539, 541, 547, 548, 572, 573,
<COBOL CLOB variable> • 1021, 1023, 1026, 1127                858, 859, 1105, 1114, 1141, 1174, 1186
<COBOL derived type specification> • 1021                    <column name> • 54, 151, 158, 183, 184, 185, 187, 304,
<COBOL host identifier> • 992, 1021, 1022, 1023, 1025         305, 307, 308, 313, 341, 343, 345, 346, 352, 357, 358,
<COBOL integer type> • 1021, 1022                             365, 366, 368, 526, 528, 529, 530, 531, 536, 537, 547,
                                                              548, 550, 572, 573, 574, 575, 576, 577, 578, 580, 581,
<COBOL multiset locator variable> • 1021, 1022, 1024,
                                                              590, 591, 594, 595, 596, 611, 630, 676, 678, 732, 740,
 1025, 1121
                                                              741, 749, 750, 751, 755, 759, 763, 811, 812, 835, 836,
<COBOL national character type> • 1021, 1022, 1023            837, 840, 841, 844, 846, 853, 985, 999, 1067, 1141,
<COBOL NCLOB variable> • 1021, 1023                           1166, 1173
<COBOL nines> • 1022                                         <column name list> • 112, 113, 304, 312, 341, 351, 526,
<COBOL nines specification> • 1022                            528, 529, 547, 549, 590, 629, 739, 809, 810, 812, 834,
<COBOL numeric type> • 1021, 1022, 1025                       846, 985, 1186
<COBOL REF variable> • 1021, 1022, 1025, 1113                <column option list> • 526, 531, 535, 1114
<COBOL type specification> • 1021                            <column options> • 525, 526, 530, 531, 1174
<COBOL user-defined type locator variable> • 1021, 1022,     <column reference> • 57, 59, 129, 174, 175, 176, 177,
 1024, 1026, 1119                                             178, 185, 187, 188, 189, 191, 192, 279, 319, 320, 325,
                                                              326, 327, 329, 331, 332, 344, 345, 349, 478, 493, 528,
<COBOL user-defined type variable> • 1021, 1022, 1023,
                                                              537, 582, 752, 753, 754, 755, 756, 757, 759, 811, 817,
 1025, 1122
                                                              824, 846, 1099, 1109, 1136, 1139, 1164, 1184, 1185,
<COBOL variable definition> • 992, 1021, 1023, 1025,          1192
 1160
                                                             COLUMN_NAME • 136, 1055, 1067
COLLATE • 137, 502
                                                             <comma> • 131, 132, 162, 163, 179, 191, 197, 244, 285,
<collate clause> • 59, 161, 163, 202, 252, 253, 320, 321,     291, 293, 298, 301, 304, 320, 322, 323, 324, 325, 331,
 331, 332, 334, 502, 536, 537, 539, 603, 604, 612, 613,       341, 345, 351, 365, 383, 391, 416, 467, 473, 474, 499,
 650, 651, 1104, 1105, 1174                                   505, 506, 517, 525, 590, 634, 635, 675, 676, 677, 714,
COLLATION • 136, 177, 523, 616, 618, 619, 732, 739,           717, 721, 736, 739, 744, 747, 765, 771, 817, 824, 839,
 763, 765, 920                                                853, 860, 861, 887, 890, 892, 909, 936, 939, 963, 967,
<collation definition> • 99, 156, 519, 616, 617, 749, 790,    1007, 1013, 1014, 1015, 1027, 1032, 1037, 1042, 1055
 1059, 1104, 1156, 1166                                      COMMAND_FUNCTION • 136, 1055, 1058, 1068
<collation name> • 59, 152, 156, 158, 159, 321, 332, 502,    COMMAND_FUNCTION_CODE • 136, 1055, 1059, 1160
 523, 604, 612, 613, 616, 618, 732, 739, 740, 749, 750,      <comment> • 135, 136, 139
 765, 766, 920, 1104
                                                             <comment character> • 136
<collation specification> • 920
                                                             COMMIT • 53, 117, 119, 137, 525, 531, 533, 550, 569,
COLLATION_CATALOG • 136, 936, 939, 961, 1159                  858, 896
COLLATION_NAME • 136, 936, 939, 961, 1159                    <commit statement> • 64, 95, 98, 101, 103, 104, 105, 115,
COLLATION_SCHEMA • 136, 936, 939, 961, 1159                   118, 120, 504, 768, 791, 813, 896, 897, 907, 1050, 1059,
COLLECT • 137, 505, 507, 515, 1124, 1175                      1135, 1169, 1186
<collection derived table> • 71, 303, 304, 306, 308, 310,    COMMITTED • 116, 118, 119, 136, 887, 891
 1117, 1124                                                  <common sequence generator option> • 726
<collection type> • 45, 46, 161, 163, 166, 170, 171, 1125


1216 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                         ISO/IEC 9075-2:2003 (E)




<common sequence generator options> • 463, 536, 538,       <constraint name list> • 610, 892, 893
 726, 727                                                  CONSTRAINT_CATALOG • 136, 1055, 1065, 1067
<common value expression> • 68, 199, 200, 237, 239,        CONSTRAINT_NAME • 136, 1056, 1066, 1067
 279, 293, 294, 295, 385, 389, 392, 403, 411, 413, 415,    CONSTRAINT_SCHEMA • 136, 1056, 1065, 1067
 416, 1094
                                                           CONSTRAINTS • 136, 892, 896, 1208, 1209
<comp op> • 7, 68, 375, 376, 377, 378, 379, 380, 381,
                                                           CONSTRUCTOR • 37, 39, 136, 499, 500, 501, 635, 638,
 399, 400, 518, 812, 813, 1166, 1188
                                                            640, 641, 642, 643, 645, 657, 659, 660, 661, 663, 664,
<comparison predicate> • 7, 20, 26, 68, 177, 238, 280,      666, 668, 669, 670, 671, 675, 677, 678, 695
 347, 373, 375, 376, 379, 399, 400, 442, 447, 449, 518,
                                                           <constructor method selection> • 222, 223, 474, 476, 477
 813, 949, 1188, 1189, 1190
                                                           containing SQL not permitted • 488
<comparison predicate part 2> • 197, 375
                                                           containing SQL not permitted • 1075
<computational operation> • 505, 514, 515, 1099, 1124,
 1125, 1126, 1129, 1143, 1183                              CONTAINS • 136, 637, 658, 677, 685, 692, 696, 701, 702,
                                                            711, 1156
<concatenation> • 252, 253, 254, 255, 1179, 1202
                                                           <contextually typed row value constructor> • 293, 294,
<concatenation operator> • 16, 135, 252, 283, 946
                                                            295, 296, 297, 299, 835, 1103, 1129, 1165
CONDITION • 137, 1055, 1171, 1175
                                                           <contextually typed row value constructor element> • 293,
<condition> • 1003, 1004                                    294, 295, 835
<condition action> • 1003, 1005                            <contextually typed row value constructor element list> •
<condition information> • 1055, 1065                        293, 295, 299, 1103
<condition information item> • 1055, 1056, 1065            <contextually typed row value expression> • 218, 296,
<condition information item name> • 1055, 1056, 1069        297, 298, 299, 835, 853, 948, 950, 1184
<condition number> • 1055, 1056, 1065, 1169                <contextually typed row value expression list> • 298, 299,
CONDITION_NUMBER • 136, 1055, 1065                          1103
CONNECT • 137, 794, 901, 1051                              <contextually typed table value constructor> • 218, 295,
<connect statement> • 101, 111, 120, 122, 129, 791, 794,    298, 299, 834, 835, 836, 838, 845, 948, 1103, 1112,
 901, 902, 903, 1050, 1059, 1108, 1148, 1158, 1159,         1165, 1184
 1168                                                      <contextually typed value specification> • 181, 293, 294,
CONNECTION • 136, 794, 904, 1051                            835, 839, 841, 853, 855, 1191
connection does not exist • 794, 904, 906, 1051, 1072      CONTINUE • 136, 1003
connection exception • 120, 794, 902, 904, 906, 1051,      CONVERT • 137, 256
 1072                                                      CORR • 62, 137, 505, 511
connection failure • 904, 1072                             <correlation name> • 70, 151, 157, 184, 303, 304, 306,
<connection name> • 120, 152, 157, 158, 159, 901, 902,      342, 343, 366, 629, 828, 831, 832, 839, 840, 842, 844,
 904, 906, 1068, 1107                                       845, 846, 849, 850, 1064, 1108, 1181, 1182
connection name in use • 902, 1072                         CORRESPONDING • 137, 351, 357, 364, 581, 599, 1095
<connection object> • 904, 905, 906                        <corresponding column list> • 351, 357
<connection target> • 901                                  <corresponding spec> • 351
<connection user name> • 122, 152, 157, 901, 902, 1158,    COUNT • 60, 61, 137, 194, 346, 505, 507, 509, 510, 514,
 1159                                                       936, 937, 958, 963, 968, 1063, 1064, 1099, 1151, 1154,
                                                            1208
CONNECTION_NAME • 136, 1055, 1068
                                                           COVAR_POP • 62, 137, 505, 511
CONSTRAINT • 137, 503, 579, 584, 585, 589, 609, 628,
 713, 762, 1003, 1004, 1005, 1006, 1089, 1207, 1208        COVAR_SAMP • 62, 137, 505, 511
<constraint characteristics> • 503, 504, 536, 538, 545,    CREATE • 137, 519, 525, 590, 591, 603, 612, 616, 620,
 603, 611, 625, 1106                                        625, 629, 634, 646, 647, 648, 675, 705, 709, 711, 714,
                                                            726, 743, 1207, 1208
<constraint check time> • 503, 504
                                                           CROSS • 137, 312, 314, 315
<constraint name> • 152, 158, 159, 503, 523, 545, 579,
 584, 585, 603, 604, 609, 610, 611, 625, 626, 627, 628,    <cross join> • 312, 315, 316, 318, 1097
 708, 713, 762, 892, 893, 1003, 1005, 1006, 1101, 1166     CUBE • 59, 68, 73, 137, 320, 323
<constraint name definition> • 503, 504, 536, 538, 545,    <cube list> • 320, 321, 322, 323, 324, 328, 1138
 603, 604, 611, 1101, 1106, 1166



©ISO/IEC 2003 – All rights reserved                                                                    Index 1217
ISO/IEC 9075-2:2003 (E)




CUME_DIST • 60, 62, 63, 137, 193, 194, 196, 514, 1142,          943, 952, 953, 956, 975, 976, 977, 978, 984, 985, 986,
 1146                                                           988, 1053
CURRENT • 137, 194, 332, 333, 336, 338, 339, 340, 828,         cursor specification cannot be executed • 972, 1075
 846, 906, 982, 984, 986, 988                                  CURSOR_NAME • 136, 1056, 1065, 1067
<current collation specification> • 176, 177, 179, 180, 1105   CYCLE • 78, 137, 365, 462, 464, 726
<current date value function> • 270, 1189                      <cycle clause> • 365, 366, 367, 368
<current local time value function> • 270, 271, 1102, 1190     <cycle column> • 365
<current local timestamp value function> • 270, 271, 1102,     <cycle column list> • 365, 366
 1190                                                          <cycle mark column> • 365, 366
<current time value function> • 270, 271, 1098                 <cycle mark value> • 365, 366
<current timestamp value function> • 270, 271, 1098
CURRENT_DATE • 118, 137, 213, 214, 270, 271, 280,                                    —D—
 570, 626, 1104, 1165
                                                               DATA • 136, 526, 534, 677, 680, 685, 692, 696, 701, 702,
CURRENT_DEFAULT_TRANSFORM_GROUP • 123,
                                                                788, 936, 938, 939, 940, 959, 964, 965, 971, 1009, 1023,
 137, 176, 178, 179, 180, 815, 1053, 1122
                                                                1029, 1034, 1039, 1044, 1156, 1168
CURRENT_PATH • 90, 122, 137, 176, 177, 179, 180, 238,
                                                               data exception • 167, 179, 205, 206, 207, 208, 209, 210,
 541, 542, 543, 544, 815, 1053, 1115, 1151
                                                                211, 212, 213, 214, 215, 235, 242, 247, 248, 249, 250,
CURRENT_ROLE • 111, 137, 176, 177, 179, 180, 238,               254, 255, 261, 262, 264, 265, 269, 275, 284, 286, 298,
 346, 541, 542, 543, 544, 736, 739, 741, 743, 744, 748,         310, 335, 336, 337, 338, 339, 387, 388, 393, 420, 421,
 815, 1053, 1138                                                422, 425, 426, 427, 428, 453, 462, 480, 493, 494, 509,
CURRENT_TIME • 137, 270, 271, 1165                              510, 513, 651, 773, 785, 820, 821, 826, 827, 856, 913,
CURRENT_TIMESTAMP • 137, 270, 271, 280, 570, 626,               938, 940, 1068, 1072, 1151, 1152
 696, 1104, 1165                                               <data type> • 16, 43, 45, 81, 88, 89, 90, 147, 157, 161,
CURRENT_TRANSFORM_GROUP_FOR_TYPE • 123,                         163, 166, 168, 169, 170, 171, 173, 201, 203, 216, 222,
 137, 176, 178, 179, 180, 815, 1053, 1122                       223, 294, 308, 314, 346, 348, 453, 454, 477, 491, 492,
CURRENT_USER • 111, 118, 137, 176, 177, 178, 180,               499, 500, 530, 534, 536, 537, 539, 571, 595, 637, 640,
 238, 346, 541, 542, 543, 544, 736, 739, 740, 743, 744,         644, 650, 651, 658, 665, 675, 676, 679, 681, 682, 688,
 747, 815, 1053, 1095, 1096, 1150                               690, 692, 694, 696, 698, 701, 705, 726, 727, 752, 753,
                                                                754, 755, 756, 757, 759, 767, 771, 773, 774, 781, 782,
CURSOR • 137, 809, 957, 975, 976, 1174
                                                                793, 947, 995, 1112, 1114, 1117, 1119, 1120, 1121,
<cursor attribute> • 955                                        1124, 1125, 1126, 1149, 1186, 1201
<cursor attributes> • 955                                      <data type list> • 499, 500, 668, 669
<cursor holdability> • 809, 810, 814, 954, 955, 975, 976,      <data type or domain name> • 536, 537
 1140, 1184, 1185
                                                               data type transform function violation • 966, 970, 1075
<cursor intent> • 976
                                                               DATE • 11, 12, 31, 32, 34, 94, 138, 144, 147, 162, 165,
<cursor name> • 152, 153, 154, 158, 160, 495, 767, 809,         167, 170, 210, 211, 267, 270, 435, 438, 942, 951
 810, 815, 817, 822, 828, 846, 952, 975, 977, 978, 979,
                                                               <date literal> • 144, 147, 1188
 981, 982, 984, 985, 986, 988, 994, 1142, 1191
                                                               <date string> • 135, 144
cursor operation conflict • 567, 830, 833, 843, 847, 851,
 1078                                                          <date value> • 144, 149
cursor operation conflict • 1065                               <datetime factor> • 238, 267
<cursor returnability> • 809, 810, 813, 954, 955, 975, 976,    datetime field overflow • 269, 335, 422, 427, 1073
 1140                                                          <datetime literal> • 143, 144, 148, 149, 150, 542, 1188,
<cursor scrollability> • 809, 810, 813, 954, 955, 975, 976,     1189
 1099, 1109                                                    <datetime primary> • 238, 267, 268
<cursor sensitivity> • 809, 810, 813, 953, 955, 975, 976,      <datetime term> • 238, 267, 268, 269, 272, 273, 275
 1109, 1134                                                    <datetime type> • 31, 161, 162, 167, 170, 924, 961, 1150,
cursor sensitivity exception • 816, 829, 832, 836, 837, 842,    1188, 1189
 847, 850, 1072                                                <datetime value> • 145, 148, 211, 212, 213, 214, 215
<cursor specification> • 82, 96, 183, 193, 217, 755, 756,      <datetime value expression> • 237, 238, 239, 244, 245,
 758, 760, 809, 810, 811, 812, 813, 815, 817, 822, 846,         246, 247, 267, 268, 269, 272, 273, 275, 1092, 1190



1218 Foundation (SQL/Foundation)                                                       ©ISO/IEC 2003 – All rights reserved
                                                                                             ISO/IEC 9075-2:2003 (E)




<datetime value function> • 238, 267, 268, 270, 271, 541,     <delete statement: positioned> • 56, 95, 96, 100, 103, 106,
 542, 543, 815, 1190                                            108, 110, 567, 756, 759, 791, 813, 828, 829, 830, 833,
DATETIME_INTERVAL_CODE • 136, 924, 936, 940, 941,               843, 847, 851, 982, 986, 1060, 1184, 1185
 942, 961                                                     <delete statement: searched> • 56, 100, 103, 106, 108,
DATETIME_INTERVAL_PRECISION • 136, 924, 936,                    109, 755, 756, 757, 759, 760, 791, 830, 831, 833, 847,
 940, 941, 942, 961                                             896, 943, 1049, 1060, 1063, 1064, 1108, 1131, 1169,
DAY • 32, 138, 148, 268, 335, 336, 430, 434, 467, 942,          1184
 946, 951                                                     <delimited identifier> • 134, 135, 139, 141, 151, 179, 1097,
<day-time interval> • 145                                       1145, 1148, 1180
<day-time literal> • 145, 148                                 <delimited identifier body> • 134, 139, 141, 1097
<days value> • 144, 145, 148                                  <delimited identifier part> • 134, 135, 139, 141, 1097
DEALLOCATE • 138, 489, 768, 935, 952, 956, 974, 1050          <delimiter token> • 134, 135, 139
<deallocate descriptor statement> • 82, 102, 104, 768,        DENSE_RANK • 60, 63, 138, 193, 194, 508, 1155
 792, 935, 1050, 1059, 1086                                   dependent privilege descriptors still exist • 762, 1074
<deallocate prepared statement> • 80, 81, 95, 102, 104,       <dependent variable expression> • 62, 191, 505, 506, 508,
 792, 956, 1060, 1088                                           511, 512, 515, 516, 1099, 1100
DEC • 138, 162, 163, 169, 785, 787, 1032, 1033, 1043,         DEPTH • 136, 365, 366
 1150                                                         DEREF • 138, 231, 233
DECIMAL • 11, 12, 27, 138, 162, 163, 165, 169, 433, 438,      <dereference operation> • 228, 230, 347, 578, 587, 600,
 924, 925, 941, 1033, 1043, 1046, 1149, 1150                    753, 754, 756, 757, 759, 1113
DECLARE • 138, 809, 858, 975, 991, 992, 1000, 1042,           <dereference operator> • 228, 230, 231
 1045                                                         DERIVED • 136, 526, 529, 593, 596
<declare cursor> • 79, 94, 95, 96, 100, 105, 107, 109, 110,   <derived column> • 183, 258, 313, 314, 319, 325, 341,
 154, 333, 483, 489, 765, 767, 809, 810, 815, 817, 822,         343, 344, 345, 346, 347, 401, 811, 812, 821, 960, 1099,
 832, 837, 842, 850, 975, 977, 986, 988, 991, 994, 996,         1140, 1167, 1173
 1001, 1154, 1157, 1164, 1167, 1168, 1184, 1185               <derived column list> • 303, 304, 305, 307, 308, 1181
DEFAULT • 57, 125, 138, 181, 365, 519, 528, 536, 539,         <derived representation> • 13, 44, 634, 635, 637, 645
 541, 549, 551, 554, 557, 562, 565, 576, 607, 794, 834,
                                                              <derived table> • 58, 71, 303, 307, 308, 310, 347, 354,
 835, 838, 847, 901, 902, 904, 906, 919, 1051, 1093,
                                                                359, 1103
 1159, 1207
                                                              DESC • 58, 59, 136, 336, 337, 338, 514, 517, 518, 812
<default clause> • 49, 526, 530, 531, 536, 539, 541, 542,
 544, 575, 603, 604, 606, 610, 650, 835, 1186, 1190           DESCRIBE • 138, 957
<default option> • 49, 50, 181, 528, 530, 531, 539, 541,      <describe input statement> • 81, 102, 104, 957, 958, 959,
 542, 543, 544, 713, 1096, 1115, 1138                           962, 964, 1088, 1168, 1194
<default specification> • 181, 182, 294, 835, 841, 854,       <describe output statement> • 81, 82, 102, 104, 957, 958,
 1191                                                           959, 962, 968, 1087, 1168
default value too long for information schema • 544, 1079     <describe statement> • 792, 938, 942, 957, 1060, 1159
DEFAULTS • 136, 526, 527, 528                                 <described object> • 957
DEFERRABLE • 136, 503, 504, 538, 545, 603, 625, 892,          DESCRIPTOR • 136, 768, 933, 935, 936, 939, 957, 967,
 1106, 1208                                                     1050
DEFERRED • 136, 503, 504, 892, 1207, 1208, 1209               <descriptor item name> • 936, 937, 938, 939, 940, 1136
DEFINED • 87, 136, 484, 677, 685, 697, 924, 926, 1154         <descriptor name> • 153, 157, 159, 160, 768, 933, 935,
                                                                936, 937, 938, 939, 940, 957, 958, 963, 964, 967, 968,
DEFINER • 87, 136, 484, 676, 677, 685, 694, 696, 697,
                                                                1050, 1086, 1088, 1159, 1191
 758, 953
                                                              DETERMINISTIC • 63, 138, 487, 637, 640, 646, 648, 658,
DEGREE • 136, 924, 926, 936, 940, 941, 961
                                                                677, 680, 685, 692, 694, 711, 1156
DELETE • 53, 113, 126, 127, 128, 129, 138, 525, 531,
                                                              <deterministic characteristic> • 635, 640, 658, 676, 677,
 533, 534, 549, 550, 552, 553, 555, 567, 568, 569, 598,
                                                                679, 680
 629, 630, 734, 739, 756, 759, 828, 829, 831, 832, 858,
 859, 862, 883, 896, 982, 986, 1174, 1207, 1208, 1209         DIAGNOSTICS • 136, 887, 1055
<delete rule> • 549, 551, 552, 553, 554, 555, 556, 557,       diagnostics exception • 1070, 1074
 558, 568, 1093                                               <diagnostics size> • 887, 889, 890, 909, 1093



©ISO/IEC 2003 – All rights reserved                                                                         Index 1219
ISO/IEC 9075-2:2003 (E)




<digit> • 131, 134, 139, 144, 147, 150, 151, 164, 208, 209,   <drop assertion statement> • 98, 523, 579, 585, 589, 602,
  395, 854, 1003, 1071, 1102, 1161                             627, 628, 708, 713, 762, 791, 1060, 1101
<direct implementation-defined statement> • 1049, 1050,       <drop attribute definition> • 652, 655, 656
  1051, 1160                                                  <drop behavior> • 522, 578, 581, 584, 587, 589, 600, 602,
<direct invocation> • 222                                      610, 618, 627, 672, 674, 703, 704, 707, 712, 721, 723,
<direct select statement: multiple rows> • 100, 104, 107,      729, 747, 764, 1091, 1187
  109, 1049, 1050, 1053, 1060                                 <drop character set statement> • 98, 155, 523, 614, 615,
<direct SQL data statement> • 1049, 1052                       791, 1060, 1100
<direct SQL statement> • 83, 88, 90, 115, 120, 121, 122,      <drop collation statement> • 99, 156, 523, 618, 619, 763,
  125, 129, 153, 154, 155, 156, 451, 476, 477, 693, 793,       791, 1060, 1104
  794, 914, 915, 917, 918, 1049, 1050, 1051, 1052, 1086,      <drop column default clause> • 574, 576, 1096
  1147, 1169                                                  <drop column definition> • 571, 581, 582, 1091
<directly executable statement> • 1049                        <drop column scope clause> • 574, 578, 579, 1096, 1114
DISCONNECT • 138, 906                                         <drop data type statement> • 83, 99, 523, 672, 674, 763,
disconnect error • 907, 1079                                   791, 1060, 1091, 1193
<disconnect object> • 906                                     <drop domain constraint definition> • 605, 609, 1101, 1106
<disconnect statement> • 101, 120, 791, 906, 907, 1060,       <drop domain default clause> • 605, 607, 1106
  1108, 1167, 1168                                            <drop domain statement> • 98, 522, 610, 611, 708, 713,
DISPATCH • 136, 648, 676, 711                                  763, 791, 1060, 1094
<dispatch clause> • 675, 676, 681                             <drop method specification> • 652, 668, 671
DISPLAY • 1022                                                <drop role statement> • 99, 523, 746, 790, 1060, 1137,
DISTINCT • 20, 26, 47, 61, 62, 138, 194, 195, 217, 239,        1138
  287, 288, 289, 290, 328, 342, 345, 347, 349, 350, 351,      <drop routine statement> • 83, 99, 523, 578, 585, 589,
  355, 356, 357, 360, 361, 362, 364, 380, 409, 410, 445,       602, 628, 673, 703, 704, 708, 712, 722, 724, 725, 763,
  447, 505, 507, 508, 509, 514, 515, 635, 812, 1095, 1099,     790, 1060, 1091, 1111, 1193
  1102, 1109, 1125, 1130, 1132, 1139, 1140, 1165, 1166        <drop schema statement> • 98, 522, 524, 790, 1060, 1096
<distinct predicate> • 238, 373, 409, 410, 442, 443, 949,     <drop sequence generator statement> • 99, 523, 729, 791,
  1132                                                         1060, 1133
<distinct predicate part 2> • 197, 409, 410, 1132             <drop table constraint definition> • 571, 584, 586, 1096,
division by zero • 242, 248, 1073                              1097
DOMAIN • 136, 522, 603, 605, 610, 611, 708, 713, 732,         <drop table statement> • 98, 522, 587, 588, 589, 708, 762,
  739, 762, 763                                                790, 859, 1060, 1091, 1187
<domain constraint> • 49, 177, 215, 603, 604, 608             <drop transform element list> • 717, 721, 722
<domain definition> • 98, 164, 519, 521, 541, 569, 603,       <drop transform statement> • 99, 673, 704, 723, 725, 791,
  604, 750, 790, 1060, 1094, 1105, 1166                        1060, 1122
<domain name> • 49, 151, 158, 159, 201, 203, 204, 215,        <drop transliteration statement> • 99, 156, 523, 623, 624,
  346, 522, 536, 537, 538, 543, 603, 604, 605, 606, 607,       791, 1060, 1106
  608, 609, 610, 708, 713, 732, 739, 740, 750, 762, 763,      <drop trigger statement> • 99, 523, 581, 585, 589, 602,
  947, 1094, 1174                                              628, 633, 708, 713, 762, 791, 1060, 1134
DOUBLE • 11, 12, 27, 138, 162, 165, 170, 433, 438, 924,       <drop user-defined cast statement> • 99, 673, 674, 704,
  926, 1011, 1019, 1027, 1030, 1149, 1150                      707, 708, 790, 1060, 1118, 1119
<double colon> • 135, 224                                     <drop user-defined ordering statement> • 99, 704, 712,
<double period> • 135, 1007, 1037                              713, 791, 1060, 1123
<double quote> • 17, 131, 132, 134, 139, 140, 141, 262,       <drop view statement> • 98, 522, 579, 585, 589, 600, 601,
  264                                                          602, 628, 708, 713, 762, 790, 1060, 1091, 1187
<doublequote symbol> • 134, 135, 141, 264                     DYNAMIC • 138, 676, 680, 765, 767, 768, 991, 992, 1089,
DROP • 138, 522, 523, 576, 578, 579, 581, 582, 584, 585,       1174
  586, 587, 588, 589, 600, 601, 602, 607, 609, 610, 614,      <dynamic close statement> • 82, 95, 100, 104, 106, 108,
  618, 623, 627, 628, 633, 655, 668, 672, 673, 674, 703,       110, 792, 981, 1060, 1087
  704, 707, 708, 712, 713, 721, 722, 723, 724, 725, 729,
  746, 762, 763, 764, 859, 1091



1220 Foundation (SQL/Foundation)                                                       ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)




<dynamic cursor name> • 153, 159, 160, 978, 979, 981,        <embedded SQL Ada program> • 80, 991, 993, 995, 1001,
 982, 984, 985, 1086, 1160                                    1004, 1007, 1008, 1010, 1011, 1085, 1130
<dynamic declare cursor> • 82, 94, 100, 105, 107, 109,       <embedded SQL begin declare> • 992, 993, 1001, 1038
 110, 765, 767, 952, 953, 975, 978, 979, 981, 982, 984,      <embedded SQL C program> • 80, 991, 993, 995, 1001,
 986, 988, 991, 994, 997, 1001, 1087                          1004, 1013, 1015, 1018, 1019, 1085, 1160
<dynamic delete statement: positioned> • 82, 96, 100,        <embedded SQL COBOL program> • 80, 991, 993, 995,
 104, 107, 109, 110, 567, 792, 982, 983, 1060, 1087           996, 1001, 1004, 1021, 1022, 1023, 1025, 1085, 1160
<dynamic fetch statement> • 82, 96, 100, 104, 106, 108,      <embedded SQL declare section> • 80, 992, 993, 1001,
 110, 792, 942, 967, 968, 979, 1061, 1087, 1159               1008, 1015, 1022, 1028, 1033, 1038, 1043
<dynamic open statement> • 82, 95, 100, 103, 106, 108,       <embedded SQL end declare> • 992, 993, 1001, 1038
 110, 792, 942, 963, 977, 978, 1061, 1087, 1159              <embedded SQL Fortran program> • 80, 991, 993, 995,
<dynamic parameter specification> • 81, 86, 176, 177,         996, 1001, 1004, 1027, 1028, 1030, 1031, 1085, 1127
 178, 179, 180, 273, 346, 432, 475, 478, 496, 590, 625,      <embedded SQL host program> • 80, 81, 991, 993, 994,
 631, 683, 860, 944, 951, 957, 958, 959, 960, 962, 963,       995, 1002, 1004, 1005, 1160, 1168, 1169, 1191, 1207
 964, 967, 968, 972, 974, 978, 1049, 1086, 1088, 1159,
                                                             <embedded SQL MUMPS declare> • 992, 993, 1001
 1168
                                                             <embedded SQL MUMPS program> • 80, 991, 993, 995,
<dynamic result sets characteristic> • 676, 680, 697, 700,
                                                              996, 1004, 1032, 1033, 1035, 1085, 1127
 701, 1140
                                                             <embedded SQL Pascal program> • 80, 991, 993, 995,
dynamic result sets returned • 495, 1079
                                                              996, 1001, 1004, 1037, 1038, 1040, 1041, 1085, 1128
<dynamic select statement> • 81, 82, 100, 105, 107, 108,
                                                             <embedded SQL PL/I program> • 80, 991, 993, 995, 996,
 109, 110, 793, 943, 944, 958, 959, 963, 967, 968, 972,
                                                              1001, 1004, 1005, 1042, 1043, 1045, 1046, 1086, 1160
 974, 1061, 1065
                                                             <embedded SQL statement> • 80, 81, 178, 991, 993, 994,
<dynamic single row select statement> • 81, 82, 100, 104,
                                                              995, 1001, 1008, 1015, 1022, 1028, 1033, 1038, 1043
 107, 108, 109, 110, 217, 793, 943, 944, 953, 958, 959,
 967, 968, 972, 974, 980, 1061, 1065, 1087                   <embedded transform group specification> • 991, 992,
                                                              994, 996, 997, 999, 1002, 1122
dynamic SQL error • 933, 937, 938, 940, 941, 942, 952,
 963, 964, 965, 966, 968, 969, 970, 972, 977, 978, 1074      <embedded variable name> • 176, 177, 178, 179, 631,
                                                              683, 860, 992, 996, 997, 1002, 1168, 1169, 1191
<dynamic update statement: positioned> • 82, 96, 100,
 104, 107, 109, 110, 792, 984, 985, 1061, 1087               <embedded variable specification> • 176, 177, 179, 478,
                                                              493, 590, 625, 818, 821, 825, 827, 963, 967, 1049
DYNAMIC_FUNCTION • 136, 932, 936, 939, 958, 1055,
 1059, 1068                                                  <empty grouping set> • 320, 321, 322, 323, 324, 325, 326,
                                                              328, 1139
DYNAMIC_FUNCTION_CODE • 136, 932, 936, 939, 958,
 1055, 1059                                                  <empty specification> • 181, 182, 201, 204, 295, 541, 542,
                                                              543, 835, 841, 855, 1116, 1123
                        —E—                                  END • 138, 194, 197, 198, 287, 288, 290, 367, 629, 992,
                                                              1000, 1009, 1039
E • 144
                                                             <end field> • 166, 275, 430, 467, 468, 469, 470
EACH • 138, 629, 630, 632, 1134, 1208
                                                             END-EXEC • 138
ELEMENT • 138, 236, 1175
                                                             EQUALS • 14, 38, 41, 136, 647, 709, 710, 711, 712
ELSE • 138, 194, 197, 198, 199, 287, 288, 290, 367
                                                             <equals operator> • 7, 20, 26, 68, 132, 375, 379, 381, 400,
<else clause> • 197, 199                                      442, 447, 449, 853, 936, 939, 1007, 1015, 1055, 1188
<embedded authorization clause> • 991, 996                   <equals ordering form> • 709
<embedded authorization declaration> • 80, 991, 993, 996,    error in assignment • 938, 940, 1073
 1001, 1002, 1089, 1159, 1160, 1168
                                                             ESCAPE • 138, 256, 262, 385, 386, 387, 388, 391, 392,
<embedded authorization identifier> • 991, 992                393, 945
<embedded character set declaration> • 992, 994, 995,        <escape character> • 256, 258, 262, 385, 387, 390, 391,
 1001, 1002, 1101, 1160                                       392, 393, 442, 443, 949, 1095, 1181
<embedded collation specification> • 991, 992, 994, 996      escape character conflict • 393, 1073
<embedded exception declaration> • 102, 991, 997, 1001,      <escape octet> • 385, 386, 388, 389, 442, 949
 1003, 1004, 1005, 1006, 1101, 1191
                                                             <escaped character> • 391, 392, 393
<embedded path specification> • 991, 992, 994, 996, 1002,
                                                             EVERY • 61, 138, 505, 507, 510, 514, 1126
 1115, 1160


©ISO/IEC 2003 – All rights reserved                                                                       Index 1221
ISO/IEC 9075-2:2003 (E)




<exact numeric literal> • 27, 144, 147, 149, 207, 209, 542,    905, 906, 907, 996, 997, 1001, 1051, 1147, 1148, 1159,
 1149, 1178                                                    1169, 1202, 1207
<exact numeric type> • 27, 28, 162, 165, 169, 780, 961,       EXTRACT • 138, 243, 247
 1011, 1150, 1177, 1178                                       <extract expression> • 28, 37, 243, 245, 246, 250, 251,
EXCEPT • 20, 26, 47, 74, 75, 138, 238, 239, 287, 288,          1092, 1098, 1151
 289, 351, 354, 355, 356, 357, 358, 359, 360, 362, 363,       <extract field> • 243, 245, 247
 364, 380, 445, 447, 871, 879, 1095, 1125, 1140, 1187,        <extract source> • 243, 244, 245, 247
 1192
EXCEPTION • 136, 1055, 1171                                                          —F—
EXCLUDE • 136, 332, 340
                                                              Feature F032, “CASCADE drop behavior” • 589, 602, 674,
EXCLUDING • 136, 526, 527
                                                               704, 1091
<exclusive user-defined type specification> • 416
                                                              Feature F033, “ALTER TABLE statement: DROP COLUMN
EXEC • 138, 991, 993                                           clause” • 582, 1091
EXECUTE • 113, 138, 204, 227, 475, 597, 621, 693, 704,        Feature F034, “Extended REVOKE statement” • 764, 1091,
 731, 732, 733, 735, 739, 740, 753, 754, 755, 757, 758,        1092
 972, 974, 1002
                                                              Feature F052, “Intervals and datetime arithmetic” • 150,
<execute immediate statement> • 10, 79, 81, 90, 102, 104,      171, 250, 269, 276, 277, 470, 1092
 105, 122, 123, 153, 154, 155, 156, 451, 476, 477, 792,
                                                              Feature F053, “OVERLAPS predicate” • 408, 1093
 914, 915, 917, 918, 974, 1061, 1087, 1148, 1149
                                                              Feature F111, “Isolation levels other than SERIALIZABLE”
<execute statement> • 10, 81, 82, 102, 104, 105, 792,
                                                               • 889, 909, 1093
 918, 942, 953, 963, 967, 972, 973, 1061, 1087, 1088,
 1159                                                         Feature F121, “Basic diagnostics management” • 889,
                                                               1069, 1093
<existing collation name> • 616, 758, 1156
                                                              Feature F171, “Multiple schemas per user” • 521, 1093
<existing transliteration name> • 263, 620, 621, 1156
                                                              Feature F191, “Referential delete actions” • 568, 1093
<existing window name> • 331, 333, 334, 335, 340, 1143
                                                              Feature F222, “INSERT statement: DEFAULT VALUES
EXISTS • 138, 401, 546, 548, 604, 871, 879, 1140
                                                               clause” • 838, 1093
<exists predicate> • 20, 26, 341, 373, 401, 1140, 1182
                                                              Feature F251, “Domain support” • 159, 180, 604, 611,
EXP • 138, 244, 249                                            1093, 1094
<explicit row value constructor> • 293, 294, 295, 296, 297,   Feature F262, “Extended CASE expression” • 199, 200,
 1103, 1129                                                    1094
<explicit table> • 351, 355, 356, 359, 364, 1104, 1166        Feature F263, “Comma-separated predicates in simple
<exponent> • 27, 144, 149                                      CASE expression” • 200, 1094
<exponential function> • 29, 243, 244, 245, 248, 251, 1143,   Feature F271, “Compound character literals” • 150, 1094
 1152                                                         Feature F281, “LIKE enhancements” • 389, 390, 1094,
<extended cursor name> • 153, 157, 159, 160, 952, 957,         1095
 958, 976, 977, 978, 982, 984, 1088                           Feature F291, “UNIQUE predicate” • 402, 1095
<extended statement name> • 153, 157, 158, 160, 897,          Feature F301, “CORRESPONDING in query expressions”
 952, 953, 976, 977, 1088, 1168                                • 364, 1095
EXTERNAL • 138, 676, 677, 685, 697, 1156                      Feature F302, “INTERSECT table operator” • 364, 1095
<external body reference> • 85, 676, 680                      Feature F304, “EXCEPT ALL table operator” • 364, 1095
external routine exception • 483, 488, 489, 1067, 1068,       Feature F312, “MERGE statement” • 845, 1095
 1075
                                                              Feature F321, “User authorization” • 180, 544, 910, 1095,
external routine invocation exception • 487, 1067, 1068,       1096
 1076
                                                              Feature F361, “Subprogram support” • 1002, 1096
<external routine name> • 85, 152, 158, 676, 685, 694,
                                                              Feature F381, “Extended schema manipulation” • 524,
 696, 698, 699, 700, 701, 702, 1144
                                                               574, 575, 576, 577, 579, 583, 586, 702, 1096, 1097
<external security clause> • 677, 685, 697, 698, 1136
                                                              Feature F391, “Long identifiers” • 141, 1097
<externally-invoked procedure> • 10, 79, 80, 81, 90, 93,
                                                              Feature F392, “Unicode escapes in identifiers” • 142, 1097
 106, 107, 115, 121, 129, 520, 765, 766, 767, 768, 771,
 772, 773, 774, 783, 784, 793, 794, 796, 810, 901, 902,       Feature F393, “Unicode escapes in literals” • 150, 1097




1222 Foundation (SQL/Foundation)                                                       ©ISO/IEC 2003 – All rights reserved
                                                                                          ISO/IEC 9075-2:2003 (E)




Feature F401, “Extended joined table” • 318, 1097           Feature F751, “View CHECK enhancements” • 599, 1107
Feature F402, “Named column joins for LOBs, arrays, and     Feature F761, “Session management” • 909, 914, 916,
 multisets” • ?, ?, 318, 1097                                 917, 1107
Feature F411, “Time zone specification” • 150, 171, 251,    Feature F771, “Connection management” • 159, 903, 905,
 269, 271, 913, 1098                                          907, 1107, 1108
Feature F421, “National character” • 150, 171, 215, 251,    Feature F781, “Self-referencing operations” • 833, 838,
 390, 1098, 1099, 1128                                        845, 852, 857, 1108
Feature F431, “Read-only scrollable cursors” • 813, 821,    Feature F791, “Insensitive cursors” • 813, 1108, 1109,
 1099                                                         1134
Feature F441, “Extended set function support” • 319, 514,   Feature F801, “Full set function” • 349, 1109
 515, 1099, 1100                                            Feature F821, “Local table references” • 159, 189, 1109
Feature F442, “Mixed column references in set functions”    Feature F831, “Full cursor update” • 813, 848, 1109
 • 515, 516, 1100                                           <factor> • 241, 272, 273, 274
Feature F451, “Character set definition” • 613, 615, 1100   FALSE • 138, 145, 150, 209, 210, 278, 280, 379, 786, 788
Feature F461, “Named character sets” • 160, 498, 521,       feature not supported • 890, 901, 904, 1076
 770, 917, 1002, 1100, 1101
                                                            FETCH • 138, 495, 817, 977, 979
Feature F491, “Constraint management” • 159, 504, 609,
                                                            <fetch orientation> • 817, 818, 819, 820, 821, 979, 1099
 1006, 1101
                                                            <fetch statement> • 95, 96, 100, 103, 106, 108, 110, 767,
Feature F521, “Assertions” • 626, 628, 1101
                                                              791, 795, 813, 817, 821, 829, 847, 1061, 1099, 1167,
Feature F531, “Temporary tables” • 534, 859, 1101, 1102       1184, 1185
Feature F555, “Enhanced seconds precision” • 150, 171,      <fetch target list> • 817, 818, 819, 820, 979, 1167
 271, 1102
                                                            <field definition> • 163, 170, 173, 1129, 1174
Feature F561, “Full value expressions” • 384, 514, 1102
                                                            <field name> • 43, 152, 158, 159, 173, 219, 294, 308, 313,
Feature F571, “Truth value tests” • 282, 1102, 1103           314, 348, 430, 534, 571, 854, 1129
Feature F591, “Derived tables” • 310, 1103                  <field reference> • 174, 175, 185, 219, 346, 631, 1129
Feature F611, “Indicator data types” • 180, 1103            FILTER • 138, 505
Feature F641, “Row and table constructors” • 295, 299,      <filter clause> • 61, 191, 505, 508, 509, 515, 1143
 1103
                                                            FINAL • 136, 634, 636, 649, 1112
Feature F651, “Catalog name qualifiers” • 159, 914, 1103,
                                                            <finality> • 634, 636, 637, 649, 1112, 1113
 1104
                                                            FIRST • 58, 59, 136, 336, 337, 338, 365, 517, 518, 817,
Feature F661, “Simple tables” • 364, 1104
                                                              818, 820
Feature F671, “Subqueries in CHECK constraints” • 570,
                                                            FLOAT • 11, 12, 27, 138, 162, 165, 170, 433, 434, 438,
 1104
                                                              924, 925, 941, 1043, 1046, 1149, 1150
Feature F672, “Retrospective check constraints” • 570,
                                                            FLOOR • 138, 244
 626, 1104
                                                            <floor function> • 29, 243, 244, 245, 249, 251, 1143, 1152
Feature F690, “Collation support” • 159, 502, 617, 619,
 1104                                                       <fold> • 18, 256, 257, 258, 261, 262, 263, 1179, 1202
Feature F692, “Extended collation support” • 539, 604,      FOLLOWING • 136, 194, 332, 333, 336, 337, 338, 339
 651, 1105                                                  FOR • 83, 95, 138, 177, 217, 246, 256, 257, 260, 499,
Feature F693, “SQL-session and client module collations”      616, 620, 629, 630, 632, 647, 673, 675, 677, 704, 709,
 • 180, 768, 921, 1105                                        712, 714, 717, 723, 747, 751, 752, 761, 762, 764, 765,
                                                              767, 768, 809, 810, 812, 813, 814, 846, 919, 920, 945,
Feature F695, “Translation support” • 159, 266, 622, 624,
                                                              953, 975, 976, 991, 992, 1089, 1091, 1109, 1116, 1131,
 1105, 1106
                                                              1134, 1208
Feature F701, “Referential update actions” • 568, 1106
                                                            FOREIGN • 138, 538, 549, 1207, 1208
Feature F711, “ALTER domain” • 605, 606, 607, 608, 609,
                                                            FORTRAN • 136, 452, 471, 487, 489, 691, 699, 701, 769,
 1106
                                                              783, 785, 786, 787, 788, 995, 1089, 1090
Feature F721, “Deferrable constraints” • 504, 893, 1106
                                                            <Fortran array locator variable> • 1027, 1028, 1030, 1031,
Feature F731, “INSERT column privileges” • 742, 1106,         1120
 1107
                                                            <Fortran BLOB locator variable> • 1027, 1029, 1031, 1127
Feature F741, “Referential MATCH types” • 406, 568, 1107
                                                            <Fortran BLOB variable> • 1027, 1029, 1031, 1127


©ISO/IEC 2003 – All rights reserved                                                                     Index 1223
ISO/IEC 9075-2:2003 (E)




<Fortran CLOB locator variable> • 1027, 1029, 1031, 1127     <general set function> • 20, 26, 191, 447, 505, 506, 507,
<Fortran CLOB variable> • 1027, 1028, 1029, 1031, 1127        509, 514, 515, 516, 1099, 1100, 1102
<Fortran derived type specification> • 1027                  <general value specification> • 122, 123, 176, 179, 180,
<Fortran host identifier> • 992, 1027, 1028, 1029, 1030       604, 786, 787, 963, 1086, 1094, 1095, 1115, 1151
<Fortran multiset locator variable> • 1027, 1028, 1030,      <generalized expression> • 474, 477, 478, 479, 481, 496,
  1031, 1121                                                  1110
<Fortran REF variable> • 1027, 1028, 1030, 1031, 1113        <generalized invocation> • 222, 223
<Fortran type specification> • 1027, 1028                    GENERATED • 57, 136, 525, 526, 527, 528, 529, 535,
                                                              536, 592, 593, 596, 635, 1114
<Fortran user-defined type locator variable> • 1027, 1028,
  1029, 1031, 1119                                           <generation clause> • 536, 537, 539, 540, 1133
<Fortran user-defined type variable> • 1027, 1029, 1031,     <generation expression> • 528, 536, 537
  1122                                                       <generation option> • 526, 527
<Fortran variable definition> • 992, 1027, 1028, 1030        <generation rule> • 536
FOUND • 136, 1003, 1006                                      GET • 138, 612, 936, 1055
FREE • 138, 860                                              <get descriptor information> • 936, 938
<free locator statement> • 92, 100, 103, 104, 107, 108,      <get descriptor statement> • 82, 102, 104, 792, 936, 937,
  110, 685, 791, 860, 943, 951, 1061, 1140, 1156, 1202        938, 1061, 1086, 1168
FROM • 55, 71, 73, 138, 211, 212, 213, 214, 215, 230,        <get diagnostics statement> • 93, 102, 792, 1055, 1056,
  234, 236, 243, 246, 247, 256, 257, 259, 260, 287, 288,      1058, 1065, 1069, 1080, 1093, 1169
  290, 291, 301, 304, 305, 306, 312, 314, 316, 318, 327,     <get header information> • 936, 937, 938
  345, 355, 357, 366, 367, 368, 409, 495, 513, 514, 534,     <get item information> • 936, 937, 938
  546, 547, 548, 551, 582, 588, 591, 598, 599, 604, 611,     GLOBAL • 52, 138, 153, 158, 159, 525, 532, 952
  615, 616, 619, 620, 623, 635, 647, 674, 676, 704, 714,
                                                             <global or local> • 525
  721, 722, 729, 746, 747, 817, 828, 831, 843, 844, 868,
  871, 879, 896, 901, 902, 910, 911, 914, 915, 917, 918,     GO • 136, 1003, 1004, 1005, 1006
  919, 920, 933, 943, 945, 952, 974, 976, 977, 979, 982,     <go to> • 1003, 1004, 1005, 1006
  986, 1063, 1064, 1208, 1209                                GOTO • 136, 1003
<from clause> • v, 55, 72, 187, 195, 300, 301, 302, 306,     <goto target> • 1003, 1004
  319, 321, 327, 334, 344, 347, 348, 354, 365, 593, 864,     GRANT • 113, 138, 497, 534, 598, 612, 648, 732, 733,
  869, 877, 1190, 1191                                        734, 735, 736, 737, 744, 747, 750, 751, 752, 761, 764,
<from constructor> • 217, 834, 836                            1091
<from default> • 834, 838, 1093                              <grant privilege statement> • 98, 731, 736, 738, 1061,
<from sql> • 714, 715, 716, 719, 720, 721                     1111, 1116, 1183
<from sql function> • 714, 715, 719, 720                     <grant role statement> • 99, 114, 731, 744, 745, 1061,
<from subquery> • 217, 834, 835, 836, 838, 1108               1137
FULL • 14, 38, 41, 65, 70, 138, 312, 313, 314, 315, 316,     <grant statement> • 113, 497, 520, 534, 598, 612, 731,
  318, 354, 404, 405, 449, 549, 551, 552, 558, 561, 647,      732, 733, 734, 735, 737, 740, 790, 1192
  709, 710, 711, 712, 1097, 1123                             GRANTED • 136, 736, 737, 744, 747, 748
<full ordering form> • 709                                   <grantee> • 736, 737, 739, 741, 744, 745, 747, 748, 763,
FUNCTION • 40, 138, 499, 500, 501, 646, 647, 648, 675,        764, 1092
  711                                                        <grantor> • 736, 739, 740, 741, 743, 744, 747, 1138
function executed no return statement • 485, 1078            <greater than operator> • 132, 375, 376, 518, 812
<function specification> • 84, 675, 680, 684, 1193           <greater than or equals operator> • 135, 375, 376
FUSION • 138, 505, 507, 510, 515, 1125, 1175                 GROUP • 138, 320, 321, 322, 325, 326, 327, 328, 329,
                                                              332, 340, 345, 506, 677, 919, 1139
                      —G—                                    <group by clause> • v, 20, 26, 51, 73, 195, 300, 306, 320,
                                                              321, 322, 324, 327, 328, 329, 334, 344, 345, 347, 445,
G • 134, 136, 164
                                                              584, 591, 593, 1139, 1165, 1181, 1190, 1191
GENERAL • 86, 136, 487, 490, 492, 648, 677, 690, 694,
                                                             <group name> • 677, 682, 686, 687, 689, 690, 691, 704,
 696, 701, 702, 1111
                                                              714, 715, 717, 719, 721, 723, 766, 919, 994, 997, 999
<general literal> • 143



1224 Foundation (SQL/Foundation)                                                      ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)




<group specification> • 677, 682, 686, 687, 689, 690, 691,   <hypothetical set function> • 193, 506, 508, 512, 515,
 766, 994, 997, 999                                           1143, 1155
GROUPING • ?, ?, ?, ?, ?, ?, 59, 73, 138, 191, 192, 320,     <hypothetical set function value expression list> • 506,
 322, 323, 324, 325, 326, 328, 1139                           508, 513, 515, 1100
<grouping column reference> • 320, 321, 322, 324, 326        HZ • 1077
<grouping column reference list> • 73, 320, 321, 326, 328,
 627, 1139                                                                           —I—
<grouping element> • 320, 324, 328, 1139                     <identifier> • ?, 42, 77, 82, 120, 151, 152, 153, 157, 174,
<grouping element list> • 320, 325                             183, 186, 304, 307, 341, 342, 344, 345, 349, 392, 438,
<grouping operation> • 191, 192, 322, 326, 327, 1138,          629, 635, 636, 637, 638, 714, 902, 933, 952, 976, 1056,
 1139                                                          1058, 1067, 1068, 1137, 1149
<grouping set> • 320, 322, 323, 324, 325                     <identifier body> • 134, 140, 141
<grouping set list> • 320, 328, 1139                         <identifier chain> • 86, 183, 185, 1137
<grouping sets specification> • 320, 321, 322, 323, 324,     <identifier extend> • 134, 139
 325, 328, 1139                                              <identifier part> • 134, 139, 141, 1097, 1180
                                                             <identifier start> • 134, 139, 141, 1097
                        —H—                                  IDENTITY • 138, 526, 527, 528, 536
HAVING • 138, 329                                            <identity column specification> • 532, 536, 537, 539, 572,
<having clause> • v, 59, 73, 188, 191, 195, 300, 306, 313,     1133
 319, 321, 329, 334, 344, 345, 347, 354, 591, 593, 1181,     <identity option> • 526, 527
 1190, 1191                                                  IMMEDIATE • 137, 503, 504, 545, 603, 625, 892, 896,
<header item name> • 936, 937, 938, 939, 942                   974, 1106, 1207, 1208, 1209
held cursor requires same isolation level • 890, 1077        IMPLEMENTATION • 87, 137, 484, 677, 685, 697, 1154
<hexit> • 135, 140, 144, 146, 147, 542                       <implementation-defined character set name> • 497, 498
HIERARCHY • 112, 136, 233, 309, 534, 597, 598, 731,          implementation-defined classes • 1071
 733, 735, 736, 737, 738, 747, 751, 752, 753, 754, 756,      implementation-defined exception code • 1147
 757, 760, 761, 764, 831, 832, 841, 849, 850, 1116           implementation-defined subclasses • 1071
<high value> • 391, 393, 394                                 <implicitly typed value specification> • 181, 201, 541
HOLD • 138, 809, 810, 813, 814, 861, 975, 1140               IN • 138, 243, 367, 383, 639, 659, 664, 675, 683, 688,
<hold locator statement> • 92, 100, 103, 104, 107, 108,        689, 690, 945, 951, 962
 110, 685, 791, 861, 943, 951, 1061, 1140, 1156              <in predicate> • 238, 347, 373, 383, 384, 442, 949, 1102,
<host identifier> • 992, 994, 995, 1001                        1194
<host label identifier> • 1003, 1004, 1005, 1006             <in predicate part 2> • 197, 383
<host parameter data type> • 766, 771, 773, 996, 997,        <in predicate value> • 383
 1119, 1120, 1121                                            <in value list> • 383, 384, 1102, 1194
<host parameter declaration> • 90, 436, 766, 767, 771,       <in-line window specification> • 57, 193, 195, 344, 1163
 772, 774, 781, 782, 793, 810, 996, 997, 998, 1001, 1169
                                                             inappropriate access mode for branch transaction • 891,
<host parameter declaration list> • 766, 771                   1077
<host parameter name> • 152, 158, 176, 177, 178, 258,        inappropriate isolation level for branch transaction • 891,
 436, 625, 631, 683, 771, 772, 793, 810, 821, 860, 861,        1077
 996, 997, 998, 1168, 1169
                                                             INCLUDING • 137, 526, 527, 528
<host parameter specification> • 176, 178, 258, 436, 478,
                                                             <inclusive user-defined type specification> • 416
 493, 818, 825, 827, 963, 967
                                                             INCREMENT • 137, 528, 726
<host PL/I label variable> • 1003, 1004, 1005, 1006
                                                             <independent variable expression> • 62, 191, 505, 506,
<host variable definition> • 992, 994, 995, 1001, 1002,
                                                               508, 511, 512, 515, 516, 1099, 1100
 1096
                                                             INDICATOR • 138, 177, 936, 938, 940, 959, 964, 970,
HOUR • 32, 122, 138, 148, 247, 268, 430, 467, 913, 942,
                                                               1168
 950, 951
                                                             indicator overflow • 420, 1073
<hours value> • 144, 145, 148




©ISO/IEC 2003 – All rights reserved                                                                       Index 1225
ISO/IEC 9075-2:2003 (E)




<indicator parameter> • 176, 177, 178, 180, 346, 1103,           <interval leading field precision> • 35, 168, 272, 273, 274,
  1151                                                             275, 381, 467, 468, 469, 470, 924, 946, 961, 1152, 1153
<indicator variable> • 177, 178, 179, 180, 346, 1103, 1151       <interval literal> • 143, 144, 148, 149, 150, 542, 1092
INITIALLY • 137, 503, 504, 545, 603, 625, 1106                   <interval primary> • 267, 268, 269, 272, 273, 1152
INNER • 70, 71, 138, 312, 313, 314, 315, 316                     <interval qualifier> • 31, 35, 144, 148, 149, 163, 166, 168,
INOUT • 138, 675, 683, 688, 690, 951                               170, 215, 272, 273, 274, 275, 456, 467, 468, 469, 470,
INPUT • 84, 137, 637, 640, 658, 677, 680, 957                      542, 798, 924, 931, 944, 961, 1092, 1153
<input using clause> • 963, 966, 972, 978, 1087, 1168            <interval string> • 135, 139, 144
INSENSITIVE • 96, 138, 809, 810, 813, 816, 832, 837,             <interval term> • 267, 268, 269, 272, 273
  842, 850, 1109                                                 <interval term 1> • 272, 273, 274, 1152
INSERT • 112, 113, 126, 127, 128, 129, 138, 534, 573,            <interval term 2> • 272, 273, 274
  582, 597, 598, 629, 630, 734, 737, 739, 740, 741, 742,         <interval type> • 31, 161, 163, 166, 170, 171, 924, 961,
  748, 749, 755, 759, 834, 836, 838, 839, 841, 859, 868,           1092
  883, 1093, 1106, 1107, 1208                                    <interval value expression> • 237, 238, 239, 244, 245,
<insert column list> • 755, 759, 834, 835, 836, 837, 838,          246, 247, 267, 268, 269, 272, 273, 274, 275, 276, 277,
  839, 840, 841, 844, 845, 948, 1112                               913, 950, 1092, 1165
<insert columns and source> • 834, 835, 836, 948                 <interval value expression 1> • 272, 273, 274, 1152
<insert statement> • 48, 56, 100, 103, 106, 108, 109, 125,       <interval value function> • 272, 273, 277, 1092
  364, 534, 755, 756, 758, 759, 760, 791, 834, 835, 836,         interval value out of range • 509, 1073
  838, 943, 948, 1049, 1061, 1063, 1064, 1104, 1108,             INTO • 138, 195, 495, 534, 817, 824, 834, 839, 967, 977,
  1131, 1169, 1184                                                 1208
<insertion target> • 834, 838, 1131                              <into argument> • 967, 968, 971
INSTANCE • 137, 499, 501, 635, 638, 649, 657, 668, 675,          <into arguments> • 967, 968, 971
  1111
                                                                 <into descriptor> • 967, 968, 970
INSTANTIABLE • 137, 634, 636, 637, 644, 647, 648, 1111
                                                                 <introducer> • 143, 146, 147
<instantiable clause> • 634, 636, 637, 648, 649, 1111,
                                                                 invalid argument for natural logarithm • 248, 1073
  1113
                                                                 invalid argument for power function • 248, 249, 1073
insufficient item descriptor areas • 959, 1079
                                                                 invalid argument for width bucket function • 250, 1073
INT • 138, 162, 163, 169, 775, 780, 782, 785, 787, 1007,
  1009, 1010, 1011, 1032, 1033, 1034, 1035, 1150                 invalid authorization specification • 773, 901, 902, 910,
                                                                   1076
INTEGER • 11, 12, 27, 57, 138, 162, 163, 165, 169, 381,
  433, 438, 482, 686, 689, 690, 710, 782, 924, 925, 951,         invalid catalog name • 914, 1076
  1011, 1019, 1025, 1027, 1029, 1030, 1033, 1037, 1038,          invalid character set name • 917, 1076
  1039, 1040, 1046, 1149, 1150, 1173, 1207, 1208                 invalid character value for cast • 206, 207, 208, 209, 210,
integrity constraint violation • 215, 504, 555, 558, 563, 567,     211, 212, 213, 214, 215, 1068, 1073
  1004, 1065, 1068, 1076                                         invalid collation name • 920, 1076
integrity constraint violation • 504, 896, 1065, 1078            invalid condition number • 888, 891, 1065, 1076
INTERSECT • 20, 26, 47, 74, 75, 138, 238, 239, 287, 351,         invalid connection name • 902, 1076
  354, 355, 356, 357, 359, 360, 363, 364, 380, 445, 447,         invalid cursor name • 952, 958, 976, 978, 982, 984, 1076
  1095, 1140, 1166
                                                                 invalid cursor state • 815, 818, 822, 829, 847, 956, 1067,
INTERSECTION • 138, 239, 289, 447, 505, 508, 510, 515,             1076
  1125, 1175
                                                                 invalid DATA target • 940, 1075
INTERVAL • 11, 12, 31, 32, 94, 122, 138, 144, 148, 163,
                                                                 invalid datetime format • 211, 212, 213, 214, 215, 1073
  170, 268, 269, 272, 273, 274, 380, 381, 407, 408, 434,
  438, 913, 941, 942, 944, 946, 950, 951                         invalid DATETIME_INTERVAL_CODE • 942, 1075
<interval absolute value function> • 37, 277                     invalid descriptor count • 964, 968, 1075
<interval factor> • 272, 273                                     invalid descriptor index • 933, 937, 940, 1075
interval field overflow • 214, 215, 275, 422, 427, 1068,         invalid escape character • 262, 387, 393, 1073
  1073                                                           invalid escape octet • 388, 1073
<interval fractional seconds precision> • 35, 149, 168, 245,     invalid escape sequence • 387, 388, 1073
  467, 468, 469, 924, 946, 961, 1153                             invalid grantor • 740, 741, 1076


1226 Foundation (SQL/Foundation)                                                          ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)




invalid indicator parameter value • 425, 1073                <join condition> • 70, 306, 312, 313, 314, 315, 359, 1188
invalid interval format • 215, 1073                          <join specification> • 69, 70, 312, 313, 314
invalid LEVEL value • 940, 941, 1075                         <join type> • 70, 312, 313, 354, 355, 1188
invalid parameter value • 773, 1073                          <joined table> • v, 20, 26, 69, 72, 74, 184, 187, 188, 303,
invalid preceding or following size in window function •       306, 308, 310, 312, 313, 314, 315, 317, 318, 343, 353,
  336, 337, 338, 339, 1073                                     362, 442, 443, 840, 1097, 1173, 1174, 1188
invalid regular expression • 262, 393, 1073
invalid repeat argument in a sample clause • 310, 1073                              —K—
invalid role specification • 911, 1076                       K • 134, 137, 164
invalid sample size • 310, 1073                              KEY • 49, 64, 65, 68, 137, 530, 538, 545, 547, 548, 549,
invalid schema name • 915, 1076                               550, 583, 1207, 1208
invalid schema name list specification • 918, 1076           <key word> • 11, 15, 134, 136, 141, 153, 278, 927, 929,
                                                              937, 939, 1145, 1161
invalid specification • 860, 861, 895, 899, 1077, 1078
                                                             KEY_MEMBER • 137, 936, 938, 939, 960, 1136
invalid SQL descriptor name • 933, 935, 937, 940, 958,
  963, 967, 1076                                             KEY_TYPE • 137, 936, 939, 958, 959, 960
invalid SQL statement identifier • 952, 1076                 KIND • 1027
invalid SQL statement name • 956, 957, 958, 972, 977,
  978, 982, 984, 1076                                                               —L—
invalid SQL-invoked procedure reference • 977, 1076          LANGUAGE • 138, 471, 637, 639, 640, 646, 648, 658,
invalid target type specification • 221, 1076                  659, 680
invalid time zone displacement value • 269, 913, 1074        <language clause> • 37, 83, 85, 471, 472, 635, 640, 645,
invalid transaction initiation • 105, 1077                     658, 676, 679, 680, 691, 694, 695, 699, 700, 701, 702,
                                                               765, 768, 769, 770, 771, 772, 961, 995, 1089, 1090,
invalid transaction state • 793, 795, 796, 829, 832, 836,
                                                               1091
  841, 847, 850, 888, 890, 891, 906, 910, 911, 1051, 1052,
  1077                                                       <language name> • 39, 471, 645, 646, 661, 666, 694, 695,
                                                               701, 702, 772
invalid transaction termination • 896, 898, 1077
                                                             LARGE • 11, 12, 15, 25, 94, 138, 161, 162, 163, 164, 169,
invalid transform group name specification • 919, 1077
                                                               215, 216, 251, 390, 396, 419, 433, 438, 537, 786, 787,
invalid use of escape character • 262, 393, 1074               788, 924, 925, 941, 945, 971, 1018, 1098, 1099, 1128,
<inverse distribution function> • 506, 508, 509, 513, 515,     1129
  1100, 1143, 1155                                           <large object length> • 161, 162, 164, 1008, 1009, 1014,
<inverse distribution function argument> • 506, 513, 515,      1016, 1021, 1023, 1027, 1028, 1029, 1032, 1034, 1037,
  1100                                                         1038, 1039, 1042, 1044
<inverse distribution function type> • 506                   <large object length token> • 134, 139, 162, 164
INVOKER • 87, 137, 166, 188, 203, 204, 231, 261, 309,        LAST • 58, 59, 137, 336, 337, 338, 517, 518, 817, 818,
  497, 502, 595, 676, 677, 693, 694, 696, 697, 829, 831,       819
  836, 841, 847, 849                                         LATERAL • 138, 303, 306, 310, 1140
IS • ?, 50, 138, 198, 254, 263, 278, 279, 280, 281, 287,     <lateral derived table> • 71, 303, 306, 307, 308, 310, 313,
  288, 290, 397, 403, 409, 415, 416, 417, 525, 538, 547,       1140
  635, 1007, 1008, 1009, 1010, 1013, 1014, 1015, 1016,
                                                             LEADING • 138, 256, 264, 265, 1022
  1017, 1018, 1021, 1022, 1023, 1024, 1027, 1028, 1029,
  1030, 1032, 1033, 1034, 1035, 1037, 1038, 1039, 1040,      LEFT • 70, 71, 138, 312, 314, 315, 316, 354, 355
  1042, 1043, 1044, 1045                                     <left brace> • 19, 132, 133, 391, 392, 393, 1173
ISOLATION • 137, 887                                         <left bracket> • 19, 132, 133, 392, 393, 395, 1013, 1037
<isolation level> • 887, 889, 890, 909, 1093                 <left bracket or trigraph> • 132, 163, 177, 181, 235, 285,
<item number> • 936, 937, 938, 939, 940                        291, 853
                                                             <left bracket trigraph> • 132, 133, 135
                        —J—                                  <left paren> • 19, 131, 132, 161, 162, 163, 174, 177, 185,
                                                               191, 193, 197, 201, 220, 222, 224, 233, 236, 243, 244,
JOIN • 71, 138, 312, 314, 315, 1064, 1174                      256, 257, 270, 272, 277, 278, 285, 290, 291, 293, 303,
<join column list> • 312, 313                                  312, 320, 321, 331, 341, 351, 356, 370, 383, 391, 392,



©ISO/IEC 2003 – All rights reserved                                                                       Index 1227
ISO/IEC 9075-2:2003 (E)




  393, 394, 416, 467, 474, 499, 505, 506, 525, 526, 536,         688, 689, 690, 694, 695, 698, 766, 771, 773, 1119, 1120,
  547, 549, 569, 590, 596, 625, 629, 634, 635, 675, 676,         1121, 1126, 1141, 1193, 1202
  705, 707, 714, 717, 719, 721, 739, 771, 828, 834, 839,       <locator reference> • 860, 861, 951
  853, 944, 945, 991, 993, 1007, 1008, 1014, 1021, 1022,       <low value> • 391, 393, 394
  1027, 1032, 1037, 1042, 1181, 1183
                                                               LOWER • 18, 138, 256, 263, 392, 395
LENGTH • 137, 782, 788, 924, 925, 936, 940, 941, 942,
  960, 961, 1009, 1023, 1029, 1034, 1038, 1044, 1159,
  1168                                                                               —M—
<length> • 81, 147, 161, 162, 163, 164, 167, 798, 944,         M • 134, 137, 164, 452, 471, 472, 487, 489, 691, 699, 701,
  1007, 1008, 1010, 1013, 1016, 1018, 1021, 1022, 1023,         769, 784, 785, 787, 995, 1001, 1090
  1027, 1028, 1030, 1032, 1033, 1037, 1038, 1040, 1042,        <major category> • 1003, 1004
  1043, 1044, 1045, 1046                                       <mantissa> • 27, 144, 149, 208, 209
<length expression> • 19, 26, 28, 243, 245, 251, 1099,         MAP • 7, 13, 38, 42, 137, 376, 378, 442, 443, 449, 647,
  1151                                                          709, 710, 711, 1123, 1163
<less than operator> • 132, 375, 379, 518, 812                 <map category> • 709, 710
<less than or equals operator> • 135, 375, 376                 <map function specification> • 13, 443, 449, 709, 710
LEVEL • 84, 137, 366, 676, 680, 694, 887, 923, 933, 936,       MATCH • 65, 138, 404, 406, 549, 551, 568, 1107
  940, 941, 959, 960, 961, 964, 968                            <match predicate> • 238, 373, 404, 405, 406, 442, 443,
<level of isolation> • 887, 888, 889, 890, 891, 909, 1093,      551, 949, 1107
  1158                                                         <match predicate part 2> • 197, 404
<levels clause> • 590, 591, 599, 1107                          <match type> • 65, 546, 549, 561
LIKE • 19, 138, 385, 386, 387, 388, 389, 390, 396, 526,        MATCHED • 137, 839
  534, 535, 1094, 1095, 1132, 1133
                                                               MAX • ?, ?, ?, ?, 61, 138, 239, 380, 449, 505, 507, 510,
<like clause> • 525, 526, 527, 532, 534, 535, 1132, 1133,       514, 515, 933, 1129, 1130, 1159, 1166
  1174
                                                               <maximum cardinality> • 163, 166, 171, 1117
<like option> • 526
                                                               <maximum dynamic result sets> • 676, 677, 693, 701
<like options> • 526, 527, 535, 1133
                                                               maximum number of stacked diagnostics areas exceeded
<like predicate> • 19, 20, 26, 373, 385, 386, 388, 390, 442,    • 1070, 1074
  1099, 1128, 1152, 1181
                                                               MAXVALUE • 137, 463, 465, 528, 726, 1153
<list of attributes> • 635, 637, 645
                                                               MEMBER • 138, 411, 1175
<literal> • 70, 72, 143, 157, 160, 176, 178, 206, 207, 208,
  210, 211, 212, 213, 214, 215, 326, 327, 341, 513, 514,       <member> • 634
  541, 542, 543, 854, 934, 939, 943, 1053, 1088, 1201          <member list> • 166, 634, 637, 638, 647, 648, 1110
LN • 138, 244, 249                                             <member name> • 499
LOCAL • 52, 54, 119, 120, 138, 153, 157, 267, 268, 275,        <member name alternatives> • 499
  525, 532, 590, 592, 596, 858, 871, 879, 890, 891, 913,       <member predicate> • 238, 347, 373, 411, 412, 413, 442,
  952, 1134, 1135                                               443, 447, 1124
<local or schema qualified name> • 151, 153, 157               <member predicate part 2> • 197, 411
<local or schema qualifier> • 151, 153, 159, 526, 858, 1109    MERGE • 138, 839, 845, 1095, 1175
<local qualified name> • 152                                   <merge correlation name> • 839, 840, 843, 1063
<local qualifier> • 151, 152, 154, 159, 160, 1109, 1142        <merge insert specification> • 755, 759, 839, 948
LOCALTIME • 138, 270                                           <merge insert value element> • 839, 840, 841
LOCALTIMESTAMP • 138, 270, 280, 570, 626, 1104                 <merge insert value list> • 217, 306, 839, 840, 841, 948
LOCATOR • 92, 137, 635, 638, 641, 657, 660, 675, 860,          <merge operation specification> • 839
  861, 924, 925, 926, 938, 940, 941, 964, 970, 971, 996,       <merge statement> • 48, 56, 100, 103, 107, 108, 109, 125,
  998, 1008, 1009, 1010, 1014, 1015, 1017, 1018, 1022,          306, 755, 756, 757, 758, 759, 760, 791, 830, 839, 840,
  1023, 1024, 1027, 1028, 1029, 1030, 1033, 1034, 1035,         841, 843, 845, 847, 853, 943, 948, 1049, 1061, 1063,
  1037, 1038, 1039, 1040, 1042, 1043, 1044, 1045                1064, 1095, 1108, 1112, 1131, 1167, 1169
locator exception • 860, 861, 1077                             <merge update specification> • 839
<locator indication> • 88, 89, 639, 641, 642, 643, 649, 658,   <merge when clause> • 839, 842
  659, 661, 663, 664, 675, 676, 680, 681, 682, 683, 686,



1228 Foundation (SQL/Foundation)                                                        ©ISO/IEC 2003 – All rights reserved
                                                                                            ISO/IEC 9075-2:2003 (E)




<merge when matched clause> • 56, 839, 842, 1063, 1064        <module path specification> • 88, 696, 765, 766, 768, 996,
<merge when not matched clause> • 56, 839, 843, 1063,          1115, 1157, 1160
 1064                                                         <module transform group specification> • 765, 766, 768,
MESSAGE_LENGTH • 137, 1056, 1068                               996, 1122
MESSAGE_OCTET_LENGTH • 137, 1056, 1068                        <modulus expression> • 29, 243, 244, 245, 248, 251, 945,
MESSAGE_TEXT • 137, 1056, 1068, 1160                           1139
METHOD • 138, 499, 500, 501, 635, 637, 668, 675, 698,         MONTH • 32, 34, 138, 148, 166, 335, 336, 430, 467, 468,
 1111, 1113                                                    942, 946
<method characteristic> • 84, 635                             <months value> • 144, 145, 148, 469
<method characteristics> • 635, 640, 648, 657, 1111           MORE • 137, 496, 1055, 1058
<method invocation> • 85, 174, 175, 185, 222, 223, 226,       most specific type mismatch • 493, 1074
 231, 346, 655, 673, 700, 703, 753, 754, 755, 757, 758,       <multiple column assignment> • 853, 854, 857, 950, 1144
 1109                                                         <multiple group specification> • 677, 682, 766, 994
<method name> • 37, 38, 39, 84, 152, 158, 222, 224, 231,      multiple server transactions • 890, 901, 904, 1076
 499, 500, 501, 597, 635, 638, 640, 642, 643, 645, 646,       <multiplier> • 134, 139, 162, 164
 657, 661, 664, 666, 668, 670, 675, 678, 679, 731, 732,       MULTISET • 11, 45, 46, 47, 94, 138, 163, 170, 181, 182,
 733, 853, 854, 855, 857, 1112                                 238, 239, 287, 288, 289, 290, 291, 435, 447, 456, 507,
<method reference> • 228, 231, 232, 346, 578, 587, 597,        541, 678, 835, 841, 855, 925, 926, 938, 940, 947, 964,
 600, 655, 673, 700, 703, 731, 732, 733, 753, 754, 755,        970, 971, 1123, 1125, 1175
 756, 757, 758, 759, 1114                                     <multiset element> • 291, 292, 947
<method selection> • 222, 223, 474, 476, 477                  <multiset element list> • 291, 292, 947
<method specification> • 37, 39, 84, 635, 638, 649, 1141      <multiset element reference> • 47, 174, 175, 236, 347,
<method specification designator> • 84, 675, 677, 678,         1123, 1124
 679, 692, 693, 695, 697, 698, 1110, 1113                     <multiset primary> • 287, 288, 447
<method specification list> • 37, 39, 634, 635, 638, 645,     <multiset set function> • 47, 239, 290, 447
 646, 649, 1110
                                                              <multiset term> • 287, 288, 289, 447
MIN • ?, ?, ?, ?, 61, 138, 239, 380, 449, 505, 507, 510,
                                                              <multiset type> • 163, 166, 171, 649, 681, 773, 1008, 1010,
 514, 515, 1129, 1130, 1166
                                                               1015, 1017, 1022, 1024, 1028, 1030, 1033, 1035, 1038,
<minus sign> • 19, 131, 132, 136, 139, 144, 145, 241, 242,     1040, 1043, 1045, 1121, 1123, 1124, 1141
 267, 269, 272, 273, 392, 393, 394, 469, 470, 946, 1092
                                                              <multiset value constructor> • 174, 175, 291, 292, 1124,
MINUTE • 32, 122, 138, 148, 247, 268, 430, 467, 913,           1137
 942, 950
                                                              <multiset value constructor by enumeration> • 291, 292
<minutes value> • 144, 145, 148
                                                              <multiset value constructor by query> • 291, 292, 363,
MINVALUE • 137, 463, 465, 528, 726, 1153                       364, 1131, 1132
MOD • 138, 244, 251, 1139                                     <multiset value expression> • 236, 237, 238, 239, 287,
MODIFIES • 138, 677, 680, 692, 696, 701, 702                   288, 289, 290, 411, 413, 447, 1125
modifying SQL-data not permitted • 483, 485, 489, 1075,       <multiset value function> • 287, 288, 290, 1124
 1078                                                         multiset value overflow • 509, 1074
MODULE • 52, 138, 152, 154, 157, 187, 189, 770, 858,          MUMPS • 137, 471, 699, 769, 784, 1034, 1035, 1081,
 859, 1066, 1109                                               1085, 1089, 1090
<module authorization clause> • 80, 156, 765, 766, 768,       <MUMPS array locator variable> • 1032, 1033, 1035, 1036,
 996, 1089, 1149, 1159, 1160                                   1120
<module authorization identifier> • 78, 79, 87, 112, 520,     <MUMPS BLOB locator variable> • 1032, 1033, 1034,
 696, 758, 765, 766, 772, 773, 901, 953, 992, 1159, 1168       1036, 1127
<module character set specification> • 79, 758, 770, 995,     <MUMPS BLOB variable> • 1032, 1034, 1036, 1127
 1101, 1157
                                                              <MUMPS character variable> • 1032, 1033
<module collation specification> • 765, 766, 767, 768, 1105
                                                              <MUMPS CLOB locator variable> • 1032, 1034, 1036,
<module collations> • 765, 992, 996                            1127
<module contents> • 154, 765                                  <MUMPS CLOB variable> • 1032, 1033, 1034, 1036, 1127
<module name clause> • 765, 770, 995, 1101                    <MUMPS derived type specification> • 1032, 1033



©ISO/IEC 2003 – All rights reserved                                                                        Index 1229
ISO/IEC 9075-2:2003 (E)




<MUMPS host identifier> • 992, 1032, 1033, 1035             NO • 16, 22, 78, 138, 332, 340, 380, 462, 463, 464, 465,
<MUMPS length specification> • 1032, 1033                    498, 526, 549, 550, 551, 616, 640, 648, 658, 677, 680,
<MUMPS multiset locator variable> • 1032, 1033, 1035,        692, 701, 702, 726, 809, 810, 896, 898, 920, 975, 1111,
 1036, 1121                                                  1153
<MUMPS numeric variable> • 1032                             no active SQL-transaction for branch transaction • 890,
                                                             1077
<MUMPS REF variable> • 1032, 1033, 1035, 1114
                                                            no additional dynamic result sets returned • 822, 977, 1077
<MUMPS type specification> • 1032
                                                            no data • 91, 453, 454, 795, 796, 819, 820, 822, 825, 833,
<MUMPS user-defined type locator variable> • 1032, 1033,
                                                             838, 845, 852, 937, 977, 980, 1052, 1053, 1071, 1077
 1034, 1036, 1119
                                                            no subclass • 1071, 1072, 1074, 1075, 1076, 1077, 1078,
<MUMPS user-defined type variable> • 1032, 1034, 1036,
                                                             1079
 1123
                                                            <non-cycle mark value> • 365, 366
<MUMPS variable definition> • 992, 1032, 1033, 1035
                                                            <non-escaped character> • 391, 392
<mutated set clause> • 853, 854, 855, 857, 950, 1112
                                                            <non-reserved word> • 136
<mutated target> • 853, 854, 855
                                                            <non-second primary datetime field> • 467, 469
                      —N—                                   noncharacter in UCS string • 167, 1074
                                                            <nondelimiter token> • 9, 134, 139
N • 143
                                                            <nondoublequote character> • 134, 135, 139
NAME • 137, 676, 700, 936, 939, 959, 960, 1168
                                                            NONE • 38, 138, 645, 709, 713, 911
<named columns join> • 69, 70, 312, 313, 314, 315, 316,
                                                            <nonparenthesized value expression primary> • 174, 175,
 318, 1097
                                                             238, 278, 279, 280, 282, 296, 1126
NAMES • 137, 770, 917, 992
                                                            <nonquote character> • 136, 143, 146
NATIONAL • 15, 138, 161, 162, 163, 215, 216, 251, 390,
                                                            NORMALIZE • 138, 149, 254, 257, 263, 1175
 781, 782, 1018, 1030, 1098, 1099, 1128, 1145, 1149
                                                            <normalize function> • 25, 256, 257, 260, 261, 266, 1130,
<national character large object type> • 161, 162, 172,
                                                             1146
 1126
                                                            NORMALIZED • 137, 254, 263, 403
<national character string literal> • 134, 139, 143, 145,
 146, 150, 1098                                             <normalized predicate> • 25, 373, 403, 1130, 1146
<national character string type> • 161, 171, 1098           <normalized predicate part 2> • 197, 403
NATURAL • 69, 70, 138, 312, 313, 314, 315, 316, 442,        NOT • 19, 30, 138, 198, 278, 279, 280, 281, 376, 377,
 443, 581                                                    382, 383, 385, 386, 391, 392, 397, 403, 408, 409, 410,
                                                             411, 413, 415, 416, 417, 503, 504, 527, 528, 529, 530,
<natural join> • 312, 313, 318, 354, 1097
                                                             536, 538, 545, 546, 547, 548, 603, 604, 625, 634, 636,
<natural logarithm> • 29, 243, 244, 245, 248, 251, 1143,     640, 648, 649, 658, 677, 680, 694, 839, 1003, 1006,
 1152                                                        1106, 1111, 1112, 1132, 1141
NCHAR • 138, 161, 162, 163, 775, 780, 781, 782, 1014,       <not equals operator> • 20, 26, 135, 375, 376, 381, 400,
 1016, 1018                                                  442, 447, 449
NCLOB • 138, 162, 163, 1014, 1016, 1018, 1021, 1023         NULL • 30, 50, 84, 125, 138, 181, 198, 199, 204, 279, 287,
NESTING • 137, 957, 958, 959                                 288, 290, 326, 327, 346, 397, 425, 527, 528, 529, 530,
<nesting option> • 957                                       536, 538, 547, 548, 549, 551, 553, 556, 559, 564, 637,
NEW • 138, 226, 629, 630, 631, 676, 680, 694                 640, 651, 658, 677, 680, 886, 1141, 1182
<new invocation> • 222, 223, 226, 480                       <null ordering> • 59, 334, 517, 518, 1142, 1155
<new specification> • 85, 174, 175, 226, 227, 1110          <null predicate> • 20, 373, 397, 398, 1192
<new transition table name> • 128, 629, 630, 631, 632       <null predicate part 2> • 197, 397
<new transition variable name> • 128, 185, 629, 630, 631,   null row not permitted in table • 298, 1074
 632                                                        <null specification> • 181, 182, 294, 541, 886, 1185
<new window name> • 331, 332, 333, 334                      null value eliminated in set function • 509, 511, 513, 1079
<newline> • 136, 139, 146, 1148                             null value in array target • 494, 820, 826, 856, 1074
NEXT • 137, 217, 495, 817, 818, 819, 977, 979               null value not allowed • 179, 487, 1074, 1076
<next value expression> • 78, 174, 175, 217, 218, 238,      null value substituted for mutator subject parameter • 480,
 1133                                                        651, 1074



1230 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)




null value, no indicator parameter • 420, 938, 1074           ON • 53, 71, 84, 138, 312, 497, 525, 531, 533, 534, 549,
<null-call clause> • 84, 635, 640, 658, 676, 677, 680, 700,    550, 551, 569, 582, 588, 598, 611, 612, 615, 619, 623,
 701, 702                                                      629, 637, 640, 658, 674, 677, 680, 704, 729, 732, 733,
NULLABLE • 137, 936, 939, 959, 960                             734, 735, 737, 739, 839, 858, 896, 1064, 1207, 1208
NULLIF • 138, 197, 198                                        ONLY • 14, 56, 71, 83, 95, 138, 234, 303, 310, 416, 593,
                                                               596, 647, 709, 710, 765, 767, 768, 809, 810, 828, 829,
NULLS • 58, 59, 137, 336, 337, 338, 517, 518
                                                               830, 831, 832, 834, 840, 841, 842, 843, 846, 848, 849,
NUMBER • 137, 1055, 1058                                       850, 851, 865, 866, 877, 879, 887, 888, 891, 953, 982,
<number of conditions> • 887, 888, 890, 891, 1167              984, 986, 988, 991, 992, 1089, 1117
NUMERIC • 11, 12, 27, 138, 162, 165, 169, 433, 438, 782,      <only spec> • 303, 307, 309, 310, 753, 754, 757, 760,
 924, 925, 941, 944, 945, 946, 951, 1025, 1150                 1117
<numeric primary> • 241, 242, 1178                            OPEN • 138, 815, 978
<numeric type> • 161, 162, 1177                               <open statement> • 95, 100, 103, 106, 108, 110, 767, 791,
<numeric value expression> • 62, 235, 237, 239, 241, 242,      810, 815, 977, 996, 997, 1001, 1061, 1169, 1184
 244, 245, 246, 247, 248, 249, 257, 303, 506, 515, 944,       OPTION • 54, 56, 112, 113, 114, 137, 233, 309, 534, 590,
 1099, 1100, 1152, 1178                                        591, 592, 596, 597, 598, 599, 648, 731, 732, 733, 734,
<numeric value expression base> • 244, 248                     735, 736, 737, 738, 741, 743, 744, 745, 746, 747, 750,
<numeric value expression dividend> • 244, 248, 945            751, 752, 753, 754, 756, 757, 760, 761, 762, 764, 831,
                                                               832, 837, 841, 843, 844, 848, 849, 850, 851, 871, 879,
<numeric value expression divisor> • 244, 245, 248, 945
                                                               1067, 1091, 1107, 1116, 1130
<numeric value expression exponent> • 244, 248
                                                              OPTIONS • 137, 526, 590
<numeric value function> • 241, 243, 246, 1202
                                                              OR • 30, 68, 138, 199, 278, 279, 281, 287, 288, 376, 379,
numeric value out of range • 206, 207, 242, 247, 248, 249,     382, 408
 250, 421, 426, 509, 510, 513, 1068, 1074
                                                              ORDER • 95, 138, 331, 449, 506, 513, 514, 647, 709, 711,
                                                               809, 810, 1123
                        —O—                                   <order by clause> • 20, 26, 59, 95, 183, 193, 195, 217,
OBJECT • 11, 12, 15, 25, 94, 137, 161, 162, 163, 164,          285, 306, 333, 809, 810, 811, 812, 813, 846, 984, 1053,
 169, 215, 216, 251, 390, 396, 419, 433, 438, 537, 786,        1109, 1164, 1165, 1167
 787, 788, 924, 925, 941, 945, 971, 1018, 1098, 1099,         <ordered set function> • 191, 195, 505, 506
 1128, 1129                                                   ORDERING • 137, 647, 704, 709, 712
<object column> • 755, 759, 810, 840, 843, 846, 847, 848,     <ordering category> • 709
 849, 850, 851, 853, 854, 855, 856
                                                              <ordering form> • 709
<object name> • 736, 737, 739, 740, 741, 742, 747, 764,
 1091, 1092, 1110, 1112, 1116                                 <ordering specification> • 59, 334, 336, 337, 338, 514,
                                                               517
<object privileges> • 737, 739, 740
                                                              ORDINALITY • 71, 137, 303, 304, 305, 306
<occurrences> • 933, 934, 937, 940, 958, 964, 968, 1088,
 1159                                                         <ordinary grouping set> • 320, 322, 323, 324, 325, 326,
                                                               328, 1139
<octet length expression> • 243, 247, 944, 1179, 1202
                                                              <ordinary grouping set list> • 320, 322, 323
<octet like predicate> • 385, 386, 388, 389, 949, 1128
                                                              <original method specification> • 37, 38, 39, 635, 637,
<octet like predicate part 2> • 197, 385                       640, 645, 648, 657, 1111
<octet pattern> • 385, 386, 442, 949                          OTHERS • 137, 332, 340
OCTET_LENGTH • 138, 243, 247, 260, 936, 939, 960,             OUT • 138, 675, 683, 686, 687, 689, 691, 951
 961, 1159, 1168
                                                              OUTER • 138, 312, 1064
OCTETS • 137, 162
                                                              <outer join type> • 312, 1188
OF • 95, 138, 411, 413, 416, 417, 525, 532, 534, 590, 629,
 784, 809, 828, 846, 982, 984, 986, 988, 1037, 1038,          OUTPUT • 137, 957
 1039, 1040, 1115                                             <output using clause> • 967, 968, 971, 972, 979, 1087,
OLD • 84, 138, 629, 630, 631, 676, 680                         1168
<old transition table name> • 128, 629, 630, 631, 632         OVER • 138, 193, 194, 195, 513, 514
<old transition variable name> • 128, 629, 630, 631, 632      OVERLAPS • 36, 138, 407, 408, 1093
                                                              <overlaps predicate> • 36, 238, 373, 407, 408, 449, 949,
                                                               1093



©ISO/IEC 2003 – All rights reserved                                                                      Index 1231
ISO/IEC 9075-2:2003 (E)




<overlaps predicate part 1> • 197, 198, 407                 <Pascal host identifier> • 992, 1037, 1038, 1040
<overlaps predicate part 2> • 197, 198, 407                 <Pascal multiset locator variable> • 1037, 1038, 1040,
OVERLAY • 18, 138, 257, 265, 945, 1136                       1041, 1121
<override clause> • 834, 835, 838, 839, 840, 1115           <Pascal REF variable> • 1037, 1038, 1040, 1041, 1114
OVERRIDING • 137, 635, 638, 639, 834, 837, 844              <Pascal type specification> • 1037, 1038
<overriding method specification> • 37, 38, 39, 635, 642,   <Pascal user-defined type locator variable> • 1037, 1039,
 646, 663                                                    1041, 1119
                                                            <Pascal user-defined type variable> • 1037, 1039, 1041,
                      —P—                                    1123
                                                            <Pascal variable definition> • 992, 1037, 1038, 1040
PAD • 16, 22, 137, 380, 498, 616
                                                            PATH • 137, 473, 918
<pad characteristic> • 616, 617
                                                            <path column> • 365, 366
PARAMETER • 138, 346, 485, 487, 489, 490, 492, 640,
 658, 676, 682, 685, 690, 694, 696, 701, 702                <path specification> • 473, 519, 696, 765, 992, 1115
<parameter mode> • 639, 659, 664, 675, 682, 683, 686,       <path-resolved user-defined type name> • 79, 90, 123,
 687, 688, 689, 690, 691, 951, 962, 1067, 1068               154, 161, 163, 166, 171, 176, 178, 179, 220, 224, 226,
                                                             416, 474, 477, 478, 525, 529, 532, 533, 534, 590, 592,
<parameter style> • 37, 39, 89, 640, 645, 646, 648, 661,
                                                             598, 634, 677, 682, 686, 687, 689, 690, 704, 766, 815,
 666, 676, 677, 682, 696, 1111
                                                             919, 994, 1008, 1009, 1010, 1012, 1014, 1015, 1017,
<parameter style clause> • 635, 640, 658, 676, 679, 680,     1018, 1019, 1022, 1024, 1026, 1027, 1028, 1029, 1031,
 700, 701, 702                                               1032, 1033, 1034, 1036, 1037, 1039, 1041, 1042, 1043,
<parameter type> • 435, 639, 659, 664, 666, 675, 682,        1044, 1045, 1046, 1109, 1115, 1117, 1119, 1120, 1124
 683, 686, 687, 688, 689, 690, 691, 697, 698, 1118, 1119,   <percent> • 19, 131, 132, 387, 388, 389, 391, 392, 393,
 1120, 1121, 1126                                            394
<parameter using clause> • 963, 972                         PERCENT_RANK • 60, 63, 138, 193, 194, 196, 1142,
PARAMETER_MODE • 137, 932, 937, 939, 962, 1056,              1146
 1067, 1068, 1159                                           PERCENTILE_CONT • 62, 138, 506, 509, 513, 514, 1155
PARAMETER_NAME • 137, 1056, 1067, 1068                      PERCENTILE_DISC • 62, 138, 506, 514
PARAMETER_ORDINAL_POSITION • 137, 937, 939,                 <period> • 131, 132, 144, 145, 147, 151, 152, 183, 185,
 959, 962, 1056, 1067, 1068, 1159                            187, 208, 209, 219, 222, 257, 341, 343, 469, 474, 635,
PARAMETER_SPECIFIC_CATALOG • 137, 937, 939,                  781, 853, 1007, 1021
 959, 962, 1159                                             <PL/I array locator variable> • 1042, 1043, 1045, 1046,
PARAMETER_SPECIFIC_NAME • 137, 937, 939, 959,                1121
 962, 1159                                                  <PL/I BLOB locator variable> • 1042, 1044, 1046, 1128
PARAMETER_SPECIFIC_SCHEMA • 137, 937, 939, 959,             <PL/I BLOB variable> • 1042, 1044, 1046, 1128
 962, 1159
                                                            <PL/I CLOB locator variable> • 1042, 1044, 1047, 1128
<parenthesized boolean value expression> • 278, 279,
                                                            <PL/I CLOB variable> • 1042, 1043, 1044, 1046, 1128
 280
                                                            <PL/I derived type specification> • 1042
<parenthesized value expression> • 174
                                                            <PL/I host identifier> • 992, 1042, 1043, 1044, 1045
PARTIAL • 65, 137, 404, 405, 549, 551, 555, 563
                                                            <PL/I multiset locator variable> • 1042, 1043, 1045, 1046,
<partial method specification> • 635, 649, 657, 663, 1111
                                                             1121
PARTITION • 138, 331
                                                            <PL/I REF variable> • 1042, 1043, 1045, 1046, 1114
PASCAL • 137, 452, 471, 487, 489, 691, 699, 701, 769,
                                                            <PL/I type fixed binary> • 1042, 1043
 784, 785, 787, 995, 1040, 1090
                                                            <PL/I type fixed decimal> • 1042, 1043
<Pascal array locator variable> • 1037, 1038, 1040, 1041,
 1120                                                       <PL/I type float binary> • 1042, 1043
<Pascal BLOB locator variable> • 1037, 1039, 1041, 1128     <PL/I type specification> • 1042, 1043, 1160
<Pascal BLOB variable> • 1037, 1039, 1041, 1128             <PL/I user-defined type locator variable> • 1042, 1045,
                                                             1046, 1120
<Pascal CLOB locator variable> • 1037, 1039, 1041, 1128
                                                            <PL/I user-defined type variable> • 1042, 1044, 1046, 1123
<Pascal CLOB variable> • 1037, 1038, 1039, 1041, 1128
                                                            <PL/I variable definition> • 992, 1042, 1043, 1045, 1160
<Pascal derived type specification> • 1037
                                                            PLACING • 137, 257, 945



1232 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                             ISO/IEC 9075-2:2003 (E)




PLI • 137, 452, 471, 487, 489, 691, 699, 701, 769, 784,       <privilege column list> • 736, 739, 740, 741, 742, 747,
 785, 786, 787, 788, 995, 1090, 1091                           748, 1107, 1135, 1182, 1183
<plus sign> • 19, 131, 132, 135, 140, 144, 241, 242, 267,     <privilege method list> • 113, 736, 739, 740, 741, 742,
 269, 272, 391, 392, 393, 394, 946, 1092                       747, 748, 1112
POSITION • 7, 138, 243, 945                                   privilege not granted • 737, 1079
<position expression> • 19, 20, 26, 28, 243, 244, 442, 443,   privilege not revoked • 763, 1079
 945, 1151, 1180, 1202                                        PRIVILEGES • 137, 588, 737, 739, 740, 763
POWER • 138, 244, 245, 512                                    <privileges> • 736, 737, 739, 740, 741, 742, 747, 748, 763,
<power function> • 29, 243, 244, 245, 248, 251, 1143,          764, 1091, 1092, 1110, 1112, 1116, 1183
 1152                                                         PROCEDURE • 138, 499, 500, 501, 675, 680, 771, 976
PRECEDING • 137, 194, 332, 333, 336, 337, 338, 339            <procedure name> • 80, 152, 771, 772, 774, 996, 997,
PRECISION • 11, 12, 27, 138, 162, 165, 170, 433, 438,          1169
 924, 925, 926, 937, 940, 941, 942, 961, 1011, 1019,          prohibited SQL-statement attempted • 484, 485, 488, 1078
 1027, 1030, 1149, 1150, 1168                                 prohibited SQL-statement attempted • 1075
<precision> • 81, 162, 163, 164, 165, 169, 170, 782, 798,     prohibited statement encountered during trigger execution
 944, 1032, 1033, 1042, 1046, 1149, 1150                       • 884, 1077
<predefined type> • 161, 438, 603, 634, 636, 637, 1008,       PUBLIC • 111, 114, 137, 157, 497, 612, 739, 741, 748,
 1014, 1022, 1027, 1032, 1037, 1042, 1193                      749, 750, 751, 859, 911
<predicate> • 30, 278, 279, 280, 373, 387, 389, 1173, 1182
<preparable dynamic delete statement: positioned> • 82,                              —Q—
 100, 104, 107, 108, 110, 943, 952, 973, 986, 987, 1061,
 1088                                                         <qualified asterisk> • 341, 344, 1181
<preparable dynamic update statement: positioned> • 82,       <qualified identifier> • 84, 151, 152, 153, 154, 155, 156,
 100, 104, 107, 108, 110, 943, 952, 973, 988, 989, 1061,       157, 184, 186, 187, 226, 228, 264, 307, 342, 349, 416,
 1088                                                          474, 475, 480, 487, 503, 625, 635, 636, 637, 638, 639,
                                                               642, 644, 653, 657, 660, 663, 665, 669, 670, 684, 685,
<preparable implementation-defined statement> • 108,
                                                               858, 1066, 1067, 1137
 943, 944, 1159
                                                              <qualified join> • 312, 313, 354
<preparable SQL control statement> • 943, 944
                                                              <quantified comparison predicate> • 20, 26, 238, 280, 347,
<preparable SQL data statement> • 943
                                                               373, 399, 400, 442, 449, 949, 1182
<preparable SQL schema statement> • 943
                                                              <quantified comparison predicate part 2> • 197, 399
<preparable SQL session statement> • 943
                                                              <quantifier> • 280, 399, 400
<preparable SQL transaction statement> • 943
                                                              <query expression> • vi, 51, 53, 54, 55, 63, 66, 70, 73, 74,
<preparable statement> • 81, 88, 90, 122, 123, 125, 153,       86, 217, 239, 280, 285, 286, 291, 292, 306, 307, 308,
 154, 155, 156, 178, 451, 476, 477, 693, 914, 915, 917,        310, 314, 345, 348, 349, 351, 352, 353, 355, 356, 359,
 918, 943, 944, 973, 1148, 1149                                360, 361, 363, 364, 365, 370, 371, 429, 534, 573, 578,
PREPARE • 138, 489, 943, 952, 956, 974                         579, 581, 587, 590, 591, 592, 595, 596, 599, 600, 610,
<prepare statement> • 10, 79, 81, 83, 90, 102, 104, 122,       614, 618, 623, 625, 655, 672, 673, 700, 703, 707, 708,
 123, 153, 154, 155, 156, 158, 159, 178, 451, 476, 477,        712, 713, 732, 734, 749, 750, 752, 755, 756, 758, 760,
 792, 914, 915, 917, 918, 919, 943, 952, 953, 954, 956,        792, 809, 810, 815, 833, 834, 836, 838, 845, 852, 857,
 957, 972, 975, 1061, 1086, 1148, 1149, 1168                   866, 868, 869, 871, 879, 948, 978, 986, 988, 1053, 1095,
prepared statement not a cursor specification • 952, 977,      1108, 1112, 1131, 1132, 1167, 1187, 1190
 1075                                                         <query expression body> • 54, 157, 306, 333, 351, 352,
PRESERVE • 53, 137, 525, 533, 569                              353, 354, 355, 356, 357, 358, 359, 361, 365, 445, 811,
                                                               864, 869, 876, 1166, 1173
PRIMARY • 49, 64, 65, 68, 138, 530, 545, 547, 548, 550,
 583, 1207, 1208                                              query expression too long for information schema • 599,
                                                               1079
<primary datetime field> • 32, 36, 148, 149, 166, 167, 168,
 202, 211, 212, 213, 214, 215, 243, 245, 247, 267, 268,       <query name> • 51, 53, 54, 74, 151, 157, 159, 304, 307,
 269, 274, 275, 335, 336, 380, 381, 407, 430, 467, 468,        308, 309, 310, 351, 352, 353, 354, 355, 356, 360, 361,
 469, 1151                                                     365, 1131
PRIOR • 137, 817, 818, 819, 820                               <query primary> • 74, 187, 351, 354, 356, 357, 358, 359,
                                                               811, 864, 869, 876, 1173



©ISO/IEC 2003 – All rights reserved                                                                         Index 1233
ISO/IEC 9075-2:2003 (E)




<query specification> • v, 20, 26, 55, 59, 63, 74, 157, 187,   REFERENCES • 113, 138, 188, 309, 534, 549, 551, 573,
 191, 193, 195, 217, 218, 239, 306, 314, 321, 333, 334,          581, 582, 597, 604, 731, 733, 734, 737, 739, 740, 741,
 341, 342, 343, 344, 345, 346, 347, 348, 349, 351, 354,          748, 749, 750, 751, 753, 754, 757, 859, 1207, 1208
 355, 356, 359, 361, 365, 401, 445, 584, 591, 592, 593,        <references specification> • 536, 538, 549, 568, 1107,
 627, 792, 811, 812, 825, 864, 865, 869, 877, 980, 1109,         1186
 1140, 1166, 1190                                              REFERENCING • 138, 629, 630
<query term> • 74, 351, 354, 355, 356, 357, 358, 361, 364,     <referencing columns> • 65, 546, 549, 550, 568, 1134
 445, 811, 864, 876, 1095, 1166, 1173
                                                               <referential action> • 549, 550, 551, 558, 567, 568, 1133,
<question mark> • 19, 81, 132, 177, 391, 392, 393, 394,          1207, 1208
 1173
                                                               <referential constraint definition> • 20, 65, 445, 451, 545,
<quote> • 131, 132, 134, 136, 140, 141, 143, 144, 145,           546, 549, 550, 551, 1192, 1208
 146, 147, 150, 1094, 1179
                                                               <referential triggered action> • 65, 546, 549
<quote symbol> • 141, 143, 147
                                                               REGR_AVGX • 62, 138, 506, 511
                                                               REGR_AVGY • 62, 138, 506, 511
                       —R—
                                                               REGR_COUNT • 62, 138, 506, 508, 511, 1155
RANGE • 58, 138, 194, 331, 333, 335
                                                               REGR_INTERCEPT • 62, 138, 505, 512
RANK • 60, 63, 138, 193, 194, 508, 1155
                                                               REGR_R2 • 138
<rank function type> • 193, 346, 506, 513
                                                               REGR_SLOPE • 62, 138, 505, 512
READ • 95, 116, 118, 119, 137, 809, 810, 887, 888, 891
                                                               REGR_SXX • 62, 138, 506, 511
read-only SQL-transaction • 829, 832, 836, 841, 847, 850,
                                                               REGR_SXY • 62, 138, 506, 511
  1052, 1077
                                                               REGR_SYY • 62, 138, 506, 511
reading SQL-data not permitted • 483, 485, 489, 1075,
  1078                                                         <regular character set> • 391
READS • 138, 677, 685, 692, 696, 701, 702, 1156                <regular character set identifier> • ?, 392, 393
REAL • 11, 12, 27, 138, 162, 165, 170, 433, 438, 775, 782,     <regular expression> • 262, 391, 393, 394
  785, 787, 924, 925, 1007, 1011, 1019, 1027, 1030, 1032,      <regular expression substring function> • 16, 17, 18, 256,
  1033, 1037, 1040, 1149, 1150                                   257, 258, 261, 262, 265, 1141
RECURSIVE • 74, 138, 159, 304, 310, 351, 352, 363, 364,        <regular factor> • 391
  590, 591, 592, 599, 1131, 1132                               <regular identifier> • 21, 134, 139, 140, 141, 151, 1097,
<recursive search order> • 365, 366                              1145, 1148, 1180
REF • 8, 11, 43, 44, 54, 138, 163, 170, 435, 525, 529, 577,    <regular primary> • 391
  578, 593, 594, 595, 634, 635, 648, 674, 837, 844, 924,       <regular term> • 391
  926, 1018                                                    <regular view specification> • 590, 595
<reference column list> • 549, 550, 581                        RELATIVE • 7, 38, 42, 137, 376, 378, 709, 711, 817, 819,
<reference generation> • 525, 535, 1114                          820, 1163
<reference resolution> • 44, 174, 175, 233, 234, 347, 578,     <relative category> • 709
  587, 597, 600, 731, 732, 733, 753, 754, 756, 757, 760,       <relative function specification> • 709, 710
  1114                                                         RELEASE • 138, 895
<reference type> • 161, 163, 166, 170, 171, 220, 221, 531,     <release savepoint statement> • 85, 101, 116, 484, 488,
  651, 705, 706, 961, 1008, 1010, 1015, 1018, 1022, 1024,        685, 791, 895, 1061, 1135, 1156, 1174
  1025, 1028, 1030, 1033, 1035, 1038, 1040, 1043, 1045,
                                                               <repeat argument> • 56, 303, 304, 310, 1146
  1112, 1113, 1117, 1118, 1124
                                                               <repeat factor> • 391, 394
<reference type specification> • 634, 636, 637, 649, 1113,
  1115                                                         REPEATABLE • 116, 118, 119, 137, 303, 887, 891
<reference value expression> • 230, 233, 237, 239, 240,        <repeatable clause> • 56, 303, 310, 1146
  578, 587, 600, 1113                                          <representation> • 634, 636, 1193
<referenceable view specification> • 590, 591, 592, 595,       request failed • 829, 832, 836, 837, 842, 847, 850, 1072
  599, 1115                                                    request rejected • 816, 1072
<referenced table and columns> • 65, 546, 549, 550, 581        <reserved word> • 136, 137, 140, 153, 1174, 1177, 1178,
<referenced type> • 163, 166, 170, 651, 1112                     1179, 1201
                                                               RESTART • 137, 728


1234 Foundation (SQL/Foundation)                                                        ©ISO/IEC 2003 – All rights reserved
                                                                                               ISO/IEC 9075-2:2003 (E)




RESTRICT • 137, 522, 549, 555, 558, 563, 567, 568, 578,          RIGHT • 70, 71, 138, 312, 313, 314, 315, 316, 354, 355,
  581, 584, 587, 588, 600, 610, 618, 627, 655, 668, 672,          1064
  700, 703, 707, 712, 721, 723, 729, 761, 1133                   <right arrow> • 135, 228
restrict violation • 555, 558, 563, 567, 1076                    <right brace> • 132, 133, 391, 1173
restricted data type attribute violation • 965, 966, 968, 969,   <right bracket> • 19, 132, 133, 392, 393, 395, 1013, 1037
  970, 1075                                                      <right bracket or trigraph> • 132, 163, 177, 181, 235, 285,
RESULT • 8, 40, 138, 635, 637, 638, 639, 640, 641, 648,           291, 853
  657, 659, 660, 664, 675, 676, 680, 682, 683, 693, 695,         <right bracket trigraph> • 132, 133, 135
  697, 1111
                                                                 <right paren> • 19, 131, 132, 161, 162, 163, 174, 177, 185,
<result> • 197, 198, 199                                          191, 193, 197, 201, 220, 222, 224, 233, 236, 243, 244,
<result cast> • 89, 491, 492, 640, 642, 658, 659, 663, 676,       256, 257, 270, 272, 277, 278, 285, 290, 291, 293, 303,
  678, 679, 680, 681, 682, 686, 694, 696                          312, 320, 321, 331, 341, 351, 356, 370, 383, 391, 392,
<result cast from type> • 37, 39, 641, 646, 649, 658, 661,        393, 394, 416, 467, 474, 499, 505, 506, 525, 526, 536,
  666, 676, 680, 681, 686, 1141                                   547, 549, 569, 590, 596, 625, 629, 634, 635, 675, 676,
<result expression> • 198, 199, 947, 948                          705, 707, 714, 717, 719, 721, 739, 771, 828, 834, 839,
<result set cursor> • 976, 977                                    853, 944, 945, 991, 993, 1007, 1008, 1014, 1021, 1022,
                                                                  1027, 1032, 1037, 1042, 1181, 1183
<result using clause> • 967, 972, 973, 1088
                                                                 <rights clause> • 676, 685, 698, 1137
RETURN • 96, 138, 646, 647, 648, 711, 809, 810, 886,
  975                                                            ROLE • 137, 523, 743, 746, 911
<return statement> • 101, 105, 107, 109, 485, 791, 886,          <role definition> • 99, 520, 743, 790, 1061, 1137, 1138,
  1061, 1193                                                      1156
<return value> • 886, 966, 970                                   <role granted> • 744, 745
RETURNED_CARDINALITY • 137, 937, 939, 971                        <role name> • 114, 151, 152, 158, 159, 743, 744, 745,
                                                                  746, 747, 748, 751, 911, 1137
RETURNED_LENGTH • 137, 937, 939, 971
                                                                 <role revoked> • 747, 748, 761
RETURNED_OCTET_LENGTH • 137, 937, 939, 971
                                                                 <role specification> • 911, 950
RETURNED_SQLSTATE • 137, 495, 1056, 1065, 1066,
  1067, 1068                                                     ROLLBACK • 117, 119, 138, 898
RETURNS • 84, 138, 637, 646, 647, 648, 676, 677, 711             <rollback statement> • 64, 85, 92, 95, 101, 103, 104, 105,
                                                                  115, 116, 118, 119, 120, 485, 488, 685, 768, 791, 898,
<returns clause> • 635, 640, 642, 649, 658, 661, 663, 666,
                                                                  899, 907, 1050, 1062, 1135, 1147, 1156, 1169, 1186
  675, 676, 679, 680, 886, 1141
                                                                 ROLLUP • 59, 68, 73, 138, 320, 322
<returns data type> • 37, 38, 39, 88, 443, 449, 491, 492,
  614, 618, 639, 640, 643, 644, 645, 646, 649, 657, 658,         <rollup list> • 320, 321, 322, 324, 328, 1138
  659, 661, 664, 665, 666, 676, 679, 680, 681, 682, 683,         ROUTINE • 137, 499, 500, 501, 523, 579, 585, 589, 602,
  686, 687, 689, 690, 691, 694, 695, 697, 698, 886, 970,          628, 673, 704, 708, 712, 722, 724, 725, 763
  1118, 1119, 1120, 1121, 1126, 1141                             <routine body> • 83, 85, 86, 87, 675, 676, 683, 693, 734,
<returns table type> • 676, 677, 698, 1137                        758, 886
<returns type> • 621, 676, 677, 678                              <routine characteristic> • 676, 699, 1090, 1091
<reverse solidus> • 132, 140, 1148                               <routine characteristics> • 675, 676, 679, 680, 699, 1135
REVOKE • 138, 582, 588, 611, 615, 619, 623, 674, 704,            <routine invocation> • 77, 79, 85, 86, 88, 90, 122, 125,
  729, 746, 747, 764, 1091, 1092                                  174, 175, 198, 222, 223, 224, 225, 226, 231, 239, 271,
<revoke option extension> • 747, 764, 1091, 1116                  304, 319, 346, 354, 360, 436, 474, 480, 493, 496, 515,
                                                                  520, 537, 569, 597, 625, 631, 655, 673, 685, 693, 695,
<revoke privilege statement> • 747, 748, 752, 761, 763,
                                                                  696, 697, 699, 700, 703, 731, 732, 733, 735, 753, 754,
  1061
                                                                  755, 757, 758, 766, 792, 831, 840, 849, 885, 918, 950,
<revoke role statement> • 746, 747, 748, 752, 761, 762,           951, 961, 1088, 1099, 1100, 1144, 1156, 1174, 1193,
  764, 1061, 1138                                                 1207
<revoke statement> • 98, 581, 582, 587, 588, 600, 601,           <routine name> • 79, 85, 86, 88, 90, 122, 125, 183, 184,
  611, 615, 619, 623, 627, 673, 674, 703, 704, 729, 740,          186, 342, 349, 378, 379, 474, 475, 480, 520, 660, 663,
  747, 748, 751, 752, 761, 762, 763, 764, 790, 1091, 1092,        665, 666, 669, 670, 684, 766, 918, 999, 1067, 1068,
  1187                                                            1137, 1173
                                                                 <routine type> • 499, 500, 501, 1111



©ISO/IEC 2003 – All rights reserved                                                                           Index 1235
ISO/IEC 9075-2:2003 (E)




ROUTINE_CATALOG • 137, 1056, 1067, 1068                     Feature S041, “Basic reference types” • 171, 229, 230,
ROUTINE_NAME • 137, 1056, 1067, 1068                         240, 1012, 1019, 1025, 1031, 1035, 1041, 1046, 1113,
ROUTINE_SCHEMA • 137, 1056, 1067, 1068                       1114
ROW • 11, 138, 163, 194, 206, 291, 293, 294, 295, 332,      Feature S043, “Enhanced reference types” • 171, 216,
 333, 336, 338, 339, 340, 366, 367, 435, 454, 629, 630,      232, 234, 535, 577, 579, 599, 649, 838, 1114, 1115
 632, 639, 659, 678, 683, 854, 924, 926, 938, 940, 941,     Feature S051, “Create table of type” • 534, 1115
 961, 964, 970, 1129, 1134, 1173                            Feature S071, “SQL paths in function and type name
<row subquery> • 55, 293, 294, 295, 370, 371, 1103           resolution” • 180, 473, 521, 544, 768, 918, 1002, 1115
<row type> • 161, 163, 166, 170, 171, 173, 1129             Feature S081, “Subtables” • 535, 738, 741, 764, 1116
<row type body> • 163                                       Feature S091, “Basic array support” • ?, ?, 171, 182, 235,
<row value constructor> • 55, 293, 294, 295, 296, 297,       250, 284, 286, 310, 857, 1116, 1117, 1124
 413, 1165                                                  Feature S092, “Arrays of user-defined types” • 171, 1117
<row value constructor element> • 68, 279, 293, 294, 295,   Feature S094, “Arrays of reference types” • 171, 1117
 385, 949, 1103                                             Feature S095, “Array constructors by query” • 286, 1117
<row value constructor element list> • 293, 1165            Feature S096, “Optional array bounds” • ?, ?, 171, 1117
<row value constructor predicand> • 68, 199, 200, 279,      Feature S097, “Array element assignment” • 180, 1117
 293, 294, 295, 296, 297, 385, 392, 403, 411, 415, 416,     Feature S111, “ONLY in query expressions” • 310, 830,
 949, 1094, 1126                                             1117
<row value expression> • 218, 237, 239, 296, 297, 298,      Feature S151, “Type predicate” • 417, 1117, 1118
 383, 384, 442, 447, 454, 948, 1102, 1129, 1192, 1194       Feature S161, “Subtype treatment” • ?, ?, 221, 1118
<row value expression list> • 298                           Feature S162, “Subtype treatment for references” • ?, ?,
<row value predicand> • 68, 197, 198, 199, 200, 238, 279,    221, 1118
 296, 297, 347, 375, 382, 383, 385, 389, 391, 392, 397,     Feature S201, “SQL-invoked routines on arrays” • 496,
 399, 403, 404, 407, 409, 411, 413, 415, 416, 417, 442,      697, 1118
 443, 449, 949, 1094
                                                            Feature S202, “SQL-invoked routines on multisets” • 496,
<row value predicand 1> • 407, 408, 949                      697, 698, 1118
<row value predicand 2> • 407, 408, 949                     Feature S211, “User-defined cast functions” • 706, 708,
<row value predicand 3> • 409                                1118, 1119
<row value predicand 4> • 409                               Feature S231, “Structured type locators” • 698, 773, 1012,
<row value special case> • 296, 297, 835, 1129               1019, 1026, 1031, 1036, 1041, 1046, 1119, 1120
ROW_COUNT • 137, 1055, 1063, 1064, 1169                     Feature S232, “Array locators” • 698, 773, 1012, 1019,
ROW_NUMBER • 60, 138, 193, 194, 196, 239, 346, 514,          1025, 1031, 1036, 1041, 1046, 1120, 1121
 1142                                                       Feature S233, “Multiset locators” • 698, 773, 1012, 1019,
ROWS • 53, 58, 138, 194, 239, 331, 333, 338, 525, 531,       1025, 1031, 1036, 1041, 1046, 1121
 533, 550, 569, 858, 951                                    Feature S241, “Transform functions” • 180, 697, 716, 725,
                                                             768, 919, 1002, 1012, 1019, 1025, 1031, 1036, 1041,
                      —S—                                    1046, 1121, 1122, 1123
                                                            Feature S242, “Alter transform statement” • 718, 1123
S • 1022
                                                            Feature S251, “User-defined orderings” • 711, 713, 1123
Feature S023, “Basic structured types” • 159, 171, 223,
 227, 496, 648, 649, 651, 697, 741, 1109, 1110              Feature S261, “Specific type method” • 266, 1123
Feature S024, “Enhanced structured types” • 225, 443,       Feature S271, “Basic multiset support” • 171, 182, 236,
 446, 448, 450, 501, 648, 649, 651, 652, 697, 704, 738,      250, 290, 292, 310, 412, 415, 515, 1116, 1117, 1123,
 742, 838, 845, 857, 1110, 1111, 1112                        1124
Feature S025, “Final structured types” • 649, 1112          Feature S272, “Multisets of user-defined types” • 171, 1124
Feature S026, “Self-referencing structured types” • 651,    Feature S274, “Multisets of reference types” • 171, 1124
 1112                                                       Feature S275, “Advanced multiset support” • 289, 414,
Feature S027, “Create method by specific method name”        443, 515, 1125
 • 698, 1112, 1113                                          Feature S281, “Nested collection types” • 171, 1125
Feature S028, “Permutable UDT options list” • 649, 1113     Feature S291, “Unique constraint on entire row” • 548,
                                                             1125



1236 Foundation (SQL/Foundation)                                                     ©ISO/IEC 2003 – All rights reserved
                                                                                            ISO/IEC 9075-2:2003 (E)




<sample clause> • 56, 303, 308, 310, 311, 371, 1143,         <schema path specification> • 76, 519, 520, 521, 1115,
 1146                                                         1155
<sample method> • 56, 303, 310                               <schema procedure> • 675
<sample percentage> • 56, 303, 310                           <schema qualified name> • 52, 77, 122, 151, 152, 155,
SAVEPOINT • 84, 138, 676, 680, 694, 894, 895, 898             156, 487, 915, 1148, 1149
<savepoint clause> • 85, 92, 485, 488, 685, 898, 899,        <schema qualified routine name> • 83, 152, 158, 499, 500,
 1135, 1156                                                   501, 653, 675, 677, 681, 683, 684, 692, 693, 697, 1136
savepoint exception • 894, 895, 899, 1077                    <schema routine> • 99, 519, 675, 677, 697, 1062, 1136
<savepoint level indication> • 676, 680, 699, 1135           <schema-resolved user-defined type name> • 152, 155,
<savepoint name> • 115, 152, 158, 159, 894, 895, 899,         166, 499, 500, 501, 634, 636, 651, 652, 653, 655, 657,
 1135                                                         663, 665, 668, 672, 675, 678, 705, 706, 709, 712, 714,
                                                              717, 719, 721, 723, 739, 740, 741, 742, 1110, 1112
<savepoint specifier> • 116, 894, 895, 898
                                                             SCHEMA_NAME • 137, 1056, 1066, 1067
<savepoint statement> • 85, 101, 105, 115, 116, 484, 488,
 685, 791, 894, 1062, 1135, 1156, 1158, 1174                 SCOPE • 138, 163, 431, 530, 578, 595
<scalar subquery> • 174, 175, 230, 236, 370, 371, 383,       <scope clause> • 163, 166, 170, 171, 203, 526, 531, 535,
 513, 514, 753, 754, 756, 757, 759, 1192                      577, 590, 594, 1114
SCALE • 137, 924, 925, 937, 940, 941, 942, 961, 1159,        <scope option> • 153, 157, 158, 159, 933, 935, 937, 940,
 1168                                                         952, 953, 958, 963, 967, 986, 988
<scale> • 81, 162, 164, 165, 782, 798, 1032, 1033, 1042,     SCOPE_CATALOG • 137, 924, 926, 937, 940, 942, 961
 1046, 1150                                                  SCOPE_NAME • 137, 924, 926, 937, 940, 942, 961
SCHEMA • 137, 519, 522, 765, 766, 915, 991, 992, 996,        SCOPE_SCHEMA • 137, 924, 926, 937, 940, 942, 961
 1159, 1160                                                  SCROLL • 95, 138, 809, 810, 817, 975, 979
schema and data statement mixing not supported • 793,        SEARCH • 138, 365
 1052, 1077                                                  <search clause> • 365, 366, 367, 368
<schema authorization identifier> • 112, 519, 520            <search condition> • 30, 49, 50, 56, 61, 64, 65, 66, 68, 70,
<schema character set or path> • 519                          72, 73, 117, 188, 191, 197, 199, 217, 254, 262, 263, 306,
<schema character set specification> • 173, 519, 520, 521,    309, 312, 313, 315, 319, 328, 329, 330, 418, 505, 509,
 537, 763, 1101, 1155                                         538, 546, 547, 569, 570, 573, 578, 579, 581, 584, 587,
<schema definition> • 77, 90, 98, 112, 153, 154, 155, 156,    600, 603, 604, 608, 610, 614, 618, 623, 625, 626, 627,
 217, 233, 476, 477, 497, 503, 519, 520, 521, 526, 527,       628, 629, 655, 672, 673, 700, 703, 707, 708, 712, 713,
 537, 590, 594, 603, 612, 613, 616, 620, 621, 625, 630,       731, 750, 753, 754, 755, 756, 757, 759, 760, 831, 832,
 636, 678, 681, 685, 692, 693, 727, 763, 790, 1062, 1155,     833, 839, 840, 842, 843, 845, 849, 850, 851, 852, 884,
 1187, 1192                                                   1063, 1064, 1104, 1108, 1135, 1136, 1165, 1182
<schema element> • 519, 521, 1192                            search condition too long for information schema • 570,
                                                              626, 1079
<schema function> • 675
                                                             <search or cycle clause> • 351, 355, 365, 369
<schema name> • 52, 77, 79, 88, 90, 122, 151, 152, 153,
 154, 155, 156, 157, 158, 174, 179, 222, 224, 226, 378,      <searched case> • 197, 199, 1191
 473, 474, 476, 477, 479, 497, 498, 499, 503, 519, 520,      <searched when clause> • 197, 199
 521, 522, 523, 526, 527, 530, 534, 537, 545, 571, 588,      SECOND • 32, 35, 138, 148, 167, 168, 245, 430, 467, 468,
 590, 593, 594, 595, 601, 603, 604, 605, 610, 612, 614,       469, 542, 942, 946, 951, 1151
 616, 618, 620, 621, 623, 625, 628, 630, 631, 633, 635,      <seconds fraction> • 145, 148, 149, 150, 469, 1102
 636, 639, 647, 648, 657, 658, 663, 668, 673, 678, 679,      <seconds integer value> • 145, 148, 469
 681, 692, 700, 701, 703, 704, 707, 708, 710, 711, 712,
                                                             <seconds value> • 144, 145, 148
 727, 729, 765, 766, 858, 859, 914, 915, 991, 992, 996,
 1065, 1066, 1067, 1068, 1093, 1148, 1149, 1157, 1159,       SECTION • 137, 992
 1160, 1163                                                  SECURITY • 137, 166, 188, 203, 204, 231, 261, 309, 497,
<schema name characteristic> • 915, 950                       502, 595, 676, 677, 685, 693, 694, 696, 697, 829, 831,
                                                              836, 841, 847, 849
<schema name clause> • 156, 519, 520, 521, 1093, 1149
                                                             SELECT • 55, 71, 73, 113, 138, 188, 195, 230, 233, 234,
<schema name list> • 179, 473, 520, 696, 766, 918, 1155,
                                                              236, 287, 288, 290, 291, 304, 305, 306, 309, 312, 314,
 1157
                                                              316, 318, 322, 326, 327, 341, 345, 355, 357, 366, 367,
                                                              368, 513, 514, 532, 534, 546, 547, 548, 551, 573, 581,



©ISO/IEC 2003 – All rights reserved                                                                        Index 1237
ISO/IEC 9075-2:2003 (E)




 582, 591, 596, 597, 598, 599, 604, 631, 662, 731, 732,       <sequence generator start with option> • 463, 726, 727
 733, 736, 737, 739, 740, 741, 742, 747, 748, 749, 750,       SERIALIZABLE • 63, 116, 117, 118, 119, 120, 137, 795,
 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 812,        796, 887, 889, 891, 909, 1051, 1093
 824, 831, 832, 841, 843, 844, 849, 850, 859, 868, 871,       serialization failure • 118, 1078
 879, 1063, 1064, 1135, 1208
                                                              SERVER_NAME • 137, 1056, 1068
<select list> • 20, 26, 55, 59, 70, 74, 183, 188, 191, 193,
                                                              SESSION • 137, 909, 910
 194, 195, 217, 306, 313, 314, 317, 319, 321, 326, 333,
 334, 341, 342, 343, 344, 345, 346, 347, 349, 354, 357,       <session characteristic> • 123, 909
 365, 401, 584, 594, 627, 755, 756, 758, 760, 811, 824,       <session characteristic list> • 123, 909
 825, 826, 867, 869, 877, 957, 958, 968, 1136, 1140,          SESSION_USER • 111, 138, 176, 177, 179, 180, 238,
 1181, 1184, 1185, 1190                                        541, 542, 543, 544, 815, 1053, 1095, 1096, 1150
<select statement: single row> • 48, 59, 100, 103, 106,       SET • 14, 59, 119, 120, 125, 138, 161, 163, 164, 290, 365,
 108, 110, 157, 193, 195, 217, 306, 333, 334, 755, 756,        415, 497, 519, 523, 549, 551, 553, 554, 556, 557, 559,
 758, 760, 791, 792, 795, 824, 825, 1062, 1167, 1191           562, 564, 565, 572, 575, 580, 606, 612, 614, 615, 739,
<select sublist> • 258, 341, 343, 594, 867                     782, 794, 839, 846, 849, 890, 891, 892, 896, 904, 909,
<select target list> • 195, 824, 825, 826, 827, 1167           910, 911, 913, 914, 915, 917, 918, 919, 920, 939, 984,
                                                               988, 1000, 1007, 1008, 1013, 1014, 1015, 1016, 1018,
SELF • 39, 137, 635, 637, 638, 639, 640, 641, 644, 645,
                                                               1021, 1023, 1027, 1028, 1032, 1033, 1037, 1038, 1040,
 646, 648, 657, 658, 659, 660, 665, 1111
                                                               1042, 1043, 1051, 1134, 1135, 1149, 1207, 1208, 1209
<self-referencing column name> • 525, 526, 530, 595
                                                              <set catalog statement> • 81, 102, 122, 791, 914, 1062,
<self-referencing column specification> • 525, 529, 590,       1104, 1107
 592, 594
                                                              <set clause> • 810, 842, 843, 847, 848, 851, 853, 854,
<semicolon> • 131, 132, 629, 771, 991, 993, 1013, 1032,        855, 856, 857, 950, 1108, 1112
 1037, 1042, 1049
                                                              <set clause list> • 306, 839, 840, 843, 846, 848, 849, 851,
SENSITIVE • 96, 138, 809, 810, 813, 816, 1134                  853, 854, 855, 984, 988, 1143
SEPARATE • 1022                                               <set column default clause> • 574, 575, 1096
<separator> • 135, 136, 139, 140, 143, 144, 145, 146, 147,    <set connection statement> • 101, 120, 121, 129, 791,
 241, 854, 993, 1004, 1028, 1201                               794, 904, 905, 1051, 1062, 1108
SEQUENCE • 137, 523, 726, 728, 729, 739                       <set constraints mode statement> • 64, 101, 504, 791,
<sequence column> • 365, 366                                   795, 892, 893, 1062, 1106, 1207, 1208
<sequence generator cycle option> • 463, 464, 465, 466,       <set descriptor information> • 939
 726, 727                                                     <set descriptor statement> • 82, 102, 104, 792, 938, 939,
<sequence generator data type option> • 726, 727, 1156         940, 942, 1062, 1086, 1168
<sequence generator definition> • 99, 519, 726, 727, 790,     <set domain default clause> • 605, 606, 1106
 1062, 1133, 1156                                             <set function specification> • 73, 74, 174, 175, 188, 191,
<sequence generator increment> • 463, 465, 726                 313, 319, 328, 330, 332, 340, 344, 345, 346, 348, 349,
<sequence generator increment by option> • 463, 465,           354, 506, 508, 509, 569, 584, 627, 811, 812, 854, 1099,
 726, 727                                                      1136, 1184, 1190
sequence generator limit exceeded • 462, 1074                 <set function type> • 505, 507
<sequence generator max value> • 463, 465, 726, 1153          <set header information> • 939, 942
<sequence generator maxvalue option> • 463, 465, 726,         <set item information> • 939, 940
 727, 1153                                                    <set local time zone statement> • 101, 122, 791, 913, 950,
<sequence generator min value> • 463, 465, 726, 1153           1062, 1098
<sequence generator minvalue option> • 463, 465, 726,         <set names statement> • 81, 102, 123, 792, 917, 1062,
 727, 1153                                                     1101, 1107
<sequence generator name> • 152, 158, 160, 217, 218,          <set path statement> • 81, 102, 122, 792, 918, 1062, 1115,
 726, 727, 728, 729, 739, 740, 1133                            1148
<sequence generator option> • 726                             <set predicate> • 373, 415, 447, 1124
<sequence generator options> • 726                            <set predicate part 2> • 197, 415
<sequence generator restart value> • 466, 728                 <set quantifier> • 20, 26, 195, 217, 320, 321, 328, 341,
<sequence generator start value> • 463, 726                    342, 344, 345, 349, 350, 505, 506, 507, 514, 812, 824,
                                                               825, 1099, 1109, 1130, 1139, 1165, 1180, 1184



1238 Foundation (SQL/Foundation)                                                       ©ISO/IEC 2003 – All rights reserved
                                                                                             ISO/IEC 9075-2:2003 (E)




<set role statement> • 101, 111, 791, 911, 912, 1062, 1138    <simple value specification 2> • 939, 940
<set schema statement> • 81, 102, 122, 791, 915, 916,         <simple when clause> • 197, 198, 199, 200, 1094
 1062, 1107                                                   <single datetime field> • 166, 467, 468, 469
<set session characteristics statement> • 101, 116, 117,      <single group specification> • 677, 682, 766, 994
 123, 791, 795, 909, 1062, 1093, 1107                         SIZE • 137, 887
<set session collation statement> • 102, 123, 792, 920,       SMALLINT • 11, 12, 27, 138, 162, 165, 169, 433, 438,
 921, 1062, 1105, 1159                                         775, 780, 782, 924, 925, 1007, 1011, 1019, 1025, 1046,
<set session user identifier statement> • 101, 111, 791,       1149
 910, 950, 1062, 1096, 1159                                   <solidus> • 131, 132, 139, 241, 242, 272, 946
<set target> • 853, 854, 950                                  SOME • 61, 138, 399, 505, 507, 510, 514, 1126
<set target list> • 853, 854, 950                             <some> • 399, 400
<set time zone value> • 913                                   <sort key> • 58, 194, 333, 334, 336, 337, 338, 449, 508,
<set transaction statement> • 93, 101, 116, 117, 791, 794,     513, 517, 811, 951, 1184, 1185
 796, 888, 890, 891, 1051, 1062, 1135, 1187                   <sort specification> • 59, 334, 508, 509, 513, 515, 517,
<set transform group statement> • 102, 122, 792, 919,          518, 810, 811, 812, 813, 1100, 1155, 1166
 944, 1062, 1122                                              <sort specification list> • 58, 286, 331, 335, 365, 366, 449,
SETS • 73, 137, 320, 322, 323, 324, 325, 328, 676, 680,        506, 508, 513, 515, 517, 809, 811, 812, 1100, 1155,
 1139                                                          1166
SIGN • 1022                                                   SOURCE • 137, 635
<sign> • 144, 145, 149, 208, 210, 241, 272, 273, 1177,        <source character set specification> • 620, 750
 1178                                                         <source data type> • 705, 707
<signed integer> • 27, 144                                    SPACE • 16, 22, 137, 392, 395, 498, 616
<signed numeric literal> • 143, 144, 149, 206, 207, 463,      <space> • 9, 15, 16, 82, 120, 131, 132, 133, 139, 145,
 465, 542, 726, 728, 1153                                      179, 206, 207, 208, 209, 210, 254, 263, 264, 380, 395,
SIMILAR • 16, 17, 19, 138, 256, 262, 391, 392, 393, 395,       421, 425, 426, 543, 785, 787, 993, 1028, 1068
 396, 945, 1132                                               SPECIFIC • 138, 499, 523, 579, 585, 589, 602, 628, 635,
<similar pattern> • 391, 392, 393, 394, 443, 949               673, 675, 676, 698, 704, 708, 711, 712, 722, 724, 725,
<similar predicate> • 19, 20, 373, 391, 392, 395, 396, 442,    763, 1113
 443, 949, 1129, 1132, 1152, 1173                             <specific method name> • 37, 38, 39, 635, 639, 645, 646,
<similar predicate part 2> • 197, 391                          657, 658, 661, 662, 663, 666, 667, 668, 675, 678, 679
SIMPLE • 137, 404, 549, 551, 552, 558, 559                    <specific method specification designator> • 668
<simple case> • 197, 198, 199, 948, 1094, 1191                <specific name> • 85, 152, 158, 499, 523, 578, 585, 628,
<simple comment> • 136, 139, 944, 1187                         673, 676, 678, 679, 681, 693, 695, 700, 703, 709, 710,
<simple comment introducer> • 136, 139                         722, 724, 725, 763, 1067, 1068
<simple Latin letter> • 131, 151, 395                         <specific routine designator> • 38, 499, 500, 501, 620,
                                                               621, 700, 703, 704, 705, 709, 710, 711, 714, 738, 739,
<simple Latin lower case letter> • 131, 133, 141, 395
                                                               740, 741, 976, 977, 1111
<simple Latin upper case letter> • 131, 133, 141, 395,
                                                              <specific type method> • 256, 257, 260, 261, 264, 266,
 1003, 1071, 1161
                                                               1123
<simple table> • 74, 351, 354, 355, 356, 359, 360, 362,
                                                              SPECIFIC_NAME • 137, 1056, 1067, 1068
 364, 811, 1104, 1166
                                                              SPECIFICTYPE • 138, 257, 711
<simple target specification> • 129, 176, 178, 179, 436,
 437, 925, 926, 936, 938, 1055, 1056, 1058, 1065, 1069,       SQL • 8, 85, 86, 138, 166, 188, 203, 204, 231, 261, 309,
 1151                                                          346, 471, 485, 489, 490, 492, 497, 502, 595, 637, 639,
                                                               640, 645, 647, 648, 658, 659, 661, 676, 677, 680, 682,
<simple target specification 1> • 936, 937, 938, 1168
                                                               685, 692, 693, 694, 696, 701, 702, 711, 714, 765, 829,
<simple target specification 2> • 936, 937, 938, 1168          831, 836, 841, 847, 849, 933, 935, 936, 939, 957, 967,
<simple value specification> • 120, 152, 153, 157, 176,        991, 992, 1008, 1009, 1010, 1014, 1015, 1016, 1017,
 177, 178, 179, 258, 436, 437, 494, 817, 818, 820, 826,        1018, 1021, 1022, 1023, 1024, 1027, 1028, 1029, 1030,
 853, 855, 856, 857, 887, 902, 925, 926, 933, 935, 936,        1032, 1033, 1034, 1035, 1037, 1038, 1039, 1040, 1042,
 937, 939, 940, 943, 952, 958, 963, 967, 976, 1056, 1117       1043, 1044, 1045, 1111, 1156
<simple value specification 1> • 939, 942



©ISO/IEC 2003 – All rights reserved                                                                         Index 1239
ISO/IEC 9075-2:2003 (E)




<SQL argument> • 222, 354, 436, 474, 475, 477, 478,        <SQL schema statement> • 77, 128, 166, 188, 203, 204,
 493, 496, 950, 951, 1088, 1118                             231, 261, 309, 475, 497, 502, 544, 573, 595, 630, 631,
<SQL argument list> • 86, 174, 222, 224, 226, 228, 231,     685, 693, 790, 792, 795, 796, 829, 831, 836, 841, 847,
 354, 432, 436, 474, 475, 477, 478, 684, 951                849, 943, 1049, 1052, 1156
<SQL condition> • 1003, 1006, 1089, 1101                   <SQL session statement> • 631, 790, 791, 943, 1049,
<SQL connection statement> • 85, 129, 631, 685, 790,        1156
 791, 792, 793, 794, 1049, 1050, 1051, 1068, 1154, 1156    <SQL special character> • 131, 135
<SQL control statement> • 85, 105, 790, 791, 792, 796,     <SQL statement name> • 10, 152, 160, 489, 943, 952,
 943, 944                                                   953, 956, 957, 958, 972, 1086, 1191
<SQL data change statement> • 631, 685, 791, 1156          <SQL statement variable> • 10, 104, 943, 944, 974
<SQL data statement> • 685, 790, 791, 793, 1156            <SQL terminal character> • 131, 1148
<SQL descriptor statement> • 792                           <SQL terminator> • 991, 992, 993
<SQL diagnostics information> • 1055                       <SQL transaction statement> • 85, 631, 685, 790, 791,
<SQL diagnostics statement> • 93, 129, 790, 792, 793,       943, 1049, 1154, 1156
 796, 797                                                  <SQL-client module definition> • 52, 78, 79, 80, 81, 82,
<SQL dynamic data statement> • 115, 792, 793, 1147          87, 88, 94, 106, 107, 112, 147, 154, 155, 156, 177, 178,
                                                            187, 476, 477, 483, 489, 520, 532, 595, 604, 612, 613,
<SQL dynamic statement> • 159, 631, 685, 790, 792, 963,
                                                            616, 621, 625, 630, 631, 644, 652, 678, 692, 693, 696,
 967, 1156
                                                            697, 727, 765, 766, 767, 768, 769, 770, 771, 772, 773,
<SQL executable statement> • 790                            774, 795, 809, 815, 858, 953, 956, 957, 972, 974, 975,
<SQL language character> • 21, 131, 164, 207, 208, 209,     978, 979, 981, 982, 984, 995, 1001, 1002, 1089, 1090,
 210, 520, 770, 994, 1145, 1157                             1147, 1154, 1168, 1169, 1191
<SQL language identifier> • 134, 151, 152, 153, 157        <SQL-client module name> • 80, 129, 152, 158, 770, 774,
<SQL language identifier part> • 151, 153                   995, 1164, 1168
<SQL language identifier start> • 151                      SQL-client unable to establish SQL-connection • 902, 1072
<SQL parameter declaration> • 83, 85, 89, 614, 618, 639,   <SQL-data access indication> • 635, 640, 648, 658, 676,
 640, 642, 658, 660, 666, 675, 681, 682, 686, 688, 689,     677, 679, 680, 692, 696, 700, 701, 702, 1111
 690, 691, 695, 697, 1111                                  <SQL-invoked function> • 84, 675, 677, 683, 886
<SQL parameter declaration list> • 37, 38, 39, 183, 184,   <SQL-invoked procedure> • 84, 675, 677, 683, 1193
 342, 500, 635, 639, 640, 645, 646, 657, 658, 663, 664,    <SQL-invoked routine> • 10, 86, 475, 588, 600, 601, 647,
 675, 679, 681, 682                                         673, 675, 677, 678, 679, 680, 681, 682, 683, 692, 693,
<SQL parameter name> • 88, 152, 158, 183, 184, 342,         697, 699, 711, 767, 790, 792, 1001, 1141, 1144, 1193
 625, 639, 640, 643, 647, 648, 658, 664, 675, 679, 682,    <SQL-path characteristic> • 918, 950
 683, 999, 1068
                                                           <SQL-server name> • 120, 152, 157, 901, 902, 1068,
<SQL parameter reference> • 176, 177, 185, 190, 478,        1148, 1159
 493, 631, 817, 818, 820, 824, 825, 826, 1173
                                                           SQL-server rejected establishment of SQL-connection •
<SQL prefix> • 991, 992, 993                                902, 1072
<SQL procedure statement> • 63, 81, 85, 87, 91, 93, 106,   SQLEXCEPTION • 138, 1003, 1006
 107, 129, 271, 436, 552, 578, 629, 676, 685, 693, 734,
                                                           SQLSTATE • 86, 90, 91, 93, 138, 489, 504, 688, 771, 772,
 735, 771, 772, 773, 790, 792, 795, 884, 944, 991, 997,
                                                            781, 783, 784, 995, 996, 998, 1001, 1003, 1005, 1006,
 998, 1000, 1001, 1004, 1005, 1050, 1156, 1164, 1169,
                                                            1011, 1058, 1065, 1071, 1080, 1089, 1160, 1163
 1208
                                                           <SQLSTATE char> • 1003, 1004
<SQL routine body> • 584, 627, 676, 685, 694, 695, 698,
 699, 759, 760, 1144, 1154, 1156                           <SQLSTATE class value> • 1003, 1004, 1005
SQL routine exception • 483, 484, 485, 488, 1067, 1068,    <SQLSTATE subclass value> • 1003, 1004, 1005
 1078                                                      SQLWARNING • 138, 1003, 1006
<SQL routine spec> • 166, 188, 203, 204, 231, 261, 309,    SQRT • 138, 244, 507, 512
 497, 502, 595, 676, 684, 685, 693, 829, 831, 836, 841,    <square root> • 29, 243, 244, 245, 251, 1143
 847, 849                                                  <standard character set name> • 497, 498
<SQL schema definition statement> • 790                    START • 138, 528, 726, 887, 888, 1134
<SQL schema manipulation statement> • 790                  <start field> • 166, 275, 430, 467, 468, 469



1240 Foundation (SQL/Foundation)                                                   ©ISO/IEC 2003 – All rights reserved
                                                                                              ISO/IEC 9075-2:2003 (E)




<start position> • 256, 257, 259, 260, 261, 264                 <subtable clause> • 55, 525, 526, 529, 530, 532, 533, 534,
<start transaction statement> • 101, 104, 116, 117, 791,         535, 1116
  794, 887, 888, 1051, 1062, 1134                               <subtype clause> • 40, 634, 636, 637, 638, 644, 645, 647
STATE • 7, 13, 38, 42, 137, 376, 379, 645, 709, 711, 713        <subtype operand> • 220
<state category> • 709, 710, 711                                <subtype treatment> • 174, 175, 220, 221, 1118
STATEMENT • 137, 629, 630, 632, 1208                            <subview clause> • 590, 592, 593, 594, 595, 598, 599
statement completion unknown • 120, 1078                        successful completion • 91, 453, 495, 796, 1005, 1052,
<statement cursor> • 976                                         1071, 1078
<statement information> • 1055                                  SUM • 60, 61, 138, 505, 507, 510, 1151, 1154
<statement information item> • 1055, 1056, 1058                 <supertable clause> • 526
<statement information item name> • 1055, 1056, 1069,           <supertable name> • 526, 532
  1140                                                          <supertype name> • 634, 638
<statement name> • 152, 153, 159, 897, 952, 953, 956,           SYMMETRIC • 138, 382, 1139
  957, 972, 974, 975, 978, 982, 984, 1168                       syntax error or access rule violation • 795, 944, 951, 953,
<statement or declaration> • 991, 1001, 1002                     972, 974, 1050, 1066, 1067, 1071, 1078
statement too long for information schema • 631, 1079           SYSTEM • 114, 138, 303, 497, 525, 529, 534, 535, 582,
STATIC • 37, 39, 83, 89, 138, 476, 490, 499, 500, 501,           588, 592, 596, 597, 598, 604, 611, 613, 615, 617, 619,
  635, 638, 641, 642, 643, 645, 648, 649, 657, 660, 661,         621, 623, 635, 648, 693, 704, 727, 729, 732, 733, 734,
  663, 664, 668, 669, 670, 671, 675, 676, 677, 678, 695,         735, 743, 749, 750, 751, 834, 837, 844, 859, 1114
  711, 765, 767, 768, 953, 991, 992, 1089, 1111                 <system-generated representation> • 634, 635, 637
<static method invocation> • 85, 174, 175, 224, 225, 655,       SYSTEM_USER • 138, 176, 177, 179, 180, 238, 346, 541,
  673, 700, 703, 753, 754, 755, 757, 758, 1110                   542, 543, 544, 815, 1053, 1095, 1096, 1150, 1151
<static method selection> • 224, 474, 476, 477, 479
<status parameter> • 436, 771, 772                                                     —T—
STDDEV_POP • 61, 62, 138, 505, 506, 507, 515, 1143              Feature T031, “BOOLEAN data type” • 150, 171, 239, 282,
STDDEV_SAMP • 61, 62, 138, 505, 506, 507, 515, 1143              295, 514, 1125, 1126
string data, length mismatch • 1074                             Feature T041, “Basic LOB data type support” • 150, 172,
string data, right truncation • 207, 208, 209, 210, 254, 255,    698, 1011, 1019, 1026, 1031, 1036, 1041, 1046, 1047,
  263, 421, 425, 426, 1068, 1074, 1079                           1126, 1127, 1128
<string length> • 256, 257, 259, 260, 261, 265                  Feature T042, “Extended LOB data type support” • 215,
                                                                 216, 266, 389, 390, 396, 443, 647, 1099, 1128, 1129
<string position expression> • 243, 244, 246
                                                                Feature T051, “Row types” • 159, 171, 173, 219, 295, 297,
<string value expression> • 177, 179, 237, 239, 243, 244,
                                                                 349, 1129
  245, 246, 247, 251, 252, 253, 260, 261, 265, 443, 944,
  1099, 1202                                                    Feature T052, “MAX and MIN for row types” • ?, ?, 515,
                                                                 1129
<string value function> • 252, 256, 257, 261, 945, 1202
                                                                Feature T053, “Explicit aliases for all-fields reference” •
STRUCTURE • 137, 957
                                                                 350, 1130
STYLE • 137, 346, 485, 487, 489, 490, 492, 640, 658, 676,
                                                                Feature T061, “UCS support” • 172, 266, 403, 1082, 1130
  682, 685, 690, 694, 696, 701, 702
                                                                Feature T071, “BIGINT data type” • 172, 1011, 1020, 1130
SUBCLASS_ORIGIN • 137, 1056, 1065, 1080, 1160
                                                                Feature T111, “Updatable joins, unions, and columns” •
SUBMULTISET • 138, 413, 1175
                                                                 348, 360, 591, 599, 814, 833, 838, 845, 852, 1130, 1131
<submultiset predicate> • 238, 347, 373, 413, 414, 447,
                                                                Feature T121, “WITH (excluding RECURSIVE) in query
  1125
                                                                 expression” • 159, 310, 363, 1131
<submultiset predicate part 2> • 197, 413
                                                                Feature T122, “WITH (excluding RECURSIVE) in
<subquery> • 103, 105, 106, 157, 191, 193, 217, 313, 319,        subquery” • 363, 1131
  329, 330, 333, 341, 344, 345, 346, 348, 349, 354, 363,
                                                                Feature T131, “Recursive query” • 364, 599, 1131, 1132
  364, 370, 371, 508, 509, 526, 528, 534, 537, 569, 570,
  591, 599, 811, 833, 842, 850, 851, 1104, 1107, 1109,          Feature T132, “Recursive query in subquery” • 364, 1132
  1131, 1132, 1136, 1187, 1190                                  Feature T141, “SIMILAR predicate” • 396, 1132
SUBSTRING • 16, 138, 246, 256, 257, 260, 945                    Feature T151, “DISTINCT predicate” • 410, 1132
substring error • 261, 265, 1074


©ISO/IEC 2003 – All rights reserved                                                                          Index 1241
ISO/IEC 9075-2:2003 (E)




Feature T152, “DISTINCT predicate with negation” • 410,       Feature T434, “GROUP BY DISTINCT” • 328, 1139
 1132                                                         Feature T441, “ABS and MOD functions” • 251, 1139
Feature T171, “LIKE clause in table definition” • 534, 1132   Feature T461, “Symmetric BETWEEN predicate” • 382,
Feature T172, “AS subquery clause in table definition” •       1139
 535, 1132                                                    Feature T471, “Result sets return value” • 697, 813, 1139,
Feature T173, “Extended LIKE clause in table definition”       1140
 • 535, 1132, 1133                                            Feature T491, “LATERAL derived table” • 310, 1140
Feature T174, “Identity columns” • 539, 580, 1133             Feature T501, “Enhanced EXISTS predicate” • 401, 1140
Feature T175, “Generated columns” • 540, 1133                 Feature T511, “Transaction counts” • 1069, 1140
Feature T176, “Sequence generator support” • 160, 218,        Feature T551, “Optional key words for default syntax” •
 727, 728, 729, 1133                                           364, 814, 1140
Feature T191, “Referential action RESTRICT” • 568, 1133       Feature T561, “Holdable locators” • 860, 861, 1140
Feature T201, “Comparable data types for referential          Feature T571, “Array-returning external SQL-invoked
 constraints” • 568, 1133, 1134                                functions” • 649, 697, 1141
Feature T211, “Basic trigger capability” • 311, 632, 633,     Feature T572, “Multiset-returning external SQL-invoked
 741, 1134                                                     functions” • 649, 697, 1141
Feature T212, “Enhanced trigger capability” • 632, 1134       Feature T581, “Regular expression substring function” •
Feature T231, “Sensitive cursors” • 813, 1109, 1134            265, 1141
Feature T241, “START TRANSACTION statement” • 888,            Feature T591, “UNIQUE constraints of possibly null
 1134                                                          columns” • 548, 1141
Feature T251, “SET TRANSACTION statement: LOCAL               Feature T601, “Local cursor references” • 160, 1142
 option” • 891, 1134, 1135                                    Feature T611, “Elementary OLAP operations” • 196, 340,
Feature T261, “Chained transactions” • 897, 899, 1135          518, 1142
Feature T271, “Savepoints” • 159, 894, 895, 899, 1135         Feature T612, “Advanced OLAP operations” • 160, 196,
Feature T272, “Enhanced savepoint management” • 484,           251, 340, 515, 1142, 1143
 488, 694, 699, 1135                                          Feature T613, “Sampling” • 311, 1143
Feature T281, “SELECT privilege with column granularity”      Feature T621, “Enhanced numeric functions” • 251, 515,
 • 742, 1135                                                   1143
Feature T301, “Functional dependencies” • 329, 330, 340,      Feature T641, “Multiple column assignment” • 857, 1143,
 349, 938, 1135, 1136                                          1144
Feature T312, “OVERLAY function” • 265, 1136                  Feature T651, “SQL-schema statements in SQL routines”
Feature T322, “Overloading of SQL-invoked functions and        • 485, 698, 1144
 procedures” • 697, 1136                                      Feature T652, “SQL-dynamic statements in SQL routines”
Feature T323, “Explicit security for external routines” •      • 485, 698, 1144
 698, 1136                                                    Feature T653, “SQL-schema statements in external
Feature T324, “Explicit security for SQL routines” • 698,      routines” • 488, 698, 1144
 1137                                                         Feature T654, “SQL-dynamic statements in external
Feature T325, “Qualified SQL parameter references” •           routines” • 488, 699, 1144
 186, 349, 1137                                               Feature T655, “Cyclically dependent routines” • 699, 1144
Feature T326, “Table functions” • 292, 311, 698, 1137         TABLE • 138, 291, 303, 351, 355, 361, 362, 367, 522, 525,
Feature T331, “Basic roles” • 159, 743, 745, 746, 764,         571, 579, 582, 585, 587, 588, 589, 602, 611, 628, 629,
 912, 1137, 1138                                               630, 631, 676, 677, 708, 713, 739, 762, 763, 764, 858,
Feature T332, “Extended roles” • 180, 544, 741, 743, 1138      859, 1091, 1207, 1208
Feature T351, “Bracketed comments” • 142, 1138                <table commit action> • 525, 858
Feature T431, “Extended grouping capabilities” • 192, 328,    <table constraint> • 545, 546, 611, 1067
 1138, 1139                                                   <table constraint definition> • 525, 528, 529, 530, 533,
Feature T432, “Nested and concatenated GROUPING                538, 539, 545, 583, 611, 1185
 SETS” • 328, 1139                                            <table contents source> • 525
Feature T433, “Multiargument GROUPING function” • ?,
 ?, 192, 1139



1242 Foundation (SQL/Foundation)                                                       ©ISO/IEC 2003 – All rights reserved
                                                                                               ISO/IEC 9075-2:2003 (E)




<table definition> • 51, 52, 55, 98, 154, 217, 519, 525, 526,   <target specification> • ?, 129, 176, 178, 179, 436, 437,
 527, 532, 534, 536, 537, 539, 545, 547, 548, 549, 569,           474, 478, 493, 569, 590, 795, 815, 817, 818, 820, 824,
 573, 790, 1062, 1174, 1192                                       825, 826, 827, 951, 967, 968, 969, 970, 1151, 1193
<table element> • 525, 527, 532                                 <target subtype> • 220, 221, 1118
<table element list> • 525, 529, 531, 858                       <target table> • 755, 759, 828, 829, 830, 831, 832, 833,
<table expression> • 57, 58, 59, 74, 187, 193, 195, 300,          834, 839, 840, 841, 842, 843, 845, 846, 848, 849, 850,
 329, 332, 334, 341, 343, 345, 347, 348, 354, 365, 755,           851, 852, 853, 982, 984, 986, 988, 1063, 1117, 1131
 756, 758, 760, 811, 824, 825, 864, 869, 877, 1190, 1191        target table disagrees with cursor specification • 982, 984,
<table factor> • v, 71, 72, 184, 303, 306, 307, 308, 310,         1078
 312, 354                                                       TEMPORARY • 51, 52, 137, 525, 531, 532, 533, 858
<table function column list> • 676, 677                         <temporary table declaration> • 52, 79, 99, 105, 107, 109,
<table function column list element> • 676                        121, 154, 187, 482, 483, 536, 539, 569, 765, 858, 859,
<table function derived table> • 303, 304, 311, 1137              991, 994, 997, 1001, 1049, 1102, 1154
<table name> • 55, 77, 151, 153, 154, 157, 163, 166, 304,       <term> • 241, 272, 273
 307, 308, 309, 522, 525, 526, 527, 528, 530, 532, 534,         THEN • 138, 194, 197, 198, 199, 287, 288, 290, 367, 839
 537, 545, 547, 548, 549, 551, 571, 572, 577, 578, 579,         TIES • 137, 332, 340
 581, 583, 584, 585, 587, 588, 589, 590, 591, 593, 594,         TIME • 11, 12, 31, 32, 34, 94, 138, 144, 148, 162, 165,
 595, 596, 600, 601, 602, 609, 629, 630, 632, 661, 667,           167, 170, 211, 212, 213, 214, 245, 267, 269, 270, 275,
 708, 713, 732, 734, 739, 740, 741, 748, 749, 750, 755,           345, 435, 438, 440, 913, 942, 949, 951, 1152
 756, 759, 762, 763, 810, 828, 831, 834, 838, 839, 840,         <time fractional seconds precision> • 31, 32, 162, 165,
 842, 846, 849, 851, 858, 896, 972, 982, 984, 994, 1063,          167, 168, 170, 245, 456, 798, 1150
 1066, 1108, 1116, 1180, 1188
                                                                <time interval> • 145
<table or query name> • 54, 70, 71, 185, 187, 303, 304,
                                                                <time literal> • 144, 148, 149, 150, 1102, 1189
 306, 307, 308, 309, 343, 347, 351, 352, 355, 356, 359,
 593, 810, 828, 831, 832, 842, 844, 845, 846, 849, 850,         <time precision> • 162, 165, 167, 171, 211, 212, 213, 270,
 1108, 1180                                                       271, 924, 961, 1102, 1150
<table primary> • v, 63, 71, 303, 304, 306, 307, 308, 309,      <time string> • 135, 144
 310, 354, 355                                                  <time value> • 144, 145, 149, 1189
<table reference> • v, 55, 56, 63, 69, 72, 187, 301, 302,       <time zone> • 238, 267, 268, 269, 1098
 303, 308, 310, 312, 347, 348, 353, 354, 355, 360, 365,         <time zone field> • 243, 245, 250, 251, 1092, 1098
 569, 591, 593, 596, 732, 749, 750, 752, 753, 754, 755,         <time zone interval> • 144, 145, 148, 149, 150, 1098, 1189
 757, 758, 759, 760, 828, 832, 839, 840, 842, 843, 845,
                                                                <time zone specifier> • 267, 268, 269
 846, 850, 864, 869, 877, 982, 984, 986, 988, 1063, 1108,
 1117, 1146, 1173, 1180, 1188, 1190                             TIMESTAMP • 11, 12, 31, 32, 34, 94, 138, 144, 148, 162,
                                                                  165, 167, 170, 211, 212, 213, 214, 245, 267, 270, 275,
<table reference list> • 72, 301, 302, 353
                                                                  345, 435, 438, 440, 942, 949, 951
<table row value expression> • 296, 297, 298, 299
                                                                <timestamp literal> • 144, 148, 149, 150, 1102, 1189
<table scope> • 525, 529, 532, 534, 1102
                                                                <timestamp precision> • 162, 165, 167, 171, 212, 270,
<table subquery> • 238, 280, 303, 354, 370, 383, 399,             271, 924, 961, 1102, 1150
 401, 402, 404, 405, 406, 442, 443, 445, 449, 949, 1140,
                                                                <timestamp string> • 135, 139, 144
 1178, 1180, 1181, 1182
                                                                TIMEZONE_HOUR • 138, 167, 243, 247
<table value constructor> • v, 69, 295, 298, 299, 351, 355,
 356, 359, 364, 383, 836, 867, 948, 1103, 1104, 1165            TIMEZONE_MINUTE • 138, 167, 244
<table value constructor by query> • 291, 292, 1137             TO • 17, 32, 122, 138, 215, 262, 268, 274, 275, 365, 381,
                                                                  391, 392, 393, 395, 430, 467, 468, 497, 534, 598, 612,
TABLE_NAME • 137, 1056, 1066, 1067
                                                                  620, 647, 714, 721, 722, 732, 733, 734, 735, 736, 737,
TABLESAMPLE • 138, 303, 1175                                      744, 794, 898, 901, 913, 942, 946, 950, 951, 1003, 1004,
<target array element specification> • 176, 177, 178, 180,        1005, 1006, 1051
 478, 493, 818, 820, 824, 826, 1117                             <to sql> • 714, 715, 716, 719, 720, 721
<target array reference> • 177, 178                             <to sql function> • 714, 715, 719
<target character set specification> • 620, 750                 <token> • 134, 139, 993, 1201
<target data type> • 705, 707                                   too many • 894, 1078
                                                                TOP_LEVEL_COUNT • 137, 936, 939, 958



©ISO/IEC 2003 – All rights reserved                                                                           Index 1243
ISO/IEC 9075-2:2003 (E)




TRAILING • 138, 256, 264, 265                                 <trigger action time> • 185, 629, 632
TRANSACTION • 119, 120, 137, 887, 888, 890, 891, 1134,        <trigger column list> • 129, 629, 630, 632
  1135                                                        <trigger definition> • 53, 99, 126, 128, 129, 157, 185, 519,
<transaction access mode> • 887, 888, 890, 891, 909,            629, 630, 631, 632, 790, 1062, 1134, 1156
  1187                                                        <trigger event> • 129, 629, 630, 632
<transaction characteristics> • 890, 909                      <trigger name> • 152, 158, 523, 629, 630, 631, 633, 708,
<transaction mode> • 887, 888, 890, 1186                        713, 762, 1066
transaction resolution unknown • 120, 1072                    TRIGGER_CATALOG • 137, 1056, 1066
transaction rollback • 118, 120, 504, 896, 897, 1065, 1066,   TRIGGER_NAME • 137, 1056, 1066
  1078, 1080                                                  TRIGGER_SCHEMA • 137, 1056, 1066
TRANSACTION_ACTIVE • 137, 1055, 1065, 1069, 1140              <triggered action> • 86, 128, 129, 271, 573, 587, 600, 629,
TRANSACTIONS_COMMITTED • 137, 1055, 1064, 1069,                 630, 631, 632, 833, 842, 851, 1134, 1156
  1140                                                        triggered action exception • 884, 1066, 1078
TRANSACTIONS_ROLLED_BACK • 137, 1055, 1065,                   triggered action exception • 896, 1066, 1078
  1069, 1140                                                  triggered data change violation • 563, 567, 1065, 1066,
<transcoding> • 19, 256, 257, 258, 261, 263, 264, 266,          1078
  1105, 1152                                                  <triggered SQL statement> • 126, 129, 478, 629, 631, 755,
<transcoding name> • 152, 155, 158, 159, 256, 258, 259,         756, 757, 831, 836, 849, 883, 896, 1156, 1174
  264, 1105, 1149                                             TRIM • 138, 211, 212, 213, 214, 215, 256, 257, 259, 260,
TRANSFORM • 137, 647, 673, 677, 704, 714, 717, 723,             901, 902, 910, 911, 914, 915, 917, 918, 919, 920, 933,
  919                                                           952, 976
<transform definition> • 43, 99, 519, 714, 716, 790, 1062,    <trim character> • 26, 256, 259, 264
  1122                                                        trim error • 264, 265, 1074
<transform element> • 714                                     <trim function> • 19, 26, 256, 257, 259, 261, 264, 1179,
<transform element list> • 714, 719                             1202
<transform group> • 714                                       <trim octet> • 257, 260, 265
<transform group characteristic> • 919, 950                   <trim operands> • 256
<transform group element> • 723                               <trim source> • 256, 259, 260, 264, 265
<transform group specification> • 676, 677, 682, 697, 765,    <trim specification> • 256, 257, 259, 260, 264, 265
  992, 1122                                                   TRUE • 138, 145, 150, 209, 210, 278, 280, 367, 379, 711,
<transform kind> • 721                                          788, 831
TRANSFORMS • 137, 714, 717, 723                               <truth value> • 278, 279, 282, 1103
<transforms to be dropped> • 723                              TYPE • 137, 523, 634, 652, 672, 674, 677, 739, 763, 919,
<transition table name> • 51, 53, 54, 304, 307, 309, 311,       924, 925, 926, 937, 938, 940, 941, 942, 959, 960, 961,
  629, 1134                                                     964, 970, 971, 1008, 1009, 1010, 1014, 1015, 1016,
<transition table or variable> • 629                            1017, 1018, 1021, 1022, 1023, 1024, 1027, 1028, 1029,
<transition table or variable list> • 629, 630                  1030, 1032, 1033, 1034, 1035, 1037, 1038, 1039, 1040,
                                                                1042, 1043, 1044, 1045, 1159, 1168
TRANSLATE • 138, 256
                                                              <type list> • 416
TRANSLATION • 138, 523, 620, 623, 732, 739
                                                              <type predicate> • 373, 416, 417, 1118
<transliteration definition> • 99, 156, 519, 620, 621, 622,
  732, 750, 790, 1062, 1105, 1156                             <type predicate part 2> • 198, 416
<transliteration name> • 19, 152, 156, 158, 159, 256, 259,    <typed table clause> • 525, 529, 532, 533
  261, 263, 523, 604, 620, 621, 623, 732, 739, 740, 750,      <typed table element> • 525
  1105                                                        <typed table element list> • 525, 531
<transliteration routine> • 620, 621
<transliteration source> • 620, 621                                                  —U—
TREAT • 138, 220                                              U • 134, 143
TRIGGER • 113, 138, 523, 534, 582, 586, 589, 602, 628,        UESCAPE • 16, 134, 138, 140
  629, 631, 633, 708, 713, 739, 740, 741, 754, 762, 1134,     UNBOUNDED • 137, 194, 332, 333, 336, 337, 338, 339
  1208


1244 Foundation (SQL/Foundation)                                                       ©ISO/IEC 2003 – All rights reserved
                                                                                              ISO/IEC 9075-2:2003 (E)




UNCOMMITTED • 116, 118, 119, 137, 887, 888, 891                <updatability clause> • 809, 810, 812, 813, 846, 985, 1053,
undefined DATA value • 938, 1075                                1109
UNDER • 41, 55, 113, 137, 526, 532, 590, 595, 598, 634,        UPDATE • 95, 113, 126, 127, 128, 129, 534, 549, 551,
 644, 648, 652, 734, 739, 740, 741, 753, 758, 1110, 1116        553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563,
<underscore> • 19, 132, 133, 143, 151, 153, 387, 388,           564, 565, 566, 567, 572, 573, 582, 598, 629, 734, 737,
 389, 391, 392, 393, 394, 781, 1180                             739, 740, 741, 748, 749, 755, 759, 809, 810, 812, 813,
                                                                814, 839, 841, 846, 847, 849, 850, 859, 874, 883, 984,
<Unicode 4 digit escape value> • 135, 140
                                                                988, 1109, 1131, 1174, 1208
<Unicode 6 digit escape value> • 135, 140
                                                               UPDATE • 138
<Unicode character escape value> • 135, 140
                                                               <update rule> • 549, 550, 551, 558, 559, 562, 563, 564,
<Unicode character string literal> • 134, 139, 143, 146,        565, 567, 568, 1106
 150, 1097
                                                               <update source> • 217, 218, 755, 756, 757, 759, 760, 842,
<Unicode delimited identifier> • 134, 139, 140, 141, 142,       847, 848, 851, 853, 854, 855, 856, 857, 950, 1108, 1112
 151, 1097
                                                               <update statement: positioned> • 48, 56, 95, 96, 100, 103,
<Unicode delimiter body> • 134, 135, 140, 141                   107, 109, 110, 218, 567, 755, 759, 791, 810, 813, 830,
<Unicode escape character> • 134, 135, 140, 1148                833, 843, 846, 847, 848, 851, 852, 853, 985, 988, 1063,
<Unicode escape specifier> • 134, 140, 143                      1108, 1109, 1184, 1185
<Unicode escape value> • 135, 140, 143, 146                    <update statement: searched> • 48, 56, 100, 103, 107,
<Unicode identifier part> • 135, 140                            108, 109, 218, 572, 755, 756, 757, 759, 760, 791, 830,
                                                                847, 849, 852, 853, 943, 1049, 1063, 1064, 1131, 1169,
<Unicode representation> • 143, 146
                                                                1184
UNION • 20, 26, 47, 67, 74, 75, 138, 234, 238, 239, 287,
                                                               <update target> • 853, 855, 856, 857, 950, 1112, 1117
 288, 289, 305, 316, 327, 351, 353, 355, 356, 357, 359,
 360, 361, 362, 363, 364, 380, 445, 447, 513, 599, 864,        UPPER • 18, 138, 256, 263, 392, 395
 876, 1125, 1140, 1166, 1174, 1187, 1192                       <upper limit> • 391, 394
UNIQUE • 54, 64, 138, 402, 404, 405, 406, 530, 545, 547,       USAGE • ?, 113, 137, 166, 204, 217, 261, 497, 498, 502,
 548, 1095, 1125, 1141                                          532, 538, 595, 604, 611, 612, 613, 615, 616, 617, 619,
<unique column list> • 65, 445, 529, 545, 547, 548, 550,        621, 623, 648, 727, 729, 732, 739, 740, 742, 750, 752,
 1141, 1186                                                     753, 754, 755, 756, 757, 758, 759, 1021, 1022, 1023,
                                                                1024, 1112, 1157, 1160
<unique constraint definition> • 20, 26, 445, 529, 545, 547,
 548, 550, 1186                                                USER • 138, 176, 177, 180, 525, 529, 541, 544, 593, 596,
                                                                834, 901, 1095, 1096
<unique predicate> • 373, 402, 445, 1095
                                                               <user identifier> • 111, 114, 151, 152, 158, 901, 910
<unique specification> • 536, 538, 547, 1185
                                                               <user-defined cast definition> • 48, 99, 519, 705, 706, 790,
UNKNOWN • 138, 145, 150, 278
                                                                1063, 1118
UNNAMED • 137, 937, 939, 959, 960, 1168
                                                               <user-defined character set name> • 497, 498
UNNEST • 138, 236, 287, 288, 290, 303, 304
                                                               <user-defined ordering definition> • 99, 442, 443, 449,
<unqualified schema name> • 151, 153, 155, 156, 157,            519, 709, 711, 790, 1063, 1123
 179, 264, 520, 915, 1065, 1066, 1067, 1068
                                                               <user-defined representation> • 44, 634, 637, 638, 645,
<unquoted date string> • 144, 145, 211                          647
<unquoted interval string> • 144, 145, 208, 210, 214           <user-defined type body> • 634, 636
<unquoted time string> • 144, 145, 211, 212, 213, 214,         <user-defined type definition> • 40, 41, 44, 50, 83, 84, 99,
 1189                                                           166, 519, 634, 636, 644, 649, 651, 653, 654, 790, 1063,
<unquoted timestamp string> • 144, 145, 1189                    1112, 1193
<unsigned integer> • 144, 145, 149, 150, 162, 163, 164,        <user-defined type name> • 37, 38, 79, 84, 152, 154, 155,
 208, 209, 391, 467, 677, 1003, 1004, 1005, 1006, 1102,         158, 163, 166, 220, 224, 264, 416, 477, 478, 481, 523,
 1177                                                           529, 532, 592, 644, 683, 704, 763, 926, 994, 997, 999
<unsigned literal> • 143, 176                                  <user-defined type option> • 634
<unsigned numeric literal> • 134, 143, 144                     <user-defined type option list> • 634, 649, 1113
<unsigned value specification> • 174, 175, 176, 177, 178,      <user-defined type specification> • 416
 185, 332, 333, 336, 337, 338, 339                             <user-defined type value expression> • 237, 239, 257, 264
unterminated C string • 785, 1074




©ISO/IEC 2003 – All rights reserved                                                                          Index 1245
ISO/IEC 9075-2:2003 (E)




USER_DEFINED_TYPE_CATALOG • 137, 924, 926, 937,                VARCHAR • 138, 161, 163, 438, 1014, 1015, 1018, 1032,
 940, 942, 961                                                  1034, 1035
USER_DEFINED_TYPE_CODE • 137, 937, 939, 961                    VARYING • 11, 15, 94, 138, 161, 163, 164, 169, 173, 433,
USER_DEFINED_TYPE_NAME • 137, 924, 926, 937,                    438, 537, 782, 785, 787, 788, 924, 925, 941, 944, 945,
 940, 942, 961                                                  946, 949, 950, 971, 1014, 1016, 1018, 1033, 1042, 1043,
USER_DEFINED_TYPE_SCHEMA • 137, 924, 926, 937,                  1045, 1046, 1173
 940, 942, 961                                                 <vertical bar> • 19, 132, 133, 391, 392, 393, 394
USING • 138, 243, 246, 256, 257, 258, 312, 365, 442, 443,      VIEW • 137, 522, 579, 585, 589, 590, 591, 600, 601, 628,
 634, 839, 957, 963                                             708, 713, 762
<using argument> • 963, 965                                    <view column list> • 590, 591, 595, 596, 749, 750, 751
<using arguments> • 963, 965                                   <view column option> • 590, 594
using clause does not match dynamic parameter                  <view definition> • 51, 55, 56, 98, 154, 519, 590, 591, 592,
 specifications • 963, 964, 1075                                594, 595, 599, 749, 750, 751, 790, 1063, 1107, 1132,
using clause does not match target specifications • 968,        1190, 1192
 1075                                                          <view element> • 590
using clause required for dynamic parameters • 972, 978,       <view element list> • 590, 594
 1075                                                          <view specification> • 590
using clause required for result fields • 972, 1075
<using descriptor> • 957, 963                                                         —W—
<using input descriptor> • 963, 964                            warning • 91, 115, 208, 210, 263, 421, 422, 453, 489, 495,
                                                                509, 511, 513, 544, 567, 570, 599, 626, 631, 737, 763,
                        —V—                                     796, 822, 830, 833, 843, 847, 851, 907, 959, 1052, 1065,
                                                                1067, 1068, 1071, 1078
VALUE • 49, 66, 138, 176, 177, 180, 217, 278, 279, 547,
 548, 604, 611, 834, 837, 844, 936, 939, 1025, 1094,           WHEN • 138, 194, 197, 198, 199, 287, 288, 290, 367, 629,
 1125, 1160                                                     839
<value expression> • ?, 11, 55, 57, 58, 61, 63, 67, 74, 174,   <when operand> • 197, 198, 200, 948, 1094
 175, 185, 191, 194, 197, 198, 199, 201, 202, 203, 204,        <when operand list> • 197, 198, 200, 1094
 205, 220, 237, 238, 239, 258, 271, 280, 285, 291, 293,        WHENEVER • 138, 1003
 298, 313, 314, 319, 326, 328, 341, 343, 345, 346, 349,        WHERE • 73, 138, 230, 234, 304, 305, 315, 319, 368, 505,
 354, 365, 376, 377, 381, 445, 449, 474, 477, 478, 479,         513, 514, 546, 548, 604, 828, 831, 843, 846, 849, 982,
 505, 506, 507, 508, 509, 513, 514, 515, 516, 517, 536,         984, 986, 988, 1063, 1064, 1208, 1209
 647, 648, 707, 755, 756, 757, 759, 760, 792, 811, 839,        <where clause> • v, 72, 73, 188, 195, 300, 306, 319, 321,
 853, 854, 857, 869, 877, 886, 944, 946, 947, 948, 950,         327, 334, 344, 348, 354, 1099, 1187, 1190
 962, 1099, 1100, 1102, 1108, 1126, 1129, 1136, 1155,
                                                               <white space> • 135, 136, 139, 140
 1165, 1174, 1184, 1185, 1192
                                                               WHITESPACE • 392, 395
<value expression primary> • 174, 175, 185, 219, 222,
 228, 231, 237, 239, 241, 252, 267, 268, 272, 273, 283,        <width bucket bound 1> • 244, 250
 287, 288, 341, 342, 343, 578, 587, 597, 600, 731, 732,        <width bucket bound 2> • 244, 250
 733, 753, 754, 755, 756, 757, 759, 946, 1178, 1192,           <width bucket count> • 244, 246, 250
 1193                                                          <width bucket function> • 29, 243, 244, 246, 250, 251,
<value specification> • 176, 177, 178, 238, 258, 384, 390,      1142
 436, 437, 815, 831, 836, 849, 910, 911, 914, 915, 917,        <width bucket operand> • 244, 250
 918, 919, 920, 950, 951, 1049, 1053, 1095, 1102, 1150,
                                                               WIDTH_BUCKET • 138, 244
 1160, 1193
                                                               WINDOW • 138, 195, 331
VALUES • 55, 138, 298, 304, 366, 383, 513, 834, 835,
 836, 838, 839, 1093, 1208, 1209                               <window clause> • 59, 188, 191, 195, 300, 306, 331, 332,
                                                                333, 334, 335, 340, 344, 345, 1136, 1142, 1165
VAR_POP • 61, 62, 138, 505, 506, 507, 510, 515, 1143,
 1155                                                          <window definition> • 57, 331, 332, 333, 334
VAR_SAMP • 61, 62, 138, 505, 506, 507, 510, 515, 1143,         <window definition list> • 331
 1155                                                          <window frame between> • 331, 332, 333
                                                               <window frame bound> • 332




1246 Foundation (SQL/Foundation)                                                        ©ISO/IEC 2003 – All rights reserved
                                                                                           ISO/IEC 9075-2:2003 (E)




<window frame bound 1> • 332, 333, 335                                              —X—
<window frame bound 2> • 332, 333, 335
                                                              X • 144
<window frame clause> • 58, 331, 333, 335
<window frame exclusion> • 58, 331, 332, 339, 340, 1143
                                                                                    —Y—
<window frame extent> • 331, 333
                                                              YEAR • 32, 34, 138, 148, 166, 335, 336, 430, 434, 467,
<window frame following> • 332, 333, 336, 338, 339, 950
                                                               468, 942, 946
<window frame preceding> • 332, 333, 336, 337, 338, 339,
                                                              <year-month literal> • 145, 148, 469
 950
                                                              <years value> • 144, 145, 148, 469
<window frame start> • 331, 332, 333
<window frame units> • 331
<window function> • 57, 58, 59, 174, 175, 193, 194, 195,
                                                                                    —Z—
 196, 217, 239, 313, 319, 329, 333, 334, 343, 344, 346,       zero-length character string • 179, 255, 265, 1074, 1151,
 507, 508, 509, 1142                                           1152
<window function type> • 193, 195, 346                        ZONE • 12, 31, 32, 34, 137, 148, 162, 165, 167, 170, 211,
<window name> • 153, 159, 160, 193, 194, 195, 196, 331,        212, 213, 214, 245, 267, 269, 270, 275, 345, 440, 913,
 333, 1142                                                     942, 949, 951
<window name or specification> • 193, 195, 196, 1142
<window order clause> • 58, 331, 332, 333, 335, 338
<window partition clause> • 58, 331, 332, 333, 334, 445
<window partition column reference> • 331, 332, 334
<window partition column reference list> • 331
<window specification> • 58, 193, 195, 239, 331, 340, 950,
 1142
<window specification details> • 194, 331
WITH • 12, 31, 32, 34, 56, 71, 96, 112, 113, 114, 138, 148,
 159, 162, 165, 167, 170, 211, 212, 213, 214, 233, 245,
 267, 270, 275, 303, 304, 305, 306, 309, 310, 345, 351,
 363, 440, 514, 526, 528, 534, 590, 591, 592, 596, 597,
 598, 599, 635, 646, 647, 648, 705, 709, 714, 726, 728,
 731, 732, 733, 734, 735, 736, 737, 738, 741, 743, 744,
 745, 746, 747, 750, 751, 752, 753, 754, 756, 757, 760,
 761, 809, 810, 813, 831, 832, 837, 841, 843, 844, 848,
 849, 850, 851, 871, 879, 933, 942, 949, 951, 957, 958,
 959, 1067, 1116, 1130, 1131, 1138, 1159
with check option violation • 871, 880, 1067, 1079
<with clause> • 74, 351, 352, 360, 363, 1131
<with column list> • 351, 352, 360, 365
<with list> • 74, 351, 352, 360
<with list element> • 53, 54, 307, 351, 352, 355, 356, 360,
 361, 365, 368
<with or without data> • 526
<with or without time zone> • 162, 165, 171, 1098, 1189
WITHIN • 138, 506
<within group specification> • 191, 506, 508
WITHOUT • 12, 31, 32, 34, 138, 148, 162, 165, 170, 211,
 212, 213, 214, 267, 270, 275, 809, 810, 814, 951, 957,
 975, 1140
WORK • 137, 896, 898
WRITE • 137, 887, 888, 891




©ISO/IEC 2003 – All rights reserved                                                                      Index 1247
1 Possible problems with SQL/Foundation

Some possible problem have been observed with SQL/Foundation as defined in this document.
These are noted below. Further contributions to this list are welcome. Deletions from the list
(resulting from change proposals that correct the problems or from research indicating that the
problems do not, in fact, exist) are even more welcome. Other comments may appear in the same
list.
Because of the increasingly dynamic nature of this list (problems being removed because they are
solved, new problems being added), it has become rather confusing to have the problem numbers
automatically assigned by the document production facility. In order to reduce this confusion, I have
instead assigned "fixed" numbers to each possible problem. These numbers will not change from
printing to printing, but will instead develop "gaps" between numbers as problems are solved.




                                                    Possible problems with SQL/Foundation 1
Editor’s Notes for WG3:HBA-003 = H2-2003-305


Significant Possible Problems:
999 In the body of the Working Draft, I have occasionally highlighted a point that requires urgent
attention thus:
                                          **Editor’s Note**
Text of the problem.

These items are indexed under "**Editor’s Note**".
703 The following Possible Problem has been noted:
    Severity: Major Technical
    Reference: P02, SQL/Foundation, Subclause 4.17, "Integrity constraints"
    Note at: None.
    Source: WG3:BBN-139/X3H2-98-363
    Possible Problem:
    It seems that SQL3’s specification of deferrable constraints is ill-specified. Referential con-
    straints are based on the notion of marking rows for deletion before the rows are effectively
    deleted at the end of the SQL statement. This is necessary because updates cascaded by refer-
    ential constraints need to be ‘‘propagated’’ through rows marked for deletion in order to avoid
    anomalies (non deterministic behavior). If a referential constraint is deferred, then rows that
    need to be kept around for the execution of referential constraints will not be present at the end
    of the transaction (or when the referential constraint is turned to immediate). These rows will
    be deleted at the end of the SQL statements. So, it is unclear how referential constraints are
    checked in these cases (e.g., are we supposed to maintain multiple versions of the database and
    check the constraints against those versions? If so, how do the updates are ˆpropagated˜ to the
    current version of the database?).
    Another problem with deferrable constraints is that stored procedures and triggers can never
    rely on the existence of a consistent database during their execution because the application
    that caused the in-vocation of the stored procedure and/or trigger could have deferred the
    checking of certain constraints prior to the invocation of the procedure or trigger. (Please
    note that this has also a major impact to the implementation of such concepts because plans
    generated by optimizers (e.g., the exploitation of a unique index) can be invalidated by deferring
    such constraints.)
    Also it is not clear to me that deferrable constraints and triggers work smoothly. First, BEFORE
    triggers execute BEFORE the SQL statement that activates them. However, the BEFORE
    execution cannot be guaranteed if referential constraints are deferred because the execution of
    the BEFORE trigger needs to be deferred as well. Second, if the BEFORE trigger is modifying
    the values of transition variables such that they can be inserted/updated with correct values
    in the database, what will happen with such values if the BEFORE trigger executes after
    the database has been updated? Third, triggers are executed in a well defined order. This is
    important to guarantee that changes to the database are done in a deterministic manner. If
    constraints are deferred, then one may end up deferring the execution of several instances
    of the same trigger for which there is no well defined order of execution. This will lead to
    non-deterministic behavior in the database.
    Proposed Solution:
    None provided with comment.

770 The following Possible Problem has been noted:
    Severity: Major Technical
    Reference: P02, SQL/Foundation, Subclause 20.1, "<embedded SQL host program>"
    Note at:



2   Editor’s Notes for ISO-ANSI working draft Database Language SQL (SQL/Foundation)
                                                Editor’s Notes for WG3:HBA-003 = H2-2003-305


   Source: WG3:BHX-166
   Possible Problem:
   Since multiple SQL data types map onto the same C data type in Table 17, "Data type corre-
   spondences for C", in Subclause 13.6, "Data type correspondences", SR22) of Subclause 20.1,
   "<embedded SQL host program>", cannot correctly identify the corresponding SQL data type of
   a given C data type.
   The problem identified is caused by Table 17, "Data type correspondences for C", in Subclause
   13.6, "Data type correspondences", that defines the mapping of C data types onto SQL data
   types. The table maps more than one SQL data type onto the same C data type. Hence, when
   the mapping table is used in reverse, a single C data types maps onto more than one SQL data
   type. Now, in case of syntax rule 22) of Subclause 20.1, "<embedded SQL host program>", the
   SQL data type has to be determined while an <embedded SQL host program> is processed.
   Thus, the SQL data types can only be derived syntactically from the C data types based on
   Table 17, "Data type correspondences for C", in Subclause 13.6, "Data type correspondences".
   The solution of the problems would require a change of Table 17, "Data type correspondences for
   C", in Subclause 13.6, "Data type correspondences", such that a single SQL data type maps onto
   a single C data type. There might be an alternative solution which accesses the definition of a
   routine to find out the SQL data types rather than using the mentioned table. Both solutions
   result in major changes of the document and might also lead to compatibility issue. Hence, a
   real solution of the identified problems cannot be developed in the given timeframe.
   Proposed Solution:
   None provided with comment.

772 The following Possible Problem has been noted:
   Severity: Major Technical
   Reference: P02, SQL/Foundation, No particular location
   Note at: None.
   Source: WG3:BHX-118
   Possible Problem:
   The proposal accepted in WG3:BHX-118 creates a new problem. It makes is possible for an
   externally-invoked procedure invoked directly from the SQL-client to define a WITH RETURN
   cursor that is left open when the externally-invoked procedure returns to the SQL-client. This
   is at best meaningless, since the SQL-client has no way to do anything with that cursor, and at
   worst causes a problem with resource "leaks" related to unclosed cursors.
   Proposed Solution:
   None provided with comment.

820 The following Possible Problem has been noted:
   Severity: Major Technical
   Reference: P02, SQL/Foundation, Subclause 13.4, "Calls to an <externally-invoked procedure>"
   Note at: None.
   Source: WG3:PER-176/H2-2001-???
   Possible Problem:
   The rules for passing large objects confuse the host environment with the SQL environment. For
   example, GR2)g) uses dot notation to indicate qualification to reference a field of a C variable or
   COBOL variable. There is a similar problem in GR3)g). CD1/2000 ballot GBR-P02-335 observed
   that GR2)g)ii) contains the text
      SUBSTRING (PN.PN-DATA FROM 1 FOR PN.PN-LENGTH)



                                                    Possible problems with SQL/Foundation 3
Editor’s Notes for WG3:HBA-003 = H2-2003-305


    and commented "surely the langauge of this statement is SQL rather than COBOL? If so, then
    surely <host parameter name>s should be preceded by <colon>?"
    Proposed Solution:
    None provided with comment.

857 The following Possible Problem has been noted:
    Severity: Major Technical
    Reference: P02, SQL/Foundation, Subclause 10.4, "<routine invocation>"
    Note at: None.
    Source: DCOR/2002, USA-STC-031
    Possible Problem:
    There is no definition of how to pass booleans or LOBs to external programs. More generally,
    the question of how to convert any SQL type to a host language type at the interface to an
    SQL-invoked routine has never been addressed. Probably it was assumed that the same mech-
    anism as was already defined for module language and embedded language applied, but in fact
    there are no rules to back up this assumption. If this assumption is correct, then the rules in
    Subclause 13.4, "Calls to an <externally-invoked procedure>", are probably appropriate. Per-
    haps they should be placed in a separate subclause so they can be referenced by both <routine
    invocation> and also <externally invoked procedure>. See also paper WG3:PER-176.
    Proposed Solution:
    None provided with comment.

865 The following Possible Problem has been noted:
    Severity: Major Technical
    Reference: P02, SQL/Foundation, Subclause 5.4, "Names and identifiers"
    Note at: None.
    Source: WG3:DRS-094
    Possible Problem:
    Consider General Rule 32), viz:
       32) The value of an <extended statement name> identifies a statement prepared by the
       execution of a <prepare statement>. If a <scope option> of GLOBAL is specified, then the
       scope of the <extended statement name> is the current SQL-session. If a <scope option> of
       LOCAL is specified or implicit, then the scope of the <extended statement name> is further
       restricted to the <SQL-client module definition> in which the <extended statement name>
       appears.
    Consider the following (assuming <SQL prefix>s and <SQL terminator>s to taste:
       In host language program P1:
       DECLARE AUTHORIZATION Mike SCHEMA Schema1
       CREATE PROCEDURE MyProc1
       PREPARE LOCAL :HostVariable1
       FROM :StatementVariable1
       In host language program P2:
       DECLARE AUTHORIZATION Mary SCHEMA Schema1
       CALL MyProc1
    Let us suppose MyProc1 was created successfully. What is the effect of calling it from a different
    program? Does it fail? If so, why, and why does it have to?




4   Editor’s Notes for ISO-ANSI working draft Database Language SQL (SQL/Foundation)
                                               Editor’s Notes for WG3:HBA-003 = H2-2003-305


   As the first few words of the quoted text acknowledge, it is the value of :HostVariable1 at
   prepare time that identifies a prepared statement, so that one might expect the scope to local to
   the SQL-client module from which MyProc1 is (ultimately) invoked rather than that in whose
   <SQL-client module definition> the <prepare statement> is contained.
   Proposed Solution:
   None provided with comment.

869 The following Possible Problem has been noted:
   Severity: Major Technical
   Reference: P02, SQL/Foundation, Subclause 11.4, "<column definition>"
   Note at: None.
   Source: WG3:DRS-091
   Possible Problem:
   If the <data type> of the <column definition> is a <reference type>, SR 16) replaces <reference
   scope check> with a <references specification> adopting <reference scope action> as <referential
   action>. Default is NO ACTION, according to SR 15). There is no restriction to <referential
   action> in the Syntax Rules. However, GR 4)f) implies that it should be RESTRICT or SET
   NULL (and not even NO ACTION). See also Subclause 4.13 "Columns, fields, and attributes",
   which suggests NO ACTION and SET NULL as valid behavior.
   Proposed Solution:
   None provided with comment.

877 The following Possible Problem has been noted:
   Severity: Major Technical
   Reference: P02, SQL/Foundation, Subclause 6.1, "<data type>"
   Note at: None.
   Source: WG3:DRS-089
   Possible Problem:
   SR 34) requires that the table T identified in the <scope clause> of a <reference type> must
   exist. However, the Access Rules do not require any applicable privileges on T. This has several
   implications:

   •   The user defining the scoped reference type cannot necessarily see T in the Information
       Schema.

   •  Depending schema objects (containing a scoped reference type) cannot be treated as usual
      by revoking such privileges when T is dropped.
   Proposed Solution:
   None provided with comment.

878 The following Possible Problem has been noted:
   Severity: Major Technical
   Reference: P02, SQL/Foundation, Subclause 6.1, "<data type>"
   Note at: None.
   Source: WG3:DRS-089
   Possible Problem:




                                                   Possible problems with SQL/Foundation 5
Editor’s Notes for WG3:HBA-003 = H2-2003-305


    Using <scope clause> as part of a <reference type> might collide with <scope clause>s provided
    in a <table definition> or <view definition> for a typed table. Since there are no restraining
    Syntax Rules, it seems to be possible to specify both, scope for an attribute of a structured
    type that is used to define a typed table, and scope on the resulting column of this table, using
    additional <column option>s. It is not really clear:

    •   whether column options replace or just temporarily override the <data type> scope (which is
        part of a <user-defined type definition>),

    •   whether one can only drop scope of a base table column defined by a column option in the
        table definition, or also the scope provided by the data type of the corresponding attribute of
        the table’s underlying structured type,

    •   whether the data type’s scope should be available again if a replacing/overriding scope of a
        column option is dropped.
    Note: In a typed table definition, the attribute descriptor of the underlying structured type is
    the basis for defining a corresponding column descriptor (Subclause 11.3 <table definition>, SR
    10) and 11)). However, the column descriptor can be changed independently afterwards using
    <alter table statement>s.
    Proposed Solution:
    None provided with comment.

879 The following Possible Problem has been noted:
    Severity: Major Technical
    Reference: P02, SQL/Foundation, Subclause 11.3, "<table definition>"
    Note at: None.
    Source: WG3:DRS-089
    Possible Problem:
    Subclauses 6.2 <field definition>, 11.4 <column definition> and 11.42 <attribute definition> all
    require <reference scope check> to be specified for scoped reference types. However, if <scope
    clause> is part of the <column option list> of a typed table definition, there is no way to specify
    <reference scope check>.
    Proposed Solution:
    None provided with comment.

880 The following Possible Problem has been noted:
    Severity: Major Technical
    Reference: P02, SQL/Foundation, Subclause 11.4, "<column definition>"
    Note at: None.
    Source: WG3:DRS-089
    Possible Problem:
    SR 18)e) specifies how a field whose type is a reference type and which is deeply nested within a
    column´s data type can be addressed when a reference scope check for this field is transformed
    into an implicit check constraint. SR 18) tries to construct one check constraint for each such
    field descriptor. However, the use of <array element reference>, defined in Subclause 6.23,
    implies that there must be one check constraint for each "path" through elements of an array.
    Consider, for instance, a column col1 of data type
    ROW ( f1 REF(ty1) SCOPE t1
    REFERENCES ARE CHECKED ON DELETE NO ACTION ) ARRAY[10]




6   Editor’s Notes for ISO-ANSI working draft Database Language SQL (SQL/Foundation)
                                               Editor’s Notes for WG3:HBA-003 = H2-2003-305


   which would lead to 10 check constraints of the form
   CHECK ( col1[i].f1 in ( SELECT selfRefCol FROM T1 ) )
   where i goes from 1 to 10. Apart from this rather strange semantics, there would also be the
   problem of actual cardinality vs. maximum cardinality of such an array:

   •   If the constraints are to be defined at table definition time using an array’s maximum
       cardinality, checking the constraint would lead to an exception according to Subclause 6.23
       GR 2)b), if the actual cardinality of an array at checking time is smaller than the maximum
       cardinality.

   •   On the other hand, the constraints cannot reflect the actual cardinality, because arrays in
       different rows of the table can have a different cardinality.
   A similar problem arises with deeply nested attributes, addressed in SR 19). A better solution
   for checking deeply nested references might be achieved by UNNEST-ing intervening collections.
   This would also enable multisets to be used in such a "path" to a nested reference (see Language
   Opportunity 899).
   Proposed Solution:
   None provided with comment.

881 The following Possible Problem has been noted:
   Severity: Major Technical
   Reference: P02, SQL/Foundation, Subclause 11.15, "<add column scope clause>"
   Note at: None.
   Source: WG3:DRS-089
   Possible Problem:
   Subclause 11.4 <column definition>, SR 12) requires that a <reference scope check> must
   be specified whenever a reference type in a <column definition> contains a <scope clause>.
   Therefore, this should be reflected in Subclause 11.15 as well, e. g. by changing the Format to:
   <add column scope clause> ::=
   ADD <scope clause> <reference scope check>
   and adding appropriate Syntax and General Rules. See Subclause 11.4 SR 12) to 16) and GR
   4)f) for reference.
   Proposed Solution:
   None provided with comment.

882 The following Possible Problem has been noted:
   Severity: Major Technical
   Reference: P02, SQL/Foundation, Subclause 11.21, "<drop table statement>"
   Note at: None.
   Source: WG3:DRS-089
   Possible Problem:
   There is no Syntax Rule checking whether T (the table to be dropped) is used in the scope of
   a reference type generally but not directly contained in the data type descriptor of a column of
   a table other than T. An example is a table column whose data type is a row type with a field
   whose type is a reference type. It follows that such tables are dropped according to GR 2) even
   if RESTRICT is specified. See Language Opportunity 903 for reference.
   Note: This problem is similar to possible problem Possible Problem 887.
   Proposed Solution:


                                                   Possible problems with SQL/Foundation 7
Editor’s Notes for WG3:HBA-003 = H2-2003-305


    None provided with comment.

883 The following Possible Problem has been noted:
    Severity: Major Technical
    Reference: P02, SQL/Foundation, Subclause 11.21, "<drop table statement>"
    Note at: None.
    Source: WG3:DRS-089
    Possible Problem:
    Let RT be a reference type with scope clause SC, and T the table that SC refers to. Let RT be
    the declared type of an attribute A of a structured type ST. It is not specified what effect a <drop
    table statement> that causes T to be dropped has on ST. In the current version of the standard,
    <scope clause>s of attributes cannot be changed or dropped independently from the attribute.
    This would imply that at least A has to be dropped from ST as well, which in turn affects all
    tables based on ST.
    Note: This problem is similar to possible problem Possible Problem 888.
    Proposed Solution:
    None provided with comment.

884 The following Possible Problem has been noted:
    Severity: Major Technical
    Reference: P02, SQL/Foundation, Subclause 11.21, "<drop table statement>"
    Note at: None.
    Source: WG3:DRS-089
    Possible Problem:
    Let RT be a reference type with scope clause SC, and T the table that SC refers to. Let RT be
    the declared type of a column C of some other table TC. It is not adequately specified what effect
    dropping T has on the descriptor of C: GR 4) indirectly drops a constraint implicitly created if C
    was defined with REFERENCES ARE CHECKED.
    However, there should at least be another GR leading to the implicit execution of an <alter table
    statement> for TC dropping the scope of C if TC is a base table. This does not work either if TC
    is a view.
    Note: The <revoke statement> of GR 4) does not (and should not!) apply because no privilege
    is necessary for <scope clause> according to Subclause 6.1 <data type>. Note also that this
    problem applies to both regular and typed tables depending on T.
    Note: This problem is similar to possible problem Possible Problem 889.
    Proposed Solution:
    None provided with comment.

885 The following Possible Problem has been noted:
    Severity: Major Technical
    Reference: P02, SQL/Foundation, Subclause 11.21, "<drop table statement>"
    Note at: None.
    Source: WG3:DRS-089
    Possible Problem:
    If RESTRICT is specified, SR 6)f) prevents dropping of the table when it is in the scope of the
    declared type of an SQL parameter of an SQL-invoked routine. However, no General Rule
    covers this case for CASCADE.



8   Editor’s Notes for ISO-ANSI working draft Database Language SQL (SQL/Foundation)
                                              Editor’s Notes for WG3:HBA-003 = H2-2003-305


   Note: The <revoke statement> of GR 4) does not apply because no privilege is necessary for
   <scope clause> according to Subclause 6.1 <data type>.
   Note: This problem is similar to possible problem Possible Problem 890.
   Proposed Solution:
   None provided with comment.

886 The following Possible Problem has been noted:
   Severity: Major Technical
   Reference: P02, SQL/Foundation, Subclause 11.23, "<drop view statement>"
   Note at: None.
   Source: WG3:DRS-089
   Possible Problem:
   Let V be the view to be dropped, A the authorization identifier that owns the schema containing
   V. GR 2) revokes privileges on subtables of V from A. This includes V as well, because it is a
   subtable of itself.
   However, this is a rather strange rule: The usual way to drop the proper subviews of V would
   be to revoke privileges on V from A: The resulting loss of the UNDER privilege would cause the
   dropping of the proper subviews.
   Suggested solution: Bring the Syntax and General Rules in line with those of Subclause 11.21
   <drop table statement>.
   Proposed Solution:
   None provided with comment.

887 The following Possible Problem has been noted:
   Severity: Major Technical
   Reference: P02, SQL/Foundation, Subclause 11.23, "<drop view statement>"
   Note at: None.
   Source: WG3:DRS-089
   Possible Problem:
   There is no Syntax Rule checking whether V (the view to be dropped) is used in the scope of a
   reference type generally but not directly contained in the data type descriptor of a column of
   a table other than V. An example is a table column whose data type is a row type with a field
   whose type is a reference type. It follows that such tables are dropped according to GR 1) even
   if RESTRICT is specified.
   Note: This problem is similar to possible problem Possible Problem 882.
   Proposed Solution:
   None provided with comment.

888 The following Possible Problem has been noted:
   Severity: Major Technical
   Reference: P02, SQL/Foundation, Subclause 11.23, "<drop view statement>"
   Note at: None.
   Source: WG3:DRS-089
   Possible Problem:




                                                  Possible problems with SQL/Foundation 9
Editor’s Notes for WG3:HBA-003 = H2-2003-305


     Let RT be a reference type with scope clause SC, and V the view that SC refers to. Let RT be
     the declared type of an attribute A of a structured type ST. It is not specified what effect a <drop
     view statement> that causes V to be dropped has on ST. In the current version of the standard,
     <scope clause>s of attributes cannot be changed or dropped independently from the attribute.
     This would imply that at least A has to be dropped from ST as well, which in turn affects all
     tables based on ST.
     Note: This problem is similar to possible problem Possible Problem 883.
     Proposed Solution:
     None provided with comment.

889 The following Possible Problem has been noted:
     Severity: Major Technical
     Reference: P02, SQL/Foundation, Subclause 11.23, "<drop view statement>"
     Note at: None.
     Source: WG3:DRS-089
     Possible Problem:
     Let RT be a reference type with scope clause SC, and V the view that SC refers to. Let RT
     be the declared type of a column C of some other table TC. It is not adequately specified what
     effect dropping V has on the descriptor of C: There should at least be another GR leading to the
     implicit execution of an <alter table statement> for TC dropping the scope of C if TC is a base
     table. This does not work either if TC is a view.
     Note: This problem is similar to possible problem Possible Problem 884.
     Proposed Solution:
     None provided with comment.

890 The following Possible Problem has been noted:
     Severity: Major Technical
     Reference: P02, SQL/Foundation, Subclause 11.23, "<drop view statement>"
     Note at: None.
     Source: WG3:DRS-089
     Possible Problem:
     If RESTRICT is specified, SR 4)e) prevents dropping of the table when it is in the scope of
     the declared type of an SQL parameter of an SQL-invoked routine. However, no General Rule
     covers this case for CASCADE.
     Note: This problem is similar to possible problem Possible Problem 885.
     Proposed Solution:
     None provided with comment.

919 The following Possible Problem has been noted:
     Severity: Major Technical
     Reference: P02, SQL/Foundation, Subclause 16.3, "<set constraints mode statement>"
     Note at: None.
     Source: WG3:ZSH-031R3 = H2-2002-_ __
     Possible Problem:




10    Editor’s Notes for ISO-ANSI working draft Database Language SQL (SQL/Foundation)
                                                Editor’s Notes for WG3:HBA-003 = H2-2003-305


   The subclause is silent with regard to the checking of constraints when the constraints mode
   is set to IMMEDIATE. Turning to Subclause 16.6, "<commit statement>", we see that there
   is an expectation that SET CONSTRAINTS ALL IMMEDIATE has the effect of checking all
   constraints and that this effect takes place between GR5) and GR6) of that subclause (as
   opposed to any vague notion of "at the end of the statement"). The implications for referential
   constraints that specify referential actions are not clear, especially in the case of referential
   actions that are triggering events.
   Proposed Solution:
   None provided with comment.

924 The following Possible Problem has been noted:
   Severity: Major Technical
   Reference: P02, SQL/Foundation, Subclause 4.37, "SQL-sessions"
   Note at: None.
   Source: WG3:ZSH-037R1/H2-2003-???
   Possible Problem:
   WG3:FRA-045r4 proposed no changes to what is now WG3:ZSH-013, Subclause 4.37, "SQL-
   session". However, according to WG3:FRA-045r4, Section 2.1, "Authorization stack":
      There is a stack of SQL-session contexts. There is one cell on this stack when the SQL-
      session begins. An additional SQL-session context is pushed on the stack for each <routine
      invocation>, and is removed when the <routine invocation> completes execution.
   There is no reference to this anywhere in this subclause, although there are various statements
   of the form "An SQL-session has a ...".
   Moreover, the list of SQL-session contents is incorrect and incomplete. The term "current
   SQL-session identifier" is listed, where the meaning of "current" is indicated in the following
   NOTE (55 in WG3: ZSH-013) and evidently used to distinguish the "current" SQL-session from
   dormant SQL-sessions. It is therefore probably intended to refer to the SQL-session identifier
   of the currently active (as opposed to dormant) SQL-session. If this surmise is correct, then the
   "current SQL-session user identifier" is missing.
   There is no reference to the authorization stack, though the two terms used to refer to the
   components of the only visible cell of that stack are mentioned.
   Proposed Solution:
   None provided with comment.

925 The following Possible Problem has been noted:
   Severity: Major Technical
   Reference: P02, SQL/Foundation, Subclause 4.37.4, "Execution contexts"
   Note at: None.
   Source: WG3:ZSH-037R1/H2-2003-???
   Possible Problem:
   This subclause contains the statement:
      There is always a statement execution context, a routine execution context, and zero or more
      trigger execution contexts.
   There is a significant and unnecessary inconsistency between the descriptions of routine execu-
   tion contexts and trigger execution contexts.




                                                  Possible problems with SQL/Foundation 11
Editor’s Notes for WG3:HBA-003 = H2-2003-305


     Consider what happens if an SQL-invoked routine R1 invokes another, R2. Are there now one
     or more than one routine execution contexts? The answer is clearly there is one in each of
     two levels of the stack of SQL-session contexts, as is made clear by Subclause 10.4, "<routine
     invocation>". Whether there is a routine execution context when no routine has been invoked
     is debatable: it could be (and indeed is) said that there is an empty one; or it could be said
     that there is none. In which case, it would be true to say that "there are zero or more routine
     execution contexts", as is said for trigger execution contexts.
     Consider now how it arises that there is more than one trigger execution context. The only case
     that springs to mind is that of the triggered action of a trigger T1, causing another trigger T2
     to fire. In this case, each trigger will have a trigger execution context. However, it seems fairly
     clear that the triggered action of T2 cannot access the state changes in the trigger execution
     context of T1. Therefore, to say that there are, during the execution of T2, two trigger execution
     contexts, although true in a sense, is unhelpful.
     Moreover, we seem to be saying that these two trigger execution contexts are in the same SQL-
     session context; unless, of course, T1 invokes a routine that causes T2 to fire, in which case
     a new SQL-session context is created, containing a new routine execution context. However,
     whether or not it contains, when created, the trigger execution context of T1, we are unable to
     discover.
     Proposed Solution:
     None provided with comment.

926 The following Possible Problem has been noted:
     Severity: Major Technical
     Reference: P02, SQL/Foundation, Subclause 10.4, "<routine invocation>"
     Note at: None.
     Source: WG3:ZSH-037R1/H2-2003-???
     Possible Problem:
     In WG3:DRS-013, General Rule 5) of this subclause says:
         5) Preserve the current SQL-session context CSC and create a new SQL-session context RSC
         derived from CSC as follows: ...
     This appears to specify what happens to every element of an SQL-session context when a new
     SQL-session context is created. However, it does not say what happens to:

     — The zero or more trigger execution contexts

     — The values of all valid locators

     — The text defining the SQL-path (which in any case seems somewhat redundant, since the
       SQL-path is taken care of)

     — The SQL-session collations, if any

     — The text defining the default transform group name

     — The text defining the user-defined type name-transform group name pair for each user-
       defined type explicitly set by the user
     It would at least be clearer if it said:
        5) Preserve the current SQL-session context CSC and create a new SQL-session context RSC
        as follows:
     Proposed Solution:


12    Editor’s Notes for ISO-ANSI working draft Database Language SQL (SQL/Foundation)
                                                Editor’s Notes for WG3:HBA-003 = H2-2003-305


   None provided with comment.

927 The following Possible Problem has been noted:
   Severity: Minor Technical
   Reference: P02, SQL/Foundation, Subclause 18.3, "<set role statement>"
   Note at: None.
   Source: WG3:ZSH-037R1/H2-2003-???
   Possible Problem:
   In ZSH-013, Subclause 18.3, "<set role statement>", General Rule 5) says:
      5) The role name in the latest cell of the authorization stack of the current SQL-session
      context is set to
      Case:
          a) If NONE is specified, then the null value.
          b) Otherwise, V.
   If this is the only <SQL procedure statement> in an externally-invoked procedure, then consider
   Subclause 13.1, "<SQL-client module definition>", General Rule 5), which says:
      5) Upon completion of an execution of an <externally-invoked procedure> contained in an
      <SQL-client module definition>, the latest pair of authorization identifiers in the authoriza-
      tion stack is removed.
   Thus it appears that a newly set role name is immediately discarded, except in the case where
   it is contained in a <compound statement>, and is followed by at least one <SQL procedure
   statement>.
   BEGIN
     SET ROLE ’admin’;
     DELETE T1;
   END
   According to GR4 of Subclause 13.1, "<SQL-client module definition>", the incipient execution of
   this statement causes a "new pair of authorization identifiers [to be] appended to the authoriza-
   tion stack". We assume this "new pair" to constitute what is elsewhere called "the latest cell" in
   that stack.
   By the time the SET ROLE statement is executed, the cell created under that GR4) is still the
   latest cell. At least, we can find no contrary indication anywhere in the GRs of Subclause 13.5,
   "<SQL procedure statement>", or, in PSM, those of Subclause 13.1, "<compound statement>".
   So, when we next get to GR5) of Subclause 13.1, "<SQL-client module definition>", deleting the
   latest cell still deletes the one in which the role name is set to ’admin’. Thus, the effect of the
   SET ROLE is undone as soon as we reach the end of the <compound statement>. However, it
   was at least in effect for the DELETE statement!
   But now consider this <externally-invoked procedure>:
   BEGIN
     BEGIN
       SET ROLE ’admin’;
       DELETE T1;
     END;
     DELETE T2;
   END
   Now the role is in effect for both DELETE statements. So it can have an effect on statements
   that are outside the one immediately containing it.


                                                   Possible problems with SQL/Foundation 13
Editor’s Notes for WG3:HBA-003 = H2-2003-305


     In any case, Clause 18, "Session management", is entitled "Session management". It seems that
     the one thing SET ROLE has no effect on is the SQL-session (seen as a sequence of executions
     of externally-invoked procedures).
     As evidence that this state of affairs appears to be intended, we quote the following text (slightly
     rearranged) from WG3:FRA-045r4
        10. The <set role statement> changes the role name on top of the authorization stack in the
        latest SQL-session context, but not the user name.
        8. Upon completion of an <externally-invoked procedure>, the cell of the authorization stack
        that was pushed for that invocation of the <externally invoked procedure> is removed.
     Thus the present text appears faithfully to implement the stated intentions of the authors of
     WG3:FRA-045.
     And we are perplexed that the difference in behaviour between <set role statement> and <set
     session user identifier statement> seems greater than one might expect, a change made by
     WG3:FRA-045r4 without explanation.
     Proposed Solution:
     None provided with comment.

928 The following Possible Problem has been noted:
     Severity: Major Technical
     Reference: P02, SQL/Foundation, Subclause 4.34.1.1, "SQL-session authorization identifiers",
     Subclause 18.2, "<set session user identifier statement>", and Subclause 18.3, "<set role state-
     ment>"
     Note at: None.
     Source: WG3:ZSH-037R1/H2-2003-???
     Possible Problem:
     Subclauses 4.34.1.1, "SQL-session authorization identifiers" includes the paragraph:
        The <set session user identifier statement> changes the value of the current SQL-session
        user identifier. The <set role statement> changes the value of the current role name for the
        current SQL-session.
     While the second sentence is accurate, the first is a serious understatement: Subclause 18.2,
     "<set session user identifier statement>", General Rules 6), 7) and 8) are:
        6) The SQL-session user identifier of the current SQL-session context is set to V.
        7) The user identifier in every cell of the authorization stack of the current SQL-session
        context is set to V.
        8) The role name in every cell of the authorization stack of the current SQL-session context
        is set to the null value.
     WG3:FRA-045r4 introduced this inconsistency, with no explanation for the General Rules of
     Subclause 18.2, "<set session user identifier statement>".
     Proposed Solution:
     None provided with comment.




14    Editor’s Notes for ISO-ANSI working draft Database Language SQL (SQL/Foundation)
                                             Editor’s Notes for WG3:HBA-003 = H2-2003-305


Minor Problems and Wordsmithing Candidates:
634 The following Possible Problem has been noted:
   Severity: Minor Technical
   Reference: P02, SQL/Foundation, Subclause 3.1, "Definitions"
   Note at: None.
   Source: DBL:LGW-152/X3H2-97-352 (also DBL:LGW-023/X3H2-97-044, SEQ# 1, JAPAN-F-015)
   Possible Problem:
   The current SQL3 specification depends on the first DIS of ISO/IEC 10646, UCS. UCS had been
   completely changed from the first DIS. Some of the definitions taken from the first DIS had
   been dropped from ISO/IEC 10646. Some of the definitions found in the CD are different from
   SC2 definitions found in ISO/IEC 10646 and ISO/IEC 2022.
   Proposed Solution:
   None provided with comment.

769 The following Possible Problem has been noted:
   Severity: Minor Technical
   Reference: P02, SQL/Foundation, Subclause 14.5, "<select statement: single row>"
   Note at: None.
   Source: WG3:BHX-143
   Possible Problem:
   <select statement: single row> appears to have no counterpart of SR6)a) of Subclause 14.3,
   "<fetch statement>". It has instead SR2), requiring the number of targets to equal the num-
   ber of columns in the result of the query. Is there a good reason for this apparent lack of
   parallelism?
   Proposed Solution:
   None provided with comment.

844 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02, SQL/Foundation, Subclause 13.3, "<externally-invoked procedure>"
   Note at: None.
   Source: WG3:YYJ-034 = H2-2001-_ __
   Possible Problem:
   The use of savepoint levels, introduced by WG3:PER-061 and extended by WG3:YYJ-034, still
   does not cover the case of externally-invoked procedures.
   Proposed Solution:
   None provided with comment.

845 The following Language Opportunity has been noted:
   Severity: Minor Technical
   Reference: P02, SQL/Foundation, Subclause 4.10, "Collection types"
   Note at: None.
   Source: WG3:YYJ-016 (CAN-P02-001, USA-P02-005)
   Language Opportunity:
   The next edition of the SQL standard should standardize the syntax and semantics of one or
   more additional collection types.
   Proposed Solution:



                                                Possible problems with SQL/Foundation 15
Editor’s Notes for WG3:HBA-003 = H2-2003-305


     None provided with comment.

846 The following Language Opportunity has been noted:
     Severity: Minor Technical
     Reference: P02, SQL/Foundation, Subclause 4.27, "SQL-invoked routines"
     Note at: None.
     Source: WG3:YYJ-016 (USA-P02-014)
     Language Opportunity:
     The next edition of the SQL standard should allow the use of dynamic SQL statements inside
     SQL-invoked routines.
     Proposed Solution:
     None provided with comment.

847 The following Language Opportunity has been noted:
     Severity: Minor Technical
     Reference: P02, SQL/Foundation, Subclause 4.27, "SQL-invoked routines"
     Note at: None.
     Source: WG3:YYJ-016 (USA-P02-014)
     Language Opportunity:
     The next edition of the SQL standard should allow the use of SQL schema statements inside
     SQL-invoked routines.
     Proposed Solution:
     None provided with comment.

848 The following Language Opportunity has been noted:
     Severity: Minor Technical
     Reference: P02, SQL/Foundation, No particular location
     Note at: None.
     Source: WG3:YYJ-016 (USA-P02-113)
     Language Opportunity:
     A number of DBMS products support materialized views whose results are stored in the
     database and subsequently maintained by the system whenever any of the generally under-
     lying base tables of the views changes. Materialized views play an important role in offering
     significant performance gains for complex queries, especially in Data Warehouse applications.
     The next edition of the SQL standard should standardize the syntax and semantics of material-
     ized views.
     Proposed Solution:
     None provided with comment.

849 The following Language Opportunity has been noted:
     Severity: Minor Technical
     Reference: P02, SQL/Foundation, No particular location
     Note at: None.
     Source: WG3:YYJ-016 (USA-P02-114)
     Language Opportunity:




16    Editor’s Notes for ISO-ANSI working draft Database Language SQL (SQL/Foundation)
                                                 Editor’s Notes for WG3:HBA-003 = H2-2003-305


   In [FoundationCD], it is possible write insert and update statements where the value of one
   or more fields are not immediately known by the updater. This includes columns populated by
   subqueries, functions, system values, etc. In some cases, the updater needs to know the values
   after the insert/update has occurred. In some cases, this can be accomplished by requerying the
   data after the update. In other cases, the updater cannot easily requery the data. This includes
   cases such as when a function is used to generate the primary key. For example:
      Insert into T1 ( c1 , c2 , c3 )
      values ( fn_generate_pk(’T1’) , :var 2 , :var 3 );
   It would be useful to have a mechanism that allows an insert or update statement to return the
   inserted or updated rows in a singleton select or a cursor.
   Proposed Solution:
   None provided with comment.

850 The following Language Opportunity has been noted:
   Severity: Minor Technical
   Reference: P02, SQL/Foundation, No particular location
   Note at: None.
   Source: WG3:YYJ-016 (USA-P02-117)
   Language Opportunity:
   SQL should be enhanced to support EJB Query Language.
   Information about the EJB Query Language can be found the public document available at:
   http://java.sun.com/aboutJava/communityprocess/first/jsr019/ejb2-finaldraft.pdf
   particularly in Chapter 10.
   Proposed Solution:
   None provided with comment.

862 The following Possible Problem has been noted:
   Severity: Minor Technical
   Reference: P02, SQL/Foundation, Subclause 16.2, "<set transaction statement>"
   Note at: None.
   Source: WG3:ICN-045 = H2-2002-_ __
   Possible Problem:
   The standard does not specify a maximum for <number of conditions>. Presumably there is an
   implementation-defined or -dependent maximum value of <number of conditions>. For example,
   we could add the following GR after GR 2):
   2) If <number of conditions> exceeds an implementation-dependent maximum number of
   conditions, then an exception condition is raised: invalid condition number. We must also add
   an entry in either the implementation-defined annex or the implementation-dependent annex.
   Proposed Solution:
   None provided with comment.

866 The following Possible Problem has been noted:
   Severity: Minor Editorial
   Reference: P02, SQL/Foundation, Subclause 10.4, "<routine invocation>", Syntax Rule 2) et al
   Note at: None.
   Source: WG3:DRS-094
   Possible Problem:



                                                    Possible problems with SQL/Foundation 17
Editor’s Notes for WG3:HBA-003 = H2-2003-305


     There is notation in the SRs of this subclause that unnecessarily confusing.

     •    RI is used in SRs 1), 2), 6) 7) 8) 9) and GR 2)

     •    R1 is used in SRs 6) 7) and 8)

     •    R is used locally in two subrules of SR 5) and redefined in GR 2) and used extensively
          thereafter.
     Although it is clear that R1 and RI are distinct terms, their similarity makes it difficult to know
     whether, in each occurrence of either, the correct one is being used, though admittedly, in SR 7)
     and SR 8) R2 also occurs, in contrast to R1, which helps.
     Proposed Solution:
     None provided with comment.

868 The following Possible Problem has been noted:
     Severity: Minor Technical
     Reference: P02, SQL/Foundation, Subclause 5.4, "Names and identifiers", Syntax Rules
     Note at: None.
     Source: WG3:DRS-043
     Possible Problem:
     Two BNF non-terminals have similar names and identical formats:
     <schema qualified type name> ::=
         [ <schema name> <period> ] <qualified identifier>
     <schema qualified name> ::=
         [ <schema name> <period> ] <qualified identifier>
     Syntax Rule 11) deals with case of a <schema qualified name> that contains no <schema name>
     and SR 13) deals with the possible equivalence of two <schema qualified name>s.
     However, there is no rule to deal with the case of a <schema qualified type name> that contains
     no <schema name>, though the possible equivalence of two <schema qualified type name>s is
     dealt with by Syntax Rule 9), which is effectively identical to SR 13).
     Without claiming to know the reason for the difference, but noting that <schema qualified
     routine name> is defined simply as <schema qualified name>, we wonder whether the first
     definition above could be replaced by:
     <schema qualified type name> ::=
     <schema qualified name>
     which would make SR 9) redundant and it could then be deleted.
     Proposed Solution:
     None provided with comment.

870 The following Possible Problem has been noted:
     Severity: Minor Technical
     Reference: P02, SQL/Foundation, Subclause 4.13, "Columns, fields, and attributes"
     Note at: None.
     Source: WG3:DRS-091
     Possible Problem:
     The content specification of a column descriptor contained in Subclause 4.13, "Columns, fields,
     and attributes" does not include information about <reference scope check> or <reference scope
     check action>.


18       Editor’s Notes for ISO-ANSI working draft Database Language SQL (SQL/Foundation)
                                               Editor’s Notes for WG3:HBA-003 = H2-2003-305


   The specifications for the content of an attribute descriptor or a field descriptor do not con-
   tain any information about the <reference scope check action>, which, if the data type of the
   attribute being described or field is a reference type, can be contained in <reference scope
   check>.
   Proposed Solution:
   None provided with comment.

871 The following Possible Problem has been noted:
   Severity: Minor Technical
   Reference: P02, SQL/Foundation, Subclause 6.2, "<field definition>"
   Note at: None.
   Source: WG3:DRS-091
   Possible Problem:
   Syntax Rule 4) demands that if the <data type> contained in the <field definition> is a scoped
   reference type, either REFERENCES ARE NOT CHECKED or REFERENCES ARE CHECKED
   ON DELETE NO ACTION shall be specified. This is not adequate and not consistent with
   Subclause 11.4 <column definition>, where ON DELETE NO ACTION can be omitted.
   The same applies to Subclause 11.42 <attribute definition>, Syntax Rule 7).
   Proposed Solution:
   None provided with comment.

872 The following Possible Problem has been noted:
   Severity: Minor Technical
   Reference: P02, SQL/Foundation, Subclause 6.2, "<field definition>"
   Note at: None.
   Source: WG3:DRS-091
   Possible Problem:
   When generating the attribute descriptor, General Rule 3)e) misses to include the content of
   <reference scope check action> in case <reference scope check> specifies REFERENCES ARE
   CHECKED. See also PP-#020 for reference. The same applies to Subclause 11.42, "<attribute
   definition>", General Rule 3)e).
   Proposed Solution:
   None provided with comment.

873 The following Possible Problem has been noted:
   Severity: Minor Technical
   Reference: P02, SQL/Foundation, Subclause 11.3, "<table definition>"
   Note at: None.
   Source: WG3:DRS-095
   Possible Problem:
   Application of Syntax Rule 16)d)iii)4) is redundant if the <unique constraint definition> men-
   tioned in Syntax Rule 16)d)iii)3) specifies PRIMARY KEY.
   Proposed Solution:
   None provided with comment.

875 The following Possible Problem has been noted:
   Severity: Minor Technical
   Reference: P02, SQL/Foundation, Subclause 11.4, "<column definition>"


                                                  Possible problems with SQL/Foundation 19
Editor’s Notes for WG3:HBA-003 = H2-2003-305


     Note at: None.
     Source: WG3:DRS-095
     Possible Problem:
     When applying Syntax Rule 17)g) for creating column descriptors of a proper subtable T, the
     generation of <check constraint definition>s is redundant. Similar <check constraint>s already
     exist in the corresponding direct supertable of T, so that they are implicitly valid for T as well.
     The same applies to Syntax Rule 18)g).
     Proposed Solution:
     None provided with comment.

891 The following Possible Problem has been noted:
     Severity: Minor Technical
     Reference: P02, SQL/Foundation, Subclause 6.2, "<field definition>"
     Note at: None.
     Source: WG3:DRS-089
     Possible Problem:
     It is not clear what <reference scope check> implies if a field whose declared type is a reference
     type is not contained in a <table definition> but in a <view definition>, since table constraints
     such a those implicitly created for the <reference scope check> in a base table cannot be defined
     on views. While the field descriptor will indicate that references are checked, <reference scope
     check> is apparently ignored.
     Note: This problem is similar to possible problem Possible Problem 898, dealing with attributes.
     Proposed Solution:
     None provided with comment.

892 The following Possible Problem has been noted:
     Severity: Minor Technical
     Reference: P02, SQL/Foundation, Subclause 11.3, "<table definition>"
     Note at: None.
     Source: WG3:DRS-089
     Possible Problem:
     SR 10)a) replaces the <scope clause> of a <column option list> by inserting it in a proper
     <column definition> of the form <column name> <data type> <scope clause> (followed by
     default value and constraints). However, <data type> (which should be a <reference type>) can
     already contain a <scope clause>. This is not prohibited by any rule in Subclauses 11.3 or 11.4.
     Should it be prohibited, or does the new scope somehow "override" the original one?
     A consequence of the first would be that there is no way to change the scope even at column
     level.
     Proposed Solution:
     None provided with comment.

893 The following Possible Problem has been noted:
     Severity: Minor Technical
     Reference: P02, SQL/Foundation, Subclause 11.16, "<drop column scope clause>"
     Note at: None.
     Source: WG3:DRS-089
     Possible Problem:



20    Editor’s Notes for ISO-ANSI working draft Database Language SQL (SQL/Foundation)
                                               Editor’s Notes for WG3:HBA-003 = H2-2003-305


   There are different ways to specify scope for columns whose declared type is a <reference type>:
   as part a <data type> definition (Subclause 6.1), using a <column options> contained in a
   typed <table definition> (Subclause 11.3), and by adding scope in an <alter table statement>
   (Subclauses 11.10 and 11.15).
   Since all these ways affect the reference type descriptor in the column descriptor, Subclause
   11.16 seems to allow the dropping of a scope, regardless of how it was defined, either at data
   type or table level.
   One possible scope definition is part of an attribute definition of a structured type. Dropping
   the scope of a column of a typed table based on this structured type leads to the rather strange
   result that the underlying type of the table is not completely reflected in the table descriptor
   anymore.
   Proposed Solution:
   None provided with comment.

894 The following Possible Problem has been noted:
   Severity: Minor Technical
   Reference: P02, SQL/Foundation, Subclause 11.16, "<drop column scope clause>"
   Note at: None.
   Source: WG3:DRS-089
   Possible Problem:
   It is not specified what happens to the scope of a view column based on a column whose scope is
   being dropped.
   Proposed Solution:
   None provided with comment.

895 The following Possible Problem has been noted:
   Severity: Minor Technical
   Reference: P02, SQL/Foundation, Subclause 11.21, "<drop table statement>"
   Note at: None.
   Source: WG3:DRS-089
   Possible Problem:
   SR 6)f) effectively states the same as the second part of SR 6)d). Furthermore, Note 272 in SR
   6) does not apply to SR 6)d) and 6)f): No privilege is necessary for <scope clause> according to
   Subclause 6.1 <data type>. See Possible Problem 883 for reference.
   Note: This problem is similar to possible problem Possible Problem 897.
   Proposed Solution:
   None provided with comment.

896 The following Possible Problem has been noted:
   Severity: Minor Technical
   Reference: P02, SQL/Foundation, Subclause 11.22, "<view definition>"
   Note at: None.
   Source: WG3:DRS-089
   Possible Problem:




                                                  Possible problems with SQL/Foundation 21
Editor’s Notes for WG3:HBA-003 = H2-2003-305


     GR 1)c)ii)2)B) determines the scope of a column of a typed view if the column’s data type is a
     reference type. According to this rule, which is based on SR 22)v) and 22)x), it seems that a
     column’s scope can only be defined by a <view column option> and not by the corresponding
     attribute’s data type or (as for regular views) by the scope of the corresponding column of the
     underlying <query expression>.
     Proposed Solution:
     None provided with comment.

897 The following Possible Problem has been noted:
     Severity: Minor Technical
     Reference: P02, SQL/Foundation, Subclause 11.23, "<drop view statement>"
     Note at: None.
     Source: WG3:DRS-089
     Possible Problem:
     Note 281 in SR 4) does not apply to SR 4)e): No privilege is necessary for <scope clause>
     according to Subclause 6.1 <data type>. See Possible Problem 889 for reference.
     Note: This problem is similar to possible problem Possible Problem 895.
     Proposed Solution:
     None provided with comment.

898 The following Possible Problem has been noted:
     Severity: Minor Technical
     Reference: P02, SQL/Foundation, Subclause 11.42, "<attribute definition>"
     Note at: None.
     Source: WG3:DRS-089
     Possible Problem:
     It is not clear what <reference scope check> implies when an attribute whose declared type is
     a reference type is not contained in a <table definition> but in a <view definition>, since table
     constraints such a those implicitly created for the <reference scope check> in a base table cannot
     be defined on views. While the attribute descriptor will indicate that references are checked,
     <reference scope check> is apparently ignored.
     Note: This problem is similar to possible problem Possible Problem 891, dealing with fields.
     Proposed Solution:
     None provided with comment.

918 The following Possible Problem has been noted:
     Severity: Minor Technical
     Reference: P02, SQL/Foundation, No particular location
     Note at: None.
     Source: WG3:ZSH-034R1 = H2-2002-_ __
     Possible Problem:
     What does CURRENT_ROLE tell us?
     During execution of an SQL routine R whose security characteristic is DEFINER, an invocation
     of CURRENT_ROLE will return the authorization identifier (i.e., the role name) of the owner of
     R.




22    Editor’s Notes for ISO-ANSI working draft Database Language SQL (SQL/Foundation)
                                                Editor’s Notes for WG3:HBA-003 = H2-2003-305


   If it were considered that a user might be interested in knowing what role was actually set by
   the most recent <set role statement>, then we would need a SESSION_ROLE, analogous to
   SESSION_USER.
   Proposed Solution:
   None provided with comment.

923 The following Possible Problem has been noted:
   Severity: Minor Technical
   Reference: P02, SQL/Foundation, Subclause 11.22, "<view definition>"
   Note at: Subclause 11.22, "<view definition>", after GR 1)c)
   Source: WG3:ARN-027R2/H2-2003-248R3
   Possible Problem:
   The GRs of Subclause 11.22, "<view definition>", do not set the values of all items in the column
   descriptors.
   Proposed Solution:
   None provided with comment.

929 The following Possible Problem has been noted:
   Severity: Major Technical
   Reference: P02, SQL/Foundation, Subclause 10.4, "<routine invocation>"
   Note at: None.
   Source: WG3:ZSH-037R1/H2-2003-???
   Possible Problem:
   In DRS-013, General Rule 5) of this subclause says:
      5) Preserve the current SQL-session context CSC and create a new SQL-session context RSC
      derived from CSC as follows: ...
          b) Set the values of the current SQL-session identifier, the identities of all instances of
          global temporary tables, ... to their values in CSC.
          ...
          d) Case:
              i) If R is an SQL routine, then remove from RSC the identities of all instances of
              created local temporary tables, ...
   Whereas Subrule b) implies that the creation of RSC begins with an empty SQL-session context,
   Subrule d) i) implies that RSC begins as a copy of CSC.
   Proposed Solution:
   None provided with comment.

930 The following Possible Problem has been noted:
   Severity: Minor Technical
   Reference: P02, SQL/Foundation, <REFERENCE>(\FULL) or No particular location
   Note at: None.
   Source: WG3:ZSH-037R1/H2-2003-???
   Possible Problem:
   General Rule 4) say:
      4) The current authorization identifier for privilege determination for the execution of S is
      the SQL-session user identifier.


                                                  Possible problems with SQL/Foundation 23
Editor’s Notes for WG3:HBA-003 = H2-2003-305


     This takes no account of the possibility of a non-null CURRENT_ROLE, which means that
     execution of a <set role statement> will achieve nothing for the user of direct SQL.
     Proposed Solution:
     None provided with comment.




24    Editor’s Notes for ISO-ANSI working draft Database Language SQL (SQL/Foundation)
                                                 Editor’s Notes for WG3:HBA-003 = H2-2003-305


Language Opportunities
014 It was noted in conjunction with CAN-106 discussions that if one inserts a row in a view V1
but do not have INSERT privilege on the underlying view V2 that has a WITH CHECK OPTION
constraint, then a constraint violation exception is raised; however, one can then not discover
anything about that constraint!
055 It has been noted that schema manipulation requires no privileges, but depends directly on
ownership of the schema.
129 [Note from SLC] We use the terms "destroyed", "deallocated", "deleted", "released", and perhaps
others in various places. Are these terms used consistently and could the number of such terms be
reduced?
134 [Note from SLC] The functions LOWER and UPPER might be better defined in terms of
translations and collations so that they properly account for all character sets instead of only
<simple Latin character>s.
190 Jim Melton said, in his response to TC LB X3H2-90-267:
   We believe that many implementations will have schema objects other than those specified in
   SQL2 (e.g., indexes, stored <module>s, etc.) that may depend on schema objects defined in
   SQL2. The DROP semantics for such implementations will depend on those implementation-
   defined objects as well as those specified in SQL2, yet the SQL2 DROP rules do not appear to
   make allowances for additional restrictions on DROP statements. The wording in SQL2 must
   be enhanced to allow for such additional restrictions.
   Paper X3H2-90-373 addressed this, but failed. X3H2 suggested that a broader proposal that
   addresses the general concept of implementation-defined objects that might restrict CASCADE
   operations would be acceptable.

212 [LON-034/X3H2-90-333.1] The ISO SQL2 Editing Meeting in London noted that with the
advent of a default character set for domains and columns in a schema, there is an opportunity
to change that default character set for the schema. This might, for example, involve an ALTER
SCHEMA CHANGE CHARACTER SET statement.
217 [Mentioned by Steve Cannan, in London] Steve Cannan has noted:
   It might be necessary to redefine the actions of triggers so that certain actions survive an
   unsuccessful execution of an SQL statement. For example, a BEFORE DELETE trigger might
   be used to record attempts to alter a table for security reasons. It would therefore be necessary
   that the triggered action survive an error in the original statement.

241 [From London] The following Opportunity exists:
   When counting the number of rows "affected" by an <SQL statement>, one might consider
   counting the rows that are affected by triggered statements, too (e.g., triggers and referential
   constraints).

242 [From London] The following Opportunity exists:
   For language consistency, a correlation name should be permitted for the modified table in
   positioned and searched update and delete statements.

268 During consideration of YOK-023/X3H2-92-252, following language opportunity was identified:
   The set of <identifier>s available as <regular character set identifier>s in the <similar predi-
   cate> (see Subclause 8.6, "<similar predicate>") could profitably be enhanced to support addi-
   tional character attributes (e.g., ideographs, syllables, etc., as a result of internationalization
   work subh as that going on in SC22/WG20.


                                                    Possible problems with SQL/Foundation 25
Editor’s Notes for WG3:HBA-003 = H2-2003-305


309 The following Language Opportunity has been noted by Phil Shaw:
     Local declarations of dynamic cursor names would seem like a straightforward extension to
     X3H2-93-056/YOK-034rev.

317 The following Language Opportunity has been noted by X3H2-93-445/MUN-160:
     The representation of SQL-paths in the Information Schema needs to be specified.

327 The following Language Opportunity has been noted by X3H2-93-370R1/MUN-170:
     Object-oriented applications that model the behavior of real-=world entities need the ability
     to add an existing object to a type or to remove it from a type without destroying the object.
     Existing persons become employees and later stop being employees while continuaing to exist as
     persons. This can be achieved with a modest extension of current facilities.

The paper went on to add that a simple extension would be allow a constructor such as STUDENT( )
to accept an optional parameter whose value is an existing object that is to be made an instance of
STUDENT (but only if it is in the type hierarchy with STUDENTs).
349 Bill Kelley noted the following Language Opportunity, which has been modified by Fred Zemke:
     Severity: Language Opportunity
     Reference: P02-11.08, SQL/Foundation, Subclause 11.8, "<referential constraint definition>"
     Note at: None
     Source: WG3:YGJ-074/X3H2-99-164R1
     Language Opportunity:
     For collections types, referential integrity is not definable for elements of collections.
     Example: Assume table EMPLOYEE has PRIMARY KEY EMP_ID of type INTEGER:
     CREATE TABLE MANAGER (
         EMPNO   INTEGER,
         MANAGES INTEGER ARRAY[20] )
     Here "MANAGES" refers to a set of employees, but there is no way to say that they should
     reference employees. That is, if one were to write:
     CREATE TABLE MANAGER (
         EMPNO   INTEGER,
         MANAGES INTEGER ARRAY[20] REFERENCES EMPLOYEE )
     then EMPLOYEE.EMPNO must be a column of array type, and teh constraint says that the
     array value in MANAGER.MANAGES must either be null or be equal to an array value in
     EMPLOYEE.EMPNO. What is needed is a new syntax, perhaps:
     CREATE TABLE MANAGER (
         EMPNO   INTEGER,
         MANAGES INTEGER ARRAY[20] ELEMENT REFERENCES EMPLOYEE(EMPNO) )
     ELEMENT REFERENCES would mean that each array element of MANAGER.MANAGES
     must either be null or equal value in EMPLOYEE.EMPNO.
     (Editor’s note: In my opinion, Bill is simply trying to solve the problem using the wrong
     tools. INTEGER ARRAY[n] is meant to have elements of integers, not elements of employee
     IDs...which is a different thing altogether.)
     Solution:
     None provided.




26    Editor’s Notes for ISO-ANSI working draft Database Language SQL (SQL/Foundation)
                                                 Editor’s Notes for WG3:HBA-003 = H2-2003-305


364 Discussions on X3H2-94-???/MUN-156R1 noted the following Language Opportunity:
    Severity: Language Opportunity
    Reference: P02-16.01, SQL/Foundation, Subclause 20.1, "<embedded SQL host program>"
    Note at: None
    Source: WG3:YGJ-074/X3H2-99-164R1
    Language Opportunity:
    There is a problem for precompilers when the issue of overlapping and non-disjoint scopes for
    host variables, etc. comes into play. In addition, there are problems caused by things like C
    macros and the C #ifdef conditional facilities.
    Solution:
    None provided.



SQL:200n only (not SQL2 or SQL3)–ANSI and ISO



426 Paper X3H2-94-528/DBL:RIO-081 noted the following Possible Problem; WG3:BBN-155/X3H2-
98-378 changed it to a Language Opportunity:
    This possibility (factoring out parts of <column definition>, <field definition>, ...) was pointed
    out as an opportunity in SOU-076, and we considered attempting it. However, although there
    seemed to be no problem with the BNF, we were unsure how to specify a default character set.
    Consider Syntax Rule 6) of <column definition>, which reads:
6) If a <data type> is specified, then:
a) Let DT be the <data type>. b) If DT is CHARACTER, CHARACTER VARYING, or CHARACTER
LARGE OBJECT and does not specify a <character set specification>, then the <character set
specification> specified or implicit in the <schema character set specification> of the <schema
definition> that created the schema identified by the <schema name> immediately contained in the
<table name> of the containing <table definition> or <alter table statement> is implicit. c) If DT
is a <character string type> that identifies a character set that specifies a <collate clause> and the
<column definition> does not contain a <collate clause>, then the <collate clause> of the <character
string type> is implicit in the <column definition>.
    Now, apart from the fact that this masterpiece of prolicity probably has more angle brackets
    than it should have, it just doesn’t seem to work anyway for a LOCAL DECLARED TABLE
    (which has MODULE instead of a <schema name>).
    Furthermore, the Syntax Rules for <SQL variable declaration> (in RIO-006, SQL/PSM) contain
    nothing corresponding to this rule. If it’s needed here, is it not also needed there?
    We seem to need something rather more generic, such as "the character set of the relevant
    schema". The difficulty is specifying what we mean by "relevant" so as to cover all cases, but it
    should surely be possible.

440 Paul Cotton noted the following Language Opportunity in Ottawa, July, 1995:
    DBL:YOW-027 changed Subclause 13.4, "Calls to an <externally-invoked procedure>", to define
    BOOLEAN parameters as zero (0) for FALSE and one (1) for TRUE for the C language.




                                                   Possible problems with SQL/Foundation 27
Editor’s Notes for WG3:HBA-003 = H2-2003-305


     However, Subclause 6.12, "<cast specification>", does not currently permit BOOLEAN source
     values to be cast to a target value of type exact numeric. This would appear to be inconsistent
     with the above-referenced change. An opportunity exists to permit this cast.

452 DBL:YOW-102/X3H2-95-244 discussion noted the following opportunity:
     The specification of the isolation levels is less precise and rigorous than it should be; as a result,
     the intent is somtimes misperceived and the details are often imsinterpreted.

453 Steve Cannan noted the following Language Opportunity during discussion of DBL:YOW-
055/X3H2-95-140:
     Rules such as Subclause 11.10, "<alter table statement>", Syntax Rule 2) ("The schema iden-
     tified by...shall include the descriptor of T") would be unnecessary if the phrase "identified by"
     was defined to require existence.

468 X3H2-94-103/DBL:SOU-076 noted the following Language Opportunity:
     X3H2-94-103/DBL:SOU-076 only introduced a ROW_TYPE for SQL (i.e., for SQL variables,
     parameters, results, and columns). The host language data types are still the scalar types
     specified in SQL-86, SQL-89, and SQL-92. Thus, the proposal doesn’t add the new SQL ROW_
     TYPE to the host language mappings for module language, embedded syntax, or external
     routine parameters.
     Support for host language ROW_TYPEs would require specifying the forms of host language
     record declarations that are recognized in embedded syntax, and adding such host language
     record types to the data type correspondences for embedded syntax, module language, and
     external routines.
     Such a proposal would presumably include the ability to reference such host language variables
     as targets of FETCH, SELECT, and assignment statements, as sources of INSERT, UPDATE,
     and assignment statements, and as arguments of IN, OUT, and INOUT parameters.
     See also Language Opportunities PSM-078 , and CLI-003 , BIND-003 .

469 X3H2-94-103/DBL:SOU-076 noted the following Language Opportunity:
     SQL3 table definitions include a new LIKE clause that lets you "copy" column definitions from
     existing tables:
         CREATE TABLE EMP_DEPT (LIKE EMP, LIKE DEPT, OTHER_COLUMN CHAR(5))
     A similar clause would seem useful for ROW_TYPE declarations. The clause would, however,
     need to be generalized somewhat to allow for specifying row expressions other than tables.

470 X3H2-94-103/DBL:SOU-076 noted the following Language Opportunity:
     As noted in 469 , the LIKE clause provides a shorthand for creating tables of similar formats.
     As described in X3H2-94-103/DBL:SOU-076, this proposal includes the ability to specify a
     ROW_TYPE as a DOMAIN or a DISTINCT TYPE (this results from definint ROW_TYPE as a
     <data type>). A possible follow-on proposal could extent CREATE TABLE to allow reference to
     ROW_TYPE domains and/or types:
         CREATE DOMAIN NAME AS ROW_TYPE (FIRST CHAR(10), LAST CHAR(10));
         CREATE TABLE OF NAME;
     There are several detailed questions that such a proposal would need to address. FOr example,
     can domain names and LIKE both be used in a CREATE TABLE? Can a DISTINCT TYPE be
     used in a CREATE TABLE?



28    Editor’s Notes for ISO-ANSI working draft Database Language SQL (SQL/Foundation)
                                                Editor’s Notes for WG3:HBA-003 = H2-2003-305


471 X3H2-94-103/DBL:SOU-076 noted the following Language Opportunity:
   DBL:MUN-107/X3H2-93-437rev1 mentions the possibility of defining new ROW_TYPEs as
   "subtypes" of other ROW_TYPEs.

472 X3H2-94-103/DBL:SOU-076 noted the following Language Opportunity:
   Given two rows, R1 and R2, a "concatenation" or "join" operator could be defined. For discussion,
   assume that it would be written with the operator k. Then, if R1 has F1 fields and R2 has F2
   fields, R1 k R2 would yield a row with F1+F2 fields, where the values of the first F1 fields are
   the values of the fields of R1 and the values of the last F2 fields are the values of the fields of
   R2.

473 X3H2-94-103/DBL:SOU-076 noted the following Language Opportunity:
   According to this paper, two ROW_TYPEs are equivalent (and assignable) if both have the same
   number of fields and every pair of fields in the same position have compatible types.
   A possible follow-on could consider an option for assignment and type equivalence rules based
   on the names (instead of the positions) of the fields, similar to the <corresponding specification>
   of <query expression>s.

474 X3H2-94-103/DBL:SOU-076 noted the following Language Opportunity:
   A possible follow-on paper could extend the definition of ROW_TYPEs to allow constraints and
   default values.

475 X3H2-94-103/DBL:SOU-076 noted the following Language Opportunity:
   A possible follow-on paper could integrate the rules for ROW_TYPE comparisons in predicates
   into one single Subclause.

519 Paper X3H2-96-111/DBL:MCI-098 raised the following Language Opportunity:
   The TRIGGERED_COLUMNS base table in the Definition Schema misses an opportunity to
   capture both the explicit UPDATE columns of a trigger and other explicit or implicit "referenced"
   columns of the trigger.
   Consider replacing the "TRIGGERED_COLUMNS base table" in the current specification with
   the following new base table and view:
   TRIGGER_COLUMN_USAGE base table
   This table would consist of 8 columns (instead of the 7 columns in the existing TRIGGERED_
   COLUMNS base table). 3 columns to identify the Catalog, Schema, and Name of a Trigger. 4
   columns to identify the Catalog, Schema, Table, and Name of a Column. 1 column to indicate
   whether the named column is an explicit UPDATE column (specified in the <trigger column
   list> of an UPDATE <trigger event> of this trigger), an explicit "Contained" column (contained
   in the <triggered action> of this trigger), or an "Implicit" column (implicitly referenced because
   it happens to be a column in the subject table of an UPDATE Trigger specified without an
   explicit <trigger column list>).
   This 8-th column could also be used later to identify other kinds of column usage that may be
   the basis of a <trigger event>, e.g. SELECT (if triggers are extended to SELECT actions), or the
   actual column (or columns) that get updated by an INSTEAD OF trigger.
   TRIGGER_COLUMN_USAGE view




                                                  Possible problems with SQL/Foundation 29
Editor’s Notes for WG3:HBA-003 = H2-2003-305


     This view would consist of the same 8 columns as in the base table, but would return only
     columns owned by the CURRENT_USER that are "referenced" in some trigger (either owned
     by the CURRENT_USER or by some other user). The 8-th column would tell the owner what
     kind of "reference" (i.e. UPDATE, Contained, or Implicit) is being made to his column by the
     identified trigger.
     The TRIGGER_COLUMN_USAGE view would make it possible for a given user to return a
     list of columns (owned by that CURRENT_USER) that are the UPDATE Trigger columns of
     a trigger (possibly owned by some other user) defined in this catalog. This information is not
     derivable from the existing TRIGGERED_COLUMNS view because that view only returns
     triggers owned by the CURRENT_USER.
     The TRIGGERED_COLUMNS view (redefined over the new TRIGGER_COLUMN_USAGE base
     table) and the new TRIGGER_COLUMN_USAGE view could be used separately to answer all
     of a users legitimate Trigger questions. The TRIGGERED_COLUMNS view would return the
     UPDATE columns of triggers owned by the CURRENT_USER and the TRIGGER_COLUMN_
     USAGE view would return all catalog triggers that explicitly or implicitly "reference" a column
     owned by the CURRENT_USER. The first view would return the names of columns owned by
     other people that the given user had UPDATE privileges on, but never the names of triggers
     owned by other people, and the second view would return the names of triggers owned by other
     people but never the names of columns owned by other people. Both views are valuable to the
     user and contain information that a user has legitimate reason to know.

521 DBL:MCI-098/X3H2-96-111, noted the following Language Opportunity:
     The trigger descriptor defined in GR 2 of Subclause 11.39, "<trigger definition>", maintains an
     explicit collection of all column names referenced by the <triggered action> of the <trigger def-
     inition>. This makes the trigger descriptor different in style from a table constraint descriptor
     (see Subclause 11.6, "<table constraint definition>", GR2) or a view descriptor (see Subclause
     11.22, "<view definition>", GR1), which only maintain this information implicitly. A table check
     consraint maintains the entire <search condition> of the Check and a view descriptor maintains
     the entire <query expression> that determines the view. It may be desirable to treat constraint,
     view, and trigger descriptors in a more homogeneous fashion. Alternatively, a trigger descriptor
     may just maintain the <triggered action> as part of the descriptor, rather than the "triggered
     action column set". If this is done instead, then Syntax Rule 5 and General Rule 1 of Subclause
     11.18, "<drop column definition>", would have to be re-written to accommodate <triggered
     action> instead of "triggered action column set".

528 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02-07.10, <query specification>
     Note at: None.
     Source: DBL:MAD-170/X3H2-96-544R1, point 2.1, FCD1/1998 CAN-P02-031, DBL:CWB-
     132/X3H2-98-187
     Language Opportunity:
     DBL:MAD-170/X3H2-96-544R1, point 2.1, noted:
     The definition of a possibly nullable result column in the Syntax Rules of Subclause 7.12,
     "<query specification>", is broader than necessary, in that an aggregate of a column that is
     known not nullable is regarded as possibly nullable. For example, SUM(EMP.EMPNO) is
     defined as possibly nullable, even if EMP.EMPNO is declared NOT NULL.
     DBL:CWB-132/X3H2-98-187 added:




30    Editor’s Notes for ISO-ANSI working draft Database Language SQL (SQL/Foundation)
                                               Editor’s Notes for WG3:HBA-003 = H2-2003-305


   The problem description makes the assumption that a <set function specification>, for example
   SUM(EMPNO), is known not nullable when EMPNO is known not nullable. However, GR
   3)b) of Subclause 6.9, "<set function specification>", makes it clear that (with the exception of
   COUNT) <set function specification>s return NULL when they are applied to an empty table.
   Hence, we assume that <set function specification>s are possibly nullable, except for COUNT.
   And, that is what SR 12) of Subclause 7.12, "<query specification>", specifies. Hence, we believe
   that there is no problem with SR 12) of Subclause 7.12, "<query specification>".

587 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02, SQL/Foundation, No specific location
   Note at: None specified
   Source: Hugh Darwen, 27 January, 1997
   Language Opportunity:
   Currently, all <routine invocation>s that return values are deemed to be able to return a null.
   Hence, such results are automatically tagged as "possibly null".
   Wouldn’t it be nice if you could say, when you define a function, "NEVER RETURNS NULL" or
   words to that effect? Then its invocations would have the nice "not nullable" characteristic.

593 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02, SQL/Foundation, No specific location
   Note at: None specified
   Source: DBL:LGW-063/X3H2-97-077, point 46.
   Language Opportunity:
   There are no provisions in SQL3 for packaging ADT families. This type of packaging is needed
   to support the creation of a package of ADTs and associated subtypes and routines. It would be
   useful to define access control at the package level rather than the individual ADTs or routines.
   It would also be useful to be able to isolate the package so that subject routine resolut8ion of
   routines inside the package can be restricted to only other routines within the package.
   This packaging could be accomplished with schemas or SQL-server modules, but neither mecha-
   nism is complete at this point.

597 The following Possible Problem has been noted:
   Severity: Minor Technical
   Reference: P02, SQL/Foundation, Subclause 14.10, "<update statement: positioned>"
   Note at: None.
   Source: DBL:LGW-059/X3H2-97-261, 22 May, 1997
   Possible Problem:
   Impossible to Update Different Parts of Same Column
   SR12 prohibits the same column name from appearing more than once in the list of SET clauses.
   This means that the user who wishes to use the shorthands available for assigning to elements
   of arrays and fields of rows is rather severely restricted, unacceptably so, in our opinion. The
   problem does not arise in connection with assignment to attributes of ADT values, thanks to the
   ingenious SR11.
   Proposed Solution:
   None provided with comment.




                                                  Possible problems with SQL/Foundation 31
Editor’s Notes for WG3:HBA-003 = H2-2003-305


603 The following Language Opportuntiy has been noted:
     Severity: Language Opportunity
     Reference: P02, SQL/Foundation, Subclause 11.41, "<user-defined type definition>"
     Note at: SR<REFERENCE>(fnd_udtdef_SR_notbase\FULL)
     Source: DBL:LGW-131/X3H2-97-293, 24 July, 1997; also USA-081 in first CD ballot for
     SQL/Foundation and WG3:YGJ-074/X3H2-99-164R1
     Possible Problem:
     Subclause 11.41, "<user-defined type definition>", contains a Syntax Rule reading:
6)g) [A user-defined type] shall not be based on itself.
     This syntax rule prevents the UDT facility from modeling a recursively-defined data type such
     as "Tree". Here is a simple example of a UDT definition that is not possible because of that SR:

CREATE TYPE Tree (
       node_value                  INTEGER,
       left_subtree                Tree,
       right_subtree               Tree )


     Proposed Solution:
     None provided with comment.

607 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02, SQL/Foundation, Subclause 4.32, "Cursors"
     Note at: None specified
     Source: DBL:LGW-146/X3H2-97-349
     Language Opportunity:
     The ability to hold a cursor through rollback will be extremely useful to applications. Yet the
     second bullet of this Subclause says "a holdable-cursor is closed no matter what its state if
     the SQL-transaction is terminated with a rollback operation." This provision is not always
     necessary according to Jim Gray and Andrewas Reuter "Transaction Processing: Concepts and
     Techniques".

610 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02, SQL/Foundation, Subclause 7.9, "<group by clause>" and others
     Note at: None specified
     Source: DBL:LGW-146/X3H2-97-349
     Language Opportunity:
     Continuing work is needed to complete object support as outlined in "Providing Rich Query
     Functionality" (DBL:LHR-078 = X3H2-95-462) with regard to expanding GROUP BY to permit
     naming of grouping expressions and allowing those names to be used in the query. The ability
     to group the result of a table expression by the value of expressions is important to many
     applications. The ability to name these grouping expressions and use those names to retrieve
     the results of the grouping column cum expression in the select list of the table expression is
     equally important to avoid applications having to repeat the expression (giving opportunity for
     errors) in the select list.




32    Editor’s Notes for ISO-ANSI working draft Database Language SQL (SQL/Foundation)
                                               Editor’s Notes for WG3:HBA-003 = H2-2003-305


611 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02, SQL/Foundation, Subclause 11.39, "<trigger definition>"
   Note at: None specified
   Source: DBL:LGW-146/X3H2-97-349
   Language Opportunity:
   SQL3 should consider adding syntax to allow the user to specify the ordering in which triggers
   on the same effect should be fired.

613 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02, SQL/Foundation, No specific location
   Note at: None specified
   Source: DBL:LGW-146/X3H2-97-349
   Language Opportunity:
   The concept of substitutability is cerntal to the ADT extension of SQL; currently, pertinent
   information is scattered over a multitude of subclauses. It needs to be summarized in a separate
   subclause of the Concepts section.

624 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02, SQL/Foundation, No specific location
   Note at: None specified
   Source: DBL:LGW-146/X3H2-97-349
   Language Opportunity:
   Viewed tables allow the owner of a table to define a subset of its rows and/or columns. The
   owner may then grant access to the viewed table to other users without giving access to the
   base table itself. There is no corresponding capability provided with reeference types. To access
   a column of a row for which a user has a reference, the user is required to have SELECT
   privilege on the column of the base table. To alter such a column, the user must have UPDATE
   privilege on the column of the base table.
   A mechanism analogous to views on base tables is extremely desirable for adequate granualrity
   of access control.

626 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02, SQL/Foundation, No specific location
   Note at: None specified
   Source: DBL:LGW-146/X3H2-97-349
   Language Opportunity:
   The <dereference operation> is a very nice syntactic shorthand to avoid the writing of a join.
   This operation should be extended to allow the use of existing referential constraints.

CREATE TABLE enrollments (
       student_lname CHAR VARYING (30),
       student_fname CHAR VARYING (30),
       course REFERENCES courses (id),
       grade CHAR VARYING (2),
       FOREIGN KEY (student_lname, student_fname) REFERENCES students (lname, fname)
       );



                                                  Possible problems with SQL/Foundation 33
Editor’s Notes for WG3:HBA-003 = H2-2003-305


SELECT course -> course-name,
       (student_lname, student_fname) -> address
FROM enrollments
WHERE grade = ’A+’ ;




627 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02, SQL/Foundation, No specific location
     Note at: None specified
     Source: DBL:LGW-146/X3H2-97-349
     Language Opportunity:
     A reference type should be able to refer to a cell of a table and not just the entire row.

629 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02, SQL/Foundation, No specific location
     Note at: None specified
     Source: DBL:LGW-080/X3H2-97-???
     Language Opportunity:
     The SQL3 specifications for <attribute definition>, <routine specification>, and <abstract data
     type body> prohibit the ability to define an explicit mutator function on a single attribute of
     an ADT with the same signature as the implicit one specified in <attribute definition> (thereby
     over-riding the implicit one). This sometimes makes it difficult to choose meaningful names
     both for the attributes of an ADT and for its associated mutator functions. For example, with
     the comment attribute of the SI_StillImage ADT, it is not possible to define both an attribute
     name and an explicit mutator function on that attribute with the same name, e.g. COMMENT
     cannot beused for both names.
     It is an SQL3 Language Opportunity to provide new syntax in the SQL3 <attribute definition>
     to allow the implicit mutator function to be explicitly renamed (e.g. similar to the way the
     CONSTRUCTOR option allows the implicit constructor function of an ADT to be renamed) so
     that the more desirable attribute name can then be used to define an explicit mutator function
     for that attribute.
     Example Usage: <attribute name> <data type> [MUTATOR <mutator name>]. This new syntax
     might then be used to allow definition of a comment attribute in the SI_StillImage ADT, with its
     implicit mutator function renamed to be commentOnly, thereby allowing COMMENT to be used
     as the name of an explicit mutator function that modifies both the comment and the updateTime
     attributes of the ADT.

630 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02, SQL/Foundation, No specific location
     Note at: None specified
     Source: DBL:LGW-081/X3H2-97-???
     Language Opportunity:
     Would it be possible to allow very limited Type Templates in SQL3 like
        DECLARE TYPE TEMPLATE Pixel(n SMALLINT) AS BIT(n)




34    Editor’s Notes for ISO-ANSI working draft Database Language SQL (SQL/Foundation)
                                               Editor’s Notes for WG3:HBA-003 = H2-2003-305


   where an upper limit on the value of n is implementation-defined, but with the ability to specify
   the value of n as an integer <value expression> whenever Pixel(n) is declared as a parameter in
   an SQL-invoked routine or as an SQL variable in a compound statement.

668 The following Language Opportunity has been noted:
   Severity: Minor Technical
   Reference: P11, SQL/Schemata, Clause 5, "Information Schema"
   Note at: None.
   Source: DBL:LGW-152/X3H2-97-352 (also DBL:LGW-023/X3H2-97-044, SEQ# 406, USA-102*)
   Possible Problem:
   The ROUTINES view and base table have columns that contain the timestamp of when the
   routine was CREATED and LAST_ALTERED. These are analogous to the file creation and
   modification timestamps typically provided by a file system. These timestamps are useful for
   comparing the creation and modification timestamps of the database objects with the times-
   tamps in an external source code control and configuration management utility. Since SQL3
   supports extensive programmatic capabilities this configuration management support is ex-
   tremely useful. However it does not go far enough. Created and Last_altered timestamps would
   also be useful in the following base tables and their associated views:

   — ABSTRACT_DATA_TYPES

   — DOMAINS

   — TABLES

   — VIEWS

   — COLUMNS

   — ASSERTIONS

   — CHARACTER_SETS

   — COLLATIONS

   — TRANSLATIONS

   — TRIGGERS

   — SUB_TABLES
   Proposed Solution:
   None provided with comment.

670 The following Language Opportunity has been noted:
   Severity: Minor Technical
   Reference: P11, SQL/Schemata, Clause 5, "Information Schema"
   Note at: None.
   Source: DBL:LGW-152/X3H2-97-352 (also DBL:LGW-023/X3H2-97-044, SEQ# 409, USA-105)
   Possible Problem:
   Many "information discovery" products depend upon full text searches of document databases
   to feed the indexing mechanisms used in their search engines. It is very difficult to extend
   this technique to "structured" relational databases especially if they have high numeric content
   unless there is some textual description of the semantics associated with data values and


                                                 Possible problems with SQL/Foundation 35
Editor’s Notes for WG3:HBA-003 = H2-2003-305


     schema objects. Sometimes "information discovery" agents will search the INFORMATION_
     SCHEMA Catalog Schema Table and Column names looking for relevant key word "stems"
     to feed to the search engine. It would be very helpful to users of such agents if there were a
     "standard" way to read and write textual descriptions of what each schema object represents.
     Certainly Information Resource Dictionary Systems (IRDS) could help in this task or users
     could define a special schema for this purpose but at present there is no dependable standard
     mechanism to make such information available to outside agents. One easy-to-implement yet
     very helpful facility would be to associate a "COMMENT" or "DESCRIPTION" column with each
     relevant table in the INFORMATION_SCHEMA together with a "SET SCHEMA COMMENT
     statement" (or other appropriate syntax) that would allow the owner of a schema object to set
     and/or modify the COMMENT column associated with it. The normal Information Schema
     view definition would then determine which users are able to read the COMMENT column so
     information discovery agents would be able to "discover" whatever comments exist for PUBLIC
     schema objects and report back to their creators any interesting database content.
     In addition to information discovery agents comment or description information is crucial to
     support the reusability of ADTs. An SQL programmer must know what an ADT is supposed to
     do in order to correctly utilize or subtype it. This information can only be provided by the ADT
     creator in a text format and is much more likely to be useful if stored in the INFORMATION_
     SCHEMA than if stored in paper documentation at the bottom of a stack on someone else’s desk.
     This could be accomplished by adding syntax to the ADT definition to support a large amount of
     text.
     The SQL objects for which comment/description information would be useful include: DO-
     MAINS, TABLES, VIEWS, COLUMNS, ASSERTIONS, CHARACTER_SETS, COLLATIONS,
     TRANSLATIONS, TRIGGERS, SUB_TABLES, as well as distinct types, abstract data types,
     and SQL-invoked routines.
     Proposed Solution:
     None provided with comment.

676 The following Language Opportunity has been noted:
     Severity: Minor Technical
     Reference: P02, SQL/Foundation, No Specific Location
     Note at: None.
     Source: DBL:LGW-152/X3H2-97-352 (also DBL:LGW-023/X3H2-97-044, SEQ# 469, FRANCE-F-
     015*)
     Possible Problem:
     Some types can be named by themselves (distinct types ADTs and named row types) while
     others only by defining domains on them (collections row types).
     This unorthogonality should be removed by allowing any type to be associated to a name
     through type declaration.
     Proposed Solution:
     None provided with comment.

692 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02-06.02, <value specification> and <target specification>
     Note at: Format for <target specification>
     Source: DBL:CWB-081/X3H2-98-068
     Language Opportunity:




36    Editor’s Notes for ISO-ANSI working draft Database Language SQL (SQL/Foundation)
                                                Editor’s Notes for WG3:HBA-003 = H2-2003-305


   Although there is provision for refining a <value expression> of row type or structured type,
   there is no provision for refining a <target specification>. As a result, a field of a row or
   an attribute of a structured type cannot be passed as output or in/out argument of an SQL-
   invoked routine, or used in other target contexts. This problem is partially remedied in PSM
   <assignment statement>. Possibly the support for refined targets can be adapted from PSM and
   moved to Foundation.

693 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02-06.12, <set function specification>
   Note at: None.
   Source: FCD1/1998 NLD-P02-017, DBL:CWB-132/X3H2-98-187
   Language Opportunity:
   We do not understand SR 4). If an outer reference is permitted at all, surely it should be per-
   mitted any number of times, just as literals and host variable names can occur any number of
   times. We would add that we see no reason to prohibit outer references altogether. For exam-
   ple, if SUM(OUTER.C1) is legal, surely SUM(OUTER.C1+OUTER.C1) is also legal. Besides,
   why should column references that are not outer references be prohibited as soon as there is an
   outer reference? SR 4) of Subclause 6.9, "<set function specification>", says:
4) The <value expression> simply contained in <set function specification> shall not contain a <set
func-tion specification> or a <subquery>. If the <value expression> contains a column reference
that is an outer reference, then that outer reference shall be the only column reference contained in
the <value ex-pression>.
   We agree that the above rule is overly restrictive. However, we believe this rule was adopted in
   SQL-92 to prohibit query formulations of the form:
       SELECT *
       FROM t1
       GROUP BY ...
       HAVING ... ( SELECT c21
       FROM t2
       GROUP BY ...
       WHERE ... ( SELECT c3
       FROM t3
       WHERE SUM ( t1.c12 + t2.c22 ) > ...
       )
       )
   In the above example, outer references from multiple levels are being referenced in the same
   aggregate function. Semantically, this does not make sense and must be prohibited.

694 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02-11, Schema definition and manipulation
   Note at: None.
   Source: DBL:CWB-114/X3H2-98-169
   Language Opportunity:
   The current choices for <drop behavior>, RESTRICT and CASCADE, are too limiting. CAS-
   CADE is so sweeping that the user must hesitate to use it, not knowing what may be dropped.
   RESTRICT, on the other hand, is so limited that the user must find all dependencies and drop
   them in the proper order. There is a third model, based on the notion of invalidation. With this



                                                  Possible problems with SQL/Foundation 37
Editor’s Notes for WG3:HBA-003 = H2-2003-305


     model, a dependent definition does not block a drop; instead, the dependent object is simply
     marked invalid. Later usage of an invalid object causes its recompilation, which may very well
     succeed since the cause of invalidation may have been repaired.

696 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02, No specific location
     Note at: None.
     Source: DBL:BBN-128/X3H2-98-354 (BBN-029R1, SEQ#149, USA-P02-034)
     Language Opportunity:
     The restriction that only rows of persistent base tables can be referenced should be lifted to
     allow references to nested (un-named) row types.

707 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02, SQL/Foundation
     Note at: None.
     Source: Email from Mike Ubell 5 August, 1998
     Possible Problem:
     In X3H2-98-016, the ability to dynamically dispatch a function was eliminated in favor of
     method based dispatch. This was done to bring SQL more in line with Java and therefore, pre-
     sumably, make it easier to import non-SQL written shrink wrap applications into the database.
     Unfortunately many existing applications (and data type packages) are not written in Java
     today, or even in C++. By removing the multi-argument dispatch data types that support com-
     parison and inheritance must dispatch on one argument within the method. If the method is
     implemented in a language that does not support inheritance, then new subtypes may not be
     added to the shrink-wrapped data type.
     Proposed Solution:
     None provided with comment.

709 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02-09.06, Type precedence list determination
     Note at: None.
     Source: WG3:YGJ-021
     Language Opportunity:
     Paper DBL:BBN-168 added a Syntax Rule to Subclause 11.44, "<SQL-invoked routine>" to
     prohibit the use of ROW because there is nothing in P02-09.06, "Type precedence list determi-
     nation", to handle the type precedence requirements of anonymous row types.
     Solution:
     None provided with comment

710 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02-11, Schema definition and manipulation
     Note at: None.
     Source: WG3:YGJ-021
     Language Opportunity:




38    Editor’s Notes for ISO-ANSI working draft Database Language SQL (SQL/Foundation)
                                                Editor’s Notes for WG3:HBA-003 = H2-2003-305


   A RENAME TABLE statement has been strongly desired for a very long time and any users will
   be expecting to see it in SQL3.
   Solution:
   None provided with comment

712 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02-11.07, <default clause>
   Note at: None.
   Source: WG3:YGJ-021 and WG3:PER-098R1/H2-2001-059
   Language Opportunity:
   It is not possible to specify default values for columns or attributes of an array type, a multiset
   type, a reference type, a row type, or a user-defined type.
   Solution:
   None provided with comment

713 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02-11.42, <SQL-invoked routine>
   Note at: None.
   Source: WG3:YGJ-021
   Language Opportunity:
   Currently all parameters must be of some specific concrete type. There needs to be a mechanism
   to declare that a parameter is a character string of arbitrary, unspecified type, at least when
   invoking PSM. (And there should be some mechanism within PSM to interrogate the character
   set and length of a character string parameter). Otherwise the subject routine rules allow you
   to resolve to the same PSM routine no matter what the parameter’s character set, but when
   the function is invoked, you will get an error when trying to assign the input argument to the
   parameter’s type if the input argument’s character set is different from the one declared in the
   function’s signature. There should also be a mechanism to declare that the return type of a
   function is determined by a parameter’s type.
   Solution:
   None provided with comment

715 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02-13.08, <insert statement>
   Note at: None.
   Source: WG3:YGJ-021
   Language Opportunity:
   When a row of a table that has a system-generated column is inserted, the application has no
   way to access the newly generated value. This was not an issue when only explicit values were
   inserted by the application.
   Solution:
   None provided with comment

717 The following Language Opportunity has been noted:
   Severity: Language Opportunity


                                                   Possible problems with SQL/Foundation 39
Editor’s Notes for WG3:HBA-003 = H2-2003-305


     Reference: P02-13.09, <update statement: positioned>
     Note at: None.
     Source: WG3:YGJ-021
     Language Opportunity:
     The Format for <update target> does not provide a way to set a field of an anonymous row
     type. Seemingly the only way to update column of an anonymous row type is to replace the
     entire column, which will be awkward in many instances. For example, suppose I only want to
     update the STREET portion of an ADDRESS column. Looks like I have to use UPDATE T SET
     ADDRESS = ROW (:STREETVAR, T.CITY, T.STATE, T.ZIP); This means the query writer has to
     repeat the entire definition of the anonymous row in the query, which can be quite laborious, as
     well as hiding the simplicity of what the user is actually doing. Also, we must support all kinds
     of nesting of anonymous rows and UDTs.
     Solution:
     None provided with comment

719 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02-No specific location
     Note at: None.
     Source: WG3:YGJ-021
     Language Opportunity:
     The reference type and the dereference operator have been added to SQL3. The ability to
     update a column or delete a row via a reference must be supplied as well.
     Solution:
     None provided with comment

720 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02-No specific location
     Note at: None.
     Source: WG3:YGJ-021
     Language Opportunity:
     SQL3 requires that a table have an associated user-defined type in order to be referenceable.
     The combination of user-defined type and base table is now very difficult to change in any way.
     The two would have to be disassociated, each altered separately, and then associated again.
     Neither the disassociation of user-defined type and base table nor the altering of a user-defined
     type are supported.
     Solution:
     None provided with comment

721 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02-No specific location
     Note at: None.
     Source: WG3:YGJ-021
     Language Opportunity:




40    Editor’s Notes for ISO-ANSI working draft Database Language SQL (SQL/Foundation)
                                               Editor’s Notes for WG3:HBA-003 = H2-2003-305


   Constraints are not a part of a user-defined type. This means that the constraints that are
   intended for each table of a user-defined type must be explicitly copied and maintained by a
   user.
   Solution:
   None provided with comment

722 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02-No specific location
   Note at: None.
   Source: WG3:FRA-092R2
   Language Opportunity:
   The table defining features in Core SQL should be examined to ensure that the features exhaust
   all ov Core (perhaps by showing that all BNF nonterminals that are available to Core have been
   assigned to some faeture) and that they are rigorously stated.
   Solution:
   None provided with comment

723 The following Language Opportunity has been noted:
   Severity: Language Opportunity (Major Technical)
   Reference: P02-Subclause 6.4, "<value specification> and <target specification>"
   Note at: None.
   Source: WG3:FRA-132/X3H2-98-694
   Language Opportunity:
   Currently we have no capability to treat an <element reference> as a <target specification>.
   This precludes their use as output arguments of routine invocations, for example. The same
   observation can be made of <field reference>, <dereference operation>, <reference resolution>,
   and <method invocation> (some of these subject to the restriction that the method must be a
   mutator). (Lest you object that [Fred is] thinking of allowing surreptitious updates to column
   values by referencing them as output arguments of a routine invocation, be it noted that these
   expressions can also be used with parameters and variables.) However, [Fred believes] that
   the general solution to this problem is to introduce a notion of l-values and r-values, as in the
   specification of C.
   Solution:
   None provided with comment

724 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02-Subclause 14.10, "<update statement: positioned>"
   Note at: None.
   Source: WG3:FRA-093/X3H2-98-628)
   Language Opportunity:
   The <simple value specification> immediately contained in an <update target> of a <set clause>
   specifying the array element of the target column to be updated should be a <value specifi-
   cation> rather than a <simple value specification>. This would allow the use of a <dynamic
   parameter specification> which is currently prohibited because a <simple value specification>
   cannot be a <dynamic parameter specification>. General Rules 14)a)ii)5)c) of <update state-
   ment: positioned> and <update statement: searched> will cause an exception to be raised if



                                                  Possible problems with SQL/Foundation 41
Editor’s Notes for WG3:HBA-003 = H2-2003-305


     a null value is passed as a <value specification> so no change is necessary to preclude a null
     value.
     Solution:

     •    Changes to Subclause 14.10, "<update statement: positioned>":

          — Revise the BNF for <update target>, replacing <simple value specification> with <value
            specification>.

          — Replace <simple value specification> with <value specification> in Syntax Rule 10),
            General Rule 14) and Conformance Rule 2).

     •    Changes to Subclause 14.11, "<update statement: searched>":

          — Replace <simple value specification> with <value specification> in Syntax Rule 9) and
            General Rule 14).

725 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02-Subclause 4.27, "SQL-invoked routines"
     Note at: None.
     Source: WG3:FRA-122/X3H2-98-688)
     Language Opportunity:
     Subclause 4.27, "SQL-invoked routines", does not adequately describe the concepts of dynamic
     binding and subject function selection.
     Solution: None included with comment.

726 The following Possible Problem has been noted:
     Severity: Major Technical
     Reference: P05, SQL/Bindings, Dynamic SQL
     Note at: None.
     Source: WG3:FRA-126R1 and WG3:PER-098R1/H2-2001-059
     Possible Problem:
     There is no way to retrieve a locator for an array, a multiset, or a UDT without having pre-
     knowledge of the type of data to be accessed because the rules for <get descriptor statement>
     require that the data type of the <simple target specification> ‘‘match’’ that represented by the
     item descriptor area when retrieving DATA. For UDT locators, ‘‘match’’ implies that the UDT for
     which the locator was declared be the same as that specified in the SQL item descriptor area.
     For array locators and multiset locators, ‘‘match’’ implies that the element data types be the
     same. The only way to declare a host variable appropriately is to know in advance what UDTs,
     arrays, or multisets will be accessed. This is unacceptable for dynamic SQL. A similar problem
     exists with reference types.
     Proposed Solution:
     None provided with comment.

729 The following Possible Problem has been noted:
     Severity: Language Opportunity
     Reference: P02-06.01, SQL/Foundation — Subclause 6.1, "<data type>"
     Note at: None.
     Source: WG3:YGJ-112 (SQL/MM YGJ-023), Paul Cotton for WG4, July 6, 1999, and Paul
     Scarponcini via email on 6 July 1999
     Possible Problem:


42       Editor’s Notes for ISO-ANSI working draft Database Language SQL (SQL/Foundation)
                                                Editor’s Notes for WG3:HBA-003 = H2-2003-305


   According to YGJ-112: "REF types need to be scoped; i.e., the table(s) they refer to must be
   explicitly provided. If a column is of type REF type, the scope may be defined at table creation
   time. If the column is of type UDT which contains REF type attributes, then the scope must be
   declared when the UDT is created.
   The SQL/MM Part 3: Spatial standard defines the UDTs for spatial data. The standard is
   unable to predict in which tables the referenced information will be stored; this is a function
   of database design. Therefore, column scoping must be expanded to support deeply nested
   references, i.e., REF types within a UDT or ARRAY. This would allow a user, when creating
   tables, to define the scope of a UDTs REF type as part of the column definition for a column of
   type UDT."
   When a <reference type> is used as the data type of an attribute of a structured type, the <scope
   clause> must be specified when the encompassing user-defined type is defined. It is a Language
   Opportunity to be able to specify the <scope clause> of the "nested" <reference type>s when a
   column is defined on the encompassing user-defined type.
   Paul Scarponcini added:
   This applies to ARRAYs as well (e.g., an ARRY of REF, and ARRAY of UDTs having REF
   attributes. The resultant syntax may be quite messy, as different REFs within the column may
   have different scopes. Would it be worth considering reversing the scope specification: when the
   reference dtable is created, specify that it shall be included in the scope for a particular column,
   rahter than specifying the referenced table when the referencing column is specified?
   Proposed Solution:
   None provided with comment.

730 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02-06.01, SQL/Foundation — Subclause 6.1, "<data type>"
   Note at: None.
   Source: WG3:YGJ-112 (SQL/MM YGJ-023) and Paul Cotton for WG4, July 6, 1999
   Possible Problem:
   According to YGJ-112: "A second limitation of SQL 99 with respect to REF types is that they
   only achieve uni-directional "pointers"." A REF type value may be de-referenced to obtain
   the instance to which it refers. It is a Language Opportunity to provide direct support for
   determining all instances of a REF type which refer to a particular instance.
   Proposed Solution:
   None provided with comment.

740 The following Possible Problem has been noted:
   Severity: Language Opportunity
   Reference: P02-04.35.02, SQL/Foundation — Subclause 4.38.2, "Execution of triggers"
   Note at: None.
   Source: WG3:YGJ-074/X3H2-99-164R1, modified by WG3:PER-171/H2-2001-???
   Possible Problem:
   The leading three words of the following paragraph obscure the meaning of the paragraph.
   Other paragraphs in various parts of this standard may have the same problem.
      A consequence of the execution of an SQL-data change statement that causes at least one
      transition to arise in some state change is called an SQL-update operation.




                                                   Possible problems with SQL/Foundation 43
Editor’s Notes for WG3:HBA-003 = H2-2003-305


     A possible rewording might be something like this:
        A consequence of the execution of an SQL-data change statement is called an SQL-update
        operation if and only if that consequence causes at least one transition to arise in some state
        change.
     Proposed Solution:
     None provided with comment.

747 The following Possible Problem has been noted:
     Severity: Language Opportunity
     Reference: P02-07.09, SQL/Foundation—Subclause 11.10, "<alter table statement>"
     Note at: None.
     Source: WG3:RTM-028/X3H2-99-252R1
     Language Opportunity:
     It might be useful to have an option so that a conventional (SQL-92) table can evolve to become
     a table of type. However, any such proposal must avoid the pitfalls noted during development
     of SQL:1999 for evolution to a table of "named row type" (to use the terminology current before
     structured types were introduced).
     The proposal must account for the <reference type specification> of the user-defined type.
     If <reference generation> is DERIVED, it may be necessary to require a unique constraint
     or primary key constriant on the appropriate columns. If <references generation> is USER
     GENERATED, it may be necessary to require that the table has no rows.
     Probably the self-referencing column must be added to the table as part of its evolution to a
     table of structured type. It is unlikely that the unaltered table will have as its first column a
     reference to the very type to which the table will be evolving. And, if perchance that condition
     were met, what would be do with the previously existing values in that column?
     Proposed Solution:
     None provided with comment.

756 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02, SQL/Foundation, Subclause 7.4, "<table expression>".
     Note at: None.
     Source: WG3:YGJ-069r1 = H2-99-155r3 and WG3:BHX-096/H2-2000-248R1
     Language Opportunity:
     It might be useful to be able to filter windowed results based on the values of <OLAP function>,
     most likely through a new clause analogous to <where clause> and <having clause>, but
     following <window clause>.
     Proposed Solution:
     None provided with comment.

758 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: PO2, SQL/Foundation, No particular location
     Note at: None.
     Source: WG3:BHX-149
     Language Opportunity:




44    Editor’s Notes for ISO-ANSI working draft Database Language SQL (SQL/Foundation)
                                               Editor’s Notes for WG3:HBA-003 = H2-2003-305


   If might be useful to add to SQL the ability to use explicit character set names taken from
   the public registry for character set names (an IANA [Internet Assigned Numbers Authority]
   registry available at ftp://ftp.isi.edu.in-notes/iana/assignments/character-sets).
   Proposed Solution:
   None provided with comment.

642 The following Language Opportunity has been noted:
   Severity: Minor Technical
   Reference: P02, SQL/Foundation, Subclause 11.5, "<default clause>"
   Note at: None.
   Source: DBL:LGW-152/X3H2-97-352 (also DBL:LGW-023/X3H2-97-044, SEQ# 222, CAN-F-062,
   converted to LO by WG3:BHX-038/H2-2000-018R3)
   Possible Problem:
   It might be useful to allow default values for row types, perhaps by using row constructors.
   Proposed Solution:
   None provided with comment.

773 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: PO2, SQL/Foundation
   Note at: None.
   Source: WG3:BHX-107/H2-2000-_ __
   Language Opportunity:
   It is desirable to provide the capability on CREATE TABLE to change options (scope, reference
   checking, NOT NULL specification, default values, datalink control definitions, and so on) that
   are associated with components nested inside row types, collection types, and structured types.
   Proposed Solution:
   None provided with comment.

778 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: PO2, SQL/Foundation
   Note at: None.
   Source: WG3:BHX-117/H2-2000-_ __
   Language Opportunity:
   WG3:SLD-046 added several new fields to the CLI descriptor area: CURRENT_TRANSFORM_
   GROUP, SPECIFIC_TYPE_CATALOG, SPECIFIC_TYPE_SCHEMA, and SPECIFIC_TYPE_
   NAME. The same fields could profitably be added to the SQL descriptor area, too.
   Solution:
   None proposed with comment.

787 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: PO2, SQL/Foundation
   Note at: None.
   Source: WG3:PER-146/H2-2001-??? (FCD1/2000 WG3-P01-011)
   Language Opportunity:




                                                 Possible problems with SQL/Foundation 45
Editor’s Notes for WG3:HBA-003 = H2-2003-305


     [Jake Knoppers] saw that with respect to "normative references" point 1p that ISO 8601:2001
     version is to be referenced. This is good; [he works] on that standard. [His]comment is that
     serious consideration should also be given to referencing ISO 19108:2000 "Geographic infor-
     mation — Temporal schema". ISO 8601 deals mainly with Gregorian calendar referencing.
     Increasingly, various areas of business application such as banking/financial services, geomatics,
     intelligent transportation systems, etc. use other calendar referencing systems, such as the
     GPS clock, which is use for synchronization among the global position satellites and provides
     for a "common" single world wide date/time referencing among IT systems of autonomous or-
     ganizations (one then maps the GPS date/time stamp to one’s local time, whatever it is). It is
     likely that many SQL based implementations will do the same. [He does] not know whether you
     want to treat this as a "comment" an "informative note/footnote", etc. but [he thinks] that it is
     important for SQL users.
     Solution:
     None proposed with comment.

788 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: PO2, SQL/Foundation
     Note at: None.
     Source: WG3:PER-146/H2-2001-??? (FCD1/2000 WG3-P01-018)
     Language Opportunity:
     Allow implementations to be able to represent year numbers outside of 0001-9999 (0000 is 1
     B.C, etc.). The restriction of YEAR to be between 0001 and 9999 is unsupportable. Note also
     that ISO/IEC 8601:2001 does not have any such restriction; 0000 and negative years are allowed
     (year 0000 is year 1 BC, -0001 is year 2 BC, ...), as are year indications with more than 4 digits.
     Further, sub-second precision should be possible to use (i.e. required by the standard). (Note:
     The CD Editing Meeting believes that this sentence means that implementations should be
     mandated to supply significant digits, other than zero, to the right of the decimal point, although
     there may be hardware that does not support "clock ticks" at such a fine granularity.)
     Solution:
     None proposed with comment.

789 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: PO2, SQL/Foundation
     Note at: None.
     Source: WG3:PER-146/H2-2001-??? (FCD1/2000 WG3-P02-010)
     Language Opportunity:
     Allow decimal numbers to be expressed using any one (for each numeral) of the decimal number
     category (Nd) ranges in the UCS. Conversely, there should also be a way of getting out formatted
     numbers using a specified range (by script name or similar) of Nd characters.
     Allow the character MINUS as an ’alias’ to HYPHEN-MINUS in arithmetic expressions. Al-
     low LESS-THAN OR EQUAL, GREATER-THAN OR EQUAL, as well as LESS-THAN OR
     SLANTED EQUAL (Unicode 3.2), and GREATER-THAN OR SLANTED EQUAL (Unicode 3.2)
     with their obvious comparison semantics. Allow DOT OPERATOR for multiplication.
     Solution:
     None proposed with comment.




46    Editor’s Notes for ISO-ANSI working draft Database Language SQL (SQL/Foundation)
                                               Editor’s Notes for WG3:HBA-003 = H2-2003-305


791 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: PO2, SQL/Foundation
   Note at: None.
   Source: WG3:PER-146/H2-2001-??? (FCD1/2000 USA-P02-010)
   Language Opportunity:
   There is no discussion of the relationship between determinism and isolation level. Two read
   transactions starting at the exact same time working on the "same" SQL data can still have
   different results if they operate on different isolation levels.
   The May, 2001 CD Editing Meeting in Perth observed that describing such interactions is
   extremely difficult and all such descriptions known to the Editing Meeting participants rely
   heavily (perhaps exclusively) on the locking paradigm, which the standard does not require.
   Because of this, the Editing Meeting believed that a complete resolution of this Language
   Opportunity is quite unlikely.
   Solution:
   None proposed with comment.

807 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: PO2, SQL/Foundation, No specific location
   Note at: None.
   Source: WG3:PER-171/H2-2001-??? (FCD1/2000 USA-P02-010)
   Language Opportunity:
   It may be useful to have a notion of "hereditary property" of BNF nonterminals. A hereditary
   property P would work like this: If A ::= B, then P(A) = P(B), unless there is an explicit syntax
   rule to the contrary.
   Examples of hereditary properties would be declared type, scale, precision, most specific type,
   value.
   This is already the haphazard approach of the standard, for example, to say in one SR that "the
   data type of B is DT" and then later assume that the data type of A is DT since A ::= B.
   Solution:
   None proposed with comment.

808 The following Language Opportunity has been noted:
   Severity: Language Opportunity (was Possible Problem 736 )
   Reference: P02, SQL/Foundation, Subclause 6.35, "<array value expression>"
   Note at: Function
   Source: WG3:PER-171/H2-2001-??? (FCD1/2000 NLD-P02-027), from WG3:YGJ-074/X3H2-99-
   164R1
   Possible Problem:
   The ability to extract a subarray of an array would be useful. Such an ability would also satisfy
   a separate Language Opportunity to be able to truncate an array.
   Proposed Solution:
   None provided with comment.

809 The following Language Opportunity has been noted:
   Severity: Language Opportunity (was Possible Problem 737 )


                                                  Possible problems with SQL/Foundation 47
Editor’s Notes for WG3:HBA-003 = H2-2003-305


     Reference: P02, SQL/Foundation, Subclause 14.10, "<update statement: positioned>"
     Note at: None.
     Source: WG3:PER-171/H2-2001-???, FCD1/2000 NLD-P02-063 (from WG3:YGJ-074/X3H2-99-
     164R1
     Possible Problem:
     There is no ability to truncate an array. Assigning NULL to the last element of an array does
     not decrease the length of the array.
     Proposed Solution:
     None provided with comment.

812 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02, SQL/Foundation, Subclause 6.1, "<data type>"
     Note at: End of Conformance Rules of Subclause 6.1, "<data type>"
     Source: WG3:PER-098R1/H2-2001-059
     Language Opportunity:
     Perhaps Feature S096, ‘‘Optional array bounds’’, can be folded in Feature S091, ‘‘Basic array
     support’’.
     Proposed Solution:
     None provided with comment.

815 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02, SQL/Foundation, Table 18, "Data type correspondences for COBOL"
     Note at: None.
     Source: WG3:PER-107/H2-2001-115
     Possible Problem:
     Table 18, "Data type correspondences for COBOL", maintains that the COBOL type correspond-
     ing to BOOLEAN is PICTURE X. Before the deletion of the BIT type (by paper WG3:PER-
     107/H2-2001-115), Subclause 20.5, "<embedded SQL COBOL program>", maintained that the
     declaration ‘‘PIC X USAGE IS BIT’’ could be used either to correspond to a bit string or to
     a BOOLEAN. This was flawed because the embedded COBOL processor needs to know what
     SQL type to assign to an embedded variable declaration. After the deletion of the BIT type,
     there appears to be no support for BOOLEAN in Subclause 20.5, "<embedded SQL COBOL
     program>", not even in a buggy Syntax Rule. Note that it will not do to overload ‘‘PICTURE
     X’’ as either CHAR(1) or BOOLEAN, for the same reason that it was not acceptable to overload
     ‘‘PIC X USAGE IS BIT’’ as either BIT(1) or BOOLEAN. Perhaps ‘‘USAGE IS BOOLEAN’’ is in
     order.
     Proposed Solution:
     None provided with comment.

816 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02, SQL/Foundation, Subclause 6.15, "<subtype treatment>"
     Note at: End of Conformance Rules of Subclause 6.15, "<subtype treatment>"
     Source: WG3:PER-099/H2-2001-061
     Language Opportunity:




48    Editor’s Notes for ISO-ANSI working draft Database Language SQL (SQL/Foundation)
                                               Editor’s Notes for WG3:HBA-003 = H2-2003-305


   Perhaps Feature S162, ‘‘Subtype treatment for references’’, can be folded into Feature S161,
   ‘‘Subtype treatment’’.
   Proposed Solution:
   None provided with comment.

819 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02, SQL/Foundation, Subclause 6.9, "<set function specification>"
   Note at: Subclause 6.9, "<set function specification>", following Conformance Rules
   Source: WG3:PER-044R1/H2-2000-619
   Language Opportunity:
   The proponents of multiargument GROUPING function believe that it is a trivial extension of
   the single argument function, and therefore does not warrant a separate feature. This could be
   achieved by simply deleting the Conformance Rule that creates Feature T433, ‘‘Multiargument
   GROUPING function’’, thereby allowing all GROUPING functions to fall under Feature T431,
   ‘‘Extended grouping capabilities’’.
   Proposed Solution:
   None provided with comment.

822 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02, SQL/Foundation, Subclause 11.3, "<table definition>"
   Note at: None.
   Source: WG3:PER-104/H2-2001-085R1
   Language Opportunity:
   The ability to specify options for inheriting column default and identity column properties, as in
   the <like clause>, would also be beneficial for the <as subquery clause>.
   Proposed Solution:
   None provided with comment.

827 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02, SQL/Foundation, No particular location
   Note at: None.
   Source: FCD1/2000 WG4-P02-001)
   Language Opportunity:
   It should be allowed to invoke a method using a <routine invocation> with a signature that is
   identical to the <method selection> specified in Subclause 6.16, "<method invocation>", and in
   Subclause 6.17, "<static method invocation>", respectively.
   Proposed Solution:
   None provided with comment.

829 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02, SQL/Foundation, Subclause 6.15, "<subtype treatment>"
   Note at: None.
   Source: WG3:PER-186/H2-2001-???
   Language Opportunity:


                                                  Possible problems with SQL/Foundation 49
Editor’s Notes for WG3:HBA-003 = H2-2003-305


     WG3:PER-099 extended <subtype treatment> so that an expression of type REF(t1) would be
     TREATed as one of type REF(t2) if t2 is a subtype of T1. It was noted that, in that case, it
     should also be possible to TREAT:

     — An expression of type t1 ARRAY[n] as one of type t2 ARRAY[n].

     — An expression of type t1 MULTISET as one of type t2 MULTISET.

     — An expression of type ROW( . . . , f1 t1, . . . ) as one of type ROW( . . . , f1 t2, . . . ).
     In the ROW case, it might even be possible to support TREATment over more than one field.
     For example, an expression of the type ROW( . . . , f1 t1, . . . , f2 t1, . . . ) might be TREATable
     as ROW( . . . , f1 t1, . . . , f2 t2, . . . ), as ROW( . . . , f1 t2, . . . , f2 t1, . . . ), or as ROW( . . .
     , f1 t2, . . . , f2 t2, . . . ), even though SQL does not (at the time of writing this Language
     Opportunity) support multiple inheritance in general. In the ROW case, it would also be
     necessary to decide whether field names must match as indicated in these examples.
     Proposed Solution:
     None provided with comment.

830 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02, SQL/Foundation, No particular location
     Note at: None.
     Source: WG3:PER-188/H2-2001-???
     Language Opportunity:
     In the mathematical community, multiset union of M1 and M2 is defined as consisting of every
     element that is an element of either M1 or of M2, occurring either as many times as it does
     in M1 or as many times as it does in M2, whichever is the greater. (The SQL operator called
     UNION ALL, and also called MULTISET UNION after acceptance of WG3:PER-098 is referred
     to as ‘‘union plus’’, denoted thus: U+.)
     The mathematical definition of multiset union seems just as good a counterpart of the multiset
     intersection we already have as union plus does, because intersection can be expressed by
     just changing "either" to "both", "or" to "and", and "greater" to "lesser" in the above informal
     definition of multiset union.
     Proposed Solution:
     None provided with comment.

831 The merger of X3H2-95-178/DBL:YOW-048, X3H2-95-201/DBL:YOW-049R, and X3H2-95-
179R2/DBL:YOW-050R proposed the following Language Opportunity:
     Exceptions that are passed back through a routine invocation should be traceable. The list
     of <routine invocations> that they were propagated back through should be made available
     somewhere, such as in the Diagnostics Area.
     (Was Language Opportunity PSM-061 )

874 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02, SQL/Foundation, Subclause 11.3, "<table definition>"
     Note at: None.
     Source: WG3:DRS-095
     Language Opportunity:




50    Editor’s Notes for ISO-ANSI working draft Database Language SQL (SQL/Foundation)
                                               Editor’s Notes for WG3:HBA-003 = H2-2003-305


   Since in section 1.1.2 we gave reasons for determining the <reference generation> implicitly, it
   would be most convenient if the <column constraint definition>s necessary for derived reference
   representations were implicit, and determined by examination of the corresponding user-defined
   type descriptor.
   Proposed Solution:
   None provided with comment.

876 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02, SQL/Foundation, No particular location
   Note at: None.
   Source: WG3:DRS-128
   Language Opportunity:
   SQL/Foundation, as currently written, prohibits the creation and invocation of multiple poly-
   morphic routines whose parameters differ only by character set or by interval class (year-month
   or day-time). This is clearly unacceptable for many users’ needs.
   This Opportunity has been "narrowed" by acceptance of WG3:FRA-120R1. It was formerly
    PSM-127 .
   Proposed Solution:
   None provided with comment.

899 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02, SQL/Foundation, Subclause 11.4, "<column definition>"
   Note at: None.
   Source: WG3:DRS-089
   Language Opportunity:
   If the <data type> of the <column definition> simply contains a <row type> or a structured
   type, SR 18) and 19) replace <reference scope check>s of <field definition>s and <attribute
   definition>s nested within these structures with appropriate <check constraint definition>s.

   •   The referencing fields and attributes can be deeply nested within a <column definition>’s
       <data type>. However, only intervening row types, structured types and array types are
       allowed according to SR 18)e) and 19)e), what about multiset types?

   •  Check constraints have no associated <referential action>s. Subclause 6.2 <field definition>
      and Subclause 11.42 <attribute definition> therefore correctly restrict <reference scope
      action> to NO ACTION. However, this is an inadequate limitation for users of this concept,
      and it also clashes with the description in Subclause 4.14, "Columns, fields, and attributes".
   Proposed Solution:
   None provided with comment.

900 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02, SQL/Foundation, Subclause 11.4, "<column definition>"
   Note at: None.
   Source: WG3:DRS-089
   Language Opportunity:




                                                  Possible problems with SQL/Foundation 51
Editor’s Notes for WG3:HBA-003 = H2-2003-305


     If the <data type> contained in a <column definition> contains a <collection type> whose
     element type is a <reference type>, there is no way to specify that references shall be checked.
     This is an inadequate limitation.
     See also Editor’s Note 729 in SQL/Foundation for reference.
     Proposed Solution:
     None provided with comment.

901 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02, SQL/Foundation, Subclause 11.4, "<column definition>"
     Note at: None.
     Source: WG3:DRS-089
     Language Opportunity:
     If a column’s declared type is a scoped reference type, <reference scope check> must be specified.
     A corresponding implicit default might be easier to handle for a user, for example, REFER-
     ENCES ARE NOT CHECKED could be implicit if <reference scope check> is not specified.
     Proposed Solution:
     None provided with comment.

902 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02, SQL/Foundation, Subclause 11.4, "<column definition>"
     Note at: None.
     Source: WG3:DRS-089
     Language Opportunity:
     There does not seem to be a sensible benefit in having a <reference type> without <scope
     clause> contained in a <column definition>, since any usage of <reference value expression>
     depends on the reference type including a scope. See Subclauses 6.20 <dereference operation>
     and 6.22 <reference resolution> for reference. While Subclause 11.15 <add column scope clause>
     allows to add scope to columns being based on <reference type>s (e.g. in cases of circular
     references), this is not possible for <reference type>s nested within row types, structured types
     or collection types contained in a column’s <data type>. This is an inadequate limitation.
     Proposed Solution:
     None provided with comment.

903 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02, SQL/Foundation, Subclause 11.21, "<drop table statement>"
     Note at: None.
     Source: WG3:DRS-089
     Language Opportunity:
     The treatment of a table with a column whose descriptor generally contains a field, attribute, or
     collection descriptor including a reference type with scope is very excessive when the associated
     table is dropped using CASCADE: The referencing table is dropped as well according to GR
     2). This is quite different to dropping regular tables with foreign keys or tables with columns
     immediately based on a scoped reference: These tables are unaffected, only the associated
     referential constraints are dropped.




52    Editor’s Notes for ISO-ANSI working draft Database Language SQL (SQL/Foundation)
                                               Editor’s Notes for WG3:HBA-003 = H2-2003-305


   Note: Both checked and unchecked references are treated the same when the table in the scope
   of the reference type is dropped.
   Note: This problem is similar to possible problem Language Opportunity 904.
   Proposed Solution:
   None provided with comment.

904 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02, SQL/Foundation, Subclause 11.23, "<drop view statement>"
   Note at: None.
   Source: WG3:DRS-089
   Language Opportunity:
   The treatment of a table with a column whose descriptor generally contains a field, attribute, or
   collection descriptor including a reference type with scope is very excessive when the associated
   view is dropped using CASCADE: The referencing table (even if is a base table!) is dropped as
   well according to GR 1). This is quite different to dropping regular tables.
   Note: This problem is similar to possible problem Language Opportunity 903.
   Proposed Solution:
   None provided with comment.

858 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02, SQL/Foundation, Subclause 6.28, "<string value expression>"
   Note at: SR 3).
   Source: WG3:ICN-054R2 = H2-2002-_ __
   Possible Problem:
   The term "character string operands" was used to replace a previously undefined term "compo-
   nents" in SR2. Is this the correct terminology to use?
   Proposed Solution:
   None provided with comment.

909 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02, SQL/Foundation, Subclause 8.2, "<comparison predicate>"
   Note at: None.
   Source: WG3:ZSH-155 = H2-2002-_ __
   Language Opportunity:
   The Syntax Rules convert all comparison predicates so that they only use < and =. The GRs for
   comparison of user-defined types spell out rules for > and other comparisons even though they
   have been transformed away. NOTE 167 following the GR claims that these unreachable GRs
   are there for informational purposes. In the case of RELATIVE order, there are some strong
   assumptions being made that RF(X,Y) = –RF(Y,X); otherwise, the system breaks down. We
   should document what are the expectations for the relative order function somewhere. We do
   not find such documentation either in <user-defined ordering function> or in Concepts.
   Proposed Solution:
   None provided with comment.




                                                 Possible problems with SQL/Foundation 53
Editor’s Notes for WG3:HBA-003 = H2-2003-305


836 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02, SQL/Foundation, Subclause 9.3, "Data types of results of aggregations"
     Note at: None.
     Source: WG3:YYJ-030R2 = H2-2001-_ __ and WG3:ZSH-155 = H2-2002-_ __
     Language Opportunity:
     This subclause uses terms that are less precise than they should be. Specifically, the term result
     data type and data type of the result, without specifying the result of what.
     The first sentence of Function says: "Specify the result data type of the result of an aggrega-
     tion ...". Moreover the term aggregation does not suggest the sense in which it is used here,
     having since been used extensively in the context of OLAP, see subclause 04.17.03 "Aggregate
     functions". A better title would be Data types of results of n-adic operations. Were this title
     adopted, the first sentence could be rewritten as, for example, Let IDTS be a set of data types
     specified in an application of this Subclause, and let O be the operation.
     Proposed Solution:
     None provided with comment.

910 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02, SQL/Foundation, Subclause 11.3, "<table definition>"
     Note at: None.
     Source: WG3:ZSH-155 = H2-2002-_ __
     Language Opportunity:
     Since in Section 1.1.2 (of some proposal, presumably), we gave reasons for determining the <ref-
     erence generation> implicitly, it would be most convenient if the <column constraint definition>
     necessary for derived reference representations were implicit, and determined by examination of
     the corresponding user-defined type descriptor.
     Proposed Solution:
     None provided with comment.

911 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02, SQL/Foundation, Subclause 12.7, "<revoke statement>"
     Note at: None.
     Source: WG3:ZSH-155 = H2-2002-_ __
     Language Opportunity:
     Syntax Rule 36) says:
36) If RESTRICT is specified, then there shall be no abandoned privilege descriptor, abandoned
view, abandoned table constraint, abandoned assertion, abandoned domain constraint, lost domain,
lost column, lost schema, and no descriptor that includes an impacted data type descriptor, impacted
collation, impacted charater set, abandoned user-defined type, forsaken column decriptor, forsaken
domain descriptor, or abandoned routine descriptor.
     This SR has several problems:

     •    It is unclear whether there should be a comma following "schema", though we recognize that
          a schems is a descriptor. (Note: This problem has been fixed by the addition of "and no"
          between "schema," and "descriptor".)



54       Editor’s Notes for ISO-ANSI working draft Database Language SQL (SQL/Foundation)
                                               Editor’s Notes for WG3:HBA-003 = H2-2003-305


   •   It is unclear whether the object of "includes" is a nested list. (Note: This problem has been
       resolved by making it clear that it is a nested list.)

   •   The terms used to refer to impacted, etc., objects are inconsistent with those used to so
       designate them. While it is descriptors that are said to be abandoned, impacted, etc., this
       rule referes to "impacted columns", etc.

   •   Several possible candidates for inclusion in the list are absent for no obvious reason; they
       include abandoned table descriptor, abandoned trigger descriptor, and contaiminated column
       descriptor.
   We suggest improving the clarity by using a possibly nested bullet list.
   Proposed Solution:
   None provided with comment.

734 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02, SQL/Foundation, Subclause 12.7, "<revoke statement>"
   Note at: None specified
   Source: Email from Fred Zemke, 1999-06-09 and WG3:ZSH-155 = H2-2002-_ __
   Language Opportunity:
   The OLAP Amendment has created a new kind of dependency, of a view, etc., containing an
   OLAP function that references a user-defined ordering in its ORDER BY clause, which is
   dependent on the user-defined ordering. <drop routine statement> has been edited to account
   for this dependency; does any other statement need to be edited?
   Proposed Solution:
   None provided with comment.

912 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02, SQL/Foundation, Subclause 16.2, "<set transaction statement>"
   Note at: None.
   Source: WG3:ZSH-155 = H2-2002-_ __
   Language Opportunity:
   The standard does not specify a maximum for <number of conditions>. Presumably there is an
   implementation-defined or -dependent maximum value of <number of conditions>. For example,
   we could add the following GR after GR 2):
       2) If <number of conditions> exceeds an implementation-dependent maximum number of
       conditions, then an exception condition is raised: invalid condition number.
   We must also add an entry in either the implementation-defined or the implementation-
   dependent Annex.
   Note: WG3:ICN-001 recorded "After some discussion, the consensus was that the condition
   should be a warning and that a good solution to the comment should involve adding an extra
   field to the diagnostics area, giving the current transaction’s maximum number of conditions."
   Proposed Solution:
   None provided with comment.

913 The following Language Opportunity has been noted:
   Severity: Language Opportunity


                                                  Possible problems with SQL/Foundation 55
Editor’s Notes for WG3:HBA-003 = H2-2003-305


     Reference: P02, SQL/Foundation, No particular location
     Note at: None.
     Source: WG3:ZSH-155 = H2-2002-_ __
     Language Opportunity:
     There should be an explicit specification of what features a conforming Syntax Only SQL
     Flagger must detect.
     Proposed Solution:
     None provided with comment.

914 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02, SQL/Foundation, No particular location
     Note at: None.
     Source: WG3:ZSH-155 = H2-2002-_ __
     Language Opportunity:
     Suppose you have defined a structured UDT with 50 attributes. In order to grant somebody else
     the right to retrieve and set the values of each of those attributes, you must execute no fewer
     than 101 GRANT statements! First, you must grant USAGE on the type itself. Then, you must
     grant EXECUTE on each of the 50 observer methods and EXECUTE on each of the 50 mutator
     methods. The process is particularly cumbersome, because granting EXECUTE on the observer
     methods requires something like "GRANT EXECUTE ON INSTANCE METHOD attribute_n
     FOR typename TO username" (which is easy enough), but granting EXECUTE on the mutator
     methods requires something like "GRANT EXECUTE ON INSTANCE METHOD attribute_
     n (argument-type-1, argument-type-2,...argument-type-n) FOR typename TO username". Of
     course, you could choose to use the <specific name> for the methods, but those names are likely
     to be awkward and/or non-intuitive.
     The process of entering all of those GRANTs is incredibly unfriendly to type definers and grows
     worse as UDTs get more complex.
     Contrast this with the process of granting retrieval and modification privileges on a table with
     1000 columns: "GRANT SELECT ON tablename TO username" and "GRANT UPDATE ON
     tablename TO username". That’s it.
     Granting (and revoking!) access privileges to attributes of UDTs should be made more user-
     friendly.
     Proposed Solution:
     None provided with comment.

915 The following Language Opportunity has been noted: The following Language Opportunity has
been noted:
     Severity: Language Opportunity
     Reference: P02, SQL/Foundation, No particular location
     Note at: None.
     Source: WG3:ZSH-155 = H2-2002-_ __
     Language Opportunity:
     Instead of trying to discover and remember all the possible dependencies between schema
     objects, what we should do is create the dependency at the time of creating the dependent
     object. This should enable a simplification of the rules for DROP and REVOKE, as well as
     making them more intelligible and easier to maintain.
     Proposed Solution:



56    Editor’s Notes for ISO-ANSI working draft Database Language SQL (SQL/Foundation)
                                                Editor’s Notes for WG3:HBA-003 = H2-2003-305




916 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02, SQL/Foundation, No particular location
   Note at: None.
   Source: WG3:ZSH-155 = H2-2002-_ __
   Language Opportunity:
   The character string "associate" occurs 373 times in [FoundFCD], mostly in the phrase "associ-
   ated with". In many cases the meaning, or effect, of an association between two objects can be
   found only by finding all the places where it is mentioned. In a number of such cases the phrase
   could be avoided altogether, in others the significance of the association could be more explicitly
   explained.
   We give one or two examples where it does not appear difficult to avoid the phrase.
   Subclause 03.03.01.01, "Other terms",
      ... <SQL statement variable> that was associated with an <SQL statement name> by a
      <prepare statement> ...
   Subclause 04.02.01, "Character strings and collating sequences",
      Each collation known in an SQL-environment is applicable to one or more character sets,
      and for each character set, one or more collations are applicable to it, one of which is
      associated with it as its character set collation.
   The words in bold are unnecessary, and could well be deleted altogether. The word "default"
   could be added, between "its" and "character set".
   Subclause 05.04, "Names and identifiers", Syntax Rule 17)
      17) An <identifier> that is a <correlation name> is associated with a table within a
      particular scope. The scope of a <correlation name> is either a <select statement: single
      row>, <subquery>, or <query specification> (see Subclause 7.6, "<table reference>"), or is a
      <trigger definition> (see Subclause 11.39, "<trigger definition>"). Scopes may be nested. In
      different scopes, the same <correlation name> may be associated with different tables or
      with the same table.
   Proposed Solution:
   None provided with comment.

780 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02, SQL/Foundation, No specific location
   Note at: None.
   Source: WG3:HEL-047/H2-2000-_ __
   Language Opportunity:
   2. Insurmountable (?) problem for query generators
   The unfriendliness described in 779 causes a certain difficulty to general purpose applications,
   such as query generators, that appears to be insurmountable. Given two arbitrary character
   string expressions of character set CS, there is no guaranteed way of having them compared
   under the default collation of CS without knowing what that collation is. Moreover, the default
   collation can be looked up in the Information Schema only if the character set CS itself is
   known. There is no sure way that we are aware of whereby the character set of an arbitrary
   string expression can be determined by an SQL application.


                                                  Possible problems with SQL/Foundation 57
Editor’s Notes for WG3:HBA-003 = H2-2003-305


     Proposed Solution:
     None provided with comment.

917 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02, SQL/Foundation, No particular location
     Note at: None.
     Source: WG3:ZSH-153R1 = H2-2002-153R1
     Language Opportunity:
     The concepts section needs to explain that CAST AS is the mechanism to translate datetime
     and interval data types to and from host data parameters.
     Proposed Solution:
     None provided with comment.

920 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02, SQL/Foundation, Subclause 6.34, "<boolean value expression>"
     Note at: None.
     Source: WG3:ZSH-129 = H2-2002-_ __
     Language Opportunity:
     The rules for known-not-null conditions in SR3) are more complicated than most implementa-
     tions are prepared to implement, and not necessary for most users. The full implementation of
     known not null should be placed in a conformance feature. Without the feature, a much simpler
     definition should apply.
     Proposed Solution:
     None provided with comment.

921 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02, SQL/Foundation, Subclause 13.1, "<SQL-client module definition>"
     Note at: None.
     Source: FCD1/2002, GBR-P02-485
     Language Opportunity:
     None of the GRs in this Subclause relate to the creation of an SQL module. Moreover, General
     Rule 4) relates to the invocation of an externally-invoked procedure.
     Proposed Solution:
     None provided with comment.

922 The following Language Opportunity has been noted:
     Severity: Language Opportunity
     Reference: P02, SQL/Foundation, Subclause 14.12, "<set clause list>"
     Note at: None.
     Source: WG3:ZSH-163 = H2-2003-_ __
     Language Opportunity:
     Impossible to Update Different Parts of the Same Column




58    Editor’s Notes for ISO-ANSI working draft Database Language SQL (SQL/Foundation)
                                               Editor’s Notes for WG3:HBA-003 = H2-2003-305


   SR 7) prohibits the same column name from appearing more than once in the list of SET
   clauses. This means that the user who wishes to use the shorthands available for assigning to
   fields of rows is rather severely restricted, unacceptably so, in our opinion. The problem does
   not arise in connection with assignment to attributes of UDT values, thanks to the ingenious
   SR 6).
   Proposed Solution:
   None provided with comment.

931 The following Language Opportunity has been noted:
   Severity: Language Opportunity
   Reference: P02, SQL/Foundation, No particular location
   Note at: None.
   Source: Email from Troels Arvis, 2003-07-22
   Language Opportunity:


   Please consider adding a standardized way to limit the size of a result set. The majority of SQL
   DBMSs seem to already to that to certain extends, but with different syntax.
   I think it’s a shame that such a useful feature isn’t standardized: It’s more basic and simple
   than objects, XML, etc. But still an issue which deserves some attention, I believe.
   Limiting what parts of a result set is returned is - of course - only useful if the result set is
   ordered. If it’s ordered, it’s very practical to be able to ask that that - e.g. - only a maximum
   of X rows are returned, perhaps after having skipped Y rows in the result set. I often use it in
   paginated data listings where it’s useless to work with the complete result set.
   In PostgreSQL, you can do:
   select * from country order by id_numeric limit 5 offset 5;
   SELECT id_numeric,iso_name
   FROM country
   ORDER BY id_numeric
   LIMIT 30 OFFSET 60;
   This way, I’ll get a maximum of 30 result set rows, after the system has skipped the first 60
   rows.
   Microsoft SQL Server has a somewhat similar approach:
   SELECT TOP 30 id_numeric, iso_name
   FROM country
   ORDER BY id_numeric;
   - but here you cannot specify an offset which makes the feature less useful.
   There are several other implementations. Around the Web, you may see a large number of work-
   arounds, stored procedures and other over-complex machinery to try to handle the different
   implementations (or emulate the operations when the products don’t have the feature).
   I believe that something along the line of PostgreSQL’s syntax is readable and compact.
   Proposed Solution:
   None provided with comment.




                                                  Possible problems with SQL/Foundation 59
